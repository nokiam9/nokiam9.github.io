---
title: 分组加密的工作模式概述
date: 2022-12-17 16:26:07
tags:
---

## 一、背景

在密码学中，最基本的分类就是：对称加密 Vs 非对称加密。

- 如果使用**相同的密钥**进行消息的加密与解密（算法不一定相同，例如函数 & 逆函数），就是对称加密算法（也称为ciphers），例如：DES、3DES、AES、Blowfish、IDEA、RC5、RC6...
- 否则，就是非对称加密算法，通常需要一个密钥对：公钥 (public key) + 私钥 (private key)，分别用于加密和解密，例如：RSA、DSA、ECC、DH...

关于对称加密算法，可以进一步细分为：分组加密算法 Vs 流密码算法。

- 流密码算法（Stream Cipher）：明文和密钥的长度相同，按字节与密钥逐位地做约定的运算（通常是 XOR）从而获得密文流，包括 RC4 和 GSM 等
- 分组密码算法（Block Cipher）：每次加密固定大小的块（例如 128 位），包括 AES、ChaCha20、Twofish、IDEA、Serpent、Camelia、RC6、CAST 等

由于分组密码的长度是固定的，但明文的长度是不确定的，由此带来了两个问题：

1. 明文数据长度可能不等于分组长度的倍数，如何处理碎片问题，请参见附录一。
2. 加密或解密过程中需要多次使用同一分组密钥，如何进行密钥轮转就是**工作模式**的核心问题。

> 理论上，非对称加密算法也可以应用工作模式，但出于性能问题的考虑，通常仅用于密钥传输等较少数据量的场景，大数据量的内容处理依然采用对称加密

## 二、基础的工作模式

2001年，NIST 发布了 800-38A 技术标准，定义了5种基本的分组加密工作模式。

### 1、ECB 模式（Electronic codebook，电子密码本）

ECB 模式就是传统的密码本方式，将整个明文分成若干段相同的小段，然后使用同一个密钥对每一小段进行加密，非常简单明了。

$$
\begin{flalign}
ECB加密算法： & C_j=CIPH_k(P_j)      &for\ j=1 \dots n   \\\\
ECB解密算法： & P_j=CIPH_k^{-1}(C_j) &for\ j=1 \dots n
\end{flalign}
$$

![ECB](ECB.png)

由于 ECB 模式每次分组处理采用完全相同的密钥，因此一旦某个分组的密文传输过程中出现误码，将导致当前分组的解密结果出现错误，但并不会影响其他分组，即支持加密和解密的并行处理。

ECB 模式存在严重的安全隐患，相同的明文块会被加密成相同的密文块，即著名的明文攻击问题！下图演示了一个图像文件通过 ECB 模式的加密结果。
![明文攻击](plaintext-attack.png)

造成明文攻击的根本原因，是用单一密钥对多个明文分组进行加密，但如果仅仅使用一个或者少量的分组（例如加密密钥传输等场景），ECB 模式仍然是安全的。

### 2. CBC 模式（Cipher-block chaining，密码块链接模式）

为了解决明文攻击问题，IBM 引入初始向量 IV（Initialization Vector）并提出了 CBC 模式。

$$
\begin{flalign}
CBC加密算法： & C_1 = CIPH_k(P_1 \oplus IV)  \\\\
         & C_j = CIPH_k(P_j \oplus C_{j-1})      & for\ j=2 \dots n   \\\\
CBC解密算法： & P_1 = CIPH_k^{-1}(C_1) \oplus IV  \\\\
         & P_j = CIPH_k^{-1}(C_j) \oplus C_{j-1}      & for\ j=2 \dots n   \\\\
\end{flalign}
$$

![CBC](CBC.png)

CBC 模式将 IV（或者上一个分组的密文）作为加密函数的输入，有较好的保密性，是最常见的工作模式，具有以下特点：

1. 增加了随机数 IV，相同明文可以产生不同密文，因此可以对抗明文攻击；
2. 由于分组之间存在依赖关系（每个密文块都依赖于它前面的所有明文块），加密过程无法并行化，但解密过程可以并行化！
3. 对于文件加密场景，需要为每个文件生成并存储唯一的 IV，对文件系统管理造成不小的困难；
4. 如果出现传输错误，那么后续结果解密后可能全部错误;
5. 预初始值IV可预测，敌⽅方可构建水印（watermark）,可能容易受到 padding oracle 攻击
6. 适合场景：面向分组的通⽤用传输; 认证

### 3. CFB 模式（Cipher feedback，密文反馈模式）

CFB、OFB、CTR 模式的核心思想都是将初始向量 IV 转换为流密码，只是方式有所不同。

$$
\begin{flalign}
CFB加密算法： & I_1 = IV     \\\\
    & I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}^\\#  & for\ j=2 \dots n \\\\
    & O_j = CIPH_k(I_j)     & for\ j=1,2 \dots n \\\\
    & C_j^\\# = P^\\#_j \oplus MSB_s(O_j)      & for\ j=1,2 \dots n \\\\
\end{flalign}
$$

$$
\begin{flalign}
CFB解密算法： & I_1 = IV     \\\\
    & I_j = LSB_{b-s}(I_{j-1}) | C_{j-1}^\\#  & for\ j=2 \dots n \\\\
    & O_j = CIPH_k(I_j)     & for\ j=1,2 \dots n \\\\
    & P_j^\\# = C^\\#_j \oplus MSB_s(O_j)      & for\ j=1,2 \dots n \\\\
\end{flalign}
$$

- CFB 模式需要设定参数 s（$1 <=s <= b$），通常为分组长度的因子，如1、8、64、128。每个 block 将被分为若干个长度为 s 的 segment，明文称为$P_j^\\#$，密文称为$P_j^\\#$
- $LSB_m(x)$：字节流x的m个低位，The bit string consisting of the m **least** significant bits of the bit string X.
- $MSB_m(x)$：字节流x的m个高位，The bit string consisting of the m **most** significant bits of the bit string X.
![CFB](CFB.png)

主要优势：可视为流密码，节省传输能⼒
业务场景：面向分组的通⽤用传输; 认证

### 4. OFB 模式（Output feedback, 输出反馈模式）

$$
\begin{flalign}
OFB加密算法： & I_1 = IV     \\\\
    & I_j = O_{j-1}      & for\ j=2 \dots n \\\\
    & O_j = CIPH_k(I_j)     & for\ j=1,2 \dots n \\\\
    & C_j = P_j \oplus O_j      & for\ j=1,2 \dots n-1 \\\\
    & C_n^\\# = P_n^\\# \oplus MSB_u(O_n) \\\\
\end{flalign}
$$

$$
\begin{flalign}
OFB解密算法： & I_1 = IV     \\\\
    & I_j = O_{j-1}      & for\ j=2 \dots n \\\\
    & O_j = CIPH_k(I_j)     & for\ j=1,2 \dots n \\\\
    & P_j = C_j \oplus O_j      & for\ j=1,2 \dots n-1 \\\\
    & P_n^\\# = C_n^\\# \oplus MSB_u(O_n) \\\\
\end{flalign}
$$

- 最后一个分组可能不完整，只有$u$位，此时将丢弃$O_j$对应的$b-u$位

![OFB](OFB.png)

主要优势：与CFB相似；不会出现误码传播，传输时某位错误不不会影响其他位
重要缺陷：要求在给定密钥下加密的每条消息都有一个唯一的IV。如果同一个IV用于多个消息的加密，那么这些消息的机密性可能会受到损害
业务场景：噪声信道的传输

### 5. CTR 模式（Counter，计数器模式）

CTR 模式也被称为 ICM 模式（Integer Counter Mode，整数计数模式），或者 SIC 模式（Segmented Integer Counter），不同分组流密码的随机性就是依靠计数器实现。

$$
\begin{flalign}
CTR加密算法：& O_j = CIPH_k(T_j)     & for\ j=1,2 \dots n \\\\
    & C_j = P_j \oplus O_j      & for\ j=1,2 \dots n-1 \\\\
    & C_n^\\# = P_n^\\# \oplus MSB_u(O_n)     \\\\
\end{flalign}
$$

$$
\begin{flalign}
CTR解密算法：& O_j = CIPH_k(T_j)     & for\ j=1,2 \dots n \\\\
    & P_j = C_j \oplus O_j      & for\ j=1,2 \dots n-1 \\\\
    & P_n^\\# = C_n^\\# \oplus MSB_u(O_n)     \\\\
\end{flalign}
$$
![CTR](CTR.png)

主要优势：可通过预处理实现并⾏计算，支持随机读写；简单性 + 可证明的安全性；
重要缺陷：在计算器不能维持很长的情况下，密钥只能使用一次。
适用场景：面向分组的通⽤用传输; 高速要求

## 三、增强的工作模式

### 1. GCM (Galois Counter Mode，分组模式）

![GCM](GCM.png)

GCM (Galois/Counter) 模式在 CTR 模式的基础上，添加了消息认证的功能，而且同时还具有与 CTR 模式相同的并行计算能力。因此相比 CTR 模式，GCM 不仅速度一样快，还能额外提供对消息完整性、真实性的验证能力。

在密码学中，伽罗瓦/计数器模式( GCM ) 是对称密钥加密分组密码的一种操作模式，因其性能而被广泛采用。可以使用廉价的硬件资源实现最先进的高速通信通道的 GCM 吞吐率。 [1]该操作是一种经过身份验证的加密算法，旨在提供数据真实性（完整性）和保密性。 GCM 是为块大小为 128 位的块密码定义的。 伽罗瓦消息认证码（Galois Message Authentication Code ，GMAC ) 是 GCM 的仅认证变体，可以形成增量消息认证代码。 GCM 和 GMAC 都可以接受任意长度的初始化向量。

不同的分组密码操作模式可能具有明显不同的性能和效率特性，即使使用相同的分组密码也是如此。 GCM 可以充分利用并行处理，实现 GCM 可以有效利用指令流水线或硬件流水线。相比之下，密码块链接（CBC）操作模式会导致流水线停顿，从而影响其效率和性能。

与普通计数器模式一样，块按顺序编号，然后该块编号与初始化向量（Initialization Vector，IV） 组合并使用块密码E加密，通常为AES 。然后将此加密的结果与明文进行异或以产生密文。与所有计数器模式一样，这本质上是一个流密码，因此对于每个加密的流使用不同的 IV 是必不可少的。

密文块被视为多项式的系数，然后在依赖于密钥的点H使用有限域算术对其进行评估。然后对结果进行加密，生成可用于验证数据完整性的身份验证标签。然后，加密文本包含 IV、密文和身份验证标签。

### 2. AES-XTS 模式

已有专题分析。

## 四、总结分析

加密技术研究的核心是**机密性保护**，历史上曾经将**完整性保护**（即在某些数据被修改后的情况下密码的误差传播特性）也一并纳入设计目标，但现代的研究已经确立信息安全的“**CIA原理（Confidentiality、Integrity、Availability）**”，普遍将完整性保护作为另一个完全不同的，与加密无关的密码学目标。

对比分析：

|工作模式|ECB|CBC|CFB|OFB|CTR|
|:-:|:-:|:-:|:-:|:-:|:-:|
|对抗明文攻击|否|IV & 密文|IV & 密文|IV & 密钥输出|Counter|
|转换为流密码|否|否|是|是|是|
|加密并行处理|是|否|否|否|是|
|支持随机访问解密|是|是|否|否|是|


|流密码|分组密码|
|:-:|:-:|
|按比特流顺序加密，完全串行化|按分组长度分批加密，需要处理碎片padding|
|网络数据传输是典型场景|磁盘文件加密是典型场景|
|多数基于专用电路，算法种类较少|提供软件代码实现，算法种类丰富|
|速度快，CPU资源开销少|纯软件实现消耗较多CPU资源，主流算法有指令集支持|
|根据是否依赖先前的密文，分为同步/异步模式|通过工作模式技术转换为流密码，有的支持并行化|
|加密和解密的算法一致，有利于硬件复用|加密和解密的算法不一定相同|

![vs](vs.png)

### 初始化向量（IV）

初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。

初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。

### NIST 的历史

最早出现的工作模式，ECB，CBC，OFB和CFB可以追溯到1981年[4]。2001年，NIST修订了其早先发布的工作模式任务栏表，加入了AES，并加入了CTR模式[5]。最后，在2010年1月，NIST加入了XTS-AES[6]，而其余的可信模式并没有为NIST所认证。例如CTS是一种密文窃取的模式，许多常见的密码学运行库提供了这种模式。

ECB，CBC，OFB，CFB，CTR和XTS模式仅仅提供了机密性；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的消息验证码，例如CBC-MAC。密码学社群认识到了对专用的保证完整性的方法的需求，NIST因此提出了HMAC，CMAC和GMAC。HMAC在2002年通过了认证[7]，CMAC在2005年通过[8]，GMAC则在2007年被标准化[9]。

在发现将认证模式与加密模式联合起来的难度之后，密码学社区开始研究结合了加密和认证的单一模式，这种模式被称为认证加密模式（AE，Authenticated Encryption），或称为authenc。AE模式的例子包括CCM[10]，GCM[11]，CWC，EAX，IAPM和OCB。

现在，工作模式为许多国家和国内的标准认证实体所定义，其中最有影响力的来源是美国的NIST，而其它有影响力的组织包括ISO，IEC，IEEE，美国的ANSI，以及IETF。

CFB 类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：

GCM（Galois/Counter Mode）块模式继承了 CTR 模式的所有优点，并增加了加密消息认证能力。GCM 是在对称密码中实现认证加密的快速有效的方法，强烈推荐

CBC 模式在固定大小的分组上工作。因此，在将输入数据拆分为分组后，应使用填充算法使最后一个分组的长度一致。大多数应用程序使用 PKCS7 填充方案或 ANSI X.923. 在某些情况下，CBC 阻塞模式可能容易受到「padding oracle」攻击，因此最好避免使用 CBC 模式
众所周知的不安全块模式是 ECB（电子密码本），它将相等的输入块加密为相等的输出块（无加密扩散能力）。
CBC、CTR 和 GCM 模式等大多数块都支持「随机访问」解密。比如在视频播放器中的任意时间偏移处寻找，播放加密的视频流
总之，建议使用 CTR (Counter) 或 GCM (Galois/Counter) 分组模式。 其他的分组在某些情况下可能会有所帮助，但很可能有安全隐患，因此除非你很清楚自己在做什么，否则不要使用其他分组模式！

CTR 和 GCM 加密模式有很多优点：它们是安全的（目前没有已知的重大缺陷），可以加密任意长度的数据而无需填充，可以并行加密和解密分组（在多核 CPU 中）并可以直接解密任意一个密文分组。 因此它们适用于加密加密钱包、文档和流视频（用户可以按时间查找）。 GCM 还提供消息认证，是一般情况下密码块模式的推荐选择。

请注意，GCM、CTR 和其他分组模式会泄漏原始消息的长度，因为它们生成的密文长度与明文消息的长度相同。 如果您想避免泄露原始明文长度，可以在加密前向明文添加一些随机字节（额外的填充数据），并在解密后将其删除。

---

## 附录一：分组密码的填充（padding）问题

在分组密码中，当数据长度不等于分组长度的倍数时，需要按一定的方式，将尾部明文分组进行填充，这种将尾部分组数据填满的方法称为**填充**（Padding）。常见的处理规则有：

### ANSI X9.23

在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充0。
`... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |`

### ISO 10126

在填充字节序列中，最后一个字节填充为需要填充的字节长度(示例为0x04)，其余字节填充**随机数**。
`... | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |`

### PKCS#7

PKCS#7 定义于 RFC 5652。
在填充字节序列中，每个字节填充为需要填充的字节长度(示例为0x04)。
`... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |`

### ISO/IEC 7816-4

在填充字节序列中，第一个字节填充固定值**0x80**，其余字节填充0。若只需填充一个字节，则直接填充**0x80**。
`... | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 |`
`... | DD DD DD DD DD DD DD DD | DD DD DD DD DD DD DD 80 |`

> 采用填充方式时，密文长度通常大于明文长度，意味着网络传输时需要消耗额外的传输能力。

## 附录二：密文窃取 - Ciphertext stealing

窃取密文是使用密码加密明文的技术，不须将消息填充到块大小的倍数，因此密文与明文大小相同。
它通过更改消息最后两块来实现这点。除了最后两块之外，所有块都保持不变，但“窃取”倒数第二块的一部分密文用以填充最后一块明文块。填充的最后一块，然后像往常一样加密。
最终密文的最后两块，包括部分倒数第二块（删掉“窃取”部分）和完整的最后一块，它们大小与原明文相同。
解密时要求首先解密最后一块，然后将“窃取”的密文恢复到倒数第二块，然后可以像往常一样解密。
原则上，任何使用块密码的分组加密模式都可用，但流密码模式已经可以加密任意长度的消息无需填充，因此它们不能用该操作。与窃取密文相结合的常用加密方式有电子密码本（ECB）和密码块链接（CBC）。

ECB密文窃取要明文长过一块。当明文长度为一个或更少时，一种可能的解决办法是，使用一种类似流密码的分组密码操作模式，如CTR、CFB或OFB。
CBC密文窃取不一定要明文长过一块。在明文为一块或更少块长度的情况下，初始向量（IV）可作为先前的密文块。在这种情况，必须将修改后的IV发送予接受者。但这在发送密文时IV不能由发送者自由选择的情况下（如当IV是派生值或预先确定的值）不太可能，并且在这种情况下，针对CBC模式的密文窃取只能在明长于一个块文中发生。
为了以CTS加密或解密未知长度的数据，必须延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。
![CTS-ECB](CTS_ECB.png)

密文格式
有几种不同的方式来排列密文以便传输。不同排列方式的密文位元数都相同，只是传输顺序不同，因此选择不影响安全性，纯粹是为了方便实现。
也就是分组密码如何转换为流密码的问题，也是关于填充处理的问题

> 采用密文窃取方式时，密文长度严格等于明文长度，不会浪费网络传输能力，同时这个优点非常适合磁盘文件存储（文件大小等于密文长度），因此产生 AES-XTS 工作模式。
> 密文窃取也是有代价的，需要延迟处理（和缓存）最新的两块数据块，以便处理数据流末端。
---

可以看到加密时 s 位的明文分组加密成 s 位的密文分组 ，而位数 s 不取决于加密函数，因此可以通过选择 s 的大小（通常为 8 位）来使得明文长度等于密文长度，从而不浪费传输能力。相比于 CFB 模式，那些需要填充的分组密码工作模式，往往是密文长度稍大于实际的明文长度，这样会使得传输能力被浪费。

可以看到在分组加密工作模式中仍然可以实现加密单个字节的明文分组，此时分组密码可以转换为流密码，流密码最大的特点就是明文和密文等长，分组密码则不是如此，但在一些工作模式中分组密码实际上达到了流密码的特点。

> 碎片填充造成密文长度大于明文，意味着需要消耗额外的传输能力。

## 附录三：流密码的简要分析

流密码的特点：
按位处理理明⽂文消息(as a stream)
• 典型做法是⽤用⼀一个伪随机流 密钥与明⽂文按位异或
• 流密钥的随机性完全扰乱了了 明⽂文消息的统计特性
• 不不能重复使⽤用流密钥，不不然 系统可能被破解

可对数据进行逐位加密和解密，将明文数据逐字节地加密为密文流，而不必等待指定长度的数据块形成，这与流媒体服务非常相似，经常用于某些数据在途加密，包括 SSL / TLS 密码套件、蓝牙连接、蜂窝和 4G 连接等重要业务场景。流密码实际上是如何在技术上起作用的呢？

- 基于加密密钥（Key）和种子（Nonce，随机数），通过特定算法（Stream Cipher）生成一个伪随机比特流（Keystream）
- 该伪随机比特流作为密钥流，与明文输入的一个字节进行异或运算，生成单个字节的密文输出
- 这种重复过程会在每一位明文数据中反复发生，最终生成持续不断的密文输出

![Stream Cipher](stream-cipher.png)

请注意，实际上流密码有同步 / 异步 的两种工作模式，即：

- 同步流密码（也称密钥自动密钥，即 KAK），这些类型的密码独立于任何先前的纯文本或密文生成密钥流。
- 异步流密码（也称自同步流密码，密文自动密钥或 CTAK）。这些密码依赖于先前的密文位来生成密钥流。

一般来说，流算法比分组密码更快更高效，因为它们一次只将一位数据加密为单个符号，而不是整个块。因此，它们更适合于资源较少的设备。同时，由于这种单比特数据方法，这意味着如果一个符号中有错误，则影响下一个符号的可能性较小。常见算法包括：

- Salsa20：软件和硬件均可实现
- ChaCha20：是 Salsa20 的修改版；TLS 1.3支持 ChaCha20
- RC4（**已弃用**）：由美国密码学家罗纳德·李维斯特（Ronald Rivest）在1987年设计的，常用于无线网络。由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。
- A5：用于 GSM 蜂窝网络的核心算法

但是，某些流密码容易受到**比特翻转攻击**和**密钥重用攻击**的攻击，为此需要注意不要再次使用相同的精确键-Nonce 组合。

> 由于异或运算（XOR）的**对合性**，加密和解密的计算过程可以完全相同，因此在加密算法中得到广泛应用。

---

## 参考文档

- [系列 - 写给开发人员的实用密码学](https://thiscute.world/posts/practical-cryptography-basics-1/)
- [分组加密工作模式 - Yang‘s blog](http://stuyang.com/blog/6fdd6732f56d/)
- [分组密码与流密码：它们是什么以及它们如何工作](https://www.asiaregister.com/zh/news/fen-zu-mi-ma-yu-liu-mi-ma-ta-men-shi-shen-me-yi-ji-ta-men-ru-he-gong-zuo-2453.htm)
- [分组密码工作模式 - WiKi](https://zh.m.wikipedia.org/zh-hans/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)
- [OS X Disk Util Manual Basic](https://zhuanlan.zhihu.com/p/20279484)
- [FileVault Drive Encryption (FVDE)](https://github.com/libyal/libfvde/blob/main/documentation/FileVault%20Drive%20Encryption%20(FVDE).asciidoc)
- [AES with XTS mode example - IBM](https://www.ibm.com/docs/en/linux-on-systems?topic=examples-aes-xts-mode-example)

### 文档下载

- [分组密码 工作模式建议：NIST SP 800-38A 2001 Edition](nistspecialpublication800-38a.pdf)
- [分组密码 GCM/GMAC 工作模式：NIST SP 800-38D 2001 Edition](nistspecialpublication800-38d.pdf)
- [分组密码 XTS-AESC 工作模式：NIST SP 800-38E 2001 Edition](nistspecialpublication800-38e.pdf)
- [IEEE Std 1619-2007, The XTS-AES Tweakable Block Cipher](1619-2007-NIST-Submission.pdf)
- [现代密码学理论与实践 - 苗付友.pdf](现代密码学理论与实践-苗付友.pdf)
