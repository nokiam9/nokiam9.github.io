---
title: V8引擎技术简介
date: 2021-11-05 11:34:43
tags:
---

为了追求更快的速度，乔布斯启动了Apple的浏览器项目WebKit，其中JavaScript引擎被命名为JavaScriptCore，负责JS脚本语言的解析和执行，其基本处理流程包括：

1. 对SourceCode文件进行语法解析，生成AST，并编译为ByteCode字节码文件
2. 通过解释器Interpreter，将字节码转化MachineCode机器码并执行。

## 2009年，盲目追求机器码的误区

2009年，Google启动了浏览器项目，V8引擎诞生的使命就是性能的极致，Google觉得这这种架构生成字节码会浪费时间，决定一步到位直接采用机器码。
早期V8引擎包含了`Full-Codegen`和 `Crankshaft`(曲轴) 两个编译器，即：JS源代码会被V8引擎进行两次解析，第一次使用`Full-Codegen`进行快速编译，而第二次使用`Crankshaft`进行深度优化编译，其基本处理流程为：

1. 将js源代码转化成AST（抽象语法树）。
2. 通过`Full-Codegen`引擎编译AST变成**基准的机器码**，然后直接执行这些未经优化的二进制文件。
3. 在执行机器码的过程中，通过内置的`Profiler`分析器筛选出热点函数，将标记的代码通过`Crankshaft`引擎进行优化编译生成**优化的机器码**。
4. 再次运行到这个Javascript函数时，直接使用缓存中**优化的机器码**。

{% asset_img v8-arch-0.png %}

通过取消字节码环节，V8引擎的运行速度有了明显的提示，但随着Web网页的复杂性，尤其是在智能终端上的应用普及，这种架构也暴露了不少严重的缺陷：

- **内存占用过高**：Full-Codegen生成机器码会占用大量内存，一个1M左右的JS源码文件通过编译生成的机器码通常达到10M+，而早期手机内存普遍有限，过度占用会导致性能大大降低
- **启动速度较慢**：Full-Codegen编译直接生成机器码，需要较长的编译时间，导致应用启动的速度受到较大影响
- **跨平台支持难**：Crankshaft直接生成机器码，需要自行适配不同的CPU架构，难以适应手机终端的复杂性

上述架构问题的集中体现，就是2016年[Facebook报告的Chrome代码缓存失效Bug](https://bugs.chromium.org/p/chromium/issues/detail?id=593477)。

> 当时的Chrome浏览器重复加载Facebook主页，第一次加载时长165ms，但重复加载时发现时长几乎没有变化，说明真正耗时高的js代码并没有被缓存和优化。
> 导致该Bug的原因：为缓解二进制代码占用内存空间大的矛盾，V8采取了**惰性编译**的优化原则（即只对最外层的代码进行优化编译），而Facebook首页采用的**IIFE**（立即调用函数表达式，类似于闭包函数）代码封装方式，导致浏览器并未对IIFE函数的内部关键代码进行优化。

## 2017年，字节码的回归

新版本的 V8 进行重大改变
2017年，Google发布了V8 5.9版本，完全废弃并移除了`full-codegen`和 `Crankshaft`，新增了 `Ignition`（点火器）字节码解释器和`Turbofan`（涡轮风扇）优化编译器，标志着字节码技术的全面回归。

- `Ignition`：本质上就是一个类似于Java中的JVM虚拟机，负责将AST编译成字节码，并逐句进行解释形成二进制代码并执行。
- `Turbofan`：在解释执行的过程中，`Ignition`标记重复执行的热点代码，提交给`Turbofan`进行编译生成效率更高二进制代码，今后再次运行到这个函数时便只执行机器码而非字节码

{% asset_img v8.jpg %}

也就是说，JS脚本有三种不同的启动方式：

- `Cold load`冷启动: 首次加载脚本文件时，`Ignition`编译生成字节码文件并解释执行，没有任何数据缓存
- `Warm load`暖启动：如果V8发现第二次使用了相同的脚本文件，将提交给`Turbofan`编译生成机器码文件，并与脚本文件一起加载到磁盘缓存中
- `Hot load`热启动: 如果第三次加载相同的脚本文件，V8可以从磁盘缓存中载入脚本，并直接执行对应的机器码文件

> js文件加载的过程并不是由V8负责的，它可能来自于网络请求、本地的cache或者是也可以是来自service worker，浏览器的js加载过程是V8引擎的前置步骤。

通过重新引入字节码技术，原有V8引擎存在的问题有了显著改善，体现在：

1. 首次启动时只需要编译出字节码，然后逐句执行字节码，编译出字节码的速度可远远快于编译出二进制代码的速度。
2. 字节码的数据量远远低于机器码，因此内存和磁盘的空间占用大大减少。
3. 通过虚拟机适配不同CPU架构体系，引擎代码的复杂度大大降低。


## Bytecode简介

{% asset_img bytecode.png %}

---

是通过生成字节码再将字节码转化成二进制代码的方式运行的

{% asset_img javascriptcore.png %}
{% asset_img webkit.png %}

---

## 参考文献

- [V8引擎的十年之路 - 官方网站](https://v8.dev/blog/10-years)
- [V8引擎详解系列 - 阿里巴巴暮桥](https://juejin.cn/post/6844904152745639949)
- [深入理解JavaScript的V8引擎 - 系列之一](https://juejin.cn/post/6984302939095449608)
- [深入了解 JavaScript 引擎精华](https://juejin.cn/post/6844903622333956103)

- [Java即时编译器原理解析及实践 - 美团技术](https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html)
- [关于Jvm知识看这一篇就够了](https://zhuanlan.zhihu.com/p/34426768)
- 《深入理解Java虚拟机：JVM高级特性与最佳实践》 周志明 著
