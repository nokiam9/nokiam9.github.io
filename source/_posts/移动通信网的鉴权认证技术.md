---
title: 移动通信网的鉴权认证技术
date: 2023-04-16 17:05:41
tags:
---

## 一、基本概念

移动通信网通常由三个部分组成，即核心网 (CN，core network)、无线接入网(RAN，radio access network)和用户设备(UE，user equipment)。 其中移动用户设备属于用户个人，由用户直接控制，接入网与核心网属于运营商，由运营商直接控制。如果用户希望使用运营商服务和网络资源，需要用户和运营商共同协商，这就涉及鉴权认证，判明和确认通信双方真实身份。

移动通信网的鉴权认证过程采用的是古老的“Challenge - Response”（挑战 - 响应）的机制，即认证方向被认证方发送一个“挑战”（一般是一个随机数），被认证方基于双方共有密钥，以及挑战中所包含的信息计算一个“响应”。显然，只有拥有密钥的参与方才能正确计算出这个响应。

> 一般情况下，认证可基于被认证方拥有一个独特的、不可复制的构件；或者双方都知道的一个秘密；又或者被认证方的某种唯一特征。
> 除第一代模拟通信外，从2G开始的移动通信网络的认证综合了前两种方式：一个共同的秘密（密钥）和被认证方一个独特的构件（SIM/USIM卡）。

移动通信网的鉴权认证是移动网络与终端用户之间相互识别的过程，核心是解决两个问题：

1. **你是谁?**
    基于国际移动用户识别号 IMSI（International Mobile Subscriber Identification）。
    IMSI 定义为 15 位的十进制数，其结构为：MCC + MNC + MSIN。
    全球运营商统一编码，是唯一且固定的身份标识，SIM/USIM 卡中存储了该数据。

2. **你是不是你?**
    基于永久性的根密钥 Ki，长度是 16 个字节，也就是 128 比特位。
    认证就是基于 Ki 共同秘密，配合一些其他的参数，基于一定的认证算法和协议过程而展开。
    Ki 仅在运营商的 AUC（Authentication Center）和用户的 SIM/USIM 卡中存储，基于根密钥的计算都在内部进行，绝对不允许对外暴露。
    后续需要使用的其它密钥（例如通信密钥 Kc），都是基于 Ki 通过不可逆的算法衍生出来的。

![GSM](GSM-arch.jpg)

AUC 和 SIM/USIM 是移动通信网安全的基石之一。AUC在运营商网络之内，在物理上、管理机制上、安全防护手段上都有严格的要求，卡则散落在用户手里，是不可控的环境。通常卡都采用抵制篡改（tamper-resist）的硬件设计，即要求不能从卡内读出卡内的信息，从而防止信息的泄露。

## 二、GSM 的 鉴权流程

### 1. 三元组认证向量（RAND、XRES、Kc）

GSM 系统的鉴权流程在 GSM09.02 MAP 中定义，核心是三元组认证向量（RAND、XRES、Kc）。

- RAND：移动网络AUC提供的随机数
- XRES/SRES：AUC侧计算的期望响应值（eXperted RESponse），卡侧计算的鉴权响应值（Signed RESponse），检测 XRES == SRES
- Kc：通信使用的一次性会话密钥，用于 A5 算法的加密输入

![GSM](GSM.jpeg)

在这个6步的过程里面同时实现了认证和会话密钥协商，称为AKA（Authentication and Key Agreement，会话与密钥协商）协议。

### 2. COMP128-1 算法和克隆卡问题

AKA 协议定义了 A3 和 A8 算法，其中 A3 算法以 Ki 和 RAND 作为输入参数，负责生成 SRES（32bits），A8 算法同样以 Ki 和 RAND 作为输入参数，负责生成后续用于通信加密的会话密钥 Kc（64bits）。由于这两个算法的输入参数完全相同，绝大多数运营商都直接采用 COMP128-1算法。

COMP128-1 算法于1987年设计，1991年投入使用，其设计较为简单，其实现仅需20行代码，在最初设计与使用时，所有参与方签订协议对方法进行保密。

![COMP128](comp128-struct.jpg)
> R 为轮函数，P 为置换，F 为置换与抽取。由于R、P、F均为高强度非线性运算，整体呈现哈希的雪崩特性。

1998年，COMP128-1 算法被泄露，随即在1999年即被破解。究其原因，由于COMP128-1 算法中输入的信息（128bits）大于输出的信息（96bits,即SRES+Kc），因此必然会出现不同的输入产生相同的输出，也就是“碰撞”，而且由于字节压缩得很厉害，很容易找到“碰撞”。

2000年，出现了对应的SIM卡破解软件，攻击者输入大量连续的数据就能轻易获得碰撞，以此来推算出密钥Ki。一旦计算出Ki，SIM卡就可被复制。因此，对SIM卡的破解并不是从智能卡中读取了机密信息，而是利用算法的脆弱性实施了计算破解。

### 3. 单向鉴权和伪基站问题

GSM 认证机制最大的缺陷是“单向认证”，就是说只有网络认证用户的真实性，而用户不认证网络。

2009年，OpenBTS软件发布，攻击者购置主机和笔记本电脑，再加上一个射频装置，通过**中间人攻击**方式构造“伪基站”，其基本流程是：

- 伪基站设备发射高强度的非法信号，用户终端自动连接到信号强度最高的基站并发送注册请求，这便暴露了自己的 IMSI
- 伪基站设备侦听设备，冒充目标终端向运营商真实网络侧发起注册请求
- 伪基站设备把网络下发的 RAND 转给受害者移动终端，并把终端返回的 SRES 转给网络，这就完成了鉴权认证流程

完成鉴权后，伪基站设备可以通过 A5 算法实现窃听通话，但需要消耗较高算力满足实时性要求，实际应用中通常用于伪装成任意号码（例如95588、95533、10086等银行或通信运营商的客服号码）下发短信，具有较强的迷惑性；同时，因为采用伪基站发送的短信不经过运营商网络，所以也难以监察到。

## 三、CDMA 采用的 算法

CDMA 系统的鉴权流程在 IS-41 MAP 中被详细定义。
CDMA 系统中用于移动台鉴权的密码分为两级，第一级为移动台的密钥 A_Key，第二级为共享加密数据(SSD，shared secret data)。

- 密钥 A_Key是高级密码，长度为 64 bit，由运营商分配，它和 IMSI 一同被写入移动终端永久性存储器中。
    同时，运营商核心网存储该用户的 IMSI 和对应的 A_Key。该密钥是永久性的，不在网络和空中信道上传播。
- SSD 是低级密码，长为 128 bit(分为 SSD_A 为 64 bit 和 SSD_B 为 64 bit)，它由A_Key 运算产生，存在于移动台、鉴权中心和拜访者位置寄存器。
    在鉴权过程中，核心网使用RAND 和 SSD_A 计算出期望的响应 AUTHx，倘若移动终端计算的 AUTHx(用 RAND 和 SSD_A计算所得)和核心网计算的 AUTHx 相同，则鉴权成功，攻击者因没有正确有效的 SSD 值，无法计算得到核心网所期望的 AUTHx 值导致鉴权 失败]。

## 3G 的算法

## 4G 的算法

## 5G 的算法

![VS](vs.png)

## 附录一：COMP128 算法实现

COMP128 - Details

1. x[16-31] = RAND
2. for 0<i<8
     x[0-15] = Ki
     call Compression (5 rounds)
     call FormBitsFromBytes
     if i<7 call Permute

Compress 16-byte result to 12-bytes, store in simoutput[] and return.

``` c
void comp128v1(const uint8_t *ki, const uint8_t *rand, uint8_t *sres, uint8_t *kc)
{
    int i;
    uint8_t x[32], bits[128];

    /* x[16-31] = RAND */
    memcpy(&x[16], rand, 16);

    /* Round 1-7 */
    for (i=0; i<7; i++) {
        /* x[0-15] = Ki */
        memcpy(x, ki, 16);

        /* Compression */
        _comp128_compression(x);

        /* FormBitFromBytes */
        _comp128_bitsfrombytes(x, bits);

        /* Permutation */
        _comp128_permutation(x, bits);
    }

    /* Round 8 (final) */
    /* x[0-15] = Ki */
    memcpy(x, ki, 16);

    /* Compression */
    _comp128_compression(x);

    /* Output stage */
    for (i=0; i<8; i+=2)
        sres[i>>1] = x[i]<<4 | x[i+1];

    for (i=0; i<12; i+=2)
        kc[i>>1] = (x[i + 18] << 6) |
                   (x[i + 19] << 2) |
                   (x[i + 20] >> 2);

    kc[6] = (x[30]<<6) | (x[31]<<2);
    kc[7] = 0;
}

static inline void _comp128_compression(uint8_t *x)
{
    int n;
    for (n=0; n<5; n++)
        _comp128_compression_round(x, n, _comp128_table[n]);
}

static inline void _comp128_bitsfrombytes(uint8_t *x, uint8_t *bits)
{
    int i;
    memset(bits, 0x00, 128);
    for (i=0; i<128; i++)
        if (x[i>>2] & (1<<(3-(i&3))))
            bits[i] = 1;
}

static inline void _comp128_permutation(uint8_t *x, uint8_t *bits)
{
    int i;
    memset(&x[16], 0x00, 16);
    for (i=0; i<128; i++)
        x[(i>>3)+16] |= bits[(i*17) & 127] << (7-(i&7));
}
```

---

## 参考文献

- [移动通信网中的密码算法演进 (三)：认证篇](https://www.secrss.com/articles/36564)
- [移动通信网中的密码算法演进 (一)：机密性保护](https://www.secrss.com/articles/36562)
- [移动通信网中的密码算法演进 (二)：完整性保护](https://www.secrss.com/articles/36563)
- [COMP128算法源码 - Github](https://github.com/osmocom/libosmocore/blob/master/src/gsm/comp128.c)
- [GSM SIM卡算法COMP128生日攻击原理 - 知乎](https://zhuanlan.zhihu.com/p/528866024)

### 文档下载

- [移动通信网鉴权认证综述 - 胡鑫鑫](移动通信网鉴权认证综述_胡鑫鑫.pdf)
- [COMP128算法分析中关键问题研究 - 汪涛](chinois.pdf)
- [COMP128: A Birthday Surprise - Stuart Wray](comp128-a-birthday-surprise-rev.pdf)
