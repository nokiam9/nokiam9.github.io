---
title: 密钥派生函数（KDF）概述
date: 2022-10-18 11:45:34
tags:
---

## 一、什么是 KDF

KDF（Key Derivation Function）的最初用途是密钥派生，即从秘密密码或密码短语生成密钥。

### 1、密钥拉伸（Key Stretching）

在系统要求用户设置密码时，我们习惯用4-6位的数字组合，或者字母、数字和特殊符号的某种组合，这种密码强度肯定无法抵御暴力破解、字典攻击、彩虹表攻击等技术手段，密钥派生函数由此应运而生。

KDF 最基础的用途是将密码和其他弱密钥材料来源转换为强密钥，文绉绉地说，就是采用具有低熵（安全性或随机性）的密钥，并将其扩展为更安全的更长密钥。

```js
derivedKey = keyDerivationFunction(originalKey, salt, difficulty)
```

密钥派生函数接受一个密码（或其他弱密钥材料）作为输入，通过一个特殊函数运行它，然后输出安全密钥材料，关键点是增加了一个随机数作为加密因子，这个随机数被称为**盐（Salt）**，`difficulty` 是难度系数标记。

![KDF](key-derivation-function.png)
以Apple数据保护技术为例，就是将4-6位的用户锁屏密码`Passcode`转化为256位的密文`Passcode Key`。

### 2、密钥分离（Key Separation）

KDF允许从单一的密钥材料（主密钥）生成多个不同用途的子密钥，方法是通过使用不同的 salt 随机数，这也被称为密钥多样化（Key Diversification）。

这种方式可以防止获得派生密钥的攻击者学习关于输入秘密值或任何其他派生密钥的有用信息，子密钥可以控制业务的某个部分，但只有主密钥具有完全控制权。例如，Apple 的 Secure Enclave 就以 UID 为根，派生出用于保护 Class Key 的`Key 0x835`和 用于保护 EMF Key 的`Key 0x89B`。

``` js
Key 0x835 = KDF(UID, bytes("01010101010101010101010101010101"))
Key 0x836 = KDF(UID, bytes("00E5A0E6526FAE66C5C1C6D4F16D6180"))
Key 0x838 = KDF(UID, bytes("8C8318A27D7F030717D2B8FC5514F8E1"))
Key 0x89B = KDF(UID, bytes("183e99676bb03c546fa468f51c0cbd49"))
```

### 3、密钥强化（Key Strengthening）

密钥强化同样使用随机盐扩展密钥，但随后**删除该盐**，这使得生成的密钥更强壮，但也意味着后续无法直接验证，**即使合法用户也必须进行暴力破解验证**。
但是，由于合法用户掌握了passcode等部分信息，暴力破解难度远远低于非法用户，但仍然需要消耗大量算力，因此实际应用中并不多见。

## 二、KDF 的哈希算法

理论上，KDF 可以采用 3DES 或 AES 等对称算法，好处是可以通过密钥恢复原文，但密钥保管是个大麻烦，一旦泄露所有密码就全部暴露，因此在实际应用中主要采用哈希算法。

一个理想的加密哈希函数，应当具有如下属性：

- 快速：计算速度要足够快
- 确定性：对同样的输入，应该总是产生同样的输出
- 难以分析：对输入的任何微小改动，都应该使输出完全发生变化
- 不可逆：从其哈希值逆向演算出输入值应该是不可行的。这意味着暴力破解是唯一方法
- 无碰撞：找到具有相同哈希值的两条不同消息应该非常困难（或几乎不可能）

这些特点非常适合密钥派生的业务场景，可以确保即使密码文件本身被泄露也能保护密码，同时又能方便地验证用户密码，代价是要同时保存每个用户的密文和随机数。

可以证明，所有基于哈希的 KDF 都是安全的哈希函数，但并非所有哈希函数都是基于哈希的 KDF，即 KDF 要求的是**慢哈希算法**。
![KDF Vs Hash](KDF.png)

KDF 计算速度的"慢”是相对而言的，对于普通用户而言，KDF 通常只需要在登录时被执行一次，因此慢这么一点点完全可以接受，而且用户也完全有足够的资源执行这个 KDF 函数。 但是如果一个黑客想要通过 Hash 碰撞来猜测出用户的密码，那它就必须执行海量的 KDF 计算，这个时候 KDF 的威力就显现出来了 —— 黑客将需要提供海量的 CPU/GPU 计算资源、海量的内存资源才能完成目标，而这显然得不偿失，这样 KDF 就确保了用户密码的安全性。

基于 KDF 的设计原理，Salt 是用于防止预计算攻击或rainbow表的随机数据，而要提升碰撞难度，Hash 算法主要从以下三个方向入手：

- 时间复杂度：对应 CPU/GPU 计算资源
- 空间复杂度：对应 Memory 内存资源
- 并行维度：使用无法分解的算法，锁定只允许单线程运算

## 四、主流算法

目前比较著名的 KDF 算法主要有如下几个：

PBKDF2：这是一个非常简单的加密 KDF 算法，目前已经不推荐使用。
Bcrypt：安全性在下降，用得越来越少了。不建议使用。
Scrypt：可以灵活地设定使用的内存大小，在 argon2 不可用时，可使用它。
Argon2：目前最强的密码 Hash 算法，在 2015 年赢得了密码 Hash 竞赛。
如果你正在开发一个新的程序，需要使用到 KDF，建议选用 argon2/scrypt.


Python 中最流行的密码学库是 cryptography，requests 的底层曾经就使用了它（新版本已经换成使用标准库 ssl 了），下面我们使用这个库来演示下 Scrypt 算法的使用：

Argon2 是一种密码散列函数，它总结了记忆硬函数设计中的最新技术，可用于对凭证存储、密钥派生或其他应用程序的密码进行散列。

它有一个简单的设计，旨在实现最高的内存填充率和多个计算单元的有效使用，同时仍然提供对权衡攻击的防御（通过利用最新处理器的缓存和内存组织）。

Argon2 具有三个变体：Argon2i、Argon2d 和 Argon2id。Argon2d 速度更快，并且使用依赖于数据的内存访问，这使得它对 GPU 破解攻击具有很强的抵抗力，并且适用于不受侧通道定时攻击威胁的应用程序（例如加密货币）。Argon2i 使用与数据无关的内存访问，这是密码散列和基于密码的密钥派生的首选，但它更慢，因为它通过更多的内存来防止权衡攻击。Argon2id 是 Argon2i 和 Argon2d 的混合体，使用了数据依赖和数据无关的内存访问的组合，这使得 Argon2i 对侧通道缓存定时攻击具有一定的抵抗力，而 Argon2d 对 GPU 破解攻击具有很大的抵抗力。

第一个[ citation required ]故意缓慢（密钥拉伸）的基于密码的密钥派生函数被称为“ crypt ”（或在其手册页之后的“crypt(3)” ），由Robert Morris在 1978 年发明。它将加密一个常数（零），使用用户密码的前 8 个字符作为密钥，通过执行修改后的DES加密算法的 25 次迭代（其中使用从实时计算机时钟读取的 12 位数字来干扰计算）。生成的 64 位数字被编码为 11 个可打印字符，然后存储在Unix密码文件中。[5]虽然这在当时是一个巨大的进步，但自PDP-11时代以来处理器速度的提高使得针对 crypt 的暴力攻击变得可行，并且存储方面的进步使得 12 位盐不足。crypt 函数的设计还将用户密码限制为 8 个字符，这限制了密钥空间并使强密码短语成为不可能。[需要引用]

尽管高吞吐量是通用哈希函数的理想属性，但在密码安全应用程序中则相反，在这些应用程序中，防御暴力破解是主要关注点。越来越多地使用大规模并行硬件（如 GPU、FPGA 甚至 ASIC）进行暴力破解，这使得选择合适的算法变得更加关键，因为好的算法不仅应该强制执行一定数量的计算成本，而不仅仅是CPU，但也抵制现代大规模并行平台用于此类任务的成本/性能优势。为此目的专门设计了各种算法，包括bcrypt、scrypt以及最近的Lyra2和Argon2（后者是密码哈希竞赛的获胜者）。攻击者窃取了大约 3600 万个密码哈希值的大规模Ashley Madison 数据泄露事件说明了算法选择在保护密码方面的重要性。尽管使用 bcrypt 来保护散列（使得大规模暴力破解既昂贵又耗时），但受感染数据中的很大一部分帐户还包含基于快速通用MD5算法的密码散列，这使得有可能在几周内破解超过 1100 万个密码。[6]

2017 年 6 月，美国国家标准与技术研究院 (NIST) 发布了其数字认证指南的新修订版，NIST SP 800-63B-3，[7] : 5.1.1.2 指出：“验证者应存储记忆的秘密 [ ie passwords] 以抵抗离线攻击的形式。记忆的秘密应使用合适的单向密钥派生函数进行加盐和散列。密钥派生函数将密码、盐和成本因子作为输入，然后生成密码哈希。他们的目的是让获得密码哈希文件的攻击者每次猜测密码的代价都很高，因此猜测攻击的成本很高或令人望而却步。”

现代基于密码的密钥派生函数，例如PBKDF2（在 RFC 2898 中指定）基于公认的加密哈希，例如SHA-2，使用更多的盐（至少 64 位并随机选择）和高迭代次数。NIST 建议最小迭代次数为 10,000。[7] : 5.1.1.2  “对于特别关键的密钥，或者对于非常强大的系统或用户感知性能不重要的系统，10,000,000 的迭代计数可能是合适的。” [8] ：5.2 

密钥派生
这个主题的变化包括：

结合非秘密参数从一个公共秘密值中派生一个或多个密钥（有时也称为“密钥多样化”）。这种使用可以防止获得派生密钥的攻击者学习关于输入秘密值或任何其他派生密钥的有用信息。KDF 还可用于确保派生密钥具有其他所需属性，例如避免某些特定加密系统中的“弱密钥”。
作为多方密钥协商协议的组件。这种密钥派生函数的示例包括在IEEE Std 1363-2000中定义的 KDF1 ，以及 ANSI X9.42 中的类似函数。
从秘密密码或密码短语（基于密码的 KDF）派生密钥。
从提供的密钥中派生不同长度的密钥：为此目的设计的 KDF 的一个示例是HKDF。
关键拉伸和关键加强。

密码散列
尽管它们最初用于密钥派生，但 KDF 可能因其在密码散列（通过散列比较的密码验证）中的使用而广为人知，正如passwd文件或影子密码文件所使用的那样。在暴力攻击的情况下，密码哈希函数的计算成本应该相对较高，而 KDF 的密钥拉伸恰好提供了这种特性。[需要引用]在这种情况下，非秘密参数称为“盐”。

2013 年，密码散列竞赛宣布为密码散列选择一种新的标准算法。2015 年 7 月 20 日，比赛结束，Argon2被宣布为最终获胜者。其他四种算法获得了特别认可：Catena、Lyra2、Makwa 和 yescrypt。[13]

在最一般的意义上，

密钥派生函数 (KDF) 用于什么？
密钥派生函数实际上可以做很多事情，包括：


安全地存储密码以保护它们免受黑客攻击。
基于密码的密钥派生函数 (PBKDF) 如何工作？
有许多不同的基于密码的密钥派生函数，但我们将通过讨论 PBKDF2 来演示它们的工作原理：

2017年6月，NIST发布了新版本的数字认证指南表示：“验证者应将存储的秘密（密码）放在表格以抗存储的秘密，应使用适当的单向密钥导出功能进行salt化和hash，KDF将密码，salt和成本因子作为输入，然后生成密码hash，其目的是使每个密码猜测获得密码哈希文件的攻击者尝试昂贵，因此猜测攻击的成本高；并且盐的长度必须至少为32位，并且任意选​​择，以便最小化存储散列之间的盐值碰撞。

---

## 参考文献

- [密码加密存储技术详解](https://www.ujcms.com/knowledge/509.html)
- [PBKDF2算法原理](https://blog.csdn.net/HORHEART/article/details/119968850)
- [Salted Password Hashing - Doing it Right](https://crackstation.net/hashing-security.htm)
- [Argon2 的参考 C 实现 - Github](https://github.com/p-h-c/phc-winner-argon2)